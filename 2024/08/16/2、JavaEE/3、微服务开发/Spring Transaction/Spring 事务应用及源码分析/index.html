<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Spring 事务应用及源码分析 | Sam Blog</title>
  <meta name="keywords" content="">
  <meta name="description" content="Spring 事务应用及源码分析 | Sam Blog">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="description" content="请不要自己写，Spring Boot非常实用的内置功能：https:&#x2F;&#x2F;juejin.cn&#x2F;post&#x2F;7417630844100231206  在 SpringBoot 框架中，内置了许多实用的功能，这些功能可以帮助开发者高效地开发和维护应用程序。 一、请求数据记录器SpringBoot 提供了一个内置的日志记录解决方案，通过 AbstractRequestLoggingFilter 可以记录请">
<meta property="og:type" content="article">
<meta property="og:title" content="SpringBoot2.x 内置功能 - 内置过滤器和 AOP 工具类">
<meta property="og:url" content="https://8629303.github.io/2024/10/08/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot2.x%20%E5%86%85%E7%BD%AE%E5%8A%9F%E8%83%BD%20-%20%E5%86%85%E7%BD%AE%E8%BF%87%E6%BB%A4%E5%99%A8%E5%92%8C%20AOP%20%E5%B7%A5%E5%85%B7%E7%B1%BB/index.html">
<meta property="og:site_name" content="Sam Blog">
<meta property="og:description" content="请不要自己写，Spring Boot非常实用的内置功能：https:&#x2F;&#x2F;juejin.cn&#x2F;post&#x2F;7417630844100231206  在 SpringBoot 框架中，内置了许多实用的功能，这些功能可以帮助开发者高效地开发和维护应用程序。 一、请求数据记录器SpringBoot 提供了一个内置的日志记录解决方案，通过 AbstractRequestLoggingFilter 可以记录请">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2024-10-08T08:44:19.743Z">
<meta property="article:modified_time" content="2024-10-25T10:00:36.010Z">
<meta property="article:author" content="Sam Liu">
<meta name="twitter:card" content="summary">


<link rel="icon" href="/img/my-avatar.jpg">

<link href="/blog/css/style.css?v=1.1.0" rel="stylesheet">

<link href="/blog/css/hl_theme/atom-light.css?v=1.1.0" rel="stylesheet">

<link href="//cdn.jsdelivr.net/npm/animate.css@4.1.0/animate.min.css" rel="stylesheet">

<script src="//cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
<script src="/blog/js/titleTip.js?v=1.1.0" ></script>

<script src="//cdn.jsdelivr.net/npm/highlightjs@9.16.2/highlight.pack.min.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>

<script src="//cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script>



<script src="//cdn.jsdelivr.net/npm/jquery.cookie@1.4.1/jquery.cookie.min.js" ></script>

<script src="/blog/js/iconfont.js?v=1.1.0" ></script>

<meta name="generator" content="Hexo 7.3.0"></head>
<div style="display: none">
  <input class="theme_disqus_on" value="false">
  <input class="theme_preload_comment" value="">
  <input class="theme_blog_path" value="/blog">
  <input id="theme_shortcut" value="true" />
  <input id="theme_highlight_on" value="true" />
  <input id="theme_code_copy" value="true" />
</div>



<body>
<aside class="nav">
    <div class="nav-left">
        <a href="/blog/"
   class="avatar_target">
    <img class="avatar"
         src="/blog/img/my-avatar.jpg"/>
</a>
<div class="author">
    <span>Sam Liu</span>
</div>

<div class="icon">
    
</div>



    <a class="more-menus">更多菜单</a>



<ul>
    <li>
        <div class="all active" data-rel="全部文章">全部文章
            
                <small>(183)</small>
            
        </div>
    </li>
    
        
            
                
    <li>
        <div data-rel="JavaSE">
            <i class="fold iconfont icon-right"></i>
            JavaSE
            <small>(62)</small>
        </div>
        
            <ul class="sub hide">
                
                    
    <li>
        <div data-rel="JavaSE&lt;---&gt;Java汇总篇">
            
            Java汇总篇
            <small>(28)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="JavaSE&lt;---&gt;Java基础篇">
            
            Java基础篇
            <small>(8)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="JavaSE&lt;---&gt;Java进阶篇">
            
            Java进阶篇
            <small>(4)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="JavaSE&lt;---&gt;Java新特性">
            
            Java新特性
            <small>(17)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="JavaSE&lt;---&gt;Java性能测试与安全">
            
            Java性能测试与安全
            <small>(5)</small>
        </div>
        
    </li>

                
            </ul>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="JavaEE">
            <i class="fold iconfont icon-right"></i>
            JavaEE
            <small>(71)</small>
        </div>
        
            <ul class="sub hide">
                
                    
    <li>
        <div data-rel="JavaEE&lt;---&gt;微服务开发">
            
            微服务开发
            <small>(65)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="JavaEE&lt;---&gt;JavaWeb">
            
            JavaWeb
            <small>(2)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="JavaEE&lt;---&gt;SSM框架">
            
            SSM框架
            <small>(4)</small>
        </div>
        
    </li>

                
            </ul>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="数据库">
            
            数据库
            <small>(5)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="中间件">
            <i class="fold iconfont icon-right"></i>
            中间件
            <small>(9)</small>
        </div>
        
            <ul class="sub hide">
                
                    
    <li>
        <div data-rel="中间件&lt;---&gt;ElasticSearch">
            
            ElasticSearch
            <small>(1)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="中间件&lt;---&gt;MongoDB">
            
            MongoDB
            <small>(2)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="中间件&lt;---&gt;RabbitMQ">
            
            RabbitMQ
            <small>(3)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="中间件&lt;---&gt;Redis">
            
            Redis
            <small>(3)</small>
        </div>
        
    </li>

                
            </ul>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="Linux">
            <i class="fold iconfont icon-right"></i>
            Linux
            <small>(7)</small>
        </div>
        
            <ul class="sub hide">
                
                    
    <li>
        <div data-rel="Linux&lt;---&gt;虚拟机工具">
            
            虚拟机工具
            <small>(2)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="Linux&lt;---&gt;Docker">
            
            Docker
            <small>(2)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="Linux&lt;---&gt;Kubernetes">
            
            Kubernetes
            <small>(2)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="Linux&lt;---&gt;Nginx">
            
            Nginx
            <small>(1)</small>
        </div>
        
    </li>

                
            </ul>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="开发工具">
            <i class="fold iconfont icon-right"></i>
            开发工具
            <small>(16)</small>
        </div>
        
            <ul class="sub hide">
                
                    
    <li>
        <div data-rel="开发工具&lt;---&gt;Maven">
            
            Maven
            <small>(8)</small>
        </div>
        
    </li>

                
            </ul>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="面试篇">
            
            面试篇
            <small>(1)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="前端框架">
            <i class="fold iconfont icon-right"></i>
            前端框架
            <small>(10)</small>
        </div>
        
            <ul class="sub hide">
                
                    
    <li>
        <div data-rel="前端框架&lt;---&gt;前端入门">
            
            前端入门
            <small>(6)</small>
        </div>
        
    </li>

                
            </ul>
        
    </li>

            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
</ul>
<div class="left-bottom">
    <div class="menus">
        
            
            
            
                <a class="dynamic-menu "
                   target="_blank"
                        
                   href="https://github.com/8629303">GitHub</a>
        
    </div>
    <div>
        
            <a class="about  hasFriend  site_url"
               
               href="/about">关于</a>
        
        <a style="width: 50%"
                
                                           class="friends">友链</a>
        
    </div>
</div>
<input type="hidden" id="yelog_site_posts_number" value="183">

<div style="display: none">
    <span id="busuanzi_value_site_uv"></span>
    <span id="busuanzi_value_site_pv"></span>
</div>

    </div>
    <div class="nav-right">
        <div class="friends-area">
    <div class="friends-title">
        友情链接
        <i class="iconfont icon-left"></i>
    </div>
    <div class="friends-content">
        <ul>
            
            <li><a target="_blank" href="http://yelog.org/">叶落阁</a></li>
            
        </ul>
    </div>
</div>
        <div class="title-list">
    <div class="right-top">
        <div id="default-panel">
            <i class="iconfont icon-search" data-title="搜索 快捷键 i"></i>
            <div class="right-title">全部文章</div>
            <i class="iconfont icon-file-tree" data-title="切换到大纲视图 快捷键 w"></i>
        </div>
        <div id="search-panel">
            <i class="iconfont icon-left" data-title="返回"></i>
            <input id="local-search-input" autocomplete="off"/>
            <label class="border-line" for="input"></label>
            <i class="iconfont icon-case-sensitive" data-title="大小写敏感"></i>
            <i class="iconfont icon-tag" data-title="标签"></i>
        </div>
        <div id="outline-panel" style="display: none">
            <div class="right-title">大纲</div>
            <i class="iconfont icon-list" data-title="切换到文章列表"></i>
        </div>
    </div>

    <div class="tags-list">
    <input id="tag-search" />
    <div class="tag-wrapper">
        
    </div>

</div>

    
    <nav id="title-list-nav">
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2024/10/08/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot2.x%20%E5%86%85%E7%BD%AE%E5%8A%9F%E8%83%BD%20-%20%E5%86%85%E7%BD%AE%E8%BF%87%E6%BB%A4%E5%99%A8%E5%92%8C%20AOP%20%E5%B7%A5%E5%85%B7%E7%B1%BB/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot2.x 内置功能 - 内置过滤器和 AOP 工具类">SpringBoot2.x 内置功能 - 内置过滤器和 AOP 工具类</span>
            <span class="post-date" title="2024-10-08 16:44:19">2024/10/08</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2024/10/08/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%E7%B3%BB%E5%88%97-%E5%85%A8%E7%BD%91%E6%9C%80%E5%85%A8%E7%9A%84%E7%89%88%E6%9C%AC%E5%8F%98%E6%9B%B4%E5%8F%B2/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot系列-全网最全的版本变更史">SpringBoot系列-全网最全的版本变更史</span>
            <span class="post-date" title="2024-10-08 16:38:53">2024/10/08</span>
        </a>
        
        
        <a  class="全部文章 开发工具 Maven "
           href="/blog/2024/10/08/6%E3%80%81%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Maven/Maven%20%E6%95%99%E7%A8%8B%E4%B9%8B%20%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE%20&%20%E9%B8%A3%E8%B0%A2/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Maven 教程之 参考文献 &amp; 鸣谢">Maven 教程之 参考文献 &amp; 鸣谢</span>
            <span class="post-date" title="2024-10-08 15:50:47">2024/10/08</span>
        </a>
        
        
        <a  class="全部文章 开发工具 "
           href="/blog/2024/10/07/6%E3%80%81%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/GitHub%20%E5%AE%9E%E6%88%98%E6%8A%80%E5%B7%A7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="GitHub 实战技巧">GitHub 实战技巧</span>
            <span class="post-date" title="2024-10-07 15:55:34">2024/10/07</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2024/10/07/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot2.x%20%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AF%87%20-%20%E9%9B%86%E6%88%90%20HirakiCP%20%E4%B8%8E%20Druid%20%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot2.x 数据库篇 - 集成 HirakiCP 与 Druid 数据库连接池">SpringBoot2.x 数据库篇 - 集成 HirakiCP 与 Druid 数据库连接池</span>
            <span class="post-date" title="2024-10-07 14:19:43">2024/10/07</span>
        </a>
        
        
        <a  class="全部文章 开发工具 "
           href="/blog/2024/09/30/6%E3%80%81%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/MacOS%20%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%8F%8A%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E5%8D%B8%E8%BD%BD/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="MacOS 开发环境搭建及软件安装卸载">MacOS 开发环境搭建及软件安装卸载</span>
            <span class="post-date" title="2024-09-30 23:56:52">2024/09/30</span>
        </a>
        
        
        <a  class="全部文章 开发工具 Maven "
           href="/blog/2024/09/30/6%E3%80%81%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Maven/Maven%20%E6%95%99%E7%A8%8B%E4%B9%8B%20JDK%20%E7%89%88%E6%9C%AC%E9%BB%98%E8%AE%A4%E8%AE%BE%E7%BD%AE%20/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Maven 教程之 JDK 版本默认设置">Maven 教程之 JDK 版本默认设置</span>
            <span class="post-date" title="2024-09-30 16:37:08">2024/09/30</span>
        </a>
        
        
        <a  class="全部文章 开发工具 Maven "
           href="/blog/2024/09/26/6%E3%80%81%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Maven/Maven%20%E6%95%99%E7%A8%8B%E4%B9%8B%20profiles%20%E5%A4%9A%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Maven 教程之 profiles 多环境配置">Maven 教程之 profiles 多环境配置</span>
            <span class="post-date" title="2024-09-26 17:40:34">2024/09/26</span>
        </a>
        
        
        <a  class="全部文章 开发工具 Maven "
           href="/blog/2024/09/25/6%E3%80%81%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Maven/Maven%20%E6%95%99%E7%A8%8B%E4%B9%8B%20plugin%20%E8%AF%A6%E8%A7%A3/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Maven 教程之 plugin 详解">Maven 教程之 plugin 详解</span>
            <span class="post-date" title="2024-09-25 11:32:44">2024/09/25</span>
        </a>
        
        
        <a  class="全部文章 开发工具 Maven "
           href="/blog/2024/09/21/6%E3%80%81%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Maven/Maven%20%E6%95%99%E7%A8%8B%E4%B9%8B%20pom.xml%20%E8%AF%A6%E8%A7%A3/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Maven 教程之 pom.xml 详解">Maven 教程之 pom.xml 详解</span>
            <span class="post-date" title="2024-09-21 16:14:13">2024/09/21</span>
        </a>
        
        
        <a  class="全部文章 开发工具 Maven "
           href="/blog/2024/09/21/6%E3%80%81%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Maven/Maven%20%E6%95%99%E7%A8%8B%E4%B9%8B%20settings.xml%20%E8%AF%A6%E8%A7%A3/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Maven 教程之 settings.xml 详解">Maven 教程之 settings.xml 详解</span>
            <span class="post-date" title="2024-09-21 16:14:09">2024/09/21</span>
        </a>
        
        
        <a  class="全部文章 面试篇 "
           href="/blog/2024/08/27/0%E3%80%81%E9%9D%A2%E8%AF%95%E7%AF%87/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8%E6%B1%87%E6%80%BB/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="面试宝典汇总">面试宝典汇总</span>
            <span class="post-date" title="2024-08-27 16:20:25">2024/08/27</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/blog/2024/08/26/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E8%87%AA%E5%AE%9A%E4%B9%89%E9%9B%86%E5%90%88%E5%B8%B8%E9%87%8F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 自定义集合常量">Java 自定义集合常量</span>
            <span class="post-date" title="2024-08-26 12:11:54">2024/08/26</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2024/08/26/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20MVC/SpringMVC%E4%B9%8B@InitBinder%E6%B3%A8%E8%A7%A3%EF%BC%88%E6%97%A5%E6%9C%9F%E8%BD%AC%E6%8D%A2%EF%BC%89/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringMVC之@InitBinder注解（日期转换）">SpringMVC之@InitBinder注解（日期转换）</span>
            <span class="post-date" title="2024-08-26 11:10:28">2024/08/26</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2024/08/21/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Transaction/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8B%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/Java%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BA%8B%E5%8A%A1%E6%8F%90%E4%BA%A4%E7%9A%84%E5%A4%84%E7%90%86/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 多线程事务提交的处理">Java 多线程事务提交的处理</span>
            <span class="post-date" title="2024-08-21 16:32:52">2024/08/21</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2024/08/20/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%20Cache%20%E6%95%B4%E5%90%88%20Redis%20%E7%BC%93%E5%AD%98%E6%A1%86%E6%9E%B6/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot Cache 整合 Redis 缓存框架">SpringBoot Cache 整合 Redis 缓存框架</span>
            <span class="post-date" title="2024-08-20 16:11:47">2024/08/20</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2024/08/16/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Transaction/Spring%20%E4%BA%8B%E5%8A%A1%E5%BA%94%E7%94%A8%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Spring 事务应用及源码分析">Spring 事务应用及源码分析</span>
            <span class="post-date" title="2024-08-16 10:33:57">2024/08/16</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2024/08/16/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Transaction/Spring%20JDBC%20-%20NamedParameterJdbcTemplate/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Spring JDBC - NamedParameterJdbcTemplate">Spring JDBC - NamedParameterJdbcTemplate</span>
            <span class="post-date" title="2024-08-16 00:18:18">2024/08/16</span>
        </a>
        
        
        <a  class="全部文章 开发工具 "
           href="/blog/2024/07/18/6%E3%80%81%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Git%20&%20GitHub/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Git &amp; GitHub">Git &amp; GitHub</span>
            <span class="post-date" title="2024-07-18 10:34:58">2024/07/18</span>
        </a>
        
        
        <a  class="全部文章 开发工具 Maven "
           href="/blog/2024/06/28/6%E3%80%81%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Maven/Maven%20%E5%AE%9E%E6%88%98/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Maven 实战">Maven 实战</span>
            <span class="post-date" title="2024-06-28 16:50:35">2024/06/28</span>
        </a>
        
        
        <a  class="全部文章 数据库 "
           href="/blog/2024/06/26/3%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%9D%A2%E8%AF%95%E5%AE%98%EF%BC%9A%E4%B8%8D%E4%BC%9A%E7%9C%8B%20Explain%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%EF%BC%8C%E7%AE%80%E5%8E%86%E6%95%A2%E5%86%99%20SQL%20%E4%BC%98%E5%8C%96%EF%BC%9F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="面试官：不会看 Explain执行计划，简历敢写 SQL 优化？">面试官：不会看 Explain执行计划，简历敢写 SQL 优化？</span>
            <span class="post-date" title="2024-06-26 19:33:03">2024/06/26</span>
        </a>
        
        
        <a  class="全部文章 前端框架 "
           href="/blog/2024/06/20/7%E3%80%81%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/VS%20Code%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="VS Code开发工具的使用教程">VS Code开发工具的使用教程</span>
            <span class="post-date" title="2024-06-20 14:04:02">2024/06/20</span>
        </a>
        
        
        <a  class="全部文章 前端框架 "
           href="/blog/2024/05/03/7%E3%80%81%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/VS%20Code%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B-1/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="VS Code开发工具的使用教程-1">VS Code开发工具的使用教程-1</span>
            <span class="post-date" title="2024-05-03 17:11:49">2024/05/03</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/blog/2024/04/22/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%AF%87%E4%B9%8B%20IDEA%20-%20VM%20Options%E3%80%81Program%20Arguments%E3%80%81Environment%20Variable%20%E8%A7%A3%E6%9E%90/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 命令行篇之 IDEA - VM Options、Program Arguments、Environment Variable 解析">Java 命令行篇之 IDEA - VM Options、Program Arguments、Environment Variable 解析</span>
            <span class="post-date" title="2024-04-22 10:53:10">2024/04/22</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2024/04/19/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6-%E9%85%8D%E7%BD%AE%E5%A4%96%E9%83%A8%E5%8C%96/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 配置文件-配置外部化">SpringBoot 2.x 配置文件-配置外部化</span>
            <span class="post-date" title="2024-04-19 09:18:55">2024/04/19</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/blog/2024/04/16/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E5%8E%9F%E7%90%86%E7%AF%87%E4%B9%8B%20SPI%20%E6%9C%BA%E5%88%B6/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 原理篇之 SPI 机制">Java 原理篇之 SPI 机制</span>
            <span class="post-date" title="2024-04-16 17:26:15">2024/04/16</span>
        </a>
        
        
        <a  class="全部文章 前端框架 "
           href="/blog/2024/04/15/7%E3%80%81%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE%20&%20%E9%B8%A3%E8%B0%A2/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="参考文献 &amp; 鸣谢">参考文献 &amp; 鸣谢</span>
            <span class="post-date" title="2024-04-15 18:01:47">2024/04/15</span>
        </a>
        
        
        <a  class="全部文章 开发工具 Maven "
           href="/blog/2024/01/14/6%E3%80%81%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Maven/Maven%20%E6%95%99%E7%A8%8B%E4%B9%8B%20mirror%20&%20repository%20%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Maven 教程之 mirror &amp; repository 配置详解">Maven 教程之 mirror &amp; repository 配置详解</span>
            <span class="post-date" title="2024-01-14 22:51:03">2024/01/14</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/12/07/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E4%B8%BA%E4%BB%80%E4%B9%88SpringBoot%20jar%20%E5%8F%AF%E4%BB%A5%E7%9B%B4%E6%8E%A5%E8%BF%90%E8%A1%8C/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 为什么SpringBoot jar 可以直接运行">SpringBoot 2.x 为什么SpringBoot jar 可以直接运行</span>
            <span class="post-date" title="2023-12-07 15:13:56">2023/12/07</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java基础篇 "
           href="/blog/2023/12/04/1%E3%80%81JavaSE/1.Java%20%E5%9F%BA%E7%A1%80%E7%AF%87/5%E3%80%81Java%20%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%BF%9B%E9%98%B6/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 多线程进阶">Java 多线程进阶</span>
            <span class="post-date" title="2023-12-04 16:37:09">2023/12/04</span>
        </a>
        
        
        <a  class="全部文章 "
           href="/blog/2023/11/29/MarkdownTools/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="MarkdownTools">MarkdownTools</span>
            <span class="post-date" title="2023-11-29 15:02:34">2023/11/29</span>
        </a>
        
        
        <a  class="全部文章 数据库 "
           href="/blog/2023/11/18/3%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BB%BA%E6%A8%A1%E5%B7%A5%E5%85%B7%E6%B1%87%E6%80%BB/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="数据库建模工具汇总">数据库建模工具汇总</span>
            <span class="post-date" title="2023-11-18 15:31:11">2023/11/18</span>
        </a>
        
        
        <a  class="全部文章 JavaEE SSM框架 "
           href="/blog/2023/10/08/2%E3%80%81JavaEE/2%E3%80%81SSM%E6%A1%86%E6%9E%B6/Mybatis/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Mybatis">Mybatis</span>
            <span class="post-date" title="2023-10-08 19:45:47">2023/10/08</span>
        </a>
        
        
        <a  class="全部文章 "
           href="/blog/2023/08/28/Markdown/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Markdown">Markdown</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java性能测试与安全 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/5.Java%20%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E4%B8%8E%E5%AE%89%E5%85%A8/Java%20%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E7%AF%87%E4%B9%8B%20%E5%8E%8B%E6%B5%8B%E5%B7%A5%E5%85%B7%E6%B1%87%E6%80%BB/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 性能测试篇之 压测工具汇总">Java 性能测试篇之 压测工具汇总</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java性能测试与安全 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/5.Java%20%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E4%B8%8E%E5%AE%89%E5%85%A8/Java%20%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E7%AF%87%E4%B9%8B%20%E9%AB%98%E5%B9%B6%E5%8F%91%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87%EF%BC%9AQPS%E3%80%81TPS%E3%80%81RT%E3%80%81%E5%B9%B6%E5%8F%91%E6%95%B0%E3%80%81%E5%90%9E%E5%90%90%E9%87%8F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 性能测试篇之 高并发性能指标：QPS、TPS、RT、并发数、吞吐量">Java 性能测试篇之 高并发性能指标：QPS、TPS、RT、并发数、吞吐量</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java性能测试与安全 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/5.Java%20%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E4%B8%8E%E5%AE%89%E5%85%A8/Java%20%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E7%AF%87%E4%B9%8B%20JMH%20%E5%B7%A5%E5%85%B7%E7%B1%BB/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 性能测试篇之 JMH 工具类">Java 性能测试篇之 JMH 工具类</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java性能测试与安全 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/5.Java%20%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E4%B8%8E%E5%AE%89%E5%85%A8/Java%20%E5%AE%89%E5%85%A8%E7%AF%87%E4%B9%8B%20API%20%E6%8E%A5%E5%8F%A3%E9%98%B2%E6%AD%A2%E5%8F%82%E6%95%B0%E7%AF%A1%E6%94%B9%E5%92%8C%E9%87%8D%E6%94%BE%E6%94%BB%E5%87%BB/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 安全篇之 API 接口防止参数篡改和重放攻击">Java 安全篇之 API 接口防止参数篡改和重放攻击</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java性能测试与安全 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/5.Java%20%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E4%B8%8E%E5%AE%89%E5%85%A8/Java%20%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E7%AF%87%E4%B9%8B%2048%E5%BC%A0%E5%9B%BE%E5%AD%A6%E4%BC%9A%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E3%80%81%E5%8E%8B%E6%B5%8B%E5%92%8C%E8%B0%83%E4%BC%98/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 性能测试篇之 48张图学会性能监控、压测和调优">Java 性能测试篇之 48张图学会性能监控、压测和调优</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 开发工具 "
           href="/blog/2023/08/28/6%E3%80%81%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/IDEA%20%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="IDEA 基本使用">IDEA 基本使用</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 开发工具 "
           href="/blog/2023/08/28/6%E3%80%81%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/IDEA%20%E5%BF%AB%E6%8D%B7%E9%94%AE/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="IDEA 快捷键">IDEA 快捷键</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 开发工具 "
           href="/blog/2023/08/28/6%E3%80%81%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/IDEA%20%E6%8F%92%E4%BB%B6%E5%AE%89%E8%A3%85/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="IDEA 插件安装">IDEA 插件安装</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 开发工具 "
           href="/blog/2023/08/28/6%E3%80%81%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/PostMan%20%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="PostMan 工具的使用">PostMan 工具的使用</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 开发工具 "
           href="/blog/2023/08/28/6%E3%80%81%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Git/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Git">Git</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E4%BC%98%E5%8C%96%E7%AF%87%E4%B9%8B%20%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3%20%E6%A0%A1%E9%AA%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 优化篇之 自定义注解 校验数据库表中的数据不可重复">Java 优化篇之 自定义注解 校验数据库表中的数据不可重复</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E5%B7%A5%E5%85%B7%E7%AF%87%E4%B9%8B%20API%20%E6%8E%A5%E5%8F%A3%E5%85%8D%E8%B4%B9%20JSONPlaceholder/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 工具篇之 API 接口免费 JSONPlaceholder">Java 工具篇之 API 接口免费 JSONPlaceholder</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E5%B7%A5%E5%85%B7%E7%AF%87%E4%B9%8B%20%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E7%BB%9F%E8%AE%A1%E4%BB%A3%E7%A0%81%E8%80%97%E6%97%B6/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 工具篇之 如何优雅的统计代码耗时">Java 工具篇之 如何优雅的统计代码耗时</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B9%8B%20%E4%B8%8D%E5%8F%AF%E4%B8%8D%E7%9F%A5%E7%9A%84%207%20%E4%B8%AA%20JDK%20%E5%91%BD%E4%BB%A4/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 命令行之 不可不知的 7 个 JDK 命令">Java 命令行之 不可不知的 7 个 JDK 命令</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%AF%87%E4%B9%8B%20Window%20%E5%90%8E%E5%8F%B0%E5%90%AF%E5%8A%A8%20JAR%20%E7%A8%8B%E5%BA%8F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 命令行篇之 Window 后台启动 JAR 程序">Java 命令行篇之 Window 后台启动 JAR 程序</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E5%B7%A5%E5%85%B7%E7%AF%87%E4%B9%8B%20API%20%E6%96%87%E6%A1%A3%E5%B7%A5%E5%85%B7%20Swagger3.x-2.x/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 工具篇之 API 文档工具 Swagger3.x-2.x">Java 工具篇之 API 文档工具 Swagger3.x-2.x</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E5%B7%A5%E5%85%B7%E7%AF%87%E4%B9%8B%20Lombok/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 工具篇之 Lombok">Java 工具篇之 Lombok</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E5%B7%A5%E5%85%B7%E7%AF%87%E4%B9%8B%20%E6%8E%8C%E6%8F%A114%E7%A7%8DUML%E5%9B%BE/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 工具篇之 掌握14种UML图">Java 工具篇之 掌握14种UML图</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E5%B7%A5%E5%85%B7%E7%B1%BB%E4%B9%8B%20%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B7%A5%E5%85%B7%E7%B1%BB/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 工具类之 自定义工具类">Java 工具类之 自定义工具类</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20Bean%20%E4%B9%8B%20DTO%E3%80%81VO%E3%80%81PO%E3%80%81DO%E3%80%81BO%20%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java Bean 之 DTO、VO、PO、DO、BO 类的区别">Java Bean 之 DTO、VO、PO、DO、BO 类的区别</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20JSON%20%E7%AF%87%E4%B9%8B%20Jackson/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java JSON 篇之 Jackson">Java JSON 篇之 Jackson</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20JSON%20%E7%AF%87%E4%B9%8B%20Gson/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java JSON 篇之 Gson">Java JSON 篇之 Gson</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Curl%20%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%91%BD%E4%BB%A4%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Curl 的使用及命令参数说明">Curl 的使用及命令参数说明</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20JSON%20%E7%AF%87%E4%B9%8B%20FastJson/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java JSON 篇之 FastJson">Java JSON 篇之 FastJson</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 中间件 Redis "
           href="/blog/2023/08/28/5%E3%80%81%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/backup/Redis6/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Redis6">Redis6</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 中间件 Redis "
           href="/blog/2023/08/28/5%E3%80%81%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/Redis-%E6%9C%80%E5%85%A8%E5%AE%9E%E6%88%98/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Redis-最全实战">Redis-最全实战</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 中间件 Redis "
           href="/blog/2023/08/28/5%E3%80%81%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/Redis-%E4%BB%A3%E7%A0%81%E5%AE%9E%E6%88%98/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Redis-代码实战">Redis-代码实战</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 中间件 RabbitMQ "
           href="/blog/2023/08/28/5%E3%80%81%E4%B8%AD%E9%97%B4%E4%BB%B6/RabbitMQ/RabbitMQ-3.8.14/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="RabbitMQ-3.8.14">RabbitMQ-3.8.14</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 中间件 RabbitMQ "
           href="/blog/2023/08/28/5%E3%80%81%E4%B8%AD%E9%97%B4%E4%BB%B6/RabbitMQ/RabbitMQ-3.7.x/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="RabbitMQ-3.7.x">RabbitMQ-3.7.x</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 中间件 RabbitMQ "
           href="/blog/2023/08/28/5%E3%80%81%E4%B8%AD%E9%97%B4%E4%BB%B6/RabbitMQ/RabbitMQ-3.8.14-%E5%8D%9A%E5%AE%A2%E7%89%88/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="RabbitMQ-3.8.14-博客版">RabbitMQ-3.8.14-博客版</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 中间件 MongoDB "
           href="/blog/2023/08/28/5%E3%80%81%E4%B8%AD%E9%97%B4%E4%BB%B6/MongoDB/MongDB-4.4.2-%E5%8D%9A%E5%AE%A2%E7%89%88/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="MongDB-4.4.2-博客版">MongDB-4.4.2-博客版</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 中间件 MongoDB "
           href="/blog/2023/08/28/5%E3%80%81%E4%B8%AD%E9%97%B4%E4%BB%B6/MongoDB/MongDB-4.4.2/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="MongDB-4.4.2">MongDB-4.4.2</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 中间件 ElasticSearch "
           href="/blog/2023/08/28/5%E3%80%81%E4%B8%AD%E9%97%B4%E4%BB%B6/ElasticSearch/ElasticSearch7.6.x%E5%AE%9E%E6%88%98/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="ElasticSearch7.6.x实战">ElasticSearch7.6.x实战</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Linux 虚拟机工具 "
           href="/blog/2023/08/28/4%E3%80%81Linux/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%B7%A5%E5%85%B7/Virtualbox%E7%BD%91%E7%BB%9C%E8%AE%BE%E7%BD%AE%E6%88%96%E9%85%8D%E7%BD%AE/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Virtualbox网络设置或配置">Virtualbox网络设置或配置</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Linux 虚拟机工具 "
           href="/blog/2023/08/28/4%E3%80%81Linux/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%B7%A5%E5%85%B7/Virtualbox%E5%AE%89%E8%A3%85Centos7%E5%AE%9E%E6%88%98/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Virtualbox安装Centos7实战">Virtualbox安装Centos7实战</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Linux Kubernetes "
           href="/blog/2023/08/28/4%E3%80%81Linux/Kubernetes/Minikube-k8s/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Minikube-k8s">Minikube-k8s</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Linux Kubernetes "
           href="/blog/2023/08/28/4%E3%80%81Linux/Kubernetes/k0s%20%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B%EF%BC%9A%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%20Kubernetes%20%E9%9B%86%E7%BE%A4/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="k0s 使用教程：如何快速搭建 Kubernetes 集群">k0s 使用教程：如何快速搭建 Kubernetes 集群</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Linux Nginx "
           href="/blog/2023/08/28/4%E3%80%81Linux/Nginx/Nginx-1.8.0/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Nginx-1.8.0">Nginx-1.8.0</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Linux Docker "
           href="/blog/2023/08/28/4%E3%80%81Linux/Docker/Docker%E5%88%9D%E7%BA%A7%E5%88%B0%E5%AE%9E%E6%88%98/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Docker初级到实战">Docker初级到实战</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Linux Docker "
           href="/blog/2023/08/28/4%E3%80%81Linux/Docker/Docker&Docker-Compose%E5%AE%9E%E6%88%98-%E5%93%88%E5%96%BD%E6%B2%83%E5%BE%B7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Docker&amp;Docker-Compose实战-哈喽沃德">Docker&amp;Docker-Compose实战-哈喽沃德</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring/Spring%20Bean%20%E7%9A%84%E5%8A%A8%E6%80%81%E5%88%9B%E5%BB%BA%E8%8E%B7%E5%8F%96%E5%88%A0%E9%99%A4/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Spring Bean 的动态创建获取删除">Spring Bean 的动态创建获取删除</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring/Spring%20Bean%20%E7%9A%8412%E7%A7%8D%E5%AE%9A%E4%B9%89%E6%96%B9%E6%B3%95/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Spring Bean 的12种定义方法">Spring Bean 的12种定义方法</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring/Spring%20Bean%20%E6%B3%A8%E5%85%A5%E7%9A%843%E7%A7%8D%E6%96%B9%E5%BC%8F,%20%E4%B8%BA%E4%BD%95%E5%AE%98%E6%96%B9%E5%BB%BA%E8%AE%AE%E4%BD%BF%E7%94%A8%E6%9E%84%E9%80%A0%E5%99%A8%E6%B3%A8%E5%85%A5/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Spring Bean 注入的3种方式, 为何官方建议使用构造器注入">Spring Bean 注入的3种方式, 为何官方建议使用构造器注入</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Transaction/%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/Spring%20%E8%A7%A3%E5%86%B3%E5%8D%95%E6%9C%BA%E7%8E%AF%E5%A2%83%E4%B8%8B%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E7%9A%84%E4%BA%8B%E5%8A%A1%E9%97%AE%E9%A2%98/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Spring 解决单机环境下多数据源的事务问题">Spring 解决单机环境下多数据源的事务问题</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Transaction/%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/Spring%20%E5%AE%9E%E7%8E%B0%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E5%AE%9E%E6%88%98/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Spring 实现多数据源实战">Spring 实现多数据源实战</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Transaction/%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/Spring%20%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81%E6%95%B0%E6%8D%AE%E6%BA%90%E3%80%81%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E5%88%87%E6%8D%A2%E6%96%B9%E5%BC%8F%E3%80%81%E5%A4%9A%E6%95%B0%E6%8D%AE%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Spring 实现动态数据源、多数据源切换方式、多数据事务管理">Spring 实现动态数据源、多数据源切换方式、多数据事务管理</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Transaction/Spring%20%E4%BA%8B%E5%8A%A1%E5%8E%9F%E7%90%86%E6%B7%B1%E5%85%A5%E4%B8%8E%E5%88%86%E6%9E%90/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Spring 事务原理深入与分析">Spring 事务原理深入与分析</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Security/SpringSecurity/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringSecurity">SpringSecurity</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Transaction/JDBC/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="JDBC">JDBC</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Transaction/Spring%20JDBC%20-%20JdbcTemplate/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Spring JDBC - JdbcTemplate">Spring JDBC - JdbcTemplate</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Transaction/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8B%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/JDBC%E6%89%B9%E5%A4%84%E7%90%86%E5%AE%9E%E7%8E%B0%E6%89%8B%E5%8A%A8%E4%BA%8B%E5%8A%A1%E6%8F%92%E5%85%A51000%E4%B8%87%E6%95%B0%E6%8D%AE%EF%BC%88%E5%8D%95%E7%BA%BF%E7%A8%8B%20&%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%89/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="JDBC批处理实现手动事务插入1000万数据（单线程 &amp; 多线程）">JDBC批处理实现手动事务插入1000万数据（单线程 &amp; 多线程）</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Data%20JPA/SpringData%20JPA%20%E7%B1%BB%E5%9B%BE%E5%8F%8A%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringData JPA 类图及使用方法整理">SpringData JPA 类图及使用方法整理</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Data%20JPA/SpringData%20JPA/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringData JPA">SpringData JPA</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Data%20JPA/Spring%20Data%20JPA%20%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E6%88%98/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Spring Data JPA 原理与实战">Spring Data JPA 原理与实战</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Data%20JPA/Hibernata%20JPA/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Hibernata JPA">Hibernata JPA</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Cloud%20Alibaba/SpringCloud%20Alibaba/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringCloud Alibaba">SpringCloud Alibaba</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot2.x%20%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AF%87%20-%20%E6%95%B4%E5%90%88H2%E6%95%B0%E6%8D%AE%E5%BA%93/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot2.x 数据库篇 - 整合H2数据库">SpringBoot2.x 数据库篇 - 整合H2数据库</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot2.x%20%E9%A1%B9%E7%9B%AE%E7%BB%9F%E4%B8%80%E6%9E%9A%E4%B8%BE%E8%BD%AC%E6%8D%A2%E5%AE%9E%E8%B7%B5/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot2.x 项目统一枚举转换实践">SpringBoot2.x 项目统一枚举转换实践</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AD%A6/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot从零开始学">SpringBoot从零开始学</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%E9%85%8D%E7%BD%AE%E5%B1%9E%E6%80%A7%E4%B9%8BDataSource/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot配置属性之DataSource">SpringBoot配置属性之DataSource</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SprinigBoot%E6%96%87%E7%AB%A0%E6%91%98%E8%A6%81%E5%8F%8A%E8%BD%AC%E8%BD%BD/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SprinigBoot文章摘要及转载">SprinigBoot文章摘要及转载</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/%E4%BB%A3%E7%A0%81%E5%AE%A1%E6%9F%A5%E7%9A%84%E5%BF%85%E8%A6%81%E6%80%A7%E5%92%8C%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="代码审查的必要性和最佳实践">代码审查的必要性和最佳实践</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6-%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%B9%8B@Value%E8%BF%9B%E9%98%B6/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 配置文件-读取配置文件之@Value进阶">SpringBoot 2.x 配置文件-读取配置文件之@Value进阶</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6-%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9A%84N%E7%A7%8D%E6%96%B9%E5%BC%8F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 配置文件-读取配置文件的N种方式">SpringBoot 2.x 配置文件-读取配置文件的N种方式</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6-%E8%AF%BB%E5%8F%96%20Resources%20%E6%96%87%E4%BB%B6%E4%B9%8B%E6%97%A0%E6%B3%95%E8%AF%BB%E5%8F%96Jar%E5%8C%85classpath%E4%B8%8B%E7%9A%84%E6%96%87%E4%BB%B6/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 配置文件-读取 Resources 文件之无法读取Jar包classpath下的文件">SpringBoot 2.x 配置文件-读取 Resources 文件之无法读取Jar包classpath下的文件</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E7%BB%9F%E4%B8%80%E6%8E%A5%E5%8F%A3%E8%BF%94%E5%9B%9E%E6%A0%BC%E5%BC%8F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 统一接口返回格式">SpringBoot 2.x 统一接口返回格式</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6-%E8%AF%BB%E5%8F%96%20Resources%20%E6%96%87%E4%BB%B6%E7%9A%84N%E7%A7%8D%E6%96%B9%E5%BC%8F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 配置文件-读取 Resources 文件的N种方式">SpringBoot 2.x 配置文件-读取 Resources 文件的N种方式</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B%E7%AF%87-%E6%8B%A6%E6%88%AA%E5%99%A8%E8%BF%87%E6%BB%A4%E5%99%A8%E4%B8%8E%E7%9B%91%E5%90%AC%E5%99%A8/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 切面编程篇-拦截器过滤器与监听器">SpringBoot 2.x 切面编程篇-拦截器过滤器与监听器</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3%E8%AF%A6%E8%A7%A3/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 常用注解详解">SpringBoot 2.x 常用注解详解</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3%E5%A4%A7%E5%85%A8/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 常用注解大全">SpringBoot 2.x 常用注解大全</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E5%AE%89%E5%85%A8%E5%AF%86%E7%A0%81%E5%AD%A6%E4%B9%8B%E5%8A%A0%E8%A7%A3%E5%AF%86%E7%AE%97%E6%B3%95/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 安全密码学之加解密算法">SpringBoot 2.x 安全密码学之加解密算法</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E5%90%AF%E5%8A%A8%E6%97%B6%E5%8A%A0%E8%BD%BD%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84N%E7%A7%8D%E6%96%B9%E5%BC%8F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 启动时加载初始化的N种方式">SpringBoot 2.x 启动时加载初始化的N种方式</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%8F%8A%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E8%BF%87%E7%A8%8B/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 启动流程及自动装配过程">SpringBoot 2.x 启动流程及自动装配过程</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E5%8A%A8%E6%80%81%E8%A3%85%E9%85%8DBean%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 动态装配Bean的三种方式">SpringBoot 2.x 动态装配Bean的三种方式</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E5%88%A9%E5%99%A8-1%20JUnit5/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 单元测试利器-1 JUnit5">SpringBoot 2.x 单元测试利器-1 JUnit5</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E5%88%A9%E5%99%A8-3%20MockMvc/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 单元测试利器-3 MockMvc">SpringBoot 2.x 单元测试利器-3 MockMvc</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E5%88%A9%E5%99%A8-2%20Mockito/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 单元测试利器-2 Mockito">SpringBoot 2.x 单元测试利器-2 Mockito</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E5%88%86%E7%89%87%E4%B8%8A%E4%BC%A0%E3%80%81%E6%96%AD%E7%82%B9%E7%BB%AD%E4%BC%A0%E3%80%81%E5%A4%A7%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E3%80%81%E7%A7%92%E4%BC%A0/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 分片上传、断点续传、大文件上传、秒传">SpringBoot 2.x 分片上传、断点续传、大文件上传、秒传</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20Validation%20%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C%EF%BC%88TODO%EF%BC%89/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x Validation 参数校验（TODO）">SpringBoot 2.x Validation 参数校验（TODO）</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20WebMvcConfigurer%20%E8%AF%A6%E8%A7%A3%E3%80%90SpringMVC%E3%80%91/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x WebMvcConfigurer 详解【SpringMVC】">SpringBoot 2.x WebMvcConfigurer 详解【SpringMVC】</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20YML%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x YML配置文件详解">SpringBoot 2.x YML配置文件详解</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E5%88%86%E5%B8%83%E5%BC%8F%E5%85%A8%E5%B1%80%E5%94%AF%E4%B8%80ID%E7%94%9F%E6%88%90%E6%96%B9%E6%A1%88/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 分布式全局唯一ID生成方案">SpringBoot 2.x 分布式全局唯一ID生成方案</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20JWT%20%E6%A6%82%E5%BF%B5%E7%AF%87/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x JWT 概念篇">SpringBoot 2.x JWT 概念篇</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20Jar%20%E5%8C%85%E5%90%AF%E5%8A%A8%E3%80%81%E5%81%9C%E6%AD%A2%E3%80%81%E9%87%8D%E5%90%AF%E8%84%9A%E6%9C%AC/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x Jar 包启动、停止、重启脚本">SpringBoot 2.x Jar 包启动、停止、重启脚本</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20Java%20%E5%AE%9E%E7%8E%B0%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E7%9A%848%E7%A7%8D%E6%96%B9%E5%BC%8F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x Java 实现异步编程的8种方式">SpringBoot 2.x Java 实现异步编程的8种方式</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20Java%20%E7%A8%8B%E5%BA%8F%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0%E6%80%BB%E7%BB%93/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x Java 程序命令行参数总结">SpringBoot 2.x Java 程序命令行参数总结</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20@ConfigurationProperties%E4%BB%A5%E5%8F%8A@NestedConfigurationProperty%E7%9A%84%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x @ConfigurationProperties以及@NestedConfigurationProperty的使用详解">SpringBoot 2.x @ConfigurationProperties以及@NestedConfigurationProperty的使用详解</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20@ControllerAdvice%E4%B8%89%E7%A7%8D%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x @ControllerAdvice三种使用场景">SpringBoot 2.x @ControllerAdvice三种使用场景</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20HTTP%20Content-Type%20%E8%AF%A6%E8%A7%A3/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x HTTP Content-Type 详解">SpringBoot 2.x HTTP Content-Type 详解</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20HTTP%20Headers%20%E5%A4%B4%E4%BF%A1%E6%81%AF%E8%AF%BB%E5%8F%96/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x HTTP Headers 头信息读取">SpringBoot 2.x HTTP Headers 头信息读取</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20JWT%20%E5%AE%9E%E6%88%98%E7%AF%87/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x JWT 实战篇">SpringBoot 2.x JWT 实战篇</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%20%E6%8E%A5%E5%8F%A3%E5%B9%82%E7%AD%89%E6%80%A7%E5%AE%9E%E7%8E%B0/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x  接口幂等性实现">SpringBoot 2.x  接口幂等性实现</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/Spring%20IO%20Platform%EF%BC%9A%E8%A7%A3%E5%86%B3%E4%BE%9D%E8%B5%96%E7%89%88%E6%9C%AC%E5%86%B2%E7%AA%81/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Spring IO Platform：解决依赖版本冲突">Spring IO Platform：解决依赖版本冲突</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B%E7%AF%87-AOP%20%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%8E%9F%E7%90%86/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 切面编程篇-AOP 的使用及原理">SpringBoot 2.x 切面编程篇-AOP 的使用及原理</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE SSM框架 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/2%E3%80%81SSM%E6%A1%86%E6%9E%B6/SpringMVC/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringMVC">SpringMVC</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Shiro/Shiro%E6%9D%83%E9%99%90%E5%AE%9E%E6%88%98/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Shiro权限实战">Shiro权限实战</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE SSM框架 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/2%E3%80%81SSM%E6%A1%86%E6%9E%B6/Spring/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Spring">Spring</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE SSM框架 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/2%E3%80%81SSM%E6%A1%86%E6%9E%B6/MybatisPlus/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="MybatisPlus">MybatisPlus</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE JavaWeb "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/1%E3%80%81JavaWeb/%E4%BD%A0%E8%BF%98%E5%9C%A8%E4%B8%BA%20HTTP%20%E7%9A%84%E8%BF%99%E4%BA%9B%E6%A6%82%E5%BF%B5%E5%A4%B4%E7%96%BC%E5%90%97/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="你还在为 HTTP 的这些概念头疼吗">你还在为 HTTP 的这些概念头疼吗</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE JavaWeb "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/1%E3%80%81JavaWeb/Cookie%E3%80%81Session%E3%80%81Token%E3%80%81JWT%E7%BB%88%E4%BA%8E%E8%AE%B2%E6%B8%85%E6%A5%9A%E4%BA%86/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Cookie、Session、Token、JWT终于讲清楚了">Cookie、Session、Token、JWT终于讲清楚了</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 数据库 "
           href="/blog/2023/08/28/3%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL-%E9%AB%98%E7%BA%A7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="MySQL-高级">MySQL-高级</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 数据库 "
           href="/blog/2023/08/28/3%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL-%E5%88%9D%E7%BA%A7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="MySQL-初级">MySQL-初级</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 数据库 "
           href="/blog/2023/08/28/3%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93/H2%20Database/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="H2 Database">H2 Database</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E4%BC%98%E5%8C%96%E7%AF%87%E4%B9%8B%20%E6%B3%A8%E8%A7%A3%20+%20%E5%8F%8D%E5%B0%84%E6%B6%88%E9%99%A4%E9%87%8D%E5%A4%8D%E4%BB%A3%E7%A0%81/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 优化篇之 注解 + 反射消除重复代码">Java 优化篇之 注解 + 反射消除重复代码</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E4%BC%98%E5%8C%96%E7%AF%87%E4%B9%8B%20%E5%BB%B6%E6%97%B6%E9%98%9F%E5%88%97%20-%20%E8%AE%A2%E5%8D%95%E8%B6%85%E6%97%B6%E8%87%AA%E5%8A%A8%E5%8F%96%E6%B6%88%E7%9A%84N%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 优化篇之 延时队列 - 订单超时自动取消的N种实现方式">Java 优化篇之 延时队列 - 订单超时自动取消的N种实现方式</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E9%9B%86%E5%90%88%E7%AF%87%E4%B9%8B%20%E8%8E%B7%E5%8F%96%E4%B8%A4%E4%B8%AA%E9%9B%86%E5%90%88List%E7%9A%84%E4%BA%A4%E9%9B%86%E3%80%81%E8%A1%A5%E9%9B%86%E3%80%81%E5%B9%B6%E9%9B%86%E3%80%81%E5%B7%AE%E9%9B%86%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 集合篇之 获取两个集合List的交集、补集、并集、差集的几种方式">Java 集合篇之 获取两个集合List的交集、补集、并集、差集的几种方式</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E4%BC%98%E5%8C%96%E7%AF%87%E4%B9%8B%20if-else%20%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 优化篇之 if-else 代码优化方案">Java 优化篇之 if-else 代码优化方案</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4%E5%90%84%E7%B1%BB%E5%9E%8B%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 日期时间各类型相互转换">Java 日期时间各类型相互转换</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E9%9B%86%E5%90%88%E7%AF%87%E4%B9%8B%20Lambda%20%E5%AE%9E%E7%8E%B0%E8%B6%85%E5%BC%BA%E6%8E%92%E5%BA%8F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 集合篇之 Lambda 实现超强排序">Java 集合篇之 Lambda 实现超强排序</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 动态代理">Java 动态代理</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E5%9F%BA%E6%9C%AC%E5%8A%9F%E7%AF%87%E4%B9%8B%20for%E3%80%81for-each%E3%80%81forEach()%20%E7%9A%84%20break%E3%80%81continue%E3%80%81return/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 基本功篇之 for、for-each、forEach() 的 break、continue、return">Java 基本功篇之 for、for-each、forEach() 的 break、continue、return</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6%E8%AF%A6%E8%A7%A3/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 日志框架详解">Java 日志框架详解</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java新特性 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/3.Java%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%20%E6%96%B0%E7%89%B9%E6%80%A7%E6%A6%82%E8%BF%B0%E5%8F%8A%E7%89%88%E6%9C%AC%E5%8F%91%E8%A1%8C%E5%8F%B2/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 新特性概述及版本发行史">Java 新特性概述及版本发行史</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20Bean%20%E4%B9%8B%20Record%20%E7%B1%BB/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java Bean 之 Record 类">Java Bean 之 Record 类</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E4%BC%98%E5%8C%96%E7%AF%87%E4%B9%8B%20GZIP%E5%8E%8B%E7%BC%A9%E5%AD%97%E7%AC%A6%E4%B8%B2/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 优化篇之 GZIP压缩字符串">Java 优化篇之 GZIP压缩字符串</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java进阶篇 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/2.Java%20%E8%BF%9B%E9%98%B6%E7%AF%87/JVM%20%E8%99%9A%E6%8B%9F%E6%9C%BA/Java%20GC%20%E6%80%BB%E7%BB%93/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java GC 总结">Java GC 总结</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java新特性 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/3.Java%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%209%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%209%20%E6%96%B0%E7%89%B9%E6%80%A7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 9 新特性">Java 9 新特性</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java新特性 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/3.Java%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%208%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%208%20%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8B%20Stream%20%E6%B5%81/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 8 新特性之 Stream 流">Java 8 新特性之 Stream 流</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java新特性 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/3.Java%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%208%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%208%20%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8B%20Optional%20%E7%B1%BB/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 8 新特性之 Optional 类">Java 8 新特性之 Optional 类</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java新特性 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/3.Java%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%208%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%208%20%E6%96%B0%E7%89%B9%E6%80%A7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 8 新特性">Java 8 新特性</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java新特性 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/3.Java%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%208%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%208%20%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8B%20DateTime%20API/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 8 新特性之 DateTime API">Java 8 新特性之 DateTime API</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java新特性 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/3.Java%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2018%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2018%20%E6%96%B0%E7%89%B9%E6%80%A7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 18 新特性">Java 18 新特性</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java新特性 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/3.Java%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2019%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2019%20%E6%96%B0%E7%89%B9%E6%80%A7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 19 新特性">Java 19 新特性</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java新特性 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/3.Java%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2020%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2020%20%E6%96%B0%E7%89%B9%E6%80%A7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 20 新特性">Java 20 新特性</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java新特性 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/3.Java%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2017%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2017%20%E6%96%B0%E7%89%B9%E6%80%A7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 17 新特性">Java 17 新特性</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java新特性 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/3.Java%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2015%E6%96%B0%E7%89%B9%E6%80%A7/Java%2015%20%E6%96%B0%E7%89%B9%E6%80%A7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 15 新特性">Java 15 新特性</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java新特性 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/3.Java%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2016%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2016%20%E6%96%B0%E7%89%B9%E6%80%A7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 16 新特性">Java 16 新特性</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java新特性 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/3.Java%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2013%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2013%20%E6%96%B0%E7%89%B9%E6%80%A7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 13 新特性">Java 13 新特性</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java新特性 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/3.Java%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2014%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2014%20%E6%96%B0%E7%89%B9%E6%80%A7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 14 新特性">Java 14 新特性</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java新特性 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/3.Java%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2010%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2010%20%E6%96%B0%E7%89%B9%E6%80%A7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 10 新特性">Java 10 新特性</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java新特性 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/3.Java%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2012%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2012%20%E6%96%B0%E7%89%B9%E6%80%A7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 12 新特性">Java 12 新特性</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java新特性 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/3.Java%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2011%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2011%20%E6%96%B0%E7%89%B9%E6%80%A7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 11 新特性">Java 11 新特性</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java基础篇 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/1.Java%20%E5%9F%BA%E7%A1%80%E7%AF%87/1%E3%80%81Java%20%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/Java%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 面向对象编程">Java 面向对象编程</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java基础篇 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/1.Java%20%E5%9F%BA%E7%A1%80%E7%AF%87/3%E3%80%81Java%20%E9%9B%86%E5%90%88%E7%B1%BB/Java%20%E7%B1%BB%E9%9B%86%E6%A1%86%E6%9E%B6/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 类集框架">Java 类集框架</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java基础篇 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/1.Java%20%E5%9F%BA%E7%A1%80%E7%AF%87/2%E3%80%81Java%20%E5%B8%B8%E7%94%A8%E7%B1%BB%E5%BA%93/Java%20%E5%B8%B8%E7%94%A8%E7%B1%BB%E5%BA%93/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 常用类库">Java 常用类库</span>
            <span class="post-date" title="2023-08-28 09:23:44">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java基础篇 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/1.Java%20%E5%9F%BA%E7%A1%80%E7%AF%87/5%E3%80%81Java%20%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 多线程基础">Java 多线程基础</span>
            <span class="post-date" title="2023-08-28 09:23:44">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java基础篇 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/1.Java%20%E5%9F%BA%E7%A1%80%E7%AF%87/4%E3%80%81Java%20%E5%8F%8D%E5%B0%84%E4%B8%8E%E6%B3%A8%E8%A7%A3/Java%20%E5%8F%8D%E5%B0%84%E4%B8%8E%E6%B3%A8%E8%A7%A3/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 反射与注解">Java 反射与注解</span>
            <span class="post-date" title="2023-08-28 09:23:44">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java基础篇 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/1.Java%20%E5%9F%BA%E7%A1%80%E7%AF%87/7%E3%80%81Java%20NIO%20%E6%B5%81/Java%20NIO%20%E6%B5%81/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java NIO 流">Java NIO 流</span>
            <span class="post-date" title="2023-08-28 09:23:44">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java基础篇 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/1.Java%20%E5%9F%BA%E7%A1%80%E7%AF%87/6%E3%80%81Java%20IO%20%E6%B5%81/Java%20IO%20%E6%B5%81/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java IO 流">Java IO 流</span>
            <span class="post-date" title="2023-08-28 09:23:44">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java进阶篇 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/2.Java%20%E8%BF%9B%E9%98%B6%E7%AF%87/Java%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/Java%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 设计模式">Java 设计模式</span>
            <span class="post-date" title="2023-08-28 09:23:44">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java进阶篇 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/2.Java%20%E8%BF%9B%E9%98%B6%E7%AF%87/JVM%20%E8%99%9A%E6%8B%9F%E6%9C%BA/7%20%E6%AE%B5%E5%B0%8F%E4%BB%A3%E7%A0%81%EF%BC%8C%E7%8E%A9%E8%BD%ACJava%E7%A8%8B%E5%BA%8F%E5%B8%B8%E8%A7%81%E7%9A%84%E5%B4%A9%E6%BA%83%E5%9C%BA%E6%99%AF/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="7 段小代码，玩转Java程序常见的崩溃场景">7 段小代码，玩转Java程序常见的崩溃场景</span>
            <span class="post-date" title="2023-08-28 09:23:44">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java进阶篇 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/2.Java%20%E8%BF%9B%E9%98%B6%E7%AF%87/JVM%20%E8%99%9A%E6%8B%9F%E6%9C%BA/JVM%20%E8%99%9A%E6%8B%9F%E6%9C%BA/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="JVM 虚拟机">JVM 虚拟机</span>
            <span class="post-date" title="2023-08-28 09:23:44">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 前端框架 前端入门 "
           href="/blog/2023/08/28/7%E3%80%81%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/%E5%89%8D%E7%AB%AF%E5%85%A5%E9%97%A8/Chrome%20%E6%B5%8F%E8%A7%88%E5%99%A8%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Chrome 浏览器开发者工具使用技巧总结">Chrome 浏览器开发者工具使用技巧总结</span>
            <span class="post-date" title="2023-08-28 09:23:44">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 前端框架 前端入门 "
           href="/blog/2023/08/28/7%E3%80%81%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/%E5%89%8D%E7%AB%AF%E5%85%A5%E9%97%A8/HTML5%20%E6%A0%87%E7%AD%BE%E5%A4%A7%E5%85%A8/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="HTML5 标签大全">HTML5 标签大全</span>
            <span class="post-date" title="2023-08-28 09:23:44">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 前端框架 前端入门 "
           href="/blog/2023/08/28/7%E3%80%81%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/%E5%89%8D%E7%AB%AF%E5%85%A5%E9%97%A8/3.JavaScript%E8%AF%A6%E8%A7%A3/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="3.JavaScript详解">3.JavaScript详解</span>
            <span class="post-date" title="2023-08-28 09:23:44">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 前端框架 前端入门 "
           href="/blog/2023/08/28/7%E3%80%81%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/%E5%89%8D%E7%AB%AF%E5%85%A5%E9%97%A8/2.CSS3%E8%AF%A6%E8%A7%A3/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="2.CSS3详解">2.CSS3详解</span>
            <span class="post-date" title="2023-08-28 09:23:44">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 前端框架 "
           href="/blog/2023/08/28/7%E3%80%81%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/Vue2&Vue3/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Vue2&amp;Vue3">Vue2&amp;Vue3</span>
            <span class="post-date" title="2023-08-28 09:23:44">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 前端框架 前端入门 "
           href="/blog/2023/08/28/7%E3%80%81%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/%E5%89%8D%E7%AB%AF%E5%85%A5%E9%97%A8/0.%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="0.前端知识体系">0.前端知识体系</span>
            <span class="post-date" title="2023-08-28 09:23:44">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 前端框架 前端入门 "
           href="/blog/2023/08/28/7%E3%80%81%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/%E5%89%8D%E7%AB%AF%E5%85%A5%E9%97%A8/1.HTML5%E8%AF%A6%E8%A7%A3/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="1.HTML5详解">1.HTML5详解</span>
            <span class="post-date" title="2023-08-28 09:23:44">2023/08/28</span>
        </a>
        
        <div id="no-item-tips">

        </div>
    </nav>
    <div id="outline-list">
    </div>
</div>

    </div>
    <div class="hide-list">
        <div class="semicircle" data-title="切换全屏 快捷键 s">
            <div class="brackets first"><</div>
            <div class="brackets">&gt;</div>
        </div>
    </div>
</aside>
<div id="post">
    <div class="pjax">
        <article id="post-2、JavaEE/3、微服务开发/Spring Transaction/Spring 事务应用及源码分析" class="article article-type-post" itemscope itemprop="blogPost">
    
        <h1 class="article-title">Spring 事务应用及源码分析</h1>
    
    <div class="article-meta">
        
        
        
        <span class="book">
            <i class="iconfont icon-category"></i>
            
            
            <a  data-rel="JavaEE">JavaEE</a> > 
            
            <a  data-rel="JavaEE&lt;---&gt;微服务开发">微服务开发</a>
            
        </span>
        
        
    </div>
    <div class="article-meta">
        
            发布时间 : <time class="date" title='最后更新: 2024-10-25 18:00:36'>2024-08-16 10:33</time>
        
    </div>
    <div class="article-meta">
        
        
        <span id="busuanzi_container_page_pv">
            阅读 :<span id="busuanzi_value_page_pv">
                <span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </span>
        </span>
        
        
    </div>
    
    <div class="toc-ref">
    
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E7%9A%84%E6%A1%88%E4%BE%8B%E6%BC%94%E7%A4%BA"><span class="toc-text">一、事务传播的案例演示</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E4%BB%8B%E7%BB%8D"><span class="toc-text">1、事务的隔离级别介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E4%BA%8B%E5%8A%A1%E7%9A%84%E4%BC%A0%E6%92%AD%E7%B1%BB%E5%9E%8B%E4%BB%8B%E7%BB%8D"><span class="toc-text">2、事务的传播类型介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E6%A1%88%E4%BE%8B%E6%BC%94%E7%A4%BA%E6%95%B0%E6%8D%AE%E8%AF%B4%E6%98%8E"><span class="toc-text">3、案例演示数据说明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81REQUIRED"><span class="toc-text">4、REQUIRED</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81SUPPORTS"><span class="toc-text">5、SUPPORTS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81MANDATORY"><span class="toc-text">6、MANDATORY</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E3%80%81REQUIRES-NEW"><span class="toc-text">7、REQUIRES_NEW</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8%E3%80%81NOT-SUPPORTED"><span class="toc-text">8、NOT_SUPPORTED</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9%E3%80%81NEVER"><span class="toc-text">9、NEVER</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10%E3%80%81NESTED"><span class="toc-text">10、NESTED</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#NESTED-%E4%B8%8E-REQUIRES-NEW%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">NESTED 与 REQUIRES_NEW的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NESTED-%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-text">NESTED 实现方式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E4%BA%8B%E5%8A%A1%E5%BC%80%E5%90%AF%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-text">二、事务开启的两种方式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1"><span class="toc-text">1、声明式事务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E7%BC%96%E7%A8%8B%E5%BC%8F%E4%BA%8B%E5%8A%A1"><span class="toc-text">2、编程式事务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81TransactionTemplate-%E5%AE%9E%E7%8E%B0%E7%BC%96%E7%A8%8B%E5%BC%8F%E4%BA%8B%E5%8A%A1"><span class="toc-text">1、TransactionTemplate 实现编程式事务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81TransactionManager-%E5%AE%9E%E7%8E%B0%E7%BC%96%E7%A8%8B%E5%BC%8F%E4%BA%8B%E5%8A%A1"><span class="toc-text">2、TransactionManager 实现编程式事务</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#0%E3%80%81TransactionDefinition-%E6%8E%A5%E5%8F%A3%E9%A2%84%E4%BB%8B%E7%BB%8D"><span class="toc-text">0、TransactionDefinition 接口预介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E6%8E%A5%E5%8F%A3%E5%BC%80%E5%90%AF%E4%BA%8B%E5%8A%A1-PlatformTransactionManager"><span class="toc-text">1、接口开启事务 PlatformTransactionManager</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81Spring-Mybatis-%E5%BC%80%E5%90%AF%E4%BA%8B%E5%8A%A1-DataSourceTransactionManager"><span class="toc-text">2、Spring&#x2F;Mybatis 开启事务 DataSourceTransactionManager</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81JPA-%E5%BC%80%E5%90%AF%E4%BA%8B%E5%8A%A1-JpaTransactionManager"><span class="toc-text">3、JPA 开启事务 JpaTransactionManager</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BA%8B%E5%8A%A1%E5%B7%A5%E5%85%B7%E7%B1%BB-TransactionManage"><span class="toc-text">4、自定义事务工具类 TransactionManage</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E4%BA%8B%E5%8A%A1%E5%BA%94%E7%94%A8%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-text">三、事务应用的注意事项</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%BA%94%E7%94%A8%E7%BA%A7%E5%88%AB"><span class="toc-text">1、声明式事务的应用级别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E9%95%BF%E4%BA%8B%E5%8A%A1%E3%80%81%E8%BF%87%E6%97%A9%E8%B5%B7%E5%BC%80%E4%BA%8B%E5%8A%A1"><span class="toc-text">2、长事务、过早起开事务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E9%94%81%E7%9A%84%E7%B2%92%E5%BA%A6"><span class="toc-text">3、锁的粒度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E6%AD%BB%E9%94%81"><span class="toc-text">4、数据库死锁</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E4%BA%8B%E5%8A%A1%E5%A4%B1%E6%95%88%E7%9A%84%E5%85%AB%E7%A7%8D%E5%9C%BA%E6%99%AF"><span class="toc-text">四、事务失效的八种场景</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E5%BC%82%E5%B8%B8%E6%9C%AA%E6%8A%9B%E5%87%BA"><span class="toc-text">1、异常未抛出</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E5%BC%82%E5%B8%B8%E4%B8%8Erollback%E4%B8%8D%E5%8C%B9%E9%85%8D"><span class="toc-text">2、异常与rollback不匹配</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E6%96%B9%E6%B3%95%E5%86%85%E9%83%A8%E7%9B%B4%E6%8E%A5%E8%B0%83%E7%94%A8"><span class="toc-text">3、方法内部直接调用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E5%9C%A8%E5%8F%A6%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E4%B8%AD%E4%BD%BF%E7%94%A8%E4%BA%8B%E5%8A%A1"><span class="toc-text">4、在另一个线程中使用事务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81%E6%B3%A8%E8%A7%A3%E4%BD%9C%E7%94%A8%E5%88%B0private%E7%BA%A7%E5%88%AB%E7%9A%84%E6%96%B9%E6%B3%95%E4%B8%8A"><span class="toc-text">5、注解作用到private级别的方法上</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81final-%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">6、final 类型的方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E4%B8%8D%E6%94%AF%E6%8C%81%E4%BA%8B%E5%8A%A1"><span class="toc-text">7、数据库存储引擎不支持事务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8%E3%80%81%E4%BA%8B%E5%8A%A1%E7%9A%84%E4%BC%A0%E6%92%AD%E7%B1%BB%E5%9E%8B"><span class="toc-text">8、事务的传播类型</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%E5%99%A8%E6%9E%B6%E6%9E%84%E5%88%86%E6%9E%90"><span class="toc-text">五、事务管理器架构分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E6%8E%A5%E5%8F%A3%E4%B8%8E%E7%B1%BB%E7%9A%84%E5%85%B3%E7%B3%BB%E5%9B%BE"><span class="toc-text">1、接口与类的关系图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81TransactionManager"><span class="toc-text">2、TransactionManager</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81PlatformTransactionManager"><span class="toc-text">3、PlatformTransactionManager</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81AbstractPlatformTransactionManager"><span class="toc-text">4、AbstractPlatformTransactionManager</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81TransactionTemplate"><span class="toc-text">5、TransactionTemplate</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81TransactionDefinition"><span class="toc-text">6、TransactionDefinition</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="toc-text">1、基本介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E5%9C%BA%E6%99%AF%E4%BB%8B%E7%BB%8D"><span class="toc-text">2、场景介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%89%E7%94%B5%E5%95%86%E7%B3%BB%E7%BB%9F%E8%AE%A2%E5%8D%95%E5%A4%84%E7%90%86"><span class="toc-text">1）电商系统订单处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%89%E9%93%B6%E8%A1%8C%E8%BD%AC%E8%B4%A6%E7%B3%BB%E7%BB%9F"><span class="toc-text">2）银行转账系统</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%EF%BC%89%E5%86%85%E5%AE%B9%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F"><span class="toc-text">3）内容管理系统</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E4%BB%A3%E7%A0%81%E6%A1%88%E4%BE%8B"><span class="toc-text">3、代码案例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB"><span class="toc-text">4、源码解读</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81%E6%A0%B8%E5%BF%83%E6%80%BB%E7%BB%93"><span class="toc-text">5、核心总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E3%80%81%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%E5%99%A8%E6%80%BB%E7%BB%93"><span class="toc-text">7、事务管理器总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%E5%99%A8%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-TransactionSynchronizationManager"><span class="toc-text">六、事务管理器源码分析 TransactionSynchronizationManager</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%816%E4%B8%AA%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%E5%AF%B9%E8%B1%A1-ThreadLocal"><span class="toc-text">1、6个事务管理对象 ThreadLocal</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E4%BA%8B%E5%8A%A1%E8%B5%84%E6%BA%90"><span class="toc-text">2、事务资源</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E8%8E%B7%E5%8F%96%E8%B5%84%E6%BA%90"><span class="toc-text">1、获取资源</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E7%BB%91%E5%AE%9A%E8%B5%84%E6%BA%90"><span class="toc-text">2、绑定资源</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E8%A7%A3%E7%BB%91%E8%B5%84%E6%BA%90"><span class="toc-text">3、解绑资源</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E4%BA%8B%E5%8A%A1%E5%90%8C%E6%AD%A5"><span class="toc-text">3、事务同步</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E4%BA%8B%E5%8A%A1%E5%90%8C%E6%AD%A5%E6%BF%80%E6%B4%BB"><span class="toc-text">1、事务同步激活</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E4%BA%8B%E5%8A%A1%E5%90%8C%E6%AD%A5%E6%B3%A8%E5%86%8C"><span class="toc-text">2、事务同步注册</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E8%8E%B7%E5%8F%96%E4%BA%8B%E5%8A%A1%E5%90%8C%E6%AD%A5%E5%88%97%E8%A1%A8"><span class="toc-text">3、获取事务同步列表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E5%88%A4%E6%96%AD%E5%BD%93%E5%89%8D%E4%BA%8B%E5%8A%A1%E6%98%AF%E5%90%A6%E4%B8%BA%E6%B4%BB%E8%B7%83"><span class="toc-text">4、判断当前事务是否为活跃</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81currentTransactionReadOnly-%E4%B8%8E-currentTransactionIsolationLevel"><span class="toc-text">4、currentTransactionReadOnly 与 currentTransactionIsolationLevel</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81actualTransactionActive"><span class="toc-text">5、actualTransactionActive</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81%E6%B8%85%E9%99%A4%E5%BD%93%E5%89%8D%E7%BA%BF%E7%A8%8B%E4%BA%8B%E5%8A%A1%E5%90%8C%E6%AD%A5%E6%95%B0%E6%8D%AE"><span class="toc-text">6、清除当前线程事务同步数据</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E4%BA%8B%E5%8A%A1%E5%88%9B%E5%BB%BA%E7%9A%84%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90"><span class="toc-text">七、事务创建的流程分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81getTransaction"><span class="toc-text">1、getTransaction</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81startTransaction"><span class="toc-text">2、startTransaction</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81prepareSynchronization"><span class="toc-text">3、prepareSynchronization</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81TransactionStatus"><span class="toc-text">4、TransactionStatus</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81handleExistingTransaction"><span class="toc-text">5、handleExistingTransaction</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81suspend"><span class="toc-text">6、suspend</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AB%E3%80%81%E4%BA%8B%E5%8A%A1%E6%8F%90%E4%BA%A4%E3%80%81%E5%9B%9E%E6%BB%9A%E7%9A%84%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90"><span class="toc-text">八、事务提交、回滚的流程分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81commit"><span class="toc-text">1、commit</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81processCommit"><span class="toc-text">2、processCommit</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81doCommit"><span class="toc-text">3、doCommit</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81processRollback"><span class="toc-text">4、processRollback</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81%E4%BA%8B%E5%8A%A1%E6%8F%90%E4%BA%A4%E4%B8%8E%E5%9B%9E%E6%BB%9A%E6%80%BB%E7%BB%93"><span class="toc-text">5、事务提交与回滚总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B9%9D%E3%80%81afterCommit-%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90"><span class="toc-text">九、afterCommit 实现分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81TransactionSynchronization"><span class="toc-text">1、TransactionSynchronization</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81afterCommit-%E6%96%B9%E6%B3%95%E5%88%86%E6%9E%90"><span class="toc-text">2、afterCommit 方法分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E6%89%BE%E5%88%B0%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E7%9A%84%E5%85%A5%E5%8F%A3"><span class="toc-text">1、找到方法调用的入口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%89TransactionTemplate"><span class="toc-text">1）TransactionTemplate</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%89AbstractPlatformTransactionManager"><span class="toc-text">2）AbstractPlatformTransactionManager</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%EF%BC%89TransactionSynchronizationUtils"><span class="toc-text">3）TransactionSynchronizationUtils</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E8%8E%B7%E5%8F%96TransactionSynchronization%E9%9B%86%E5%90%88"><span class="toc-text">2、获取TransactionSynchronization集合</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%89getSynchronizations"><span class="toc-text">1）getSynchronizations</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81synchronizations-%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0"><span class="toc-text">3、synchronizations 添加元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E5%AE%9E%E9%99%85%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F"><span class="toc-text">4、实际使用方式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E3%80%81%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE-%E9%B8%A3%E8%B0%A2"><span class="toc-text">十、参考文献 &amp; 鸣谢</span></a></li></ol>
    
<style>
    .left-col .switch-btn,
    .left-col .switch-area {
        display: none;
    }
    .toc-level-3 i,
    .toc-level-3 ol {
        display: none !important;
    }
</style>
</div>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="一、事务传播的案例演示"><a href="#一、事务传播的案例演示" class="headerlink" title="一、事务传播的案例演示"></a>一、事务传播的案例演示</h1><h2 id="1、事务的隔离级别介绍"><a href="#1、事务的隔离级别介绍" class="headerlink" title="1、事务的隔离级别介绍"></a>1、事务的隔离级别介绍</h2><p>Spring 框架提供了一种方便的方式来管理数据库事务，它支持多种事务隔离级别。事务隔离级别决定了事务在并发执行时的隔离程度，包括对其他事务的可见性和可能出现的并发问题。</p>
<p>以下是 Spring 框架支持的事务隔离级别及其详细说明：</p>
<ul>
<li>ISOLATION_DEFAULT（默认）：这是系统的默认隔离级别。根据具体数据库来定义，大多数数据库默认级别是可重复读。</li>
<li>ISOLATION_READ_UNCOMMITTED（读未提交）：在这个级别，一个事务可以看到其他未提交事务的变动。这种级别可以导致脏读、不可重复读和幻读的问题。</li>
<li>ISOLATION_READ_COMMITTED（读提交）：在这个级别，一个事务只能看到其他事务已经提交的变动。这种级别可以避免脏读问题，但可能会出现不可重复读和幻读的问题。</li>
<li>ISOLATION_REPEATABLE_READ（可重复读）：在这个级别，同一事务中多次读取的数据是一致的。这种级别可以避免脏读和不可重复读的问题，但可能会出现幻读的问题。</li>
<li>ISOLATION_SERIALIZABLE（可串行化）：这是最高的事务隔离级别。在这个级别，事务串行化顺序执行，可以避免脏读、不可重复读和幻读的问题。但是这种隔离级别效率低下，因为事务通常需要等待前一个事务完成，才能继续执行。</li>
</ul>
<blockquote>
<p>Spring事务的默认隔离级别与数据库一致</p>
</blockquote>
<p>在 Spring 中，可以通过以下方式设置事务的隔离级别：</p>
<pre><code class="java">// 1. 声明式事务
@Transactional(isolation = Isolation.READ_COMMITTED)  
public void someMethod1() &#123;

&#125;

// 2.1 编程式事务 PlatformTransactionManager 接口
public void someMethod1() &#123;
    DefaultTransactionDefinition definition = new DefaultTransactionDefinition();
    definition.setIsolationLevel(TransactionDefinition.ISOLATION_READ_COMMITTED);
    transactionManager.getTransaction(definition);
&#125;

// 2.2 编程式事务 transactionTemplate 类
public void someMethod1() &#123;
    transactionTemplate.setIsolationLevel(TransactionDefinition.ISOLATION_READ_COMMITTED);
&#125;
</code></pre>
<p>在上述代码中，<code>@Transactional</code>注解指定了事务的隔离级别为<code>READ_COMMITTED</code>。注意，虽然可以使用其他隔离级别，但并不是所有数据库都支持所有的隔离级别。使用哪种隔离级别取决于你的具体需求和数据库的能力。</p>
<blockquote>
<p>MySQL 事务默认隔离级别：MySQ L的事务隔离级别默认是可重复读（REPEATABLE READ），这是大多数数据库系统的默认设置。这个隔离级别可以避免脏读和不可重复读的问题，但可能会出现幻读的问题。</p>
</blockquote>
<h2 id="2、事务的传播类型介绍"><a href="#2、事务的传播类型介绍" class="headerlink" title="2、事务的传播类型介绍"></a>2、事务的传播类型介绍</h2><blockquote>
<p>作者：<a target="_blank" rel="noopener" href="https://blog.csdn.net/CSDN_WYL2016">码拉松</a>、来源：<a target="_blank" rel="noopener" href="https://blog.csdn.net/CSDN_WYL2016/article/details/122221146">https://blog.csdn.net/CSDN_WYL2016/article/details/122221146</a></p>
</blockquote>
<p>我们首先从事务的传播类型开始说起，在Spring中事务传播指的是：一个事务方法调用了另一个事务方法，比如事务方法A在执行过程中又调用了事务方法B，那么对于事务方法B来说，应该如何如何运行？于是，针对这个问题，Spring就定义了七种数据传播类型，基本上就是罗列了所有可能遇到的场景，然后供使用者选择：</p>
<ul>
<li><strong>REQUIRED</strong>：支持当前事务，如果当前不存在则新开启一个事务（默认配置）</li>
<li><strong>SUPPORTS</strong>：支持当前事务，如果当前不存在事务则以非事务方式执行</li>
<li><strong>MANDATORY</strong>：支持当前事务，如果当前不存在事务则抛出异常</li>
<li><strong>REQUIRES_NEW</strong>：创建一个新事务，如果当前已存在事务则挂起当前事务</li>
<li><strong>NOT_SUPPORTED</strong>：以非事务方式执行，如果当前已存在事务则挂起当前事务</li>
<li><strong>NEVER</strong>：以非事务方式执行，如果当前已存在事务则抛出异常</li>
<li><strong>NESTED</strong>：如果当前存在事务，则在嵌套事务中执行，否则开启一个新事务</li>
</ul>
<p>场景分类：</p>
<table>
<thead>
<tr>
<th>事务传播类型</th>
<th>前一个方法存在事务</th>
<th>前一个方法不存在事务</th>
<th>当前一个方法存在事务时，是否与其是同一个事务</th>
</tr>
</thead>
<tbody><tr>
<td>REQUIRED</td>
<td>使用前一个方法的事务</td>
<td>创建一个新的事务</td>
<td>是</td>
</tr>
<tr>
<td>SUPPORTS</td>
<td>使用前一个方法的事务</td>
<td>按非事务方式执行</td>
<td>是</td>
</tr>
<tr>
<td>MANDATORY</td>
<td>使用前一个方法的事务</td>
<td>抛出异常</td>
<td>是</td>
</tr>
<tr>
<td>REQUIRES_NEW</td>
<td>创建一个新的事务</td>
<td>创建一个新的事务</td>
<td>否</td>
</tr>
<tr>
<td>NOT_SUPPORTED</td>
<td>以非事务方式执行</td>
<td>按非事务方式执行</td>
<td>-</td>
</tr>
<tr>
<td>NEVER</td>
<td>抛出异常</td>
<td>按非事务方式执行</td>
<td>-</td>
</tr>
<tr>
<td>NESTED</td>
<td>嵌套方式使用前一个方法的事务</td>
<td>创建一个新的事务</td>
<td>是</td>
</tr>
</tbody></table>
<p>Spring 事务默认传播行为：Spring 的事务传播行为默认是 PROPAGATION_REQUIRED，也就是如果当前存在一个事务，就加入该事务；如果当前没有事务，就新建一个事务。</p>
<h2 id="3、案例演示数据说明"><a href="#3、案例演示数据说明" class="headerlink" title="3、案例演示数据说明"></a>3、案例演示数据说明</h2><p>初始化数据表</p>
<pre><code class="sql">CREATE TABLE `t1` (
    `id` int(11) NOT NULL,
    `c` int(11) DEFAULT NULL,
    PRIMARY KEY (`id`),
    KEY `idx_c` (`c`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

CREATE TABLE `t2` (
    `id` int(11) NOT NULL,
    `c` int(11) DEFAULT NULL,
    PRIMARY KEY (`id`),
    KEY `idx` (`c`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
</code></pre>
<p>两条更新语句，分别对<code>t1</code>、<code>t2</code>两张表进行更新。</p>
<pre><code class="xml">&lt;update id=&quot;updateT1&quot;&gt;
    update t1 set c = 2 where id = 1
&lt;/update&gt;
&lt;update id=&quot;updateT2&quot;&gt;
    update t2 set c = 2 where id = 1
&lt;/update&gt;
</code></pre>
<h2 id="4、REQUIRED"><a href="#4、REQUIRED" class="headerlink" title="4、REQUIRED"></a>4、REQUIRED</h2><p>含义：支持当前事务，如果当前不存在则新开启一个事务（默认配置）。</p>
<p>下面这块代码逻辑为：当调用<code>T1Service</code>中的<code>func</code>方法时，除了要更新<code>t1</code>表数据之外，还会调用<code>t2Service</code>中的<code>func</code>方法，更新<code>t2</code>表，不过，在执行<code>t2Service</code>中的方法时会遇到异常。</p>
<pre><code class="java">@Service
public class T1Service &#123;

    @Resource
    private TestMapper testMapper;

    @Resource
    private T2Service t2Service;

    @Transactional
    public void func() &#123;
        testMapper.updateT1();
        t2Service.func();
    &#125;
&#125;
</code></pre>
<pre><code class="java">@Service
public class T2Service &#123;

    @Resource
    private TestMapper testMapper;

    @Transactional
    public void func() &#123;
        testMapper.updateT2();
        int i = 1 / 0;
    &#125;
&#125;
</code></pre>
<p><code>@Transactional</code>默认的传播方式就是<code>REQUIRED</code>，所以当方法执行到<code>int i = 1 / 0</code>时，会抛出异常，此时<code>t1、t2</code>表中的数据都不会被修改，因为这两个方法使用的是同一个事务，所以只要有一个遇到异常，两个更新就都不会成功。</p>
<h2 id="5、SUPPORTS"><a href="#5、SUPPORTS" class="headerlink" title="5、SUPPORTS"></a>5、SUPPORTS</h2><p>含义：支持当前事务，如果当前不存在事务则以非事务方式执行。</p>
<p><code>t2Service</code>的<code>func</code>方法现在没有事务了，<code>t2Service</code>的<code>func</code>方法配置上<code>@Transactional(propagation = Propagation.SUPPORTS)</code>，当执行<code>int i = 1 / 0</code>时，<code>t1、t2</code>两张表数据都不会回滚。但如果配置成<code>@Transactional(propagation = Propagation.REQUIRED)</code>，则<code>t2</code>表数据会被回滚。</p>
<pre><code class="java">@Service
public class T1Service &#123;

    @Resource
    private TestMapper testMapper;

    @Resource
    private T2Service t2Service;

    // 去掉事务 @Transactional
    public void func() &#123;
        testMapper.updateT1();
        t2Service.func();
    &#125;
&#125;
</code></pre>
<pre><code class="java">@Service
public class T2Service &#123;

    @Resource
    private TestMapper testMapper;
   /**
    * 数据不会回滚，因为当前没有事务，SUPPORTS会以非事务方式执行
    * 如果配置成 @Transactional(propagation = Propagation.REQUIRED)，则事务会生效 
    */
    @Transactional(propagation = Propagation.SUPPORTS)
    public void func() &#123;
        testMapper.updateT2();
        int i = 1 / 0;
    &#125;
&#125;
</code></pre>
<h2 id="6、MANDATORY"><a href="#6、MANDATORY" class="headerlink" title="6、MANDATORY"></a>6、MANDATORY</h2><p>含义：支持当前事务，如果当前不存在事务则抛出异常。</p>
<p>当<code>t1Service</code>没有事务时，把<code>t2Service</code>的<code>func</code>方法配置为<code>@Transactional(propagation = Propagation.MANDATORY)</code></p>
<pre><code class="java">// t1Service
public void func() &#123;
    testMapper.updateT1();
    t2Service.func();
&#125;

// t2Service
@Transactional(propagation = Propagation.MANDATORY)
public void func() &#123;
    testMapper.updateT2();
    int i = 1 / 0;
&#125;
</code></pre>
<p>异常信息</p>
<pre><code class="java">org.springframework.transaction.IllegalTransactionStateException: No existing transaction found for transaction marked with propagation &#39;mandatory&#39;
    at org.springframework.transaction.support.AbstractPlatformTransactionManager.getTransaction(AbstractPlatformTransactionManager.java:362) ~[spring-tx-5.3.14.jar:5.3.14]
    at org.springframework.transaction.interceptor.TransactionAspectSupport.createTransactionIfNecessary(TransactionAspectSupport.java:595) ~[spring-tx-5.3.14.jar:5.3.14]
    at org.springframework.transaction.interceptor.TransactionAspectSupport.invokeWithinTransaction(TransactionAspectSupport.java:382) ~[spring-tx-5.3.14.jar:5.3.14]
    at org.springframework.transaction.interceptor.TransactionInterceptor.invoke(TransactionInterceptor.java:119) ~[spring-tx-5.3.14.jar:5.3.14]
    at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186) ~[spring-aop-5.3.14.jar:5.3.14]
    at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:753) ~[spring-aop-5.3.14.jar:5.3.14]
    at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:698) ~[spring-aop-5.3.14.jar:5.3.14]
</code></pre>
<h2 id="7、REQUIRES-NEW"><a href="#7、REQUIRES-NEW" class="headerlink" title="7、REQUIRES_NEW"></a>7、REQUIRES_NEW</h2><p>含义：创建一个新事务，如果当前已存在事务则挂起当前事务。</p>
<p><code>t2</code>的数据不会被更新，当没有事务时，<code>REQUIRES_NEW</code>会自己创建一个事务</p>
<pre><code class="java">// t1Service
public void func() &#123;
    testMapper.updateT1();
    t2Service.func();
&#125;

// t2Service
@Transactional(propagation = Propagation.REQUIRES_NEW)
public void func() &#123;
    testMapper.updateT2();
    int i = 1 / 0;
&#125;
</code></pre>
<p>与REQUIRED有什么区别呢？现在把抛出异常的地方放到<code>t1Service</code>中</p>
<pre><code class="java">// t1Service
@Transactional
public void func() &#123;
    testMapper.updateT1();
    t2Service.func();
    int i = 1 / 0;
&#125;

// t2Service
@Transactional(propagation = Propagation.REQUIRES_NEW)
public void func() &#123;
    testMapper.updateT2();
&#125;
</code></pre>
<p>此时执行后，<code>t2</code>的数据不会回滚，<code>t1</code>的数据会回滚，因为<code>t2</code>和<code>t1</code>不是一个事务。</p>
<h2 id="8、NOT-SUPPORTED"><a href="#8、NOT-SUPPORTED" class="headerlink" title="8、NOT_SUPPORTED"></a>8、NOT_SUPPORTED</h2><p>含义：以非事务方式执行，如果当前已存在事务则挂起当前事务。</p>
<p><code>NOT_SUPPORTED</code>的效果就是无论异常是在<code>t1Service</code>还是<code>t2Service</code>都不会回滚<code>t2</code>的数据。</p>
<pre><code class="java">// t1Service
@Transactional
public void func() &#123;
    testMapper.updateT1();
    t2Service.func();
    int i = 1 / 0;
&#125;

// t2Service
@Transactional(propagation = Propagation.NOT_SUPPORTED)
public void func() &#123;
    testMapper.updateT2();
    int i = 1 / 0;
&#125;
</code></pre>
<h2 id="9、NEVER"><a href="#9、NEVER" class="headerlink" title="9、NEVER"></a>9、NEVER</h2><p>含义：以非事务方式执行，如果当前已存在事务则抛出异常。</p>
<p>很明显，如字面含义，如果存在事务，直接抛出异常</p>
<pre><code class="java">// t1Service
@Transactional
public void func() &#123;
    testMapper.updateT1();
    t2Service.func();
&#125;

// t2Service
@Transactional(propagation = Propagation.NEVER)
public void func() &#123;
    testMapper.updateT2();
&#125;
</code></pre>
<pre><code class="java">org.springframework.transaction.IllegalTransactionStateException: Existing transaction found for transaction marked with propagation &#39;never&#39;
    at org.springframework.transaction.support.AbstractPlatformTransactionManager.handleExistingTransaction(AbstractPlatformTransactionManager.java:413) ~[spring-tx-5.3.14.jar:5.3.14]
    at org.springframework.transaction.support.AbstractPlatformTransactionManager.getTransaction(AbstractPlatformTransactionManager.java:352) ~[spring-tx-5.3.14.jar:5.3.14]
    at org.springframework.transaction.interceptor.TransactionAspectSupport.createTransactionIfNecessary(TransactionAspectSupport.java:595) ~[spring-tx-5.3.14.jar:5.3.14]
    at org.springframework.transaction.interceptor.TransactionAspectSupport.invokeWithinTransaction(TransactionAspectSupport.java:382) ~[spring-tx-5.3.14.jar:5.3.14]
    at org.springframework.transaction.interceptor.TransactionInterceptor.invoke(TransactionInterceptor.java:119) ~[spring-tx-5.3.14.jar:5.3.14]
    at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186) ~[spring-aop-5.3.14.jar:5.3.14]
    at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:753) ~[spring-aop-5.3.14.jar:5.3.14]
    at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:698) ~[spring-aop-5.3.14.jar:5.3.14]
</code></pre>
<p>果把<code>t1Service</code>中的事务去掉，则不会抛出不支持事务的异常，同时<code>t2Service</code>自己抛出异常后，数据也是不会回滚的，完全是当做无事务处理。</p>
<pre><code class="java">// t1Service
public void func() &#123;
    testMapper.updateT1();
    t2Service.func();
&#125;

// t2Service
@Transactional(propagation = Propagation.NEVER)
public void func() &#123;
    testMapper.updateT2();
    int i = 1 / 0;
&#125;
</code></pre>
<h2 id="10、NESTED"><a href="#10、NESTED" class="headerlink" title="10、NESTED"></a>10、NESTED</h2><p>含义：如果当前存在事务，则在嵌套事务中执行，否则开启一个新事务。</p>
<p>NESTED应该是几种事务传播方式中最难理解的，如果不注意，NESTED和REQUIRED功能看起来则差不多，都可以理解为有事务则加入，没有则新启一个，但实际上NESTED比REQUIRED要更加灵活。</p>
<p>先来看第一个案例，在t1Service中调用t2Service时，对t2Service抛出的异常进行了捕获，并且自己也没有再抛出。</p>
<pre><code class="java">// t1Service
@Transactional
public void func() &#123;
    testMapper.updateT1();
    try &#123;
        t2Service.func();
    &#125; catch (Exception e) &#123;
        e.printStackTrace();
    &#125;
&#125;

// t2Service
@Transactional(propagation = Propagation.REQUIRED)
public void func() &#123;
    testMapper.updateT2();
    int i = 1 / 0;
&#125;
</code></pre>
<p>当<code>t2Service</code>配置为REQUIRED时，<code>t1、t2</code>都进行了回滚，因为是同一个事务，当如果<code>t2Service</code>配置为NESTED就不一样了，此时<code>t1</code>则不会回滚。</p>
<pre><code class="java">// t1Service
@Transactional
public void func() &#123;
    testMapper.updateT1();
    try &#123;
        t2Service.func();
    &#125; catch (Exception e) &#123;
        e.printStackTrace();
    &#125;
&#125;

// t2Service
@Transactional(propagation = Propagation.NESTED)
public void func() &#123;
    testMapper.updateT2();
    int i = 1 / 0;
&#125;
</code></pre>
<h3 id="NESTED-与-REQUIRES-NEW的区别"><a href="#NESTED-与-REQUIRES-NEW的区别" class="headerlink" title="NESTED 与 REQUIRES_NEW的区别"></a>NESTED 与 REQUIRES_NEW的区别</h3><p>现在有人可能觉得NESTED和REQUIRES_NEW有点相似，但实际上要注意NESTED和REQUIRES_NEW是很有大的区别的</p>
<p>现在我们分别给<code>t1Service</code>和<code>t2Service</code>加上一个<code>TransactionSynchronizationManager.getCurrentTransactionName()</code>输出看看效果</p>
<pre><code class="java">// t1Service
@Transactional
public void func() &#123;
    testMapper.updateT1();
    System.out.println(TransactionSynchronizationManager.getCurrentTransactionName());
    try &#123;
        t2Service.func();
    &#125; catch (Exception e) &#123;
        e.printStackTrace();
    &#125;
&#125;
// t2Service
@Transactional(propagation = Propagation.REQUIRES_NEW)
public void func() &#123;
    testMapper.updateT2();
    System.out.println(TransactionSynchronizationManager.getCurrentTransactionName());
    int i = 1 / 0;
&#125;
</code></pre>
<p>输出结果</p>
<pre><code class="java">com.demo.transaction.service.T1Service.func
com.demo.transaction.service.T2Service.func
</code></pre>
<p>把<code>REQUIRES\_NEW</code>替换为<code>NESTED</code>，可以看出使用<code>NESTED</code>后，实际上还是同一个事务。</p>
<pre><code class="java">com.demo.transaction.service.T1Service.func
com.demo.transaction.service.T1Service.func
</code></pre>
<p>也就是说，使用<code>NESTED</code>时，虽然还是同一个事务，但却可以在多个方法中进行控制。</p>
<h3 id="NESTED-实现方式"><a href="#NESTED-实现方式" class="headerlink" title="NESTED 实现方式"></a>NESTED 实现方式</h3><p>这就是NESTED不同之处：两个方法同一个事务，居然没有一起回滚，这就叫嵌套事务，子事务回滚不会影响到主事务，实际上利用的是<code>savepoint</code>功能，就好像下面这样</p>
<pre><code class="sql">-- 主事务
savepoint;
-- 执行主事务代码

-- 子事务
savepoint;

-- 执行子事务代码

-- 子事务提交
commit;

-- 执行主事务代码

-- 主事务提交
commit;
</code></pre>
<p>所以，如果是在主事务中抛出异常，那么子事务也会被回滚，就像下面这样：<code>t1</code>、<code>t2</code>都会回滚。</p>
<pre><code class="java">// t1Service
@Transactional
public void func() &#123;
    testMapper.updateT1();
    t2Service.func();
    int i = 1 / 0;
&#125;
// t2Service
@Transactional(propagation = Propagation.NESTED)
public void func() &#123;
    testMapper.updateT2();
&#125;
</code></pre>
<h1 id="二、事务开启的两种方式"><a href="#二、事务开启的两种方式" class="headerlink" title="二、事务开启的两种方式"></a>二、事务开启的两种方式</h1><blockquote>
<ul>
<li>作者：<a target="_blank" rel="noopener" href="https://blog.csdn.net/myli92">tomorrow.hello</a>、来源：事务开启的两种方式：<a target="_blank" rel="noopener" href="https://blog.csdn.net/myli92/article/details/111658394">https://blog.csdn.net/myli92/article/details/111658394</a></li>
<li>作者：<a target="_blank" rel="noopener" href="https://zhaoyang10.blog.csdn.net/">zhaoyang10</a>、来源：SpringBoot 编程式事务：<a target="_blank" rel="noopener" href="https://blog.csdn.net/fzy629442466/article/details/103458630">https://blog.csdn.net/fzy629442466/article/details/103458630</a></li>
</ul>
</blockquote>
<p>通过Spring来开启事务管理非常简单，默认支持两种方式，一种为<strong>编程式事务</strong>、一种为<strong>声明式事务</strong>，大多数人对声明式事务都比较熟悉，我们就先从它开始说起。</p>
<h2 id="1、声明式事务"><a href="#1、声明式事务" class="headerlink" title="1、声明式事务"></a>1、声明式事务</h2><p>开启声明式事务非常简单，直接通过<code>@Transactional</code>注解即可</p>
<pre><code class="java">@Transactional
public void func() &#123;
&#125;
</code></pre>
<p>除了常规的支持自定义事务的隔离级别、传播属性之外，还可以设置事务的超时时间，回滚的异常类型。</p>
<pre><code class="java">public @interface Transactional &#123;

    @AliasFor(&quot;transactionManager&quot;)
    String value() default &quot;&quot;;

    @AliasFor(&quot;value&quot;)
    String transactionManager() default &quot;&quot;;

    String[] label() default &#123;&#125;;

    Propagation propagation() default Propagation.REQUIRED;

    Isolation isolation() default Isolation.DEFAULT;

    int timeout() default TransactionDefinition.TIMEOUT_DEFAULT;

    String timeoutString() default &quot;&quot;;

    boolean readOnly() default false;

    Class&lt;? extends Throwable&gt;[] rollbackFor() default &#123;&#125;;

    String[] rollbackForClassName() default &#123;&#125;;

    Class&lt;? extends Throwable&gt;[] noRollbackFor() default &#123;&#125;;

    String[] noRollbackForClassName() default &#123;&#125;;

&#125;
</code></pre>
<hr>
<p>1、在配置文件中或者启动类上启动事务：Spring 在配置类上加 @EnableTransactionManagement 注解就行（开启注解事务管理，等同于xml配置方式的 <code>&lt;tx:annotation-driven /&gt;</code>）【注意如果是SpringBoot是无需加@EnableTransactionManagement 注解的，因为SpringBoot的自动配置机制】</p>
<p>2、在方法或者类上增加@Trasactional注解：@Transactional 注解是通过 AOP 方式实现的，默认捕获 RuntimeException 的异常并触发方法中所有数据库操作（增、删、改）回滚。如果自定义异常需要设置，@Transactional(rollbackOn &#x3D; Exception.class)</p>
<p>注意：需要将异常异常信息抛出到上层框架，如果catch处理了的异常，不会被事物作为判断依据；如果异常被 catch 了，但是又在catch 中抛出了新的异常，那么事物会以这个新的异常作为是否进行回滚的判断依据。</p>
<p>使用声明式注解时，除了向外层抛出异常外，我们还可以主动设置事务需要回滚（需要在方法上增加@Trasactional）：</p>
<pre><code class="java">// 手动设置事务回滚
TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();
</code></pre>
<p>完整示例：</p>
<pre><code class="java">@Transactional(rollbackOn = Exception.class)
public void tranDelNoAutoZJ(String name) &#123;
    User deleteUer = userRepository.findOneByName(name);
    if (deleteUer != null) &#123;
        userRepository.deleteById(deleteUer.getId());
    &#125;
    if (deleteUer.getId() % 2 == 0) &#123;
        // do...
    &#125; else &#123;
        TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();
        // 主动设置事务需要回滚
    &#125;
&#125;
</code></pre>
<h2 id="2、编程式事务"><a href="#2、编程式事务" class="headerlink" title="2、编程式事务"></a>2、编程式事务</h2><p>声明式事务的最大问题就在于，粒度控制问题，声明式事务最细的粒度也是方法级别的，这很容易导致长事务问题的产生，所以我们一般使用编程式事务替代。</p>
<p>Spring 提供的<code>TransactionTemplate</code>、<code>PlatformTransactionManager</code>都支持编程式事务的实现。</p>
<p><code>TransactionTemplate</code>是在原始的事务管理类上又封装了一次，调用其核心方法<code>execute</code>实现整个事务的管理。</p>
<pre><code class="java">@Override
@Nullable
public &lt;T&gt; T execute(TransactionCallback&lt;T&gt; action) throws TransactionException &#123;
    Assert.state(this.transactionManager != null, &quot;No PlatformTransactionManager set&quot;);
    if (this.transactionManager instanceof CallbackPreferringPlatformTransactionManager) &#123;
        return ((CallbackPreferringPlatformTransactionManager) this.transactionManager).execute(this, action);
    &#125;
    else &#123;
        TransactionStatus status = this.transactionManager.getTransaction(this);
        T result;
        try &#123;
            result = action.doInTransaction(status);
        &#125;
        catch (RuntimeException | Error ex) &#123;
            // Transactional code threw application exception -&gt; rollback
            rollbackOnException(status, ex);
            throw ex;
        &#125;
        catch (Throwable ex) &#123;
            // Transactional code threw unexpected exception -&gt; rollback
            rollbackOnException(status, ex);
            throw new UndeclaredThrowableException(ex, &quot;TransactionCallback threw undeclared checked exception&quot;);
        &#125;
        this.transactionManager.commit(status);
        return result;
    &#125;
&#125;
</code></pre>
<p><code>PlatformTransactionManager</code>则更灵活一点，就定义了三个关键方法，一看就明白了</p>
<pre><code class="java">public interface PlatformTransactionManager extends TransactionManager &#123;
    TransactionStatus getTransaction(@Nullable TransactionDefinition definition) throws TransactionException;
    void commit(TransactionStatus status) throws TransactionException;
    void rollback(TransactionStatus status) throws TransactionException;
&#125;
</code></pre>
<h3 id="1、TransactionTemplate-实现编程式事务"><a href="#1、TransactionTemplate-实现编程式事务" class="headerlink" title="1、TransactionTemplate 实现编程式事务"></a>1、TransactionTemplate 实现编程式事务</h3><p>TransactionTemplate 是 Spring 提供的一个用于简化事务管理的类。它提供了一种声明式的事务管理方式，通过回调的方式执行事务代码，从而避免手动管理事务的繁琐操作。</p>
<p><strong>使用场景</strong>：</p>
<ul>
<li>需要在代码中手动管理事务但又希望简化事务管理逻辑。</li>
<li>在需要进行编程式事务管理的地方，TransactionTemplate 可以取代传统的 PlatformTransactionManager 和 TransactionStatus 的显式事务管理。</li>
</ul>
<p><strong>使用步骤</strong>：</p>
<ul>
<li><p>创建 TransactionTemplate 实例：通过注入的 PlatformTransactionManager 创建 TransactionTemplate 对象。</p>
</li>
<li><p>配置事务属性：可以根据需要设置事务的传播行为、隔离级别、超时时间等属性。</p>
</li>
<li><p>执行事务代码：使用 TransactionTemplate.execute() 方法执行事务代码块。</p>
<p>方法介绍：<code>transactionTemplate.execute</code>中入参为<code>TransactionCallback</code>或者<code>TransactionCallbackWithoutResult</code>，这是一个函数式接口，只定义了一个方法<code>doInTransaction</code> 或者<code>doInTransactionWithoutResult</code>。</p>
</li>
</ul>
<p><strong>事务属性的配置</strong></p>
<ul>
<li><p>在需要时，可以配置 TransactionTemplate 的属性：</p>
</li>
<li><p>首先需要初始化 TransactionTemplate，然后配置需要的各种属性。</p>
<pre><code class="java">// 注入TransactionTemplate  
@Bean
@ConditionalOnMissingBean
public TransactionTemplate transactionTemplate() &#123;
    // return new TransactionTemplate(this.dataSourceTransactionManager);
    return new TransactionTemplate();
&#125;

// 或者
@Autowired
public void configureTransactionTemplate(PlatformTransactionManager transactionManager) &#123;
    transactionTemplate = new TransactionTemplate(transactionManager);
    transactionTemplate.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);
    transactionTemplate.setIsolationLevel(TransactionDefinition.ISOLATION_SERIALIZABLE);
    transactionTemplate.setTimeout(30); // 超时时间30秒
&#125;
</code></pre>
</li>
</ul>
<p><strong>总结</strong>：</p>
<ul>
<li>TransactionTemplate 适用于需要手动控制事务，但又不想手动管理事务边界的场景。</li>
<li>它提供了编程式事务管理的便利性，同时确保事务的正确性和一致性。</li>
<li>与显式的事务管理相比，它减少了样板代码，并且更加符合声明式事务管理的风格。</li>
</ul>
<p>1、借助带返回参数的 TransactionCallback 执行事务管理，带有返回值：</p>
<pre><code class="java">@Resource
private TransactionTemplate transactionTemplate;

// 执行带有返回值&lt;Object&gt;的事务管理,自动执行回滚操作
public Object getObject(String str) &#123;
    transactionTemplate.execute(new TransactionCallback&lt;Object&gt;() &#123;
        @Override
        public Object doInTransaction(TransactionStatus transactionStatus) &#123;
            //... 业务代码，出现异常会自动回滚
            testMapper.updateT1();
            t2Service.func();
            int i = 1 / 0;
            return new Object();
        &#125;
    &#125;);
&#125;

// 执行带有返回值&lt;Object&gt;的事务管理,手动执行回滚操作
public Object getObject(String str) &#123;
    transactionTemplate.execute(new TransactionCallback&lt;Object&gt;() &#123;
        @Override
        public Object doInTransaction(TransactionStatus transactionStatus) &#123;
            try &#123;
                //... 业务代码，出现异常会手动回滚
                return new Object();
            &#125; catch (Exception e) &#123;
                // 手动回滚
                transactionStatus.setRollbackOnly();
                return null;
            &#125;
        &#125;
    &#125;);
&#125;
</code></pre>
<p>2、借助不带返回参数的 TransactionCallbackWithoutResult 执行事务管理，无返回值：</p>
<pre><code class="java">@Resource
private TransactionTemplate transactionTemplate;

// 执行不带返回值的事务管理,自动执行回滚操作
public void func() &#123;
    transactionTemplate.execute(new TransactionCallbackWithoutResult() &#123;
        @Override
        protected void doInTransactionWithoutResult(TransactionStatus status) &#123;
            testMapper.updateT1();
            t2Service.func();
            int i = 1 / 0;
        &#125;
    &#125;);
&#125;

// 执行不带返回值的事务管理,手动执行回滚操作
public void func() &#123;
    transactionTemplate.execute(new TransactionCallbackWithoutResult() &#123;
        @Override
        protected void doInTransactionWithoutResult(TransactionStatus status) &#123;
            try &#123;
                //... 业务代码，出现异常会手动回滚
                testMapper.updateT1();
                t2Service.func();
                int i = 1 / 0;
            &#125; catch (Exception e) &#123;
                // 手动回滚
                transactionStatus.setRollbackOnly();
            &#125;
        &#125;
    &#125;);
&#125;
</code></pre>
<p>3、或者直接使用 Lambda 表达式也能替换上面的操作。【最好掌握，可能会比较常用到】</p>
<pre><code class="java">@Resource
private TransactionTemplate transactionTemplate;

// 有返回值
public void transactionTemplateReturnTest() &#123;
    transactionTemplate.execute((transactionStatus) -&gt; &#123;
        // 业务代码或异常
        return true;
    &#125;);
&#125;

// 无返回值
public void transactionTemplateVoidTest() &#123;
    transactionTemplate.executeWithoutResult((transactionStatus) -&gt; &#123;
        // 业务代码或异常
        return true;
    &#125;);
&#125;
</code></pre>
<h3 id="2、TransactionManager-实现编程式事务"><a href="#2、TransactionManager-实现编程式事务" class="headerlink" title="2、TransactionManager 实现编程式事务"></a>2、TransactionManager 实现编程式事务</h3><p><img src="/blog/Spring-%E4%BA%8B%E5%8A%A1%E5%BA%94%E7%94%A8%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.assets/image-20241025145538217.png" alt="20230510171111"></p>
<p>这里使用Mybatis的事务管理器<code>DataSourceTransactionManager</code>简单走一下流程：</p>
<pre><code class="java">// 这个是JDBC的事务管理器实现类，不同ORM使用不同，它的接口是PlatformTransactionManager
@Resource
DataSourceTransactionManager dataSourceTransactionManager;

// 手动开启事务
@Resource
TransactionStatus status = dataSourceTransactionManager.getTransaction(new DefaultTransactionDefinition());

// 手动提交事务
dataSourceTransactionManager.commit(status);

// 手动回滚事务 (最好是放在 catch 里面, 防止程序异常而事务一直卡在哪里未提交)
dataSourceTransactionManager.rollback(status);
</code></pre>
<p>DataSourceTransactionManager 的继承图：</p>
<p><img src="/blog/Spring-%E4%BA%8B%E5%8A%A1%E5%BA%94%E7%94%A8%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.assets/image-20241025145538218.png" alt="202305101711122053"></p>
<h4 id="0、TransactionDefinition-接口预介绍"><a href="#0、TransactionDefinition-接口预介绍" class="headerlink" title="0、TransactionDefinition 接口预介绍"></a>0、TransactionDefinition 接口预介绍</h4><p>TransactionDefinition 这个接口主要用来定义事务的传播行为、隔离级别、超时时间、是否只读等属性</p>
<pre><code class="java">@Autowired
private PlatformTransactionManager transactionManager;

@Override
public String interfaceTest(Map&lt;String, Object&gt; map) &#123;
    DefaultTransactionDefinition def = new DefaultTransactionDefinition();
    // 设置事务名称
    def.setName(&quot;test-Transactional&quot;);
    // 读写或只读事务、默认：读写
    def.setReadOnly(true);
    // 事务超时时间，默认：不超时 单位：秒
    def.setTimeout(10);
    /**
     * 设置事务的隔离级别
     *
     * 1、TransactionDefinition.ISOLATION_DEFAULT
     *    这是一个默认的隔离级别，默认使用数据库的隔离级别。
     * 2、TransactionDefinition.ISOLATION_READ_UNCOMMITTED
     *    这是事务最低的隔离界别，他允许别的事务可以看到这个事务未提交的数据。
     *    这种隔离级别可能会产生脏读，不可重复读和幻像读。
     * 3、TransactionDefinition.ISOLATION_READ_COMMITTED
     *    这个级别可以保证在数据提交以后才能被另个一个事务读取。
     *    这种隔离级别可以避免脏读，但是可能会出现不可重复读和幻读。
     * 4、TransactionDefinition.ISOLATION_REPEATABLE_READ
     *    这个级别可以禁止一个事务读取一个没有提交变化的行。
     *    这种隔离级别可以防止脏读和不可重复读，但是可能会出现幻读。
     * 5、TransactionDefinition.ISOLATION_SERIALIZABLE
     *    这种隔离级别可以防止脏读、不可重复读、幻读。
     *
     */
    def.setIsolationLevel(TransactionDefinition.ISOLATION_DEFAULT);
    /**
     * 设置事务的传播行为
     *
     * 1、TransactionDefinition.PROPAGATION_REQUIRED
     *    如果当前存在事务，则加入该事务，如果当前没有事务，则创建一个新的事务。默认值
     * 2、TransactionDefinition.PROPAGATION_REQUIRES_NEW
     *    创建一个新的事务，如果当前存在事务，则把当前的事务挂起。
     * 3、TransactionDefinition.PROPAGATION_SUPPORTS
     *    如果当前存在事务，则加入该事务，如果当前没有事务，则以非事务的方式继续运行。
     * 4、TransactionDefinition.PROPAGATION_NOT_SUPPORTED
     *    以非事务方式运行，如果当前存在事务，则把当前事务挂起。
     * 5、TransactionDefinition.PROPAGATION_NEVER
     *    以非事务方式运行，如果当前存在事务，则抛出异常。
     * 6、TransactionDefinition.PROPAGATION_MANDATORY
     *    如果当前存在事务、则加入该事务，如果当前没有事务，则抛出异常
     * 7、TransactionDefinition.PROPAGATION_NESTED
     *    如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行。
     *    如果当前没有事务，则该取值等价于TransactionDefinition.PROPAGATION_REQUIRED。
     */
    def.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);
    TransactionStatus transactionStatus = transactionManager.getTransaction(def);
    try &#123;
        //
        // 提交事务
        transactionManager.commit(transactionStatus);
    &#125; catch (Exception e) &#123;
        // 回滚事务
        transactionManager.rollback(transactionStatus);
    &#125;
    return null;
&#125;
</code></pre>
<h4 id="1、接口开启事务-PlatformTransactionManager"><a href="#1、接口开启事务-PlatformTransactionManager" class="headerlink" title="1、接口开启事务 PlatformTransactionManager"></a>1、接口开启事务 PlatformTransactionManager</h4><pre><code class="java">/**
 * 事务管理器的接口
 */
@Autowired
private PlatformTransactionManager platformTransactionManager;

/**
 * 这个接口主要用来定义事务的传播行为、隔离级别、超时时间、是否只读等属性
 */
@Autowired
private TransactionDefinition transactionDefinition;

@Test
public void manualTransactionalTest() &#123;
    TransactionStatus transactionStatus = platformTransactionManager.getTransaction(transactionDefinition);
    try &#123;
        UserInfo userInfo = new UserInfo();
        iUserInfoService.insertData(userInfo);

        UserInfo userInfo1 = new UserInfo();
        iUserInfoService.insertData(userInfo1);
        platformTransactionManager.commit(transactionStatus);
    &#125; catch (Exception exception) &#123;
        platformTransactionManager.rollback(transactionStatus);
    &#125;
&#125;
</code></pre>
<h4 id="2、Spring-Mybatis-开启事务-DataSourceTransactionManager"><a href="#2、Spring-Mybatis-开启事务-DataSourceTransactionManager" class="headerlink" title="2、Spring&#x2F;Mybatis 开启事务 DataSourceTransactionManager"></a>2、Spring&#x2F;Mybatis 开启事务 DataSourceTransactionManager</h4><p>DataSourceTransactionManager 它是 Spring 提供的一个事务管理器，用于管理基于 JDBC 的事务。</p>
<p>在 MyBatis 中，对应的 TransactionManager 是 DataSourceTransactionManager，与 Spring JDBC 相同。</p>
<pre><code class="java">@Autowired
private DataSourceTransactionManager dataSourceTransactionManager;

public void tranDelNoAuto(String name) &#123;
    DefaultTransactionDefinition defaultTransactionDefinition = new DefaultTransactionDefinition();
    TransactionStatus transactionStatus = dataSourceTransactionManager.getTransaction(defaultTransactionDefinition);
    User deleteUer = userRepository.findOneByName(name);
    if (deleteUer != null) &#123;
        userRepository.deleteById(deleteUer.getId());
    &#125;
    if (deleteUer.getId() % 2 == 0) &#123;
        dataSourceTransactionManager.commit(transactionStatus);
    &#125; else &#123;
        dataSourceTransactionManager.rollback(transactionStatus);
    &#125;
&#125;
</code></pre>
<h4 id="3、JPA-开启事务-JpaTransactionManager"><a href="#3、JPA-开启事务-JpaTransactionManager" class="headerlink" title="3、JPA 开启事务 JpaTransactionManager"></a>3、JPA 开启事务 JpaTransactionManager</h4><pre><code class="java">@Autowired
private JpaTransactionManager jpaTransactionManager;

public void tranDelNoAuto(String userName) &#123;
    DefaultTransactionDefinition defaultTransactionDefinition = new DefaultTransactionDefinition();
    TransactionStatus transactionStatus = jpaTransactionManager.getTransaction(defaultTransactionDefinition);
    User delteUser = iUserDao.findByUsername(userName);
    if (delteUser != null) &#123;
        iUserDao.deleteById(delteUser.getUserid());
    &#125;
    if (delteUser.getUserid() % 2 == 0) &#123;
        jpaTransactionManager.commit(transactionStatus);
    &#125; else &#123;
        jpaTransactionManager.rollback(transactionStatus);
    &#125;
&#125;
</code></pre>
<h4 id="4、自定义事务工具类-TransactionManage"><a href="#4、自定义事务工具类-TransactionManage" class="headerlink" title="4、自定义事务工具类 TransactionManage"></a>4、自定义事务工具类 TransactionManage</h4><p>我们就基于这种方法来做一个工具类。这个工具类作用是接收一个Service层需要被事务包围的方法为参数，然后给调用端返回事务结果，供调用端根据结果做相应的处理。</p>
<pre><code class="java">import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;
import org.springframework.transaction.PlatformTransactionManager;
import org.springframework.transaction.TransactionStatus;
import org.springframework.transaction.support.DefaultTransactionDefinition;
import java.util.function.Consumer;

/**
 * 编程式事务工具类
 */
@Slf4j
@Component
public class TransactionUtil &#123;
    @Autowired
    private PlatformTransactionManager transactionManager;

    public &lt;T&gt; boolean transactional(T entity, Consumer&lt;T&gt; consumer) &#123;
        TransactionStatus status = transactionManager.getTransaction(new DefaultTransactionDefinition());
        try &#123;
            consumer.accept(entity);
            transactionManager.commit(status);
            return true;
        &#125; catch (Exception e) &#123;
            transactionManager.rollback(status);
            log.error(&quot;编程式事务业务异常回滚&quot;, e);
            return false;
        &#125;
    &#125;
&#125;
</code></pre>
<p>该类通过接收一个函数型参数，返回该函数的事务执行结果。由于我们仅仅是为了执行Service代码，并不需要改变代码的值，所有consumer.accept(null)即可。</p>
<pre><code class="java">@Service
public class TestService &#123;
    /**
     * 此处不需要事务，由TransactionUtil控制事务
     */
    public void doSome(Object entity) &#123;
        // repository.save(entity);
        System.out.println(&quot;我是Service层&quot; + entity);
    &#125;
&#125;

// Controller 中就可以使用
@RestController
public class TestController &#123;
    @Autowired TestService testService;
    @Autowired TransactionUtil transactionUtil;

    @GetMapping(&quot;/test&quot;)
    public String test() &#123;
        // 获取事务的执行结果
        boolean result = transactionUtil.transactional(new Object(), x -&gt; testService.doSome(x));
        return &quot;1&quot;;
    &#125;
&#125;
</code></pre>
<p>该工具是需要获取事务执行结果的封装。</p>
<h1 id="三、事务应用的注意事项"><a href="#三、事务应用的注意事项" class="headerlink" title="三、事务应用的注意事项"></a>三、事务应用的注意事项</h1><blockquote>
<p>作者：<a target="_blank" rel="noopener" href="https://blog.csdn.net/CSDN_WYL2016">码拉松</a>、来源：<a target="_blank" rel="noopener" href="https://blog.csdn.net/CSDN_WYL2016/article/details/122254559">https://blog.csdn.net/CSDN_WYL2016/article/details/122254559</a></p>
</blockquote>
<h2 id="1、声明式事务的应用级别"><a href="#1、声明式事务的应用级别" class="headerlink" title="1、声明式事务的应用级别"></a>1、声明式事务的应用级别</h2><p>在实际生产应用中是不建议在类似<code>Service</code>这样的<code>class</code>类上直接加上<code>@Transactional</code>注解的，因为这样会导致这个类中的所有方法在执行时都带上了事务，只要调用到数据库，就都会被进行事务管理，从而影响数据库和Web服务的QPS。这样原来根本就不需要事务的方法则多了一份负担。</p>
<p>又称：滥用@Transactional。由于声明式事务@Transactional的简单灵活，而经常导致被滥用的情况发生。</p>
<pre><code class="java">@Service
@Transactional // 不要加在Service上
public class DemoService &#123;
&#125;
</code></pre>
<h2 id="2、长事务、过早起开事务"><a href="#2、长事务、过早起开事务" class="headerlink" title="2、长事务、过早起开事务"></a>2、长事务、过早起开事务</h2><p>简单来说，就是在整个方法的生命周期内，真正需要事务管理的方法可能只占用了<code>20%</code>的时间，而其他业务流程占用了<code>80%</code>的时间，但是由于事务是对整个方法生效，从而导致事务的整体执行时间与整个方法的执行时间一样。</p>
<pre><code class="java">@Transactional
public void func() &#123;
    // 两个select花费了2秒
    select1();
    select2();
    // 两个save只花费了200毫秒
    save1();
    save2();
&#125;
</code></pre>
<p>解决方式也很简单，把长事务拆分为短事务即可</p>
<pre><code class="java">public void func() &#123;
    select1();
    select2();
    manager.save();
&#125;

@Transactional
public void save() &#123;
    save1();
    save2();
&#125;
</code></pre>
<p>也可以直接使用编程式事务，编程式事务可以更灵活的控制事务的范围。</p>
<pre><code class="java">@Resource
private TransactionTemplate transactionTemplate;

public void func() &#123;
    transactionTemplate.execute(new TransactionCallbackWithoutResult() &#123;
        @Override
        protected void doInTransactionWithoutResult(TransactionStatus status) &#123;
            testMapper.updateT1();
            t2Service.func();
            int i = 1 / 0;
        &#125;
    &#125;);
&#125;
</code></pre>
<h2 id="3、锁的粒度"><a href="#3、锁的粒度" class="headerlink" title="3、锁的粒度"></a>3、锁的粒度</h2><p>要想开启事务，就要先持有锁，因此锁的范围就很重要，InnoDB之所以能够取代Myisam，不单单只是因为InnoDB支持事务，更重要的是因为它还支持行级锁，这在高并发的业务场景中，是非常关键的。</p>
<p>所以，我们平时在写代码时，一定要注意避免表级锁的产生。</p>
<h2 id="4、数据库死锁"><a href="#4、数据库死锁" class="headerlink" title="4、数据库死锁"></a>4、数据库死锁</h2><p>看到此类的异常，不用多想，基本上就是并发事务导致的，一个事务还未结束，另一个事务想再获取锁时就会遇到这个问题。</p>
<pre><code class="java">Deadlock found when trying to get lock; try restarting transaction
</code></pre>
<p>解决的方式就前面提到的两点：</p>
<ol>
<li>避免长事务。</li>
<li>缩小锁的粒度。</li>
</ol>
<h1 id="四、事务失效的八种场景"><a href="#四、事务失效的八种场景" class="headerlink" title="四、事务失效的八种场景"></a>四、事务失效的八种场景</h1><blockquote>
<p>作者：<a target="_blank" rel="noopener" href="https://blog.csdn.net/CSDN_WYL2016">码拉松</a>、来源：<a target="_blank" rel="noopener" href="https://blog.csdn.net/CSDN_WYL2016/article/details/122263796">https://blog.csdn.net/CSDN_WYL2016/article/details/122263796</a></p>
</blockquote>
<p>本章主要针对事务失效的情况来分析，关于事务未生效的问题，也是我们在日常开发中经常会遇到的，总结一些会导致事务失效的场景，以免遇到类似的问题。</p>
<h2 id="1、异常未抛出"><a href="#1、异常未抛出" class="headerlink" title="1、异常未抛出"></a>1、异常未抛出</h2><p>被捕获的异常一定要抛出，否则是不会回滚的。</p>
<pre><code class="java">// t1Service
@Transactional
public void func() &#123;
    try &#123;
        testMapper.updateT1();
        t2Service.func();
        int i = 1 / 0;
    &#125; catch (Exception e) &#123;
        // 异常捕获了，未抛出，导致异常事务不会回滚。
        e.printStackTrace();
    &#125;
&#125;

// t2Service
@Transactional
public void func() &#123;
    testMapper.updateT2();
&#125;
</code></pre>
<h2 id="2、异常与rollback不匹配"><a href="#2、异常与rollback不匹配" class="headerlink" title="2、异常与rollback不匹配"></a>2、异常与rollback不匹配</h2><p><code>@Transactional</code>默认情况下，只会回滚<code>RuntimeException</code>和<code>Error</code>及其子类的异常，如果是受检异常或者其他业务类异常是不会回滚事务的。</p>
<pre><code class="java">@Transactional
public void func() throws Exception &#123;
    try &#123;
        testMapper.updateT1();
        t2Service.func();
        int i = 1 / 0;
    &#125; catch (Exception e) &#123;
        // 默认情况下非运行时异常不会回滚
        throw new Exception();
    &#125;
&#125;
</code></pre>
<p>修改方式也很简单，<code>@Transactional</code>支持通过<code>rollbackFor</code>指定回滚异常类型，可以直接改成<code>rollbackFor = Exception.class</code>即可</p>
<pre><code class="java">// 改成rollbackFor = Exception.class即可
@Transactional(rollbackFor = Exception.class)
public void func() throws Exception &#123;
    try &#123;
        testMapper.updateT1();
        t2Service.func();
        int i = 1 / 0;
    &#125; catch (Exception e) &#123;
        throw new Exception();
    &#125;
&#125;
</code></pre>
<h2 id="3、方法内部直接调用"><a href="#3、方法内部直接调用" class="headerlink" title="3、方法内部直接调用"></a>3、方法内部直接调用</h2><p><code>func2</code>方法是由<code>func</code>调用，虽然<code>func2</code>方法上加了<code>@Transactional</code>注解，但事务不会生效，<code>testMapper.updateT2()</code>执行的方法并不会回滚。</p>
<pre><code class="java">public void func() &#123;
    testMapper.updateT1();
    func2(); // 重点在这里: 这里属于调用内部方法
&#125;
@Transactional
public void func2() &#123;
    testMapper.updateT2();
    int i = 1 / 0;
&#125;
</code></pre>
<p>修改方式也很简单，通过注入的方式调用即可</p>
<pre><code class="java">@Service
public class T1Service &#123;

    @Resource
    private TestMapper testMapper;

    // 注入T1Service对象
    @Resource
    private T1Service t1Service;

    public void func() &#123;
        testMapper.updateT1();
        // 通过注入的方式调用自身的方法
        t1Service.func2();
    &#125;

    @Transactional
    public void func2() &#123;
        testMapper.updateT2();
        int i = 1 / 0;
    &#125;
&#125;
</code></pre>
<blockquote>
<p>注意：SpringBoot 2.6.0版本开始，默认禁止循环依赖，所以如果你使用的版本是2.6.0之后的，那么启动会遇到如下报错。</p>
</blockquote>
<pre><code class="java">As a last resort, it may be possible to break the cycle automatically by setting spring.main.allow-circular-references to true.
</code></pre>
<p>修改方式：在配置文件中把允许循环依赖打开即可。</p>
<pre><code class="properties">spring.main.allow-circular-references=true
</code></pre>
<p>当然，你也可以直接使用<code>AopContext</code>的方式来调用：</p>
<pre><code class="java">public void func() &#123;
    testMapper.updateT1();
    T1Service t1Service = (T1Service) AopContext.currentProxy();
    t1Service.func2();
&#125;
@Transactional
public void func2() &#123;
    testMapper.updateT2();
    int i = 1 / 0;
&#125;
</code></pre>
<h2 id="4、在另一个线程中使用事务"><a href="#4、在另一个线程中使用事务" class="headerlink" title="4、在另一个线程中使用事务"></a>4、在另一个线程中使用事务</h2><p><code>Spring</code>事务管理的方式就是通过<code>ThreadLocal</code>把数据库连接与当前线程绑定，如果新开启一个线程自然就不是一个数据库连接了，自然也就不是一个事务。</p>
<p><code>t2Service.func()</code>方法操作的数据并不会被回滚。</p>
<pre><code class="java">@Transactional
public void func() &#123;
    testMapper.updateT1();
    new Thread(() -&gt; t2Service.func()).start();
    int i = 1 / 0;
&#125;
</code></pre>
<h2 id="5、注解作用到private级别的方法上"><a href="#5、注解作用到private级别的方法上" class="headerlink" title="5、注解作用到private级别的方法上"></a>5、注解作用到private级别的方法上</h2><p>当你写成如下这样时，<code>IDEA</code>直接会给出提示<code>Methods annotated with ‘@Transactional’ must be overridable</code> 原因很简单，<code>private</code>修饰的方式，<code>spring</code>无法为其生成代理。</p>
<pre><code class="java">public void func() &#123;
    t1Service.func2();
&#125;

@Transactional
private void func2() &#123;
    testMapper.updateT1();
    int i = 1 / 0;
&#125;
</code></pre>
<p><img src="/blog/Spring-%E4%BA%8B%E5%8A%A1%E5%BA%94%E7%94%A8%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.assets/image-20241025145538219.png" alt="在这里插入图片描述"></p>
<h2 id="6、final-类型的方法"><a href="#6、final-类型的方法" class="headerlink" title="6、final 类型的方法"></a>6、final 类型的方法</h2><p>这个与<code>private</code>道理是一样的，都是影响了<code>Spring</code>生成代理对象，同样<code>IDEA</code>也会有相关提示。 </p>
<p><img src="/blog/Spring-%E4%BA%8B%E5%8A%A1%E5%BA%94%E7%94%A8%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.assets/image-20241025145538220.png" alt="在这里插入图片描述"></p>
<h2 id="7、数据库存储引擎不支持事务"><a href="#7、数据库存储引擎不支持事务" class="headerlink" title="7、数据库存储引擎不支持事务"></a>7、数据库存储引擎不支持事务</h2><p>注意，如果你使用的是<code>MySQL</code>数据库，那么常用的存储引擎中只有<code>InnoDB</code>才支持事务，像<code>MyISAM</code>是不支持事务的，其他存储引擎都是针对特定场景下使用的，一般也不会用到，不做讨论。</p>
<p><img src="/blog/Spring-%E4%BA%8B%E5%8A%A1%E5%BA%94%E7%94%A8%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.assets/image-20241025145538221.png" alt="在这里插入图片描述"></p>
<h2 id="8、事务的传播类型"><a href="#8、事务的传播类型" class="headerlink" title="8、事务的传播类型"></a>8、事务的传播类型</h2><p>前面已经对事务的传播类型做过介绍了，有的传播类型会以非事务方式执行，有的传播则会新开启一个事务，这些都需要额外注意。</p>
<ul>
<li><strong>REQUIRED</strong>：支持当前事务，如果当前不存在则新开启一个事务（默认配置）</li>
<li><strong>SUPPORTS</strong>：支持当前事务，如果当前不存在事务则以非事务方式执行</li>
<li><strong>MANDATORY</strong>：支持当前事务，如果当前不存在事务则抛出异常</li>
<li><strong>REQUIRES_NEW</strong>：创建一个新事务，如果当前已存在事务则挂起当前事务</li>
<li><strong>NOT_SUPPORTED</strong>：以非事务方式执行，如果当前已存在事务则挂起当前事务</li>
<li><strong>NEVER</strong>：以非事务方式执行，如果当前已存在事务则抛出异常</li>
<li><strong>NESTED</strong>：如果当前存在事务，则在嵌套事务中执行，否则开启一个新事务</li>
</ul>
<h1 id="五、事务管理器架构分析"><a href="#五、事务管理器架构分析" class="headerlink" title="五、事务管理器架构分析"></a>五、事务管理器架构分析</h1><blockquote>
<ul>
<li>作者：<a target="_blank" rel="noopener" href="https://blog.csdn.net/CSDN_WYL2016">码拉松</a>、来源：<a target="_blank" rel="noopener" href="https://blog.csdn.net/CSDN_WYL2016/article/details/122285286">https://blog.csdn.net/CSDN_WYL2016/article/details/122285286</a></li>
<li>作者：<a target="_blank" rel="noopener" href="https://author.baidu.com/home?from=bjh_article&app_id=1742572817489016">程序员古德</a>、来源：一文带你掌握Spring事务核心：TransactionDefinition详解！<ul>
<li><a target="_blank" rel="noopener" href="https://baijiahao.baidu.com/s?id=1785219136558062233%E3%80%81">https://baijiahao.baidu.com/s?id=1785219136558062233、</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qusikao/article/details/134987576">https://blog.csdn.net/qusikao/article/details/134987576</a></li>
</ul>
</li>
</ul>
</blockquote>
<p>在<code>Spring</code>中，我们可以直接使用<code>TransactionTemplate</code>或者<code>PlatformTransactionManager</code>来操作事务，<code>TransactionTemplate</code>封装了事务处理的核心流程，使用者只需把它注入到自己的上下文中，变可直接使用，而<code>PlatformTransactionManager</code>则是更底层的接口，我们可以直接通过它来控制事务，但它并不是主流的使用方式，一般还是建议优先使用<code>TransactionTemplate</code>或者直接声明式的<code>@Transaction</code>。</p>
<p>本次主要会对<code>Spring</code>事务的整体架构进行梳理，通过源码的分析，让使用者能够更清楚事务的内部实现原理。</p>
<h2 id="1、接口与类的关系图"><a href="#1、接口与类的关系图" class="headerlink" title="1、接口与类的关系图"></a>1、接口与类的关系图</h2><p><img src="/blog/Spring-%E4%BA%8B%E5%8A%A1%E5%BA%94%E7%94%A8%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.assets/image-20241025145538222.png" alt="在这里插入图片描述"></p>
<h2 id="2、TransactionManager"><a href="#2、TransactionManager" class="headerlink" title="2、TransactionManager"></a>2、TransactionManager</h2><p><code>TransactionManager</code>是一个标识接口</p>
<pre><code class="java">public interface TransactionManager &#123;
&#125;
</code></pre>
<h2 id="3、PlatformTransactionManager"><a href="#3、PlatformTransactionManager" class="headerlink" title="3、PlatformTransactionManager"></a>3、PlatformTransactionManager</h2><p><code>PlatformTransactionManager</code>接口继承了<code>TransactionManager</code>，定义了事务的核心方法，提交和回滚，正如前面提到的，可以直接使用它来控制事务，但并不建议这样做，正确的做法应该是继承<code>AbstractPlatformTransactionManager</code>类，典型的样例就是<code>JtaTransactionManager</code>和<code>DataSourceTransactionManager</code>。</p>
<pre><code class="java">public interface PlatformTransactionManager extends TransactionManager &#123;    
    TransactionStatus getTransaction(@Nullable TransactionDefinition definition) throws TransactionException;
    void commit(TransactionStatus status) throws TransactionException;
    void rollback(TransactionStatus status) throws TransactionException;
&#125;
</code></pre>
<h2 id="4、AbstractPlatformTransactionManager"><a href="#4、AbstractPlatformTransactionManager" class="headerlink" title="4、AbstractPlatformTransactionManager"></a>4、AbstractPlatformTransactionManager</h2><p>这是一个典型的采用模板方法设计的抽象类，定义了关于事务的核心处理流程。可以看到几个关键的抽象方法，都交由子类去实现。 </p>
<p><img src="/blog/Spring-%E4%BA%8B%E5%8A%A1%E5%BA%94%E7%94%A8%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.assets/image-20241025145538223.png" alt="在这里插入图片描述"></p>
<p>到了下面的具体的子类实现，只需要简单的执行就好了，比如：<code>DataSourceTransactionManager</code>类重写<code>doCommit</code>和<code>doRollback</code>方法只是简单的获取数据库连接后进行事务的提交或者回滚就好了。 </p>
<p><img src="/blog/Spring-%E4%BA%8B%E5%8A%A1%E5%BA%94%E7%94%A8%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.assets/image-20241025145538224.png" alt="在这里插入图片描述"></p>
<h2 id="5、TransactionTemplate"><a href="#5、TransactionTemplate" class="headerlink" title="5、TransactionTemplate"></a>5、TransactionTemplate</h2><p>通过分析<code>TransactionManager</code>链路下的一些类可以看出，主要就是定义了事务处理的关键方法和核心流程，那么具体执行事务的入口就要看<code>TransactionTemplate</code>了。</p>
<p><code>TransactionTemplate</code>是具体执行事务的入口，<code>XXXTemplate</code>结尾的类，通常目的都是为了简化使用者处理的流程，这种命名方式也是<code>Spring</code>的习惯。</p>
<p>而<code>TransactionTemplate</code>中定义的入口方法就是<code>execute</code>。</p>
<p><img src="/blog/Spring-%E4%BA%8B%E5%8A%A1%E5%BA%94%E7%94%A8%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.assets/image-20241025145538225.png" alt="在这里插入图片描述"></p>
<p>入参<code>TransactionCallback</code>也是一个标记性接口。</p>
<pre><code class="java">@FunctionalInterface
public interface TransactionCallback&lt;T&gt; &#123;
    @Nullable
    T doInTransaction(TransactionStatus status);
&#125;
</code></pre>
<pre><code class="java">@Override
@Nullable
public &lt;T&gt; T execute(TransactionCallback&lt;T&gt; action) throws TransactionException &#123;
    // 方法执行需要先确保transactionManager对象不为空，还记得transactionManager吗？就是前面分析的定义了事务处理的关键方法和核心流程的类。
    Assert.state(this.transactionManager != null, &quot;No PlatformTransactionManager set&quot;);
    if (this.transactionManager instanceof CallbackPreferringPlatformTransactionManager) &#123;
        return ((CallbackPreferringPlatformTransactionManager) this.transactionManager).execute(this, action);
    &#125;
    else &#123;
        TransactionStatus status = this.transactionManager.getTransaction(this);
        T result;
        try &#123;
            result = action.doInTransaction(status);
        &#125;
        catch (RuntimeException | Error ex) &#123;
            // Transactional code threw application exception -&gt; rollback
            rollbackOnException(status, ex);
            throw ex;
        &#125;
        catch (Throwable ex) &#123;
            // Transactional code threw unexpected exception -&gt; rollback
            rollbackOnException(status, ex);
            throw new UndeclaredThrowableException(ex, &quot;TransactionCallback threw undeclared checked exception&quot;);
        &#125;
        this.transactionManager.commit(status);
        return result;
    &#125;
&#125;
</code></pre>
<p>而<code>TransactionManager</code>会作为<code>TransactionTemplate</code>中的一个属性来使用。</p>
<p><img src="/blog/Spring-%E4%BA%8B%E5%8A%A1%E5%BA%94%E7%94%A8%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.assets/image-20241025145538226.png" alt="在这里插入图片描述"></p>
<p>整个<code>execute</code>中几个关键的方法实际上都是在调用<code>TransactionManager</code>中提供的方法，<code>doInTransaction</code>则是执行业务代码的地方。</p>
<p><img src="/blog/Spring-%E4%BA%8B%E5%8A%A1%E5%BA%94%E7%94%A8%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.assets/image-20241025145538227.png" alt="在这里插入图片描述"></p>
<p><img src="/blog/Spring-%E4%BA%8B%E5%8A%A1%E5%BA%94%E7%94%A8%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.assets/image-20241025145538228.png" alt="在这里插入图片描述"></p>
<h2 id="6、TransactionDefinition"><a href="#6、TransactionDefinition" class="headerlink" title="6、TransactionDefinition"></a>6、TransactionDefinition</h2><p><code>TransactionDefinition</code>是Spring框架中用于定义事务属性的核心接口，这个接口主要用来定义事务的传播行为、隔离级别、超时时间、是否只读等属性。</p>
<p><img src="/blog/Spring-%E4%BA%8B%E5%8A%A1%E5%BA%94%E7%94%A8%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.assets/image-20241025145538229.png"></p>
<p><img src="/blog/Spring-%E4%BA%8B%E5%8A%A1%E5%BA%94%E7%94%A8%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.assets/image-20241025145538230.png" alt="在这里插入图片描述"></p>
<h3 id="1、基本介绍"><a href="#1、基本介绍" class="headerlink" title="1、基本介绍"></a>1、基本介绍</h3><p><code>TransactionDefinition</code> 接口的主要方法：</p>
<ol>
<li><strong>getIsolationLevel()</strong>: 返回事务的隔离级别。隔离级别定义了事务如何与其他事务隔离，以避免如脏读、不可重复读和幻读等问题。Spring 支持多种隔离级别，如 <code>ISOLATION_DEFAULT</code>、<code>ISOLATION_READ_UNCOMMITTED</code>、<code>ISOLATION_READ_COMMITTED</code>、<code>ISOLATION_REPEATABLE_READ</code> 和 <code>ISOLATION_SERIALIZABLE</code>。</li>
<li><strong>getPropagationBehavior()</strong>: 返回事务的传播行为。传播行为决定了当一个事务方法被另一个事务方法调用时，应该如何传播事务。例如，是否应该启动新的事务、使用现有事务还是挂起现有事务等。Spring 支持如 <code>PROPAGATION_REQUIRED</code>、<code>PROPAGATION_REQUIRES_NEW</code>、<code>PROPAGATION_NESTED</code> 等多种传播行为。</li>
<li><strong>getTimeout()</strong>: 返回事务的超时时间（以秒为单位）。如果一个事务运行的时间超过了这个指定的时间，那么它可能会被底层的事务管理系统自动回滚。</li>
<li><strong>isReadOnly()</strong>: 返回事务是否为只读。一个只读事务意味着这个事务只读取数据但不修改数据。在某些情况下，数据库可以利用这个信息来优化性能。</li>
<li><strong>getName()</strong>: 返回事务的名称。这是一个可选属性，可以为事务提供一个名称，以便于识别和调试。</li>
</ol>
<p>如下一个简单的 <code>TransactionDefinition</code> 案例：</p>
<pre><code class="java">@Transactional(isolation = Isolation.READ_COMMITTED, propagation = Propagation.REQUIRES_NEW)  
public void someTransactionalMethod() &#123;  
    // ... business logic ...  
&#125;
</code></pre>
<p>在上面的例子中，指定了事务的隔离级别为 <code>READ_COMMITTED</code> 和传播行为为 <code>REQUIRES_NEW</code>。总的来说，<code>TransactionDefinition</code> 接口为 Spring 提供了一种统一和灵活的方式来定义和配置事务的各种属性，使开发者能够根据不同的业务需求调整事务的行为。</p>
<h3 id="2、场景介绍"><a href="#2、场景介绍" class="headerlink" title="2、场景介绍"></a>2、场景介绍</h3><h4 id="1）电商系统订单处理"><a href="#1）电商系统订单处理" class="headerlink" title="1）电商系统订单处理"></a>1）电商系统订单处理</h4><p>在电商系统中，当用户下单时，通常需要在数据库中创建订单记录，同时更新库存和用户的付款状态，这个过程必须是事务性的，以确保数据的一致性。这场景具有以下特点：</p>
<ol>
<li>多个库表操作（创建订单、更新库存、更新付款状态）。</li>
<li>需要确保所有操作都成功才提交事务。</li>
</ol>
<p>在该场景中 <code>TransactionDefinition</code> 的伪配置如下：</p>
<ul>
<li><strong>传播行为</strong>：<code>PROPAGATION_REQUIRED</code>，因为在一个事务上下文中执行所有操作是有意义的。</li>
<li><strong>隔离级别</strong>：<code>ISOLATION_READ_COMMITTED</code>，以避免脏读，同时允许一定程度的并发。</li>
<li><strong>超时时间</strong>：根据业务需要设定，比如30秒。</li>
</ul>
<h4 id="2）银行转账系统"><a href="#2）银行转账系统" class="headerlink" title="2）银行转账系统"></a>2）银行转账系统</h4><p>在银行转账系统中，从一个账户扣款并向另一个账户存款必须是一个原子操作，如果在扣款后因为某种原因存款失败，整个转账操作必须回滚。这场景具有以下特点：</p>
<ol>
<li>涉及两个账户的数据库操作</li>
<li>需要确保转账操作的原子性</li>
</ol>
<p>在该场景中 <code>TransactionDefinition</code> 的伪配置如下：</p>
<ul>
<li><strong>传播行为</strong>：<code>PROPAGATION_REQUIRED</code>，确保转账操作的原子性。</li>
<li><strong>隔离级别</strong>：<code>ISOLATION_SERIALIZABLE</code>，因为金融系统通常需要最严格的隔离级别。</li>
<li><strong>超时时间</strong>：相对较长，比如60秒，因为金融交易可能涉及更多验证和处理时间。</li>
</ul>
<h4 id="3）内容管理系统"><a href="#3）内容管理系统" class="headerlink" title="3）内容管理系统"></a>3）内容管理系统</h4><p>在内容管理系统中，发布一篇文章可能包括在数据库中创建文章记录、更新作者统计信息、发送通知等操作，这些操作需要在一个事务中执行，以确保数据的一致性。。这场景具有以下特点：</p>
<ol>
<li>多个数据库和外部系统操作（如发送通知）</li>
<li>需要确保所有操作都成功才提交事务</li>
</ol>
<p>在该场景中 <code>TransactionDefinition</code> 的伪配置如下：</p>
<ul>
<li><strong>传播行为</strong>：<code>PROPAGATION_REQUIRED</code>，以便在一个事务上下文中执行所有操作。</li>
<li><strong>隔离级别</strong>：<code>ISOLATION_READ_COMMITTED</code>，以平衡性能和一致性。</li>
<li><strong>超时时间</strong>：相对较短，比如10秒，因为内容管理系统通常对性能要求较高。</li>
</ul>
<h3 id="3、代码案例"><a href="#3、代码案例" class="headerlink" title="3、代码案例"></a>3、代码案例</h3><p>假设，我们正在开发一个简单的银行转账系统，需要确保转账操作的原子性。在案例中我们将使用Spring框架的事务管理功能，并通过<code>TransactionDefinition</code>来定义事务属性，核心代码如下：</p>
<pre><code class="java">import org.springframework.beans.factory.annotation.Autowired;  
import org.springframework.jdbc.core.JdbcTemplate;  
import org.springframework.transaction.PlatformTransactionManager;  
import org.springframework.transaction.TransactionDefinition;  
import org.springframework.transaction.TransactionStatus;  
import org.springframework.transaction.support.DefaultTransactionDefinition;  

public class BankService &#123;  
  
    @Autowired  
    private PlatformTransactionManager transactionManager;  
  
    @Autowired  
    private JdbcTemplate jdbcTemplate;  
  
    public void transfer(String fromAccount, String toAccount, double amount) &#123;  
        // 定义一个事务属性对象  
        TransactionDefinition transactionDefinition = new DefaultTransactionDefinition();  
        transactionDefinition.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);  
        transactionDefinition.setIsolationLevel(TransactionDefinition.ISOLATION_READ_COMMITTED);  
        transactionDefinition.setTimeout(10); // 设置超时时间为10秒  
        transactionDefinition.setReadOnly(false); // 事务不是只读的  
  
        // 获取事务状态对象  
        TransactionStatus transactionStatus = transactionManager.getTransaction(transactionDefinition);  
  
        try &#123;  
            // 从源账户扣钱  
            jdbcTemplate.update(&quot;UPDATE account SET balance = balance - ? WHERE account_number = ?&quot;, amount, fromAccount);  
            // 向目标账户加钱  
            jdbcTemplate.update(&quot;UPDATE account SET balance = balance + ? WHERE account_number = ?&quot;, amount, toAccount);  
  
            // 提交事务  
            transactionManager.commit(transactionStatus);  
            System.out.println(&quot;转账成功！&quot;);  
        &#125; catch (Exception e) &#123;  
            // 回滚事务  
            transactionManager.rollback(transactionStatus);  
            System.out.println(&quot;转账失败！&quot;);  
            throw e; // 或者选择记录错误日志等其他处理方式  
        &#125;  
    &#125;  
&#125;
</code></pre>
<p>在这个案例中，我们定义了一个<code>transfer</code>方法，用于执行转账操作。</p>
<p>在方法内部，我们首先创建了一个<code>DefaultTransactionDefinition</code>对象，并通过<code>setPropagationBehavior</code>、<code>setIsolationLevel</code>、<code>setTimeout</code>和<code>setReadOnly</code>方法配置了事务的属性，然后，我们通过<code>transactionManager.getTransaction</code>方法获取了一个<code>TransactionStatus</code>对象，该对象代表了当前事务的状态，在try-catch块中，我们执行了实际的数据库操作（扣钱和加钱），并在成功的情况下提交事务，失败的情况下回滚事务。</p>
<p>最后，我们根据事务的执行结果输出相应的提示信息。</p>
<h3 id="4、源码解读"><a href="#4、源码解读" class="headerlink" title="4、源码解读"></a>4、源码解读</h3><p>这里列出了<code>TransactionDefinition</code>核心方法以及变量，其中一些功能含义、功能重复的就以<code>... 其他XXX ...</code> 进行表示，如下：</p>
<pre><code class="java">package org.springframework.transaction;  
import java.io.Serializable;  

/**  
 * 事务定义接口，用于定义事务的属性。  
 *  
 * @author Juergen Hoeller  
 * @since 16.03.2003  
 */  
public interface TransactionDefinition extends Serializable &#123;  
  
    /**  
     * 支持当前事务，如果当前没有事务，则新建一个事务。  
     * 这是最常见的选择。  
     */  
    int PROPAGATION_REQUIRED = 0;  
  
    /**  
     * 使用默认的事务隔离级别。  
     * 实际的隔离级别由底层数据库决定。  
     */  
    int ISOLATION_DEFAULT = -1;  
  
    // ... 其他隔离级别常量 ...  
  
    /**  
     * 返回事务的传播行为。  
     * &lt;p&gt;事务的传播行为决定了当在一个事务方法中被另一个事务方法调用时，如何使用事务。  
     * 例如：&#123;@code PROPAGATION_REQUIRED&#125;表示当前方法必须在事务中运行。如果当前存在事务，则加入该事务；  
     * 如果当前没有事务，则新建一个事务。&lt;/p&gt;  
     * @return 事务的传播行为常量，如&#123;@code PROPAGATION_REQUIRED&#125;等。  
     */  
    int getPropagationBehavior();  
  
    /**  
     * 返回事务的隔离级别。  
     * &lt;p&gt;事务的隔离级别决定了事务如何处理并发问题。不同的隔离级别会影响脏读、不可重复读和幻读等问题。&lt;/p&gt;  
     * @return 事务的隔离级别常量，如&#123;@code ISOLATION_READ_COMMITTED&#125;等。  
     */  
    int getIsolationLevel();  
  
    /**  
     * 返回事务的超时时间（以秒为单位）。  
     * &lt;p&gt;如果事务在规定的时间内没有完成，则会被自动回滚。&lt;/p&gt;  
     * @return 超时时间（秒），默认值为-1，表示永不超时。  
     */  
    int getTimeout();  
  
    /**  
     * 返回事务是否为只读。  
     * &lt;p&gt;只读事务不会修改数据，因此可以进行一些优化。&lt;/p&gt;  
     * @return 如果事务为只读，则返回&#123;@code true&#125;；否则返回&#123;@code false&#125;。  
     */  
    boolean isReadOnly();  
  
    /**  
     * 返回事务的名称。  
     * &lt;p&gt;事务名称可以用于日志记录、监控和调试。&lt;/p&gt;  
     * @return 事务的名称，如果没有设置则返回&#123;@code null&#125;。  
     */  
    String getName();  
&#125;
</code></pre>
<h3 id="5、核心总结"><a href="#5、核心总结" class="headerlink" title="5、核心总结"></a>5、核心总结</h3><p><code>TransactionDefinition</code>是<code>Spring</code>框架中用于定义事务属性的核心接口，为开发者提供了事务管理的标准化方式。通过它，我们可以设置事务的传播行为、隔离级别、超时时间和只读属性等，确保数据在并发场景中的一致性和完整性。在实际应用中，<code>TransactionDefinition</code>与其他<code>Spring</code>组件如<code>PlatformTransactionManager</code>结合使用，为数据库操作提供了原子性、一致性、隔离性和持久性的保障，是构建健壮、可维护企业级应用的关键。熟悉并正确使用<code>TransactionDefinition</code>，对于提高系统性能和数据安全性具有重要意义。</p>
<h2 id="7、事务管理器总结"><a href="#7、事务管理器总结" class="headerlink" title="7、事务管理器总结"></a>7、事务管理器总结</h2><p><code>Spring</code>为我们提供的<code>TransactionTemplate</code>类，定义了事务处理的基本流程，对外暴露一个<code>execute</code>方法，并通过传入一个标记性接口<code>TransactionCallback</code>来实现使用者的业务逻辑处理，大大简化了使用方式。</p>
<p>而<code>PlatformTransactionManager</code>则更加的灵活，它的目的主要是为了能够让使用者更加方便的在事务流程前后进行业务扩展，比如它的实现类有：<code>HibernateTransactionManager、JpaTransactionManager、JtaTransactionManager</code>，很明显就是针对不同的ORM框架而定制的。</p>
<p>所以定义<code>TransactionTemplate</code>是为了让事务使用更加方便，定义<code>PlatformTransactionManager</code>是为了让扩展更加的方便。</p>
<h1 id="六、事务管理器源码分析-TransactionSynchronizationManager"><a href="#六、事务管理器源码分析-TransactionSynchronizationManager" class="headerlink" title="六、事务管理器源码分析 TransactionSynchronizationManager"></a>六、事务管理器源码分析 TransactionSynchronizationManager</h1><blockquote>
<p>作者：<a target="_blank" rel="noopener" href="https://blog.csdn.net/CSDN_WYL2016">码拉松</a>、来源：<a target="_blank" rel="noopener" href="https://blog.csdn.net/CSDN_WYL2016/article/details/122391470">https://blog.csdn.net/CSDN_WYL2016/article/details/122391470</a></p>
</blockquote>
<p><code>TransactionSynchronizationManager</code>主要作用就是管理每个线程的资源和事务同步，包括资源绑定，激活事务同步等。</p>
<h2 id="1、6个事务管理对象-ThreadLocal"><a href="#1、6个事务管理对象-ThreadLocal" class="headerlink" title="1、6个事务管理对象 ThreadLocal"></a>1、6个事务管理对象 ThreadLocal</h2><p><code>TransactionSynchronizationManager</code>中定义了6个<code>ThreadLocal</code>对象，单从名称就能分析出来，他们分别负责维护：事务资源、事务同步，事务名称、事务只读状态、事务隔离级别以及当前事务是否活跃。</p>
<pre><code class="java">private static final ThreadLocal&lt;Map&lt;Object, Object&gt;&gt; resources =
        new NamedThreadLocal&lt;&gt;(&quot;Transactional resources&quot;);
private static final ThreadLocal&lt;Set&lt;TransactionSynchronization&gt;&gt; synchronizations =
        new NamedThreadLocal&lt;&gt;(&quot;Transaction synchronizations&quot;);
private static final ThreadLocal&lt;String&gt; currentTransactionName =
        new NamedThreadLocal&lt;&gt;(&quot;Current transaction name&quot;);
private static final ThreadLocal&lt;Boolean&gt; currentTransactionReadOnly =
        new NamedThreadLocal&lt;&gt;(&quot;Current transaction read-only status&quot;);
private static final ThreadLocal&lt;Integer&gt; currentTransactionIsolationLevel =
        new NamedThreadLocal&lt;&gt;(&quot;Current transaction isolation level&quot;);
private static final ThreadLocal&lt;Boolean&gt; actualTransactionActive =
        new NamedThreadLocal&lt;&gt;(&quot;Actual transaction active&quot;);
</code></pre>
<h2 id="2、事务资源"><a href="#2、事务资源" class="headerlink" title="2、事务资源"></a>2、事务资源</h2><p>对于事务资源，<code>TransactionSynchronizationManager</code>中负责提供资源获取、绑定、解绑等接口</p>
<h3 id="1、获取资源"><a href="#1、获取资源" class="headerlink" title="1、获取资源"></a>1、获取资源</h3><pre><code class="java">/**
 * Retrieve a resource for the given key that is bound to the current thread.
 * @param key the key to check (usually the resource factory)
 * @return a value bound to the current thread (usually the active
 * resource object), or &#123;@code null&#125; if none
 * @see ResourceTransactionManager#getResourceFactory()
 */
@Nullable
public static Object getResource(Object key) &#123;
    Object actualKey = TransactionSynchronizationUtils.unwrapResourceIfNecessary(key);
    return doGetResource(actualKey);
&#125;

/**
 * Actually check the value of the resource that is bound for the given key.
 */
@Nullable
private static Object doGetResource(Object actualKey) &#123;
    Map&lt;Object, Object&gt; map = resources.get();
    if (map == null) &#123;
        return null;
    &#125;
    Object value = map.get(actualKey);
    // Transparently remove ResourceHolder that was marked as void...
    if (value instanceof ResourceHolder &amp;&amp; ((ResourceHolder) value).isVoid()) &#123;
        map.remove(actualKey);
        // Remove entire ThreadLocal if empty...
        if (map.isEmpty()) &#123;
            resources.remove();
        &#125;
        value = null;
    &#125;
    return value;
&#125;
</code></pre>
<h3 id="2、绑定资源"><a href="#2、绑定资源" class="headerlink" title="2、绑定资源"></a>2、绑定资源</h3><pre><code class="java">public static void bindResource(Object key, Object value) throws IllegalStateException &#123;
    Object actualKey = TransactionSynchronizationUtils.unwrapResourceIfNecessary(key);
    Assert.notNull(value, &quot;Value must not be null&quot;);
    Map&lt;Object, Object&gt; map = resources.get();
    // set ThreadLocal Map if none found
    if (map == null) &#123;
        map = new HashMap&lt;&gt;();
        resources.set(map);
    &#125;
    Object oldValue = map.put(actualKey, value);
    // Transparently suppress a ResourceHolder that was marked as void...
    if (oldValue instanceof ResourceHolder &amp;&amp; ((ResourceHolder) oldValue).isVoid()) &#123;
        oldValue = null;
    &#125;
    if (oldValue != null) &#123;
        throw new IllegalStateException(
            &quot;Already value [&quot; + oldValue + &quot;] for key [&quot; + actualKey + &quot;] bound to thread&quot;);
    &#125;
&#125;
</code></pre>
<h3 id="3、解绑资源"><a href="#3、解绑资源" class="headerlink" title="3、解绑资源"></a>3、解绑资源</h3><pre><code class="java">public static Object unbindResource(Object key) throws IllegalStateException &#123;
    Object actualKey = TransactionSynchronizationUtils.unwrapResourceIfNecessary(key);
    Object value = doUnbindResource(actualKey);
    if (value == null) &#123;
        throw new IllegalStateException(&quot;No value for key [&quot; + actualKey + &quot;] bound to thread&quot;);
    &#125;
    return value;
&#125;
</code></pre>
<pre><code class="java">@Nullable
private static Object doUnbindResource(Object actualKey) &#123;
    Map&lt;Object, Object&gt; map = resources.get();
    if (map == null) &#123;
        return null;
    &#125;
    Object value = map.remove(actualKey);
    // Remove entire ThreadLocal if empty...
    if (map.isEmpty()) &#123;
        resources.remove();
    &#125;
    // Transparently suppress a ResourceHolder that was marked as void...
    if (value instanceof ResourceHolder &amp;&amp; ((ResourceHolder) value).isVoid()) &#123;
        value = null;
    &#125;
    return value;
&#125;
</code></pre>
<h2 id="3、事务同步"><a href="#3、事务同步" class="headerlink" title="3、事务同步"></a>3、事务同步</h2><p>对于事务同步，<code>TransactionSynchronizationManager</code>中负责提供：事务同步激活、事务同步注册、获取事务同步列表、判断当前事务同步是否为活跃的等。</p>
<h3 id="1、事务同步激活"><a href="#1、事务同步激活" class="headerlink" title="1、事务同步激活"></a>1、事务同步激活</h3><p>实际上就是给<code>synchronizations</code>放入一个<code>LinkedHashSet</code></p>
<pre><code class="java">public static void initSynchronization() throws IllegalStateException &#123;
    if (isSynchronizationActive()) &#123;
        throw new IllegalStateException(&quot;Cannot activate transaction synchronization - already active&quot;);
    &#125;
    synchronizations.set(new LinkedHashSet&lt;&gt;());
&#125;
</code></pre>
<h3 id="2、事务同步注册"><a href="#2、事务同步注册" class="headerlink" title="2、事务同步注册"></a>2、事务同步注册</h3><p>从当前线程中取出<code>set</code>集合，并为其添加一个<code>TransactionSynchronization</code>对象</p>
<pre><code class="java">public static void registerSynchronization(TransactionSynchronization synchronization)
        throws IllegalStateException &#123;
    Assert.notNull(synchronization, &quot;TransactionSynchronization must not be null&quot;);
    Set&lt;TransactionSynchronization&gt; synchs = synchronizations.get();
    if (synchs == null) &#123;
        throw new IllegalStateException(&quot;Transaction synchronization is not active&quot;);
    &#125;
    synchs.add(synchronization);
&#125;
</code></pre>
<h3 id="3、获取事务同步列表"><a href="#3、获取事务同步列表" class="headerlink" title="3、获取事务同步列表"></a>3、获取事务同步列表</h3><pre><code class="java">public static List&lt;TransactionSynchronization&gt; getSynchronizations() throws IllegalStateException &#123;
    Set&lt;TransactionSynchronization&gt; synchs = synchronizations.get();
    if (synchs == null) &#123;
        throw new IllegalStateException(&quot;Transaction synchronization is not active&quot;);
    &#125;
    // Return unmodifiable snapshot, to avoid ConcurrentModificationExceptions
    // while iterating and invoking synchronization callbacks that in turn
    // might register further synchronizations.
    if (synchs.isEmpty()) &#123;
        return Collections.emptyList();
    &#125;
    else &#123;
        // Sort lazily here, not in registerSynchronization.
        List&lt;TransactionSynchronization&gt; sortedSynchs = new ArrayList&lt;&gt;(synchs);
        OrderComparator.sort(sortedSynchs);
        return Collections.unmodifiableList(sortedSynchs);
    &#125;
&#125;
</code></pre>
<h3 id="4、判断当前事务是否为活跃"><a href="#4、判断当前事务是否为活跃" class="headerlink" title="4、判断当前事务是否为活跃"></a>4、判断当前事务是否为活跃</h3><pre><code class="java">public static boolean isSynchronizationActive() &#123;
    return (synchronizations.get() != null);
&#125;
</code></pre>
<h2 id="4、currentTransactionReadOnly-与-currentTransactionIsolationLevel"><a href="#4、currentTransactionReadOnly-与-currentTransactionIsolationLevel" class="headerlink" title="4、currentTransactionReadOnly 与 currentTransactionIsolationLevel"></a>4、currentTransactionReadOnly 与 currentTransactionIsolationLevel</h2><p>这两个属性分别记录当前线程事务是否只读状态和其隔离级别</p>
<pre><code class="java">public static void setCurrentTransactionReadOnly(boolean readOnly) &#123;
    currentTransactionReadOnly.set(readOnly ? Boolean.TRUE : null);
&#125;
</code></pre>
<pre><code class="java">public static void setCurrentTransactionIsolationLevel(@Nullable Integer isolationLevel) &#123;
    currentTransactionIsolationLevel.set(isolationLevel);
&#125;
</code></pre>
<h2 id="5、actualTransactionActive"><a href="#5、actualTransactionActive" class="headerlink" title="5、actualTransactionActive"></a>5、actualTransactionActive</h2><p><code>actualTransactionActive</code>用于记录当前线程是否有实际活动的事务，</p>
<pre><code class="java">public static void setActualTransactionActive(boolean active) &#123;
    actualTransactionActive.set(active ? Boolean.TRUE : null);
&#125;
</code></pre>
<p>与<code>isSynchronizationActive</code>相比，线程可能存在活跃的事务，但如果当前线程的事务被挂起，那么就不是实际活跃的事务了，所以对于被挂起的线程调用<code>isSynchronizationActive</code>返回<code>true</code>，调用<code>isActualTransactionActive</code>则返回<code>false</code></p>
<pre><code class="java">public static boolean isActualTransactionActive() &#123;
    return (actualTransactionActive.get() != null);
&#125;
</code></pre>
<h2 id="6、清除当前线程事务同步数据"><a href="#6、清除当前线程事务同步数据" class="headerlink" title="6、清除当前线程事务同步数据"></a>6、清除当前线程事务同步数据</h2><p>最后，事务提交后，<code>TransactionSynchronizationManager</code>提供了清除当前线程事务同步数据的方法。</p>
<pre><code class="java">public static void clear() &#123;
    synchronizations.remove();
    currentTransactionName.remove();
    currentTransactionReadOnly.remove();
    currentTransactionIsolationLevel.remove();
    actualTransactionActive.remove();
&#125;
</code></pre>
<h1 id="七、事务创建的流程分析"><a href="#七、事务创建的流程分析" class="headerlink" title="七、事务创建的流程分析"></a>七、事务创建的流程分析</h1><blockquote>
<p>作者：<a target="_blank" rel="noopener" href="https://blog.csdn.net/CSDN_WYL2016">码拉松</a>、来源：<a target="_blank" rel="noopener" href="https://blog.csdn.net/CSDN_WYL2016/article/details/122445678">https://blog.csdn.net/CSDN_WYL2016/article/details/122445678</a></p>
</blockquote>
<p>Spring中定义事务核心流程最关键的类就是<code>AbstractPlatformTransactionManager</code>，这是一个抽象类，通过模板方法的方式定义了Spring的标准事务处理流程，是其他具体事务管理平台实现的基础。本次主要针对事务创建的流程做分析。</p>
<h2 id="1、getTransaction"><a href="#1、getTransaction" class="headerlink" title="1、getTransaction"></a>1、getTransaction</h2><p><code>getTransaction</code>方法中，定义获取一个事务时的主干流程，包含获取事务、开启事务、设置事务的隔离级别、状态、只读属性、以及前面文章中提到过的<code>TransactionSynchronizationManager</code>类中六个<code>ThreadLocal</code>变量的设置。</p>
<pre><code class="java">@Override
public final TransactionStatus getTransaction(@Nullable TransactionDefinition definition)
    throws TransactionException &#123;
    // Use defaults if no transaction definition given.
    TransactionDefinition def = (definition != null ? definition : TransactionDefinition.withDefaults());
    // 获取事务，这是一个抽象方法，交由子类去实现，获取具体的事务对象，比如DataSourceTransactionObject、JpaTransactionObject等
    Object transaction = doGetTransaction();
    boolean debugEnabled = logger.isDebugEnabled();
    // 判断当前线程是否已经存在事务，如果存在则会根据事务传播属性来处理
    if (isExistingTransaction(transaction)) &#123;
        // Existing transaction found -&gt; check propagation behavior to find out how to behave.
        return handleExistingTransaction(def, transaction, debugEnabled);
    &#125;
    // Check definition settings for new transaction.
    if (def.getTimeout() &lt; TransactionDefinition.TIMEOUT_DEFAULT) &#123;
        throw new InvalidTimeoutException(&quot;Invalid transaction timeout&quot;, def.getTimeout());
    &#125;
    // 下面这些逻辑，可以看到针对一些特定的传播属性是如何处理的，比如对于PROPAGATION_MANDATORY，则当前不存在事务就抛出异常
    // No existing transaction found -&gt; check propagation behavior to find out how to proceed.
    if (def.getPropagationBehavior() == TransactionDefinition.PROPAGATION_MANDATORY) &#123;
        throw new IllegalTransactionStateException(
            &quot;No existing transaction found for transaction marked with propagation &#39;mandatory&#39;&quot;);
    &#125;
    else if (def.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRED ||
             def.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW ||
             def.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) &#123;
        SuspendedResourcesHolder suspendedResources = suspend(null);
        if (debugEnabled) &#123;
            logger.debug(&quot;Creating new transaction with name [&quot; + def.getName() + &quot;]: &quot; + def);
        &#125;
        try &#123;
            // 开始一个新的事务
            return startTransaction(def, transaction, debugEnabled, suspendedResources);
        &#125;
        catch (RuntimeException | Error ex) &#123;
            resume(null, suspendedResources);
            throw ex;
        &#125;
    &#125;
    else &#123;
        // Create &quot;empty&quot; transaction: no actual transaction, but potentially synchronization.
        if (def.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT &amp;&amp; logger.isWarnEnabled()) &#123;
            logger.warn(&quot;Custom isolation level specified but no actual transaction initiated; &quot; +
                        &quot;isolation level will effectively be ignored: &quot; + def);
        &#125;
        boolean newSynchronization = (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS);
        // startTransaction方法中也会调用，主要就是保存TransactionSynchronizationManager的ThreadLocal属性
        return prepareTransactionStatus(def, null, true, newSynchronization, debugEnabled, null);
    &#125;
&#125;
</code></pre>
<h2 id="2、startTransaction"><a href="#2、startTransaction" class="headerlink" title="2、startTransaction"></a>2、startTransaction</h2><p>开启一个新的事务，核心业务逻辑也是由子类实现</p>
<pre><code class="java">private TransactionStatus startTransaction(TransactionDefinition definition, 
                                           Object transaction,
                                           boolean debugEnabled, 
                                           @Nullable SuspendedResourcesHolder suspendedResources) &#123;
    boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER);
    DefaultTransactionStatus status = newTransactionStatus(
            definition, transaction, true, newSynchronization, debugEnabled, suspendedResources);
    // 抽象方法，主要负责事务的创建工作，具体交由子类实现，比如DataSourceTransactionManager、JpaTransactionManager
    doBegin(transaction, definition);
    prepareSynchronization(status, definition);
    return status;
&#125;
</code></pre>
<h2 id="3、prepareSynchronization"><a href="#3、prepareSynchronization" class="headerlink" title="3、prepareSynchronization"></a>3、prepareSynchronization</h2><pre><code class="java">protected void prepareSynchronization(DefaultTransactionStatus status, TransactionDefinition definition) &#123;
    if (status.isNewSynchronization()) &#123;
        TransactionSynchronizationManager.setActualTransactionActive(status.hasTransaction());
        TransactionSynchronizationManager.setCurrentTransactionIsolationLevel(
                definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT ?
                    definition.getIsolationLevel() : null);
        TransactionSynchronizationManager.setCurrentTransactionReadOnly(definition.isReadOnly());
        TransactionSynchronizationManager.setCurrentTransactionName(definition.getName());
        TransactionSynchronizationManager.initSynchronization();
    &#125;
&#125;
</code></pre>
<h2 id="4、TransactionStatus"><a href="#4、TransactionStatus" class="headerlink" title="4、TransactionStatus"></a>4、TransactionStatus</h2><p>最后<code>getTransaction</code>方法就是返回一个<code>TransactionStatus</code>对象，<code>TransactionStatus</code>是一个接口，具体的实现类比如有：<code>DefaultTransactionStatus</code>，它主要用来保存事务处理时需要的基本信息，比如前面提到的事务对象。</p>
<h2 id="5、handleExistingTransaction"><a href="#5、handleExistingTransaction" class="headerlink" title="5、handleExistingTransaction"></a>5、handleExistingTransaction</h2><p><code>handleExistingTransaction</code>方法可以帮你搞清在不同的事务传播属性下，是如何进行处理的</p>
<pre><code class="java">private TransactionStatus handleExistingTransaction(
        TransactionDefinition definition, Object transaction, boolean debugEnabled)
        throws TransactionException &#123;
    if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NEVER) &#123;
        throw new IllegalTransactionStateException(
                &quot;Existing transaction found for transaction marked with propagation &#39;never&#39;&quot;);
    &#125;
    if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NOT_SUPPORTED) &#123;
        if (debugEnabled) &#123;
            logger.debug(&quot;Suspending current transaction&quot;);
        &#125;
        Object suspendedResources = suspend(transaction);
        boolean newSynchronization = (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS);
        return prepareTransactionStatus(
                definition, null, false, newSynchronization, debugEnabled, suspendedResources);
    &#125;
    if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW) &#123;
        if (debugEnabled) &#123;
            logger.debug(&quot;Suspending current transaction, creating new transaction with name [&quot; +
                    definition.getName() + &quot;]&quot;);
        &#125;
        SuspendedResourcesHolder suspendedResources = suspend(transaction);
        try &#123;
            return startTransaction(definition, transaction, debugEnabled, suspendedResources);
        &#125;
        catch (RuntimeException | Error beginEx) &#123;
            resumeAfterBeginException(transaction, suspendedResources, beginEx);
            throw beginEx;
        &#125;
    &#125;
    if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) &#123;
        if (!isNestedTransactionAllowed()) &#123;
            throw new NestedTransactionNotSupportedException(
                    &quot;Transaction manager does not allow nested transactions by default - &quot; +
                    &quot;specify &#39;nestedTransactionAllowed&#39; property with value &#39;true&#39;&quot;);
        &#125;
        if (debugEnabled) &#123;
            logger.debug(&quot;Creating nested transaction with name [&quot; + definition.getName() + &quot;]&quot;);
        &#125;
        if (useSavepointForNestedTransaction()) &#123;
            // Create savepoint within existing Spring-managed transaction,
            // through the SavepointManager API implemented by TransactionStatus.
            // Usually uses JDBC 3.0 savepoints. Never activates Spring synchronization.
            DefaultTransactionStatus status =
                    prepareTransactionStatus(definition, transaction, false, false, debugEnabled, null);
            status.createAndHoldSavepoint();
            return status;
        &#125;
        else &#123;
            // Nested transaction through nested begin and commit/rollback calls.
            // Usually only for JTA: Spring synchronization might get activated here
            // in case of a pre-existing JTA transaction.
            return startTransaction(definition, transaction, debugEnabled, null);
        &#125;
    &#125;
    // Assumably PROPAGATION_SUPPORTS or PROPAGATION_REQUIRED.
    if (debugEnabled) &#123;
        logger.debug(&quot;Participating in existing transaction&quot;);
    &#125;
    if (isValidateExistingTransaction()) &#123;
        if (definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT) &#123;
            Integer currentIsolationLevel = TransactionSynchronizationManager.getCurrentTransactionIsolationLevel();
            if (currentIsolationLevel == null || currentIsolationLevel != definition.getIsolationLevel()) &#123;
                Constants isoConstants = DefaultTransactionDefinition.constants;
                throw new IllegalTransactionStateException(&quot;Participating transaction with definition [&quot; +
                        definition + &quot;] specifies isolation level which is incompatible with existing transaction: &quot; +
                        (currentIsolationLevel != null ?
                                isoConstants.toCode(currentIsolationLevel, DefaultTransactionDefinition.PREFIX_ISOLATION) :
                                &quot;(unknown)&quot;));
            &#125;
        &#125;
        if (!definition.isReadOnly()) &#123;
            if (TransactionSynchronizationManager.isCurrentTransactionReadOnly()) &#123;
                throw new IllegalTransactionStateException(&quot;Participating transaction with definition [&quot; +
                        definition + &quot;] is not marked as read-only but existing transaction is&quot;);
            &#125;
        &#125;
    &#125;
    boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER);
    return prepareTransactionStatus(definition, transaction, false, newSynchronization, debugEnabled, null);
&#125;
</code></pre>
<h2 id="6、suspend"><a href="#6、suspend" class="headerlink" title="6、suspend"></a>6、suspend</h2><p>挂起一个事务，实际上具体的挂起处理还是由具体的子类去完成，返回值<code>SuspendedResourcesHolder</code>也会作为<code>DefaultTransactionStatus</code>类的一个属性。</p>
<pre><code class="java">@Nullable
protected final SuspendedResourcesHolder suspend(@Nullable Object transaction) throws TransactionException &#123;
    if (TransactionSynchronizationManager.isSynchronizationActive()) &#123;
        List&lt;TransactionSynchronization&gt; suspendedSynchronizations = doSuspendSynchronization();
        try &#123;
            Object suspendedResources = null;
            if (transaction != null) &#123;
                // 抽象方法，具体的挂起处理由子类实现
                suspendedResources = doSuspend(transaction);
            &#125;
            // 重置ThreadLocal值
            String name = TransactionSynchronizationManager.getCurrentTransactionName();
            TransactionSynchronizationManager.setCurrentTransactionName(null);
            boolean readOnly = TransactionSynchronizationManager.isCurrentTransactionReadOnly();
            TransactionSynchronizationManager.setCurrentTransactionReadOnly(false);
            Integer isolationLevel = TransactionSynchronizationManager.getCurrentTransactionIsolationLevel();
            TransactionSynchronizationManager.setCurrentTransactionIsolationLevel(null);
            boolean wasActive = TransactionSynchronizationManager.isActualTransactionActive();
            TransactionSynchronizationManager.setActualTransactionActive(false);
            return new SuspendedResourcesHolder(
                suspendedResources, suspendedSynchronizations, name, readOnly, isolationLevel, wasActive);
        &#125;
        catch (RuntimeException | Error ex) &#123;
            // doSuspend failed - original transaction is still active...
            doResumeSynchronization(suspendedSynchronizations);
            throw ex;
        &#125;
    &#125;
    else if (transaction != null) &#123;
        // Transaction active but no synchronization active.
        Object suspendedResources = doSuspend(transaction);
        return new SuspendedResourcesHolder(suspendedResources);
    &#125;
    else &#123;
        // Neither transaction nor synchronization active.
        return null;
    &#125;
&#125;
</code></pre>
<h1 id="八、事务提交、回滚的流程分析"><a href="#八、事务提交、回滚的流程分析" class="headerlink" title="八、事务提交、回滚的流程分析"></a>八、事务提交、回滚的流程分析</h1><blockquote>
<p>作者：<a target="_blank" rel="noopener" href="https://blog.csdn.net/CSDN_WYL2016">码拉松</a>、来源：<a target="_blank" rel="noopener" href="https://blog.csdn.net/CSDN_WYL2016/article/details/122587692">https://blog.csdn.net/CSDN_WYL2016/article/details/122587692</a></p>
</blockquote>
<p>Spring中定义事务核心流程最关键的类就是<code>AbstractPlatformTransactionManager</code>，这是一个抽象类，通过模板方法的方式定义了Spring的标准事务处理流程，是其他具体事务管理平台实现的基础。本次主要针对事务提交、回滚的流程做分析。</p>
<h2 id="1、commit"><a href="#1、commit" class="headerlink" title="1、commit"></a>1、commit</h2><p><code>commit</code>方法由<code>AbstractPlatformTransactionManager</code>提供，是事务的提交的入口方法，只是封装一层，核心逻辑还是在<code>processCommit</code>和<code>processRollback</code>方法中。</p>
<pre><code class="java">@Override
public final void commit(TransactionStatus status) throws TransactionException &#123;
    // 判断事务是否已经完成
    if (status.isCompleted()) &#123;
        throw new IllegalTransactionStateException(
                &quot;Transaction is already completed - do not call commit or rollback more than once per transaction&quot;);
    &#125;
    DefaultTransactionStatus defStatus = (DefaultTransactionStatus) status;
    if (defStatus.isLocalRollbackOnly()) &#123;
        if (defStatus.isDebug()) &#123;
            logger.debug(&quot;Transactional code has requested rollback&quot;);
        &#125;
        processRollback(defStatus, false);
        return;
    &#125;
    if (!shouldCommitOnGlobalRollbackOnly() &amp;&amp; defStatus.isGlobalRollbackOnly()) &#123;
        if (defStatus.isDebug()) &#123;
            logger.debug(&quot;Global transaction is marked as rollback-only but transactional code requested commit&quot;);
        &#125;
        processRollback(defStatus, true);
        return;
    &#125;
    processCommit(defStatus);
&#125;
</code></pre>
<h2 id="2、processCommit"><a href="#2、processCommit" class="headerlink" title="2、processCommit"></a>2、processCommit</h2><p>该方法执行了很多扩展方法，以及一些与事务传播类型有关的逻辑处理，最终的事务处理又由<code>doCommit</code>方法来实现。</p>
<pre><code class="java">private void processCommit(DefaultTransactionStatus status) throws TransactionException &#123;
    try &#123;
        boolean beforeCompletionInvoked = false;
        try &#123;
            boolean unexpectedRollback = false;
            // 这是一个空方法，主要是交由具体的事务处理器来实现
            prepareForCommit(status);
            // 下面两个方法都是Spring留出的扩展点，通过TransactionSynchronizationManager提供的registerSynchronization方法，
            // 可以注册TransactionSynchronization实例，从而调用TransactionSynchronization提供的相关方法
            triggerBeforeCommit(status);
            triggerBeforeCompletion(status);
            beforeCompletionInvoked = true;
            // 嵌套事务的处理分支
            if (status.hasSavepoint()) &#123;
                if (status.isDebug()) &#123;
                    logger.debug(&quot;Releasing transaction savepoint&quot;);
                &#125;
                unexpectedRollback = status.isGlobalRollbackOnly();
                status.releaseHeldSavepoint();
            &#125;
            // 大多数都是一个新的事务
            else if (status.isNewTransaction()) &#123;
                if (status.isDebug()) &#123;
                    logger.debug(&quot;Initiating transaction commit&quot;);
                &#125;
                unexpectedRollback = status.isGlobalRollbackOnly();
                // 同样的具体交给事务处理器来完成【重点】
                doCommit(status);
            &#125;
            else if (isFailEarlyOnGlobalRollbackOnly()) &#123;
                unexpectedRollback = status.isGlobalRollbackOnly();
            &#125;
            // Throw UnexpectedRollbackException if we have a global rollback-only
            // marker but still didn&#39;t get a corresponding exception from commit.
            if (unexpectedRollback) &#123;
                throw new UnexpectedRollbackException(
                    &quot;Transaction silently rolled back because it has been marked as rollback-only&quot;);
            &#125;
        &#125;
        catch (UnexpectedRollbackException ex) &#123;
            // can only be caused by doCommit
            triggerAfterCompletion(status, TransactionSynchronization.STATUS_ROLLED_BACK);
            throw ex;
        &#125;
        catch (TransactionException ex) &#123;
            // can only be caused by doCommit
            if (isRollbackOnCommitFailure()) &#123;
                doRollbackOnCommitException(status, ex);
            &#125;
            else &#123;
                triggerAfterCompletion(status, TransactionSynchronization.STATUS_UNKNOWN);
            &#125;
            throw ex;
        &#125;
        catch (RuntimeException | Error ex) &#123;
            if (!beforeCompletionInvoked) &#123;
                triggerBeforeCompletion(status);
            &#125;
            doRollbackOnCommitException(status, ex);
            throw ex;
        &#125;
        // Trigger afterCommit callbacks, with an exception thrown there
        // propagated to callers but the transaction still considered as committed.
        try &#123;
            // triggerAfterCommit和triggerAfterCompletion，
            // 和前面的triggerBeforeCommit、triggerBeforeCompletion两个方法一样，都是Spring留下的扩展点
            triggerAfterCommit(status);
        &#125;
        finally &#123;
            triggerAfterCompletion(status, TransactionSynchronization.STATUS_COMMITTED);
        &#125;
    &#125;
    finally &#123;
        cleanupAfterCompletion(status);
    &#125;
&#125;
</code></pre>
<h2 id="3、doCommit"><a href="#3、doCommit" class="headerlink" title="3、doCommit"></a>3、doCommit</h2><p>方法执行到了这一步，实际上就是获取<code>Connection</code>，然后调用<code>commit</code>即可，这是<code>JDBC</code>的使用标准。【<code>DataSourceTransactionManager#doCommit()</code>】</p>
<pre><code class="java">@Override
protected void doCommit(DefaultTransactionStatus status) &#123;
    DataSourceTransactionObject txObject = (DataSourceTransactionObject) status.getTransaction();
    Connection con = txObject.getConnectionHolder().getConnection();
    if (status.isDebug()) &#123;
        logger.debug(&quot;Committing JDBC transaction on Connection [&quot; + con + &quot;]&quot;);
    &#125;
    try &#123;
        con.commit();
    &#125;
    catch (SQLException ex) &#123;
        throw translateException(&quot;JDBC commit&quot;, ex);
    &#125;
&#125;
</code></pre>
<h2 id="4、processRollback"><a href="#4、processRollback" class="headerlink" title="4、processRollback"></a>4、processRollback</h2><p>接下来是回滚，与事务的提交处理其实差不多，可以自行阅读。</p>
<pre><code class="java">private void processRollback(DefaultTransactionStatus status, boolean unexpected) &#123;
    try &#123;
        boolean unexpectedRollback = unexpected;
        try &#123;
            triggerBeforeCompletion(status);
            if (status.hasSavepoint()) &#123;
                if (status.isDebug()) &#123;
                    logger.debug(&quot;Rolling back transaction to savepoint&quot;);
                &#125;
                status.rollbackToHeldSavepoint();
            &#125;
            else if (status.isNewTransaction()) &#123;
                if (status.isDebug()) &#123;
                    logger.debug(&quot;Initiating transaction rollback&quot;);
                &#125;
                doRollback(status);
            &#125;
            else &#123;
                // Participating in larger transaction
                if (status.hasTransaction()) &#123;
                    if (status.isLocalRollbackOnly() || isGlobalRollbackOnParticipationFailure()) &#123;
                        if (status.isDebug()) &#123;
                            logger.debug(
                                &quot;Participating transaction failed - marking existing transaction as rollback-only&quot;);
                        &#125;
                        doSetRollbackOnly(status);
                    &#125;
                    else &#123;
                        if (status.isDebug()) &#123;
                            logger.debug(
                                &quot;Participating transaction failed - letting transaction originator decide on rollback&quot;);
                        &#125;
                    &#125;
                &#125;
                else &#123;
                    logger.debug(&quot;Should roll back transaction but cannot - no transaction available&quot;);
                &#125;
                // Unexpected rollback only matters here if we&#39;re asked to fail early
                if (!isFailEarlyOnGlobalRollbackOnly()) &#123;
                    unexpectedRollback = false;
                &#125;
            &#125;
        &#125;
        catch (RuntimeException | Error ex) &#123;
            triggerAfterCompletion(status, TransactionSynchronization.STATUS_UNKNOWN);
            throw ex;
        &#125;
        triggerAfterCompletion(status, TransactionSynchronization.STATUS_ROLLED_BACK);
        // Raise UnexpectedRollbackException if we had a global rollback-only marker
        if (unexpectedRollback) &#123;
            throw new UnexpectedRollbackException(
                &quot;Transaction rolled back because it has been marked as rollback-only&quot;);
        &#125;
    &#125;
    finally &#123;
        cleanupAfterCompletion(status);
    &#125;
&#125;
</code></pre>
<h2 id="5、事务提交与回滚总结"><a href="#5、事务提交与回滚总结" class="headerlink" title="5、事务提交与回滚总结"></a>5、事务提交与回滚总结</h2><p>processRollback 和 processCommit 两个方法的主线逻辑还是比较容易理解的，但是各种状态的处理还是比较复杂的，主要为了处理那些事务传播性的问题，主要由 TransactionStatus 的实现类来控制。</p>
<h1 id="九、afterCommit-实现分析"><a href="#九、afterCommit-实现分析" class="headerlink" title="九、afterCommit 实现分析"></a>九、afterCommit 实现分析</h1><blockquote>
<p>作者：<a target="_blank" rel="noopener" href="https://blog.csdn.net/CSDN_WYL2016">码拉松</a>、来源：<a target="_blank" rel="noopener" href="https://blog.csdn.net/CSDN_WYL2016/article/details/122634565">https://blog.csdn.net/CSDN_WYL2016/article/details/122634565</a></p>
</blockquote>
<p><code>beforeCommit、beforeCompletion、afterCommit、afterCompletion</code>是Spring为我们在事务提交前、后提供的扩展点，业务在实际使用时可以通过这几个方法在事务提交前、后实现一些额外的逻辑控制，尤其是有些需要在事务提交后才能处理的逻辑，利用<code>afterCommit</code>或者<code>afterCompletion</code>可以非常方便的实现，本文就来简单分析一下Spring是通过什么样的方式来预埋这几个方法的。</p>
<h2 id="1、TransactionSynchronization"><a href="#1、TransactionSynchronization" class="headerlink" title="1、TransactionSynchronization"></a>1、TransactionSynchronization</h2><p>首先这几个方法是定义在<code>TransactionSynchronization</code>接口中的，并且定义的都是<code>default</code>方法，默认没有任何处理。</p>
<pre><code class="java">public interface TransactionSynchronization extends Ordered, Flushable &#123;
    default void beforeCommit(boolean readOnly) &#123;
    &#125;

    default void beforeCompletion() &#123;
    &#125;

    default void afterCommit() &#123;
    &#125;

    default void afterCompletion(int status) &#123;
    &#125;
&#125;
</code></pre>
<h2 id="2、afterCommit-方法分析"><a href="#2、afterCommit-方法分析" class="headerlink" title="2、afterCommit 方法分析"></a>2、afterCommit 方法分析</h2><p>这里以<code>afterCommit</code>方法为例，我们来简单分析一下实现逻辑，其他的3个实现方法大体一致。就不一一讲解分析了。</p>
<h3 id="1、找到方法调用的入口"><a href="#1、找到方法调用的入口" class="headerlink" title="1、找到方法调用的入口"></a>1、找到方法调用的入口</h3><h4 id="1）TransactionTemplate"><a href="#1）TransactionTemplate" class="headerlink" title="1）TransactionTemplate"></a>1）TransactionTemplate</h4><p>如果你使用的是编程式事务，那么<code>TransactionTemplate</code>类的<code>execute</code>方法则是整个事务执行的入口，由于我们只分析<code>afterCommit</code>的实现逻辑，所以我们直接看相关方法即可，在<code>exceute</code>中，就是<code>transactionManager.commit</code>方法。</p>
<pre><code class="java">public &lt;T&gt; T execute(TransactionCallback&lt;T&gt; action) throws TransactionException &#123;
    Assert.state(this.transactionManager != null, &quot;No PlatformTransactionManager set&quot;);
    if (this.transactionManager instanceof CallbackPreferringPlatformTransactionManager) &#123;
        return ((CallbackPreferringPlatformTransactionManager) this.transactionManager).execute(this, action);
    &#125;
    else &#123;
        TransactionStatus status = this.transactionManager.getTransaction(this);
        T result;
        try &#123;
            result = action.doInTransaction(status);
        &#125;
        catch (RuntimeException | Error ex) &#123;
            // Transactional code threw application exception -&gt; rollback
            rollbackOnException(status, ex);
            throw ex;
        &#125;
        catch (Throwable ex) &#123;
            // Transactional code threw unexpected exception -&gt; rollback
            rollbackOnException(status, ex);
            throw new UndeclaredThrowableException(ex, &quot;TransactionCallback threw undeclared checked exception&quot;);
        &#125;
        // 当前面事务处理完成之后，直接调用事务提交的方法。
        this.transactionManager.commit(status);
        return result;
    &#125;
&#125;
</code></pre>
<h4 id="2）AbstractPlatformTransactionManager"><a href="#2）AbstractPlatformTransactionManager" class="headerlink" title="2）AbstractPlatformTransactionManager"></a>2）AbstractPlatformTransactionManager</h4><p>如果是使用声明式事务，那么入口就是<code>commit</code>方法。</p>
<p>事务提交的方法由<code>AbstractPlatformTransactionManager</code>控制，逻辑也很明显，<code>processCommit</code>是真正的执行方法。</p>
<pre><code class="java">@Override
public final void commit(TransactionStatus status) throws TransactionException &#123;
    if (status.isCompleted()) &#123;
        throw new IllegalTransactionStateException(
            &quot;Transaction is already completed - do not call commit or rollback more than once per transaction&quot;);
    &#125;
    DefaultTransactionStatus defStatus = (DefaultTransactionStatus) status;
    if (defStatus.isLocalRollbackOnly()) &#123;
        if (defStatus.isDebug()) &#123;
            logger.debug(&quot;Transactional code has requested rollback&quot;);
        &#125;
        processRollback(defStatus, false);
        return;
    &#125;
    if (!shouldCommitOnGlobalRollbackOnly() &amp;&amp; defStatus.isGlobalRollbackOnly()) &#123;
        if (defStatus.isDebug()) &#123;
            logger.debug(&quot;Global transaction is marked as rollback-only but transactional code requested commit&quot;);
        &#125;
        processRollback(defStatus, true);
        return;
    &#125;
    processCommit(defStatus);
&#125;

// processCommit方法定义了流程处理的主体结构，然后通过doCommit方法，让具体的事务管理器去实现。
private void processCommit(DefaultTransactionStatus status) throws TransactionException &#123;
    try &#123;
        boolean beforeCompletionInvoked = false;
        try &#123;
            boolean unexpectedRollback = false;
            prepareForCommit(status);
            // 这两步就对应这beforeCommit、beforeCompletion的逻辑
            triggerBeforeCommit(status);
            triggerBeforeCompletion(status);
            beforeCompletionInvoked = true;
            if (status.hasSavepoint()) &#123;
                if (status.isDebug()) &#123;
                    logger.debug(&quot;Releasing transaction savepoint&quot;);
                &#125;
                unexpectedRollback = status.isGlobalRollbackOnly();
                status.releaseHeldSavepoint();
            &#125;
            else if (status.isNewTransaction()) &#123;
                if (status.isDebug()) &#123;
                    logger.debug(&quot;Initiating transaction commit&quot;);
                &#125;
                unexpectedRollback = status.isGlobalRollbackOnly();
                // 真正执行事务提交的方法，交给了具体的事务处理器去执行
                doCommit(status);
            &#125;
            else if (isFailEarlyOnGlobalRollbackOnly()) &#123;
                unexpectedRollback = status.isGlobalRollbackOnly();
            &#125;
            // Throw UnexpectedRollbackException if we have a global rollback-only
            // marker but still didn&#39;t get a corresponding exception from commit.
            if (unexpectedRollback) &#123;
                throw new UnexpectedRollbackException(
                    &quot;Transaction silently rolled back because it has been marked as rollback-only&quot;);
            &#125;
        &#125;
        catch (UnexpectedRollbackException ex) &#123;
            // can only be caused by doCommit
            triggerAfterCompletion(status, TransactionSynchronization.STATUS_ROLLED_BACK);
            throw ex;
        &#125;
        catch (TransactionException ex) &#123;
            // can only be caused by doCommit
            if (isRollbackOnCommitFailure()) &#123;
                doRollbackOnCommitException(status, ex);
            &#125;
            else &#123;
                triggerAfterCompletion(status, TransactionSynchronization.STATUS_UNKNOWN);
            &#125;
            throw ex;
        &#125;
        catch (RuntimeException | Error ex) &#123;
            if (!beforeCompletionInvoked) &#123;
                triggerBeforeCompletion(status);
            &#125;
            doRollbackOnCommitException(status, ex);
            throw ex;
        &#125;
        // Trigger afterCommit callbacks, with an exception thrown there
        // propagated to callers but the transaction still considered as committed.
        try &#123;
            // 当事务提交成功之后，调用triggerAfterCommit方法，afterCommit逻辑入口也在这
            triggerAfterCommit(status);
        &#125;
        finally &#123;
            // afterCompletion的入口。
            triggerAfterCompletion(status, TransactionSynchronization.STATUS_COMMITTED);
        &#125;
    &#125;
    finally &#123;
        cleanupAfterCompletion(status);
    &#125;
&#125;

// 调用TransactionSynchronizationUtils类的triggerAfterCommit方法
private void triggerAfterCommit(DefaultTransactionStatus status) &#123;
    if (status.isNewSynchronization()) &#123;
        TransactionSynchronizationUtils.triggerAfterCommit();
    &#125;
&#125;
</code></pre>
<h4 id="3）TransactionSynchronizationUtils"><a href="#3）TransactionSynchronizationUtils" class="headerlink" title="3）TransactionSynchronizationUtils"></a>3）TransactionSynchronizationUtils</h4><p>到了<code>TransactionSynchronizationUtils</code>之后，处理流程就很简单了，获取<code>TransactionSynchronization</code>集合，挨个遍历调用即可。</p>
<pre><code class="java">public static void triggerAfterCommit() &#123;
    invokeAfterCommit(TransactionSynchronizationManager.getSynchronizations());
&#125;

public static void invokeAfterCommit(@Nullable List&lt;TransactionSynchronization&gt; synchronizations) &#123;
    if (synchronizations != null) &#123;
        for (TransactionSynchronization synchronization : synchronizations) &#123;
            // 最终调用到afterCommit方法
            synchronization.afterCommit();
        &#125;
    &#125;
&#125;
</code></pre>
<p>通过以上的流程分析可以看出，Spring就是简单的把执行<code>afterCommit</code>方法放在事务提交后调用。</p>
<h3 id="2、获取TransactionSynchronization集合"><a href="#2、获取TransactionSynchronization集合" class="headerlink" title="2、获取TransactionSynchronization集合"></a>2、获取TransactionSynchronization集合</h3><p>根据前面的流程分析可能，<code>synchronizations</code>集合是通过调用<code>TransactionSynchronizationManager.getSynchronizations()</code>方法获取的。</p>
<pre><code class="java">public static void triggerAfterCommit() &#123;
    invokeAfterCommit(TransactionSynchronizationManager.getSynchronizations());
&#125;
</code></pre>
<h4 id="1）getSynchronizations"><a href="#1）getSynchronizations" class="headerlink" title="1）getSynchronizations"></a>1）getSynchronizations</h4><pre><code class="java">private static final ThreadLocal&lt;Set&lt;TransactionSynchronization&gt;&gt; synchronizations =
    new NamedThreadLocal&lt;&gt;(&quot;Transaction synchronizations&quot;);

public static List&lt;TransactionSynchronization&gt; getSynchronizations() throws IllegalStateException &#123;
    // synchronizations是TransactionSynchronizationManager类中定义的一个ThreadLocal全局变量
    Set&lt;TransactionSynchronization&gt; synchs = synchronizations.get();
    // 如果为null，则抛出异常
    if (synchs == null) &#123;
        throw new IllegalStateException(&quot;Transaction synchronization is not active&quot;);
    &#125;
    // Return unmodifiable snapshot, to avoid ConcurrentModificationExceptions
    // while iterating and invoking synchronization callbacks that in turn
    // might register further synchronizations.
    // 为空，直接返回
    if (synchs.isEmpty()) &#123;
        return Collections.emptyList();
    &#125;
    else &#123;
        // Sort lazily here, not in registerSynchronization.
        // 排序后，返回集合快照
        List&lt;TransactionSynchronization&gt; sortedSynchs = new ArrayList&lt;&gt;(synchs);
        OrderComparator.sort(sortedSynchs);
        return Collections.unmodifiableList(sortedSynchs);
    &#125;
&#125;
</code></pre>
<h3 id="3、synchronizations-添加元素"><a href="#3、synchronizations-添加元素" class="headerlink" title="3、synchronizations 添加元素"></a>3、synchronizations 添加元素</h3><p>很明显，现在问题又变成了<code>synchronizations</code>这个<code>ThreadLocal</code>全局变量是何时被赋值的？</p>
<p>首先在事务开始前，就会通过调用<code>initSynchronization</code>方法，先对其进行初始化，这个方法入口也很容易找到，就在<code>TransactionTemplate</code>的<code>execute</code>方法中，通过调用<code>this.transactionManager.getTransaction(this)</code>方法，完成初始化。</p>
<pre><code class="java">public static void initSynchronization() throws IllegalStateException &#123;
    if (isSynchronizationActive()) &#123;
        throw new IllegalStateException(&quot;Cannot activate transaction synchronization - already active&quot;);
    &#125;
    synchronizations.set(new LinkedHashSet&lt;&gt;());
&#125;
</code></pre>
<p><code>TransactionSynchronizationManager</code>还提供了<code>registerSynchronization</code>方法可以对其进行添加元素。</p>
<pre><code class="java">public static void registerSynchronization(TransactionSynchronization synchronization)
    throws IllegalStateException &#123;
    Assert.notNull(synchronization, &quot;TransactionSynchronization must not be null&quot;);
    Set&lt;TransactionSynchronization&gt; synchs = synchronizations.get();
    if (synchs == null) &#123;
        throw new IllegalStateException(&quot;Transaction synchronization is not active&quot;);
    &#125;
    synchs.add(synchronization);
&#125;
</code></pre>
<h3 id="4、实际使用方式"><a href="#4、实际使用方式" class="headerlink" title="4、实际使用方式"></a>4、实际使用方式</h3><p>所以，一般我们自定义的方法都是这样实现的，通过匿名类的方式，直接添加一个<code>TransactionSynchronization</code>类型的元素到<code>synchronizations</code>集合中</p>
<pre><code class="java">TransactionSynchronizationManager.registerSynchronization(new TransactionSynchronization() &#123;
    @Override
    public void afterCompletion(int status) &#123;
        // 实现你的业务逻辑，在前面分析的invokeAfterCommit方法中，会调用到这里
    &#125;
&#125;);
</code></pre>
<h1 id="十、参考文献-鸣谢"><a href="#十、参考文献-鸣谢" class="headerlink" title="十、参考文献 &amp; 鸣谢"></a>十、参考文献 &amp; 鸣谢</h1><ul>
<li>作者：<a target="_blank" rel="noopener" href="https://blog.csdn.net/CSDN_WYL2016">码拉松</a>、来源：Spring事务合集：<a target="_blank" rel="noopener" href="https://blog.csdn.net/csdn_wyl2016/category_11607107.html">https://blog.csdn.net/csdn_wyl2016/category_11607107.html</a></li>
<li>作者：<a target="_blank" rel="noopener" href="https://blog.csdn.net/CSDN_WYL2016">码拉松</a>、来源：Spring事务最佳应用指南（包含：事务传播类型、事务失效场景、使用建议、事务源码分析）：<a target="_blank" rel="noopener" href="https://blog.csdn.net/CSDN_WYL2016/article/details/134228745">https://blog.csdn.net/CSDN_WYL2016/article/details/134228745</a></li>
<li>作者：<a target="_blank" rel="noopener" href="https://blog.csdn.net/myli92">tomorrow.hello</a>、来源：事务开启的两种方式：<a target="_blank" rel="noopener" href="https://blog.csdn.net/myli92/article/details/111658394">https://blog.csdn.net/myli92/article/details/111658394</a></li>
<li>作者：<a target="_blank" rel="noopener" href="https://zhaoyang10.blog.csdn.net/">zhaoyang10</a>、来源：SpringBoot 编程式事务：<a target="_blank" rel="noopener" href="https://blog.csdn.net/fzy629442466/article/details/103458630">https://blog.csdn.net/fzy629442466/article/details/103458630</a></li>
<li>作者：<a target="_blank" rel="noopener" href="https://author.baidu.com/home?from=bjh_article&app_id=1742572817489016">程序员古德</a>、来源：一文带你掌握Spring事务核心：TransactionDefinition详解！<ul>
<li><a target="_blank" rel="noopener" href="https://baijiahao.baidu.com/s?id=1785219136558062233">https://baijiahao.baidu.com/s?id=1785219136558062233</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qusikao/article/details/134987576">https://blog.csdn.net/qusikao/article/details/134987576</a></li>
</ul>
</li>
<li>作者：<a target="_blank" rel="noopener" href="https://blog.csdn.net/fox_bert">Marvin-Fox</a>、来源：Spring 声名式事务@Transactional注解详解：<a target="_blank" rel="noopener" href="https://blog.csdn.net/fox_bert/article/details/99460057">https://blog.csdn.net/fox_bert/article/details/99460057</a></li>
</ul>

      
       <hr><span style="font-style: italic;color: gray;"> 转载请注明来源，欢迎对文章中的引用来源进行考证，欢迎指出任何有错误或不够清晰的表达。可以在下面评论区评论，也可以邮件至 8629303@qq.com </span>
    </div>
</article>


<p>
    <a  class="dashang" onclick="dashangToggle()">赏</a>
</p>






    




    </div>
    <div class="copyright">
        <p class="footer-entry">
    ©2017-2024 Sam
</p>
<p class="footer-entry">Built with <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/yelog/hexo-theme-3-hexo" target="_blank">3-hexo</a> theme</p>

    </div>
    <div class="full-toc">
        <button class="full" data-title="切换全屏 快捷键 s"><span class="min "></span></button>
<a class="" id="rocket" ></a>

    </div>
</div>

<div class="hide_box" onclick="dashangToggle()"></div>
<div class="shang_box">
    <a class="shang_close"  onclick="dashangToggle()">×</a>
    <div class="shang_tit">
        <p>喜欢就点赞,疼爱就打赏</p>
    </div>
    <div class="shang_payimg">
        <div class="pay_img">
            <img src="/blog/img/alipay.jpg" class="alipay" title="扫码支持">
            <img src="/blog/img/weixin.jpg" class="weixin" title="扫码支持">
        </div>
    </div>
    <div class="shang_payselect">
        <span><label><input type="radio" name="pay" checked value="alipay">支付宝</label></span><span><label><input type="radio" name="pay" value="weixin">微信</label></span>
    </div>
</div>


</body>
<script src="/blog/js/jquery.pjax.js?v=1.1.0" ></script>

<script src="/blog/js/script.js?v=1.1.0" ></script>
<script>
    var img_resize = 'default';
    function initArticle() {
        /*渲染对应的表格样式*/
        
            $("#post .pjax table").addClass("green_title");
        

        /*渲染打赏样式*/
        
        $("input[name=pay]").on("click", function () {
            if($("input[name=pay]:checked").val()=="weixin"){
                $(".shang_box .shang_payimg .pay_img").addClass("weixin_img");
            } else {
                $(".shang_box .shang_payimg .pay_img").removeClass("weixin_img");
            }
        })
        

        /*高亮代码块行号*/
        
        $('pre code').each(function(){
            var lines = $(this).text().trim().split('\n').length, widther='';
            if (lines>99) {
                widther = 'widther'
            }
            var $numbering = $('<ul/>').addClass('pre-numbering ' + widther).attr("unselectable","on");
            $(this).addClass('has-numbering ' + widther)
                    .parent()
                    .append($numbering);
            for(var i=1;i<=lines;i++){
                $numbering.append($('<li/>').text(i));
            }
        });
        

        /*访问数量*/
        
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js");
        

        /*代码高亮，行号对齐*/
        $('.pre-numbering').css('line-height',$('.has-numbering').css('line-height'));

        
        
    }

    /*打赏页面隐藏与展示*/
    
    function dashangToggle() {
        $(".shang_box").fadeToggle();
        $(".hide_box").fadeToggle();
    }
    

</script>

<!--加入行号的高亮代码块样式-->

<style>
    pre{
        position: relative;
        margin-bottom: 24px;
        border-radius: 10px;
        border: 1px solid #e2dede;
        background: #FFF;
        overflow: hidden;
    }
    code.has-numbering{
        margin-left: 30px;
    }
    code.has-numbering.widther{
        margin-left: 35px;
    }
    .pre-numbering{
        margin: 0;
        position: absolute;
        top: 0;
        left: 0;
        width: 20px;
        padding: 18px 3px 15px 5px;
        border-right: 1px solid #C3CCD0;
        text-align: right;
        color: #AAA;
        background-color: #fafafa;
    }
    .pre-numbering.widther {
        width: 35px;
    }
</style>

<!--自定义样式设置-->
<style>
    
    
    .nav {
        width: 582px;
    }
    .nav.fullscreen {
        margin-left: -582px;
    }
    .nav-left {
        width: 160px;
    }
    
    
    @media screen and (max-width: 1468px) {
        .nav {
            width: 492px;
        }
        .nav.fullscreen {
            margin-left: -492px;
        }
        .nav-left {
            width: 100px;
        }
    }
    
    
    @media screen and (max-width: 1024px) {
        .nav {
            width: 492px;
            margin-left: -492px
        }
        .nav.fullscreen {
            margin-left: 0;
        }
    }
    
    @media screen and (max-width: 426px) {
        .nav {
            width: 100%;
        }
        .nav-left {
            width: 100%;
        }
    }
    
    
    .nav-right .title-list nav a .post-title, .nav-right .title-list #local-search-result a .post-title {
        color: #383636;
    }
    
    
    .nav-right .title-list nav a .post-date, .nav-right .title-list #local-search-result a .post-date {
        color: #5e5e5f;
    }
    
    
    .nav-right nav a.hover, #local-search-result a.hover{
        background-color: #e2e0e0;
    }
    
    

    /*列表样式*/
    

    /* 背景图样式 */
    
    


    /*引用块样式*/
    

    /*文章列表背景图*/
    

    
</style>






<div class="mobile-menus-out" >

</div>
<div class="mobile-menus">
    
    
    
    
    <a class="dynamic-menu " target="_blank"  href="https://github.com/8629303">GitHub</a>
    
</div>


</html>
