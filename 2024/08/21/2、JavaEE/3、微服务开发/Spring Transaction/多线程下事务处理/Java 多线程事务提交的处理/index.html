<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Java 多线程事务提交的处理 | Hexo</title>
  <meta name="keywords" content="">
  <meta name="description" content="Java 多线程事务提交的处理 | Hexo">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="description" content="请不要自己写，Spring Boot非常实用的内置功能：https:&#x2F;&#x2F;juejin.cn&#x2F;post&#x2F;7417630844100231206  在 SpringBoot 框架中，内置了许多实用的功能，这些功能可以帮助开发者高效地开发和维护应用程序。 一、请求数据记录器SpringBoot 提供了一个内置的日志记录解决方案，通过 AbstractRequestLoggingFilter 可以记录请">
<meta property="og:type" content="article">
<meta property="og:title" content="SpringBoot2.x 内置功能 - 内置过滤器和 AOP 工具类">
<meta property="og:url" content="https://8629303.github.io/2024/10/08/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot2.x%20%E5%86%85%E7%BD%AE%E5%8A%9F%E8%83%BD%20-%20%E5%86%85%E7%BD%AE%E8%BF%87%E6%BB%A4%E5%99%A8%E5%92%8C%20AOP%20%E5%B7%A5%E5%85%B7%E7%B1%BB/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="请不要自己写，Spring Boot非常实用的内置功能：https:&#x2F;&#x2F;juejin.cn&#x2F;post&#x2F;7417630844100231206  在 SpringBoot 框架中，内置了许多实用的功能，这些功能可以帮助开发者高效地开发和维护应用程序。 一、请求数据记录器SpringBoot 提供了一个内置的日志记录解决方案，通过 AbstractRequestLoggingFilter 可以记录请">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2024-10-08T08:44:19.743Z">
<meta property="article:modified_time" content="2024-10-22T03:50:18.319Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">


<link rel="icon" href="/img/avatar.jpg">

<link href="/blog/css/style.css?v=1.1.0" rel="stylesheet">

<link href="/blog/css/hl_theme/atom-light.css?v=1.1.0" rel="stylesheet">

<link href="//cdn.jsdelivr.net/npm/animate.css@4.1.0/animate.min.css" rel="stylesheet">

<script src="//cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
<script src="/blog/js/titleTip.js?v=1.1.0" ></script>

<script src="//cdn.jsdelivr.net/npm/highlightjs@9.16.2/highlight.pack.min.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>

<script src="//cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script>



<script src="//cdn.jsdelivr.net/npm/jquery.cookie@1.4.1/jquery.cookie.min.js" ></script>

<script src="/blog/js/iconfont.js?v=1.1.0" ></script>

<meta name="generator" content="Hexo 7.3.0"></head>
<div style="display: none">
  <input class="theme_disqus_on" value="false">
  <input class="theme_preload_comment" value="">
  <input class="theme_blog_path" value="/blog">
  <input id="theme_shortcut" value="true" />
  <input id="theme_highlight_on" value="true" />
  <input id="theme_code_copy" value="true" />
</div>



<body>
<aside class="nav">
    <div class="nav-left">
        <a href="/blog/"
   class="avatar_target">
    <img class="avatar"
         src="/blog/img/avatar.jpg"/>
</a>
<div class="author">
    <span>John Doe</span>
</div>

<div class="icon">
    
        
            <a title="github"
               href="https://github.com/8629303"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-github"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="email"
               href="mailto:8629303@qq.com"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-email"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="qq"
               href="http://wpa.qq.com/msgrd?v=3&uin=8629303&site=qq&menu=yes"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-qq"></use>
                    </svg>
                
            </a>
        
    
</div>





<ul>
    <li>
        <div class="all active" data-rel="全部文章">全部文章
            
                <small>(172)</small>
            
        </div>
    </li>
    
        
            
                
    <li>
        <div data-rel="数据库">
            
            数据库
            <small>(5)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="开发工具">
            <i class="fold iconfont icon-right"></i>
            开发工具
            <small>(16)</small>
        </div>
        
            <ul class="sub hide">
                
                    
    <li>
        <div data-rel="开发工具&lt;---&gt;Maven">
            
            Maven
            <small>(8)</small>
        </div>
        
    </li>

                
            </ul>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="面试篇">
            
            面试篇
            <small>(1)</small>
        </div>
        
    </li>

            
        
    
        
            
        
    
        
            
        
    
        
            
                
    <li>
        <div data-rel="中间件">
            <i class="fold iconfont icon-right"></i>
            中间件
            <small>(9)</small>
        </div>
        
            <ul class="sub hide">
                
                    
    <li>
        <div data-rel="中间件&lt;---&gt;ElasticSearch">
            
            ElasticSearch
            <small>(1)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="中间件&lt;---&gt;MongoDB">
            
            MongoDB
            <small>(2)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="中间件&lt;---&gt;RabbitMQ">
            
            RabbitMQ
            <small>(3)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="中间件&lt;---&gt;Redis">
            
            Redis
            <small>(3)</small>
        </div>
        
    </li>

                
            </ul>
        
    </li>

            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
                
    <li>
        <div data-rel="JavaEE">
            <i class="fold iconfont icon-right"></i>
            JavaEE
            <small>(72)</small>
        </div>
        
            <ul class="sub hide">
                
                    
    <li>
        <div data-rel="JavaEE&lt;---&gt;微服务开发">
            
            微服务开发
            <small>(66)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="JavaEE&lt;---&gt;JavaWeb">
            
            JavaWeb
            <small>(2)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="JavaEE&lt;---&gt;SSM框架">
            
            SSM框架
            <small>(4)</small>
        </div>
        
    </li>

                
            </ul>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="JavaSE">
            <i class="fold iconfont icon-right"></i>
            JavaSE
            <small>(62)</small>
        </div>
        
            <ul class="sub hide">
                
                    
    <li>
        <div data-rel="JavaSE&lt;---&gt;Java汇总篇">
            
            Java汇总篇
            <small>(28)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="JavaSE&lt;---&gt;Java基础篇">
            
            Java基础篇
            <small>(8)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="JavaSE&lt;---&gt;Java进阶篇">
            
            Java进阶篇
            <small>(4)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="JavaSE&lt;---&gt;Java新特性">
            
            Java新特性
            <small>(17)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="JavaSE&lt;---&gt;Java性能测试与安全">
            
            Java性能测试与安全
            <small>(5)</small>
        </div>
        
    </li>

                
            </ul>
        
    </li>

            
        
    
        
            
        
    
        
            
        
    
        
            
                
    <li>
        <div data-rel="Linux">
            <i class="fold iconfont icon-right"></i>
            Linux
            <small>(7)</small>
        </div>
        
            <ul class="sub hide">
                
                    
    <li>
        <div data-rel="Linux&lt;---&gt;虚拟机工具">
            
            虚拟机工具
            <small>(2)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="Linux&lt;---&gt;Docker">
            
            Docker
            <small>(2)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="Linux&lt;---&gt;Kubernetes">
            
            Kubernetes
            <small>(2)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="Linux&lt;---&gt;Nginx">
            
            Nginx
            <small>(1)</small>
        </div>
        
    </li>

                
            </ul>
        
    </li>

            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
</ul>
<div class="left-bottom">
    <div class="menus">
        
            
            
            
    </div>
    <div>
        
            <a class="about  hasFriend  site_url"
               
               href="/about">关于</a>
        
        <a style="width: 50%"
                
                                           class="friends">友链</a>
        
    </div>
</div>
<input type="hidden" id="yelog_site_posts_number" value="172">

<div style="display: none">
    <span id="busuanzi_value_site_uv"></span>
    <span id="busuanzi_value_site_pv"></span>
</div>

    </div>
    <div class="nav-right">
        <div class="friends-area">
    <div class="friends-title">
        友情链接
        <i class="iconfont icon-left"></i>
    </div>
    <div class="friends-content">
        <ul>
            
            <li><a target="_blank" href="http://yelog.org/">叶落阁</a></li>
            
        </ul>
    </div>
</div>
        <div class="title-list">
    <div class="right-top">
        <div id="default-panel">
            <i class="iconfont icon-search" data-title="搜索 快捷键 i"></i>
            <div class="right-title">全部文章</div>
            <i class="iconfont icon-file-tree" data-title="切换到大纲视图 快捷键 w"></i>
        </div>
        <div id="search-panel">
            <i class="iconfont icon-left" data-title="返回"></i>
            <input id="local-search-input" autocomplete="off"/>
            <label class="border-line" for="input"></label>
            <i class="iconfont icon-case-sensitive" data-title="大小写敏感"></i>
            <i class="iconfont icon-tag" data-title="标签"></i>
        </div>
        <div id="outline-panel" style="display: none">
            <div class="right-title">大纲</div>
            <i class="iconfont icon-list" data-title="切换到文章列表"></i>
        </div>
    </div>

    <div class="tags-list">
    <input id="tag-search" />
    <div class="tag-wrapper">
        
    </div>

</div>

    
    <nav id="title-list-nav">
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2024/10/08/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot2.x%20%E5%86%85%E7%BD%AE%E5%8A%9F%E8%83%BD%20-%20%E5%86%85%E7%BD%AE%E8%BF%87%E6%BB%A4%E5%99%A8%E5%92%8C%20AOP%20%E5%B7%A5%E5%85%B7%E7%B1%BB/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot2.x 内置功能 - 内置过滤器和 AOP 工具类">SpringBoot2.x 内置功能 - 内置过滤器和 AOP 工具类</span>
            <span class="post-date" title="2024-10-08 16:44:19">2024/10/08</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2024/10/08/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%E7%B3%BB%E5%88%97-%E5%85%A8%E7%BD%91%E6%9C%80%E5%85%A8%E7%9A%84%E7%89%88%E6%9C%AC%E5%8F%98%E6%9B%B4%E5%8F%B2/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot系列-全网最全的版本变更史">SpringBoot系列-全网最全的版本变更史</span>
            <span class="post-date" title="2024-10-08 16:38:53">2024/10/08</span>
        </a>
        
        
        <a  class="全部文章 开发工具 Maven "
           href="/blog/2024/10/08/6%E3%80%81%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Maven/Maven%20%E6%95%99%E7%A8%8B%E4%B9%8B%20%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE%20&%20%E9%B8%A3%E8%B0%A2/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Maven 教程之 参考文献 &amp; 鸣谢">Maven 教程之 参考文献 &amp; 鸣谢</span>
            <span class="post-date" title="2024-10-08 15:50:47">2024/10/08</span>
        </a>
        
        
        <a  class="全部文章 开发工具 "
           href="/blog/2024/10/07/6%E3%80%81%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/GitHub%20%E5%AE%9E%E6%88%98%E6%8A%80%E5%B7%A7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="GitHub 实战技巧">GitHub 实战技巧</span>
            <span class="post-date" title="2024-10-07 15:55:34">2024/10/07</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2024/10/07/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot2.x%20%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AF%87%20-%20%E9%9B%86%E6%88%90%20HirakiCP%20%E4%B8%8E%20Druid%20%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot2.x 数据库篇 - 集成 HirakiCP 与 Druid 数据库连接池">SpringBoot2.x 数据库篇 - 集成 HirakiCP 与 Druid 数据库连接池</span>
            <span class="post-date" title="2024-10-07 14:19:43">2024/10/07</span>
        </a>
        
        
        <a  class="全部文章 开发工具 "
           href="/blog/2024/09/30/6%E3%80%81%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/MacOS%20%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%8F%8A%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E5%8D%B8%E8%BD%BD/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="MacOS 开发环境搭建及软件安装卸载">MacOS 开发环境搭建及软件安装卸载</span>
            <span class="post-date" title="2024-09-30 23:56:52">2024/09/30</span>
        </a>
        
        
        <a  class="全部文章 开发工具 Maven "
           href="/blog/2024/09/30/6%E3%80%81%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Maven/Maven%20%E6%95%99%E7%A8%8B%E4%B9%8B%20JDK%20%E7%89%88%E6%9C%AC%E9%BB%98%E8%AE%A4%E8%AE%BE%E7%BD%AE%20/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Maven 教程之 JDK 版本默认设置">Maven 教程之 JDK 版本默认设置</span>
            <span class="post-date" title="2024-09-30 16:37:08">2024/09/30</span>
        </a>
        
        
        <a  class="全部文章 开发工具 Maven "
           href="/blog/2024/09/26/6%E3%80%81%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Maven/Maven%20%E6%95%99%E7%A8%8B%E4%B9%8B%20profiles%20%E5%A4%9A%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Maven 教程之 profiles 多环境配置">Maven 教程之 profiles 多环境配置</span>
            <span class="post-date" title="2024-09-26 17:40:34">2024/09/26</span>
        </a>
        
        
        <a  class="全部文章 开发工具 Maven "
           href="/blog/2024/09/25/6%E3%80%81%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Maven/Maven%20%E6%95%99%E7%A8%8B%E4%B9%8B%20plugin%20%E8%AF%A6%E8%A7%A3/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Maven 教程之 plugin 详解">Maven 教程之 plugin 详解</span>
            <span class="post-date" title="2024-09-25 11:32:44">2024/09/25</span>
        </a>
        
        
        <a  class="全部文章 开发工具 Maven "
           href="/blog/2024/09/21/6%E3%80%81%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Maven/Maven%20%E6%95%99%E7%A8%8B%E4%B9%8B%20pom.xml%20%E8%AF%A6%E8%A7%A3/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Maven 教程之 pom.xml 详解">Maven 教程之 pom.xml 详解</span>
            <span class="post-date" title="2024-09-21 16:14:13">2024/09/21</span>
        </a>
        
        
        <a  class="全部文章 开发工具 Maven "
           href="/blog/2024/09/21/6%E3%80%81%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Maven/Maven%20%E6%95%99%E7%A8%8B%E4%B9%8B%20settings.xml%20%E8%AF%A6%E8%A7%A3/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Maven 教程之 settings.xml 详解">Maven 教程之 settings.xml 详解</span>
            <span class="post-date" title="2024-09-21 16:14:09">2024/09/21</span>
        </a>
        
        
        <a  class="全部文章 面试篇 "
           href="/blog/2024/08/27/0%E3%80%81%E9%9D%A2%E8%AF%95%E7%AF%87/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8%E6%B1%87%E6%80%BB/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="面试宝典汇总">面试宝典汇总</span>
            <span class="post-date" title="2024-08-27 16:20:25">2024/08/27</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/blog/2024/08/26/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E8%87%AA%E5%AE%9A%E4%B9%89%E9%9B%86%E5%90%88%E5%B8%B8%E9%87%8F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 自定义集合常量">Java 自定义集合常量</span>
            <span class="post-date" title="2024-08-26 12:11:54">2024/08/26</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2024/08/26/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20MVC/SpringMVC%E4%B9%8B@InitBinder%E6%B3%A8%E8%A7%A3%EF%BC%88%E6%97%A5%E6%9C%9F%E8%BD%AC%E6%8D%A2%EF%BC%89/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringMVC之@InitBinder注解（日期转换）">SpringMVC之@InitBinder注解（日期转换）</span>
            <span class="post-date" title="2024-08-26 11:10:28">2024/08/26</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2024/08/21/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Transaction/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8B%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/Java%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BA%8B%E5%8A%A1%E6%8F%90%E4%BA%A4%E7%9A%84%E5%A4%84%E7%90%86/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 多线程事务提交的处理">Java 多线程事务提交的处理</span>
            <span class="post-date" title="2024-08-21 16:32:52">2024/08/21</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2024/08/20/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%20Cache%20%E6%95%B4%E5%90%88%20Redis%20%E7%BC%93%E5%AD%98%E6%A1%86%E6%9E%B6/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot Cache 整合 Redis 缓存框架">SpringBoot Cache 整合 Redis 缓存框架</span>
            <span class="post-date" title="2024-08-20 16:11:47">2024/08/20</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2024/08/16/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Transaction/Spring%20%E4%BA%8B%E5%8A%A1%E5%BA%94%E7%94%A8%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Spring 事务应用及源码分析">Spring 事务应用及源码分析</span>
            <span class="post-date" title="2024-08-16 10:33:57">2024/08/16</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2024/08/16/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Transaction/Spring%20JDBC%20-%20NamedParameterJdbcTemplate/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Spring JDBC - NamedParameterJdbcTemplate">Spring JDBC - NamedParameterJdbcTemplate</span>
            <span class="post-date" title="2024-08-16 00:18:18">2024/08/16</span>
        </a>
        
        
        <a  class="全部文章 开发工具 "
           href="/blog/2024/07/18/6%E3%80%81%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Git%20&%20GitHub/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Git &amp; GitHub">Git &amp; GitHub</span>
            <span class="post-date" title="2024-07-18 10:34:58">2024/07/18</span>
        </a>
        
        
        <a  class="全部文章 开发工具 Maven "
           href="/blog/2024/06/28/6%E3%80%81%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Maven/Maven%20%E5%AE%9E%E6%88%98/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Maven 实战">Maven 实战</span>
            <span class="post-date" title="2024-06-28 16:50:35">2024/06/28</span>
        </a>
        
        
        <a  class="全部文章 数据库 "
           href="/blog/2024/06/26/3%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%9D%A2%E8%AF%95%E5%AE%98%EF%BC%9A%E4%B8%8D%E4%BC%9A%E7%9C%8B%20Explain%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%EF%BC%8C%E7%AE%80%E5%8E%86%E6%95%A2%E5%86%99%20SQL%20%E4%BC%98%E5%8C%96%EF%BC%9F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="面试官：不会看 Explain执行计划，简历敢写 SQL 优化？">面试官：不会看 Explain执行计划，简历敢写 SQL 优化？</span>
            <span class="post-date" title="2024-06-26 19:33:03">2024/06/26</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/blog/2024/04/22/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%AF%87%E4%B9%8B%20IDEA%20-%20VM%20Options%E3%80%81Program%20Arguments%E3%80%81Environment%20Variable%20%E8%A7%A3%E6%9E%90/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 命令行篇之 IDEA - VM Options、Program Arguments、Environment Variable 解析">Java 命令行篇之 IDEA - VM Options、Program Arguments、Environment Variable 解析</span>
            <span class="post-date" title="2024-04-22 10:53:10">2024/04/22</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2024/04/19/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6-%E9%85%8D%E7%BD%AE%E5%A4%96%E9%83%A8%E5%8C%96/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 配置文件-配置外部化">SpringBoot 2.x 配置文件-配置外部化</span>
            <span class="post-date" title="2024-04-19 09:18:55">2024/04/19</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/blog/2024/04/16/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E5%8E%9F%E7%90%86%E7%AF%87%E4%B9%8B%20SPI%20%E6%9C%BA%E5%88%B6/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 原理篇之 SPI 机制">Java 原理篇之 SPI 机制</span>
            <span class="post-date" title="2024-04-16 17:26:15">2024/04/16</span>
        </a>
        
        
        <a  class="全部文章 开发工具 Maven "
           href="/blog/2024/01/14/6%E3%80%81%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Maven/Maven%20%E6%95%99%E7%A8%8B%E4%B9%8B%20mirror%20&%20repository%20%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Maven 教程之 mirror &amp; repository 配置详解">Maven 教程之 mirror &amp; repository 配置详解</span>
            <span class="post-date" title="2024-01-14 22:51:03">2024/01/14</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/12/07/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E4%B8%BA%E4%BB%80%E4%B9%88SpringBoot%20jar%20%E5%8F%AF%E4%BB%A5%E7%9B%B4%E6%8E%A5%E8%BF%90%E8%A1%8C/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 为什么SpringBoot jar 可以直接运行">SpringBoot 2.x 为什么SpringBoot jar 可以直接运行</span>
            <span class="post-date" title="2023-12-07 15:13:56">2023/12/07</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java基础篇 "
           href="/blog/2023/12/04/1%E3%80%81JavaSE/1.Java%20%E5%9F%BA%E7%A1%80%E7%AF%87/5%E3%80%81Java%20%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%BF%9B%E9%98%B6/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 多线程进阶">Java 多线程进阶</span>
            <span class="post-date" title="2023-12-04 16:37:09">2023/12/04</span>
        </a>
        
        
        <a  class="全部文章 数据库 "
           href="/blog/2023/11/18/3%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BB%BA%E6%A8%A1%E5%B7%A5%E5%85%B7%E6%B1%87%E6%80%BB/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="数据库建模工具汇总">数据库建模工具汇总</span>
            <span class="post-date" title="2023-11-18 15:31:11">2023/11/18</span>
        </a>
        
        
        <a  class="全部文章 JavaEE SSM框架 "
           href="/blog/2023/10/08/2%E3%80%81JavaEE/2%E3%80%81SSM%E6%A1%86%E6%9E%B6/Mybatis/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Mybatis">Mybatis</span>
            <span class="post-date" title="2023-10-08 19:45:47">2023/10/08</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java性能测试与安全 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/5.Java%20%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E4%B8%8E%E5%AE%89%E5%85%A8/Java%20%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E7%AF%87%E4%B9%8B%20%E5%8E%8B%E6%B5%8B%E5%B7%A5%E5%85%B7%E6%B1%87%E6%80%BB/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 性能测试篇之 压测工具汇总">Java 性能测试篇之 压测工具汇总</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java性能测试与安全 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/5.Java%20%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E4%B8%8E%E5%AE%89%E5%85%A8/Java%20%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E7%AF%87%E4%B9%8B%20%E9%AB%98%E5%B9%B6%E5%8F%91%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87%EF%BC%9AQPS%E3%80%81TPS%E3%80%81RT%E3%80%81%E5%B9%B6%E5%8F%91%E6%95%B0%E3%80%81%E5%90%9E%E5%90%90%E9%87%8F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 性能测试篇之 高并发性能指标：QPS、TPS、RT、并发数、吞吐量">Java 性能测试篇之 高并发性能指标：QPS、TPS、RT、并发数、吞吐量</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java性能测试与安全 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/5.Java%20%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E4%B8%8E%E5%AE%89%E5%85%A8/Java%20%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E7%AF%87%E4%B9%8B%20JMH%20%E5%B7%A5%E5%85%B7%E7%B1%BB/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 性能测试篇之 JMH 工具类">Java 性能测试篇之 JMH 工具类</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java性能测试与安全 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/5.Java%20%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E4%B8%8E%E5%AE%89%E5%85%A8/Java%20%E5%AE%89%E5%85%A8%E7%AF%87%E4%B9%8B%20API%20%E6%8E%A5%E5%8F%A3%E9%98%B2%E6%AD%A2%E5%8F%82%E6%95%B0%E7%AF%A1%E6%94%B9%E5%92%8C%E9%87%8D%E6%94%BE%E6%94%BB%E5%87%BB/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 安全篇之 API 接口防止参数篡改和重放攻击">Java 安全篇之 API 接口防止参数篡改和重放攻击</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java性能测试与安全 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/5.Java%20%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E4%B8%8E%E5%AE%89%E5%85%A8/Java%20%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E7%AF%87%E4%B9%8B%2048%E5%BC%A0%E5%9B%BE%E5%AD%A6%E4%BC%9A%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E3%80%81%E5%8E%8B%E6%B5%8B%E5%92%8C%E8%B0%83%E4%BC%98/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 性能测试篇之 48张图学会性能监控、压测和调优">Java 性能测试篇之 48张图学会性能监控、压测和调优</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 开发工具 "
           href="/blog/2023/08/28/6%E3%80%81%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/IDEA%20%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="IDEA 基本使用">IDEA 基本使用</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 开发工具 "
           href="/blog/2023/08/28/6%E3%80%81%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/IDEA%20%E5%BF%AB%E6%8D%B7%E9%94%AE/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="IDEA 快捷键">IDEA 快捷键</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 开发工具 "
           href="/blog/2023/08/28/6%E3%80%81%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/IDEA%20%E6%8F%92%E4%BB%B6%E5%AE%89%E8%A3%85/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="IDEA 插件安装">IDEA 插件安装</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 开发工具 "
           href="/blog/2023/08/28/6%E3%80%81%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/PostMan%20%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="PostMan 工具的使用">PostMan 工具的使用</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 开发工具 "
           href="/blog/2023/08/28/6%E3%80%81%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Git/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Git">Git</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E4%BC%98%E5%8C%96%E7%AF%87%E4%B9%8B%20%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3%20%E6%A0%A1%E9%AA%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 优化篇之 自定义注解 校验数据库表中的数据不可重复">Java 优化篇之 自定义注解 校验数据库表中的数据不可重复</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E5%B7%A5%E5%85%B7%E7%AF%87%E4%B9%8B%20API%20%E6%8E%A5%E5%8F%A3%E5%85%8D%E8%B4%B9%20JSONPlaceholder/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 工具篇之 API 接口免费 JSONPlaceholder">Java 工具篇之 API 接口免费 JSONPlaceholder</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E5%B7%A5%E5%85%B7%E7%AF%87%E4%B9%8B%20%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E7%BB%9F%E8%AE%A1%E4%BB%A3%E7%A0%81%E8%80%97%E6%97%B6/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 工具篇之 如何优雅的统计代码耗时">Java 工具篇之 如何优雅的统计代码耗时</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B9%8B%20%E4%B8%8D%E5%8F%AF%E4%B8%8D%E7%9F%A5%E7%9A%84%207%20%E4%B8%AA%20JDK%20%E5%91%BD%E4%BB%A4/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 命令行之 不可不知的 7 个 JDK 命令">Java 命令行之 不可不知的 7 个 JDK 命令</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%AF%87%E4%B9%8B%20Window%20%E5%90%8E%E5%8F%B0%E5%90%AF%E5%8A%A8%20JAR%20%E7%A8%8B%E5%BA%8F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 命令行篇之 Window 后台启动 JAR 程序">Java 命令行篇之 Window 后台启动 JAR 程序</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E5%B7%A5%E5%85%B7%E7%AF%87%E4%B9%8B%20Lombok/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 工具篇之 Lombok">Java 工具篇之 Lombok</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E5%B7%A5%E5%85%B7%E7%AF%87%E4%B9%8B%20API%20%E6%96%87%E6%A1%A3%E5%B7%A5%E5%85%B7%20Swagger3.x-2.x/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 工具篇之 API 文档工具 Swagger3.x-2.x">Java 工具篇之 API 文档工具 Swagger3.x-2.x</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E5%B7%A5%E5%85%B7%E7%AF%87%E4%B9%8B%20%E6%8E%8C%E6%8F%A114%E7%A7%8DUML%E5%9B%BE/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 工具篇之 掌握14种UML图">Java 工具篇之 掌握14种UML图</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E5%B7%A5%E5%85%B7%E7%B1%BB%E4%B9%8B%20%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B7%A5%E5%85%B7%E7%B1%BB/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 工具类之 自定义工具类">Java 工具类之 自定义工具类</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20Bean%20%E4%B9%8B%20DTO%E3%80%81VO%E3%80%81PO%E3%80%81DO%E3%80%81BO%20%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java Bean 之 DTO、VO、PO、DO、BO 类的区别">Java Bean 之 DTO、VO、PO、DO、BO 类的区别</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20JSON%20%E7%AF%87%E4%B9%8B%20Jackson/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java JSON 篇之 Jackson">Java JSON 篇之 Jackson</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20JSON%20%E7%AF%87%E4%B9%8B%20Gson/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java JSON 篇之 Gson">Java JSON 篇之 Gson</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Curl%20%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%91%BD%E4%BB%A4%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Curl 的使用及命令参数说明">Curl 的使用及命令参数说明</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20JSON%20%E7%AF%87%E4%B9%8B%20FastJson/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java JSON 篇之 FastJson">Java JSON 篇之 FastJson</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 中间件 Redis "
           href="/blog/2023/08/28/5%E3%80%81%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/backup/Redis6/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Redis6">Redis6</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 中间件 Redis "
           href="/blog/2023/08/28/5%E3%80%81%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/Redis-%E6%9C%80%E5%85%A8%E5%AE%9E%E6%88%98/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Redis-最全实战">Redis-最全实战</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 中间件 Redis "
           href="/blog/2023/08/28/5%E3%80%81%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/Redis-%E4%BB%A3%E7%A0%81%E5%AE%9E%E6%88%98/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Redis-代码实战">Redis-代码实战</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 中间件 RabbitMQ "
           href="/blog/2023/08/28/5%E3%80%81%E4%B8%AD%E9%97%B4%E4%BB%B6/RabbitMQ/RabbitMQ-3.8.14/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="RabbitMQ-3.8.14">RabbitMQ-3.8.14</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 中间件 RabbitMQ "
           href="/blog/2023/08/28/5%E3%80%81%E4%B8%AD%E9%97%B4%E4%BB%B6/RabbitMQ/RabbitMQ-3.7.x/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="RabbitMQ-3.7.x">RabbitMQ-3.7.x</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 中间件 RabbitMQ "
           href="/blog/2023/08/28/5%E3%80%81%E4%B8%AD%E9%97%B4%E4%BB%B6/RabbitMQ/RabbitMQ-3.8.14-%E5%8D%9A%E5%AE%A2%E7%89%88/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="RabbitMQ-3.8.14-博客版">RabbitMQ-3.8.14-博客版</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 中间件 MongoDB "
           href="/blog/2023/08/28/5%E3%80%81%E4%B8%AD%E9%97%B4%E4%BB%B6/MongoDB/MongDB-4.4.2/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="MongDB-4.4.2">MongDB-4.4.2</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 中间件 MongoDB "
           href="/blog/2023/08/28/5%E3%80%81%E4%B8%AD%E9%97%B4%E4%BB%B6/MongoDB/MongDB-4.4.2-%E5%8D%9A%E5%AE%A2%E7%89%88/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="MongDB-4.4.2-博客版">MongDB-4.4.2-博客版</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 中间件 ElasticSearch "
           href="/blog/2023/08/28/5%E3%80%81%E4%B8%AD%E9%97%B4%E4%BB%B6/ElasticSearch/ElasticSearch7.6.x%E5%AE%9E%E6%88%98/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="ElasticSearch7.6.x实战">ElasticSearch7.6.x实战</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Linux 虚拟机工具 "
           href="/blog/2023/08/28/4%E3%80%81Linux/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%B7%A5%E5%85%B7/Virtualbox%E7%BD%91%E7%BB%9C%E8%AE%BE%E7%BD%AE%E6%88%96%E9%85%8D%E7%BD%AE/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Virtualbox网络设置或配置">Virtualbox网络设置或配置</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Linux 虚拟机工具 "
           href="/blog/2023/08/28/4%E3%80%81Linux/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%B7%A5%E5%85%B7/Virtualbox%E5%AE%89%E8%A3%85Centos7%E5%AE%9E%E6%88%98/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Virtualbox安装Centos7实战">Virtualbox安装Centos7实战</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Linux Nginx "
           href="/blog/2023/08/28/4%E3%80%81Linux/Nginx/Nginx-1.8.0/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Nginx-1.8.0">Nginx-1.8.0</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Linux Kubernetes "
           href="/blog/2023/08/28/4%E3%80%81Linux/Kubernetes/Minikube-k8s/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Minikube-k8s">Minikube-k8s</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Linux Kubernetes "
           href="/blog/2023/08/28/4%E3%80%81Linux/Kubernetes/k0s%20%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B%EF%BC%9A%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%20Kubernetes%20%E9%9B%86%E7%BE%A4/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="k0s 使用教程：如何快速搭建 Kubernetes 集群">k0s 使用教程：如何快速搭建 Kubernetes 集群</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Linux Docker "
           href="/blog/2023/08/28/4%E3%80%81Linux/Docker/Docker%E5%88%9D%E7%BA%A7%E5%88%B0%E5%AE%9E%E6%88%98/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Docker初级到实战">Docker初级到实战</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Linux Docker "
           href="/blog/2023/08/28/4%E3%80%81Linux/Docker/Docker&Docker-Compose%E5%AE%9E%E6%88%98-%E5%93%88%E5%96%BD%E6%B2%83%E5%BE%B7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Docker&amp;Docker-Compose实战-哈喽沃德">Docker&amp;Docker-Compose实战-哈喽沃德</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring/Spring%20Bean%20%E7%9A%8412%E7%A7%8D%E5%AE%9A%E4%B9%89%E6%96%B9%E6%B3%95/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Spring Bean 的12种定义方法">Spring Bean 的12种定义方法</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring/Spring%20Bean%20%E7%9A%84%E5%8A%A8%E6%80%81%E5%88%9B%E5%BB%BA%E8%8E%B7%E5%8F%96%E5%88%A0%E9%99%A4/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Spring Bean 的动态创建获取删除">Spring Bean 的动态创建获取删除</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring/Spring%20Bean%20%E6%B3%A8%E5%85%A5%E7%9A%843%E7%A7%8D%E6%96%B9%E5%BC%8F,%20%E4%B8%BA%E4%BD%95%E5%AE%98%E6%96%B9%E5%BB%BA%E8%AE%AE%E4%BD%BF%E7%94%A8%E6%9E%84%E9%80%A0%E5%99%A8%E6%B3%A8%E5%85%A5/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Spring Bean 注入的3种方式, 为何官方建议使用构造器注入">Spring Bean 注入的3种方式, 为何官方建议使用构造器注入</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Transaction/%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/Spring%20%E8%A7%A3%E5%86%B3%E5%8D%95%E6%9C%BA%E7%8E%AF%E5%A2%83%E4%B8%8B%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E7%9A%84%E4%BA%8B%E5%8A%A1%E9%97%AE%E9%A2%98/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Spring 解决单机环境下多数据源的事务问题">Spring 解决单机环境下多数据源的事务问题</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Transaction/%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/Spring%20%E5%AE%9E%E7%8E%B0%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E5%AE%9E%E6%88%98/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Spring 实现多数据源实战">Spring 实现多数据源实战</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Transaction/%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/Spring%20%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81%E6%95%B0%E6%8D%AE%E6%BA%90%E3%80%81%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E5%88%87%E6%8D%A2%E6%96%B9%E5%BC%8F%E3%80%81%E5%A4%9A%E6%95%B0%E6%8D%AE%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Spring 实现动态数据源、多数据源切换方式、多数据事务管理">Spring 实现动态数据源、多数据源切换方式、多数据事务管理</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Transaction/Spring%20%E4%BA%8B%E5%8A%A1%E5%8E%9F%E7%90%86%E6%B7%B1%E5%85%A5%E4%B8%8E%E5%88%86%E6%9E%90/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Spring 事务原理深入与分析">Spring 事务原理深入与分析</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Security/SpringSecurity/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringSecurity">SpringSecurity</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Transaction/JDBC/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="JDBC">JDBC</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Transaction/Spring%20JDBC%20-%20JdbcTemplate/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Spring JDBC - JdbcTemplate">Spring JDBC - JdbcTemplate</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Transaction/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8B%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/JDBC%E6%89%B9%E5%A4%84%E7%90%86%E5%AE%9E%E7%8E%B0%E6%89%8B%E5%8A%A8%E4%BA%8B%E5%8A%A1%E6%8F%92%E5%85%A51000%E4%B8%87%E6%95%B0%E6%8D%AE%EF%BC%88%E5%8D%95%E7%BA%BF%E7%A8%8B%20&%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%89/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="JDBC批处理实现手动事务插入1000万数据（单线程 &amp; 多线程）">JDBC批处理实现手动事务插入1000万数据（单线程 &amp; 多线程）</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Data%20JPA/SpringData%20JPA%20%E7%B1%BB%E5%9B%BE%E5%8F%8A%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringData JPA 类图及使用方法整理">SpringData JPA 类图及使用方法整理</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Data%20JPA/SpringData%20JPA/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringData JPA">SpringData JPA</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Data%20JPA/Spring%20Data%20JPA%20%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E6%88%98/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Spring Data JPA 原理与实战">Spring Data JPA 原理与实战</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Data%20JPA/Hibernata%20JPA/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Hibernata JPA">Hibernata JPA</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Cloud%20Alibaba/SpringCloud%20Alibaba/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringCloud Alibaba">SpringCloud Alibaba</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot2.x%20%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AF%87%20-%20%E6%95%B4%E5%90%88H2%E6%95%B0%E6%8D%AE%E5%BA%93/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot2.x 数据库篇 - 整合H2数据库">SpringBoot2.x 数据库篇 - 整合H2数据库</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot2.x%20%E9%A1%B9%E7%9B%AE%E7%BB%9F%E4%B8%80%E6%9E%9A%E4%B8%BE%E8%BD%AC%E6%8D%A2%E5%AE%9E%E8%B7%B5/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot2.x 项目统一枚举转换实践">SpringBoot2.x 项目统一枚举转换实践</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AD%A6/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot从零开始学">SpringBoot从零开始学</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%E9%85%8D%E7%BD%AE%E5%B1%9E%E6%80%A7%E4%B9%8BDataSource/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot配置属性之DataSource">SpringBoot配置属性之DataSource</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SprinigBoot%E6%96%87%E7%AB%A0%E6%91%98%E8%A6%81%E5%8F%8A%E8%BD%AC%E8%BD%BD/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SprinigBoot文章摘要及转载">SprinigBoot文章摘要及转载</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/%E4%BB%A3%E7%A0%81%E5%AE%A1%E6%9F%A5%E7%9A%84%E5%BF%85%E8%A6%81%E6%80%A7%E5%92%8C%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="代码审查的必要性和最佳实践">代码审查的必要性和最佳实践</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6-%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%B9%8B@Value%E8%BF%9B%E9%98%B6/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 配置文件-读取配置文件之@Value进阶">SpringBoot 2.x 配置文件-读取配置文件之@Value进阶</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6-%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9A%84N%E7%A7%8D%E6%96%B9%E5%BC%8F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 配置文件-读取配置文件的N种方式">SpringBoot 2.x 配置文件-读取配置文件的N种方式</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6-%E8%AF%BB%E5%8F%96%20Resources%20%E6%96%87%E4%BB%B6%E4%B9%8B%E6%97%A0%E6%B3%95%E8%AF%BB%E5%8F%96Jar%E5%8C%85classpath%E4%B8%8B%E7%9A%84%E6%96%87%E4%BB%B6/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 配置文件-读取 Resources 文件之无法读取Jar包classpath下的文件">SpringBoot 2.x 配置文件-读取 Resources 文件之无法读取Jar包classpath下的文件</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E7%BB%9F%E4%B8%80%E6%8E%A5%E5%8F%A3%E8%BF%94%E5%9B%9E%E6%A0%BC%E5%BC%8F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 统一接口返回格式">SpringBoot 2.x 统一接口返回格式</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6-%E8%AF%BB%E5%8F%96%20Resources%20%E6%96%87%E4%BB%B6%E7%9A%84N%E7%A7%8D%E6%96%B9%E5%BC%8F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 配置文件-读取 Resources 文件的N种方式">SpringBoot 2.x 配置文件-读取 Resources 文件的N种方式</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B%E7%AF%87-%E6%8B%A6%E6%88%AA%E5%99%A8%E8%BF%87%E6%BB%A4%E5%99%A8%E4%B8%8E%E7%9B%91%E5%90%AC%E5%99%A8/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 切面编程篇-拦截器过滤器与监听器">SpringBoot 2.x 切面编程篇-拦截器过滤器与监听器</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3%E8%AF%A6%E8%A7%A3/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 常用注解详解">SpringBoot 2.x 常用注解详解</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E5%AE%89%E5%85%A8%E5%AF%86%E7%A0%81%E5%AD%A6%E4%B9%8B%E5%8A%A0%E8%A7%A3%E5%AF%86%E7%AE%97%E6%B3%95/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 安全密码学之加解密算法">SpringBoot 2.x 安全密码学之加解密算法</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3%E5%A4%A7%E5%85%A8/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 常用注解大全">SpringBoot 2.x 常用注解大全</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E5%90%AF%E5%8A%A8%E6%97%B6%E5%8A%A0%E8%BD%BD%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84N%E7%A7%8D%E6%96%B9%E5%BC%8F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 启动时加载初始化的N种方式">SpringBoot 2.x 启动时加载初始化的N种方式</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%8F%8A%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E8%BF%87%E7%A8%8B/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 启动流程及自动装配过程">SpringBoot 2.x 启动流程及自动装配过程</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E5%8A%A8%E6%80%81%E8%A3%85%E9%85%8DBean%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 动态装配Bean的三种方式">SpringBoot 2.x 动态装配Bean的三种方式</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E5%88%A9%E5%99%A8-1%20JUnit5/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 单元测试利器-1 JUnit5">SpringBoot 2.x 单元测试利器-1 JUnit5</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E5%88%A9%E5%99%A8-3%20MockMvc/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 单元测试利器-3 MockMvc">SpringBoot 2.x 单元测试利器-3 MockMvc</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E5%88%A9%E5%99%A8-2%20Mockito/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 单元测试利器-2 Mockito">SpringBoot 2.x 单元测试利器-2 Mockito</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E5%88%86%E7%89%87%E4%B8%8A%E4%BC%A0%E3%80%81%E6%96%AD%E7%82%B9%E7%BB%AD%E4%BC%A0%E3%80%81%E5%A4%A7%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E3%80%81%E7%A7%92%E4%BC%A0/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 分片上传、断点续传、大文件上传、秒传">SpringBoot 2.x 分片上传、断点续传、大文件上传、秒传</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20Validation%20%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C%EF%BC%88TODO%EF%BC%89/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x Validation 参数校验（TODO）">SpringBoot 2.x Validation 参数校验（TODO）</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20YML%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x YML配置文件详解">SpringBoot 2.x YML配置文件详解</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20WebMvcConfigurer%20%E8%AF%A6%E8%A7%A3%E3%80%90SpringMVC%E3%80%91/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x WebMvcConfigurer 详解【SpringMVC】">SpringBoot 2.x WebMvcConfigurer 详解【SpringMVC】</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E5%88%86%E5%B8%83%E5%BC%8F%E5%85%A8%E5%B1%80%E5%94%AF%E4%B8%80ID%E7%94%9F%E6%88%90%E6%96%B9%E6%A1%88/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 分布式全局唯一ID生成方案">SpringBoot 2.x 分布式全局唯一ID生成方案</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20JWT%20%E6%A6%82%E5%BF%B5%E7%AF%87/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x JWT 概念篇">SpringBoot 2.x JWT 概念篇</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20Jar%20%E5%8C%85%E5%90%AF%E5%8A%A8%E3%80%81%E5%81%9C%E6%AD%A2%E3%80%81%E9%87%8D%E5%90%AF%E8%84%9A%E6%9C%AC/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x Jar 包启动、停止、重启脚本">SpringBoot 2.x Jar 包启动、停止、重启脚本</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20Java%20%E7%A8%8B%E5%BA%8F%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0%E6%80%BB%E7%BB%93/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x Java 程序命令行参数总结">SpringBoot 2.x Java 程序命令行参数总结</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20Java%20%E5%AE%9E%E7%8E%B0%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E7%9A%848%E7%A7%8D%E6%96%B9%E5%BC%8F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x Java 实现异步编程的8种方式">SpringBoot 2.x Java 实现异步编程的8种方式</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20@ControllerAdvice%E4%B8%89%E7%A7%8D%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x @ControllerAdvice三种使用场景">SpringBoot 2.x @ControllerAdvice三种使用场景</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20@ConfigurationProperties%E4%BB%A5%E5%8F%8A@NestedConfigurationProperty%E7%9A%84%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x @ConfigurationProperties以及@NestedConfigurationProperty的使用详解">SpringBoot 2.x @ConfigurationProperties以及@NestedConfigurationProperty的使用详解</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20HTTP%20Content-Type%20%E8%AF%A6%E8%A7%A3/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x HTTP Content-Type 详解">SpringBoot 2.x HTTP Content-Type 详解</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20HTTP%20Headers%20%E5%A4%B4%E4%BF%A1%E6%81%AF%E8%AF%BB%E5%8F%96/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x HTTP Headers 头信息读取">SpringBoot 2.x HTTP Headers 头信息读取</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20JWT%20%E5%AE%9E%E6%88%98%E7%AF%87/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x JWT 实战篇">SpringBoot 2.x JWT 实战篇</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%20%E6%8E%A5%E5%8F%A3%E5%B9%82%E7%AD%89%E6%80%A7%E5%AE%9E%E7%8E%B0/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x  接口幂等性实现">SpringBoot 2.x  接口幂等性实现</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/Spring%20IO%20Platform%EF%BC%9A%E8%A7%A3%E5%86%B3%E4%BE%9D%E8%B5%96%E7%89%88%E6%9C%AC%E5%86%B2%E7%AA%81/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Spring IO Platform：解决依赖版本冲突">Spring IO Platform：解决依赖版本冲突</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B%E7%AF%87-AOP%20%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%8E%9F%E7%90%86/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 切面编程篇-AOP 的使用及原理">SpringBoot 2.x 切面编程篇-AOP 的使用及原理</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE SSM框架 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/2%E3%80%81SSM%E6%A1%86%E6%9E%B6/SpringMVC/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringMVC">SpringMVC</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Shiro/Shiro%E6%9D%83%E9%99%90%E5%AE%9E%E6%88%98%E8%AF%BE%E7%A8%8B/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Shiro权限实战课程">Shiro权限实战课程</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Shiro/Shiro%E6%9D%83%E9%99%90%E5%AE%9E%E6%88%98/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Shiro权限实战">Shiro权限实战</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE SSM框架 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/2%E3%80%81SSM%E6%A1%86%E6%9E%B6/Spring/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Spring">Spring</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE SSM框架 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/2%E3%80%81SSM%E6%A1%86%E6%9E%B6/MybatisPlus/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="MybatisPlus">MybatisPlus</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE JavaWeb "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/1%E3%80%81JavaWeb/%E4%BD%A0%E8%BF%98%E5%9C%A8%E4%B8%BA%20HTTP%20%E7%9A%84%E8%BF%99%E4%BA%9B%E6%A6%82%E5%BF%B5%E5%A4%B4%E7%96%BC%E5%90%97/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="你还在为 HTTP 的这些概念头疼吗">你还在为 HTTP 的这些概念头疼吗</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE JavaWeb "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/1%E3%80%81JavaWeb/Cookie%E3%80%81Session%E3%80%81Token%E3%80%81JWT%E7%BB%88%E4%BA%8E%E8%AE%B2%E6%B8%85%E6%A5%9A%E4%BA%86/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Cookie、Session、Token、JWT终于讲清楚了">Cookie、Session、Token、JWT终于讲清楚了</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 数据库 "
           href="/blog/2023/08/28/3%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL-%E9%AB%98%E7%BA%A7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="MySQL-高级">MySQL-高级</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 数据库 "
           href="/blog/2023/08/28/3%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL-%E5%88%9D%E7%BA%A7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="MySQL-初级">MySQL-初级</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 数据库 "
           href="/blog/2023/08/28/3%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93/H2%20Database/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="H2 Database">H2 Database</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E4%BC%98%E5%8C%96%E7%AF%87%E4%B9%8B%20%E6%B3%A8%E8%A7%A3%20+%20%E5%8F%8D%E5%B0%84%E6%B6%88%E9%99%A4%E9%87%8D%E5%A4%8D%E4%BB%A3%E7%A0%81/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 优化篇之 注解 + 反射消除重复代码">Java 优化篇之 注解 + 反射消除重复代码</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E4%BC%98%E5%8C%96%E7%AF%87%E4%B9%8B%20%E5%BB%B6%E6%97%B6%E9%98%9F%E5%88%97%20-%20%E8%AE%A2%E5%8D%95%E8%B6%85%E6%97%B6%E8%87%AA%E5%8A%A8%E5%8F%96%E6%B6%88%E7%9A%84N%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 优化篇之 延时队列 - 订单超时自动取消的N种实现方式">Java 优化篇之 延时队列 - 订单超时自动取消的N种实现方式</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E9%9B%86%E5%90%88%E7%AF%87%E4%B9%8B%20%E8%8E%B7%E5%8F%96%E4%B8%A4%E4%B8%AA%E9%9B%86%E5%90%88List%E7%9A%84%E4%BA%A4%E9%9B%86%E3%80%81%E8%A1%A5%E9%9B%86%E3%80%81%E5%B9%B6%E9%9B%86%E3%80%81%E5%B7%AE%E9%9B%86%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 集合篇之 获取两个集合List的交集、补集、并集、差集的几种方式">Java 集合篇之 获取两个集合List的交集、补集、并集、差集的几种方式</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E4%BC%98%E5%8C%96%E7%AF%87%E4%B9%8B%20if-else%20%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 优化篇之 if-else 代码优化方案">Java 优化篇之 if-else 代码优化方案</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E9%9B%86%E5%90%88%E7%AF%87%E4%B9%8B%20Lambda%20%E5%AE%9E%E7%8E%B0%E8%B6%85%E5%BC%BA%E6%8E%92%E5%BA%8F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 集合篇之 Lambda 实现超强排序">Java 集合篇之 Lambda 实现超强排序</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4%E5%90%84%E7%B1%BB%E5%9E%8B%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 日期时间各类型相互转换">Java 日期时间各类型相互转换</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 动态代理">Java 动态代理</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E5%9F%BA%E6%9C%AC%E5%8A%9F%E7%AF%87%E4%B9%8B%20for%E3%80%81for-each%E3%80%81forEach()%20%E7%9A%84%20break%E3%80%81continue%E3%80%81return/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 基本功篇之 for、for-each、forEach() 的 break、continue、return">Java 基本功篇之 for、for-each、forEach() 的 break、continue、return</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6%E8%AF%A6%E8%A7%A3/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 日志框架详解">Java 日志框架详解</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java新特性 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/3.Java%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%20%E6%96%B0%E7%89%B9%E6%80%A7%E6%A6%82%E8%BF%B0%E5%8F%8A%E7%89%88%E6%9C%AC%E5%8F%91%E8%A1%8C%E5%8F%B2/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 新特性概述及版本发行史">Java 新特性概述及版本发行史</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20Bean%20%E4%B9%8B%20Record%20%E7%B1%BB/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java Bean 之 Record 类">Java Bean 之 Record 类</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E4%BC%98%E5%8C%96%E7%AF%87%E4%B9%8B%20GZIP%E5%8E%8B%E7%BC%A9%E5%AD%97%E7%AC%A6%E4%B8%B2/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 优化篇之 GZIP压缩字符串">Java 优化篇之 GZIP压缩字符串</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java进阶篇 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/2.Java%20%E8%BF%9B%E9%98%B6%E7%AF%87/JVM%20%E8%99%9A%E6%8B%9F%E6%9C%BA/Java%20GC%20%E6%80%BB%E7%BB%93/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java GC 总结">Java GC 总结</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java新特性 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/3.Java%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%209%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%209%20%E6%96%B0%E7%89%B9%E6%80%A7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 9 新特性">Java 9 新特性</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java新特性 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/3.Java%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%208%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%208%20%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8B%20Optional%20%E7%B1%BB/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 8 新特性之 Optional 类">Java 8 新特性之 Optional 类</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java新特性 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/3.Java%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%208%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%208%20%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8B%20Stream%20%E6%B5%81/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 8 新特性之 Stream 流">Java 8 新特性之 Stream 流</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java新特性 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/3.Java%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%208%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%208%20%E6%96%B0%E7%89%B9%E6%80%A7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 8 新特性">Java 8 新特性</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java新特性 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/3.Java%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%208%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%208%20%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8B%20DateTime%20API/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 8 新特性之 DateTime API">Java 8 新特性之 DateTime API</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java新特性 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/3.Java%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2019%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2019%20%E6%96%B0%E7%89%B9%E6%80%A7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 19 新特性">Java 19 新特性</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java新特性 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/3.Java%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2020%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2020%20%E6%96%B0%E7%89%B9%E6%80%A7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 20 新特性">Java 20 新特性</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java新特性 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/3.Java%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2018%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2018%20%E6%96%B0%E7%89%B9%E6%80%A7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 18 新特性">Java 18 新特性</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java新特性 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/3.Java%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2017%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2017%20%E6%96%B0%E7%89%B9%E6%80%A7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 17 新特性">Java 17 新特性</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java新特性 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/3.Java%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2015%E6%96%B0%E7%89%B9%E6%80%A7/Java%2015%20%E6%96%B0%E7%89%B9%E6%80%A7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 15 新特性">Java 15 新特性</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java新特性 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/3.Java%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2016%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2016%20%E6%96%B0%E7%89%B9%E6%80%A7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 16 新特性">Java 16 新特性</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java新特性 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/3.Java%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2013%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2013%20%E6%96%B0%E7%89%B9%E6%80%A7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 13 新特性">Java 13 新特性</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java新特性 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/3.Java%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2014%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2014%20%E6%96%B0%E7%89%B9%E6%80%A7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 14 新特性">Java 14 新特性</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java新特性 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/3.Java%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2011%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2011%20%E6%96%B0%E7%89%B9%E6%80%A7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 11 新特性">Java 11 新特性</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java新特性 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/3.Java%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2012%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2012%20%E6%96%B0%E7%89%B9%E6%80%A7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 12 新特性">Java 12 新特性</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java新特性 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/3.Java%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2010%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2010%20%E6%96%B0%E7%89%B9%E6%80%A7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 10 新特性">Java 10 新特性</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java基础篇 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/1.Java%20%E5%9F%BA%E7%A1%80%E7%AF%87/1%E3%80%81Java%20%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/Java%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 面向对象编程">Java 面向对象编程</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java基础篇 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/1.Java%20%E5%9F%BA%E7%A1%80%E7%AF%87/3%E3%80%81Java%20%E9%9B%86%E5%90%88%E7%B1%BB/Java%20%E7%B1%BB%E9%9B%86%E6%A1%86%E6%9E%B6/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 类集框架">Java 类集框架</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java基础篇 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/1.Java%20%E5%9F%BA%E7%A1%80%E7%AF%87/2%E3%80%81Java%20%E5%B8%B8%E7%94%A8%E7%B1%BB%E5%BA%93/Java%20%E5%B8%B8%E7%94%A8%E7%B1%BB%E5%BA%93/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 常用类库">Java 常用类库</span>
            <span class="post-date" title="2023-08-28 09:23:44">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java基础篇 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/1.Java%20%E5%9F%BA%E7%A1%80%E7%AF%87/5%E3%80%81Java%20%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 多线程基础">Java 多线程基础</span>
            <span class="post-date" title="2023-08-28 09:23:44">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java基础篇 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/1.Java%20%E5%9F%BA%E7%A1%80%E7%AF%87/4%E3%80%81Java%20%E5%8F%8D%E5%B0%84%E4%B8%8E%E6%B3%A8%E8%A7%A3/Java%20%E5%8F%8D%E5%B0%84%E4%B8%8E%E6%B3%A8%E8%A7%A3/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 反射与注解">Java 反射与注解</span>
            <span class="post-date" title="2023-08-28 09:23:44">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java基础篇 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/1.Java%20%E5%9F%BA%E7%A1%80%E7%AF%87/7%E3%80%81Java%20NIO%20%E6%B5%81/Java%20NIO%20%E6%B5%81/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java NIO 流">Java NIO 流</span>
            <span class="post-date" title="2023-08-28 09:23:44">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java基础篇 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/1.Java%20%E5%9F%BA%E7%A1%80%E7%AF%87/6%E3%80%81Java%20IO%20%E6%B5%81/Java%20IO%20%E6%B5%81/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java IO 流">Java IO 流</span>
            <span class="post-date" title="2023-08-28 09:23:44">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java进阶篇 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/2.Java%20%E8%BF%9B%E9%98%B6%E7%AF%87/Java%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/Java%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 设计模式">Java 设计模式</span>
            <span class="post-date" title="2023-08-28 09:23:44">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java进阶篇 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/2.Java%20%E8%BF%9B%E9%98%B6%E7%AF%87/JVM%20%E8%99%9A%E6%8B%9F%E6%9C%BA/JVM%20%E8%99%9A%E6%8B%9F%E6%9C%BA/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="JVM 虚拟机">JVM 虚拟机</span>
            <span class="post-date" title="2023-08-28 09:23:44">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java进阶篇 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/2.Java%20%E8%BF%9B%E9%98%B6%E7%AF%87/JVM%20%E8%99%9A%E6%8B%9F%E6%9C%BA/7%20%E6%AE%B5%E5%B0%8F%E4%BB%A3%E7%A0%81%EF%BC%8C%E7%8E%A9%E8%BD%ACJava%E7%A8%8B%E5%BA%8F%E5%B8%B8%E8%A7%81%E7%9A%84%E5%B4%A9%E6%BA%83%E5%9C%BA%E6%99%AF/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="7 段小代码，玩转Java程序常见的崩溃场景">7 段小代码，玩转Java程序常见的崩溃场景</span>
            <span class="post-date" title="2023-08-28 09:23:44">2023/08/28</span>
        </a>
        
        <div id="no-item-tips">

        </div>
    </nav>
    <div id="outline-list">
    </div>
</div>

    </div>
    <div class="hide-list">
        <div class="semicircle" data-title="切换全屏 快捷键 s">
            <div class="brackets first"><</div>
            <div class="brackets">&gt;</div>
        </div>
    </div>
</aside>
<div id="post">
    <div class="pjax">
        <article id="post-2、JavaEE/3、微服务开发/Spring Transaction/多线程下事务处理/Java 多线程事务提交的处理" class="article article-type-post" itemscope itemprop="blogPost">
    
        <h1 class="article-title">Java 多线程事务提交的处理</h1>
    
    <div class="article-meta">
        
        
        
        <span class="book">
            <i class="iconfont icon-category"></i>
            
            
            <a  data-rel="JavaEE">JavaEE</a> > 
            
            <a  data-rel="JavaEE&lt;---&gt;微服务开发">微服务开发</a>
            
        </span>
        
        
    </div>
    <div class="article-meta">
        
            发布时间 : <time class="date" title='最后更新: 2024-10-22 11:50:18'>2024-08-21 16:32</time>
        
    </div>
    <div class="article-meta">
        
        
        <span id="busuanzi_container_page_pv">
            阅读 :<span id="busuanzi_value_page_pv">
                <span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </span>
        </span>
        
        
    </div>
    
    <div class="toc-ref">
    
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="toc-text">Java 多线程事务处理最佳实践</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA"><span class="toc-text">1、环境搭建</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81CompletableFuture-TransactionManager-%E5%AE%9E%E7%8E%B0"><span class="toc-text">2、CompletableFuture + TransactionManager 实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81CompletableFuture-TransactionTemplate-%E5%AE%9E%E7%8E%B0"><span class="toc-text">3、CompletableFuture + TransactionTemplate 实现</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E6%8F%90%E4%BA%A4%E4%B8%8E%E5%9B%9E%E6%BB%9A%E6%8E%A7%E5%88%B6"><span class="toc-text">Java 多线程数据库事务提交与回滚控制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E9%A1%B9%E7%9B%AE%E7%8E%AF%E5%A2%83%E7%9A%84%E6%90%AD%E5%BB%BA"><span class="toc-text">1、项目环境的搭建</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E5%BE%AA%E7%8E%AF%E6%93%8D%E4%BD%9C%E7%9A%84%E4%BB%A3%E7%A0%81"><span class="toc-text">2、循环操作的代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E4%BD%BF%E7%94%A8%E6%89%8B%E5%8A%A8%E4%BA%8B%E5%8A%A1%E7%9A%84%E6%93%8D%E4%BD%9C%E4%BB%A3%E7%A0%81"><span class="toc-text">3、使用手动事务的操作代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E5%B0%9D%E8%AF%95%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E4%BF%AE%E6%94%B9%E3%80%90%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%A1%88%E3%80%91"><span class="toc-text">4、尝试多线程进行数据修改【两种方案】</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%9C%80%E5%A4%A7%E7%BA%BF%E7%A8%8B%E6%95%B0%E5%B0%8F%E4%BA%8E%E4%BB%BB%E5%8A%A1%E5%88%97%E8%A1%A8%E7%9A%84%E6%95%B0%E9%87%8F"><span class="toc-text">1、线程池的最大线程数小于任务列表的数量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%9C%80%E5%A4%A7%E7%BA%BF%E7%A8%8B%E6%95%B0%E5%B0%8F%E4%BA%8E%E4%BB%BB%E5%8A%A1%E5%88%97%E8%A1%A8%E7%9A%84%E6%95%B0%E9%87%8F"><span class="toc-text">2、线程池的最大线程数小于任务列表的数量</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81%E4%B8%A4%E4%B8%AA-CountDownLatch-%E6%8E%A7%E5%88%B6%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BA%8B%E5%8A%A1%E6%8F%90%E4%BA%A4%E3%80%902PC%E3%80%91"><span class="toc-text">5、两个 CountDownLatch 控制多线程事务提交【2PC】</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81TransactionStatus-%E9%9B%86%E5%90%88%E6%8E%A7%E5%88%B6%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BA%8B%E5%8A%A1%E3%80%90%E4%B8%8D%E6%8E%A8%E8%8D%90%E3%80%91"><span class="toc-text">6、TransactionStatus 集合控制多线程事务【不推荐】</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E4%BD%BF%E7%94%A8-union-%E8%BF%9E%E6%8E%A5%E5%A4%9A%E4%B8%AA-select-%E5%AE%9E%E7%8E%B0%E6%89%B9%E9%87%8F-update"><span class="toc-text">六、使用 union 连接多个 select 实现批量 update</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-text">七、总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Spring-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BA%8B%E5%8A%A1%E6%8E%A7%E5%88%B6%E5%90%84%E7%A7%8D%E6%A1%88%E4%BE%8B%E6%B1%87%E6%80%BB"><span class="toc-text">Spring 多线程事务控制各种案例汇总</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE-%E9%B8%A3%E8%B0%A2"><span class="toc-text">参考文献 &amp; 鸣谢</span></a></li></ol>
    
<style>
    .left-col .switch-btn,
    .left-col .switch-area {
        display: none;
    }
    .toc-level-3 i,
    .toc-level-3 ol {
        display: none !important;
    }
</style>
</div>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Java-多线程事务处理最佳实践"><a href="#Java-多线程事务处理最佳实践" class="headerlink" title="Java 多线程事务处理最佳实践"></a>Java 多线程事务处理最佳实践</h1><p>首先需要确认的是，使用多线程处理事务的情况下，最好是使用编程式事务，这样可以更加灵活管理事务的提交与回滚。如果是使用声明式事务<code>@Transactional</code>的话非常容易出现事务<strong>失效</strong>的情况。【因为<code>@Transactional</code>使用的方法粒度需要控制非常好才行】</p>
<p>一般在多线程下使用事务管理器，我们会在每一个线程中管理自己的事务【也就是提交和回滚事务】，与其他线程中的事务互不干扰。不过这里还是会分两种情况：</p>
<ol>
<li>所有线程一起提交事务，要么全部成功，要么全部回滚。【相当于本次操作为一个事务，类似于分布式式事务提交】</li>
<li>每个线程提交或回滚自己的事务、互不干扰。【相当于把本次操作切分为几个小模块，每个模块中管理自己的事务】</li>
</ol>
<p>本次只演示第二种情况，每个线程管理自己的事务，线程A的提交，不会影响到线程B的回滚。这也是相对常见的情况。</p>
<h2 id="1、环境搭建"><a href="#1、环境搭建" class="headerlink" title="1、环境搭建"></a>1、环境搭建</h2><p>1、导入 Maven 依赖</p>
<pre><code class="xml">&lt;parent&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
    &lt;version&gt;2.5.0&lt;/version&gt;
    &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;
&lt;/parent&gt;

&lt;properties&gt;
    &lt;maven.compiler.source&gt;11&lt;/maven.compiler.source&gt;
    &lt;maven.compiler.target&gt;11&lt;/maven.compiler.target&gt;
&lt;/properties&gt;

&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-data-jdbc&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
    &lt;artifactId&gt;lombok&lt;/artifactId&gt;
    &lt;optional&gt;true&lt;/optional&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.h2database&lt;/groupId&gt;
    &lt;artifactId&gt;h2&lt;/artifactId&gt;
    &lt;scope&gt;runtime&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre>
<p>2、properties 的配置</p>
<pre><code class="properties"># H2 数据库的配置
spring.datasource.driverClassName = org.h2.Driver
spring.datasource.url = jdbc:h2:mem:test_mem
spring.datasource.username = sa
spring.datasource.password = sa

# H2 数据库的访问配置
spring.h2.console.path = /h2
spring.h2.console.settings.web-allow-others = true
spring.h2.console.enabled = true

# 数据库的初始化脚本
spring.sql.init.platform = h2
spring.sql.init.schema-locations = classpath:db/schema.sql
spring.sql.init.data-locations = classpath:db/data.sql

# 日志的打印配置
#logging.level.org.springframework.jdbc.core.JdbcTemplate=DEBUG
#logging.level.org.springframework.jdbc.core.StatementCreatorUtils=TRACE
#logging.level.org.springframework.data.jdbc.repository.query=DEBUG
#logging.level.oorg.springframework.data.jdbc.core.JdbcAggregateTemplate=DEBUG
</code></pre>
<p>3、需要初始化的数据库脚本</p>
<ul>
<li><p>resources&#x2F;db&#x2F;schema.sql</p>
<pre><code class="sql">DROP TABLE IF EXISTS USER_INFO;
CREATE TABLE USER_INFO(USER_ID INT PRIMARY KEY AUTO_INCREMENT, USER_NAME VARCHAR(255));
</code></pre>
</li>
<li><p>resources&#x2F;db&#x2F;data.sql</p>
<pre><code class="sql">INSERT INTO USER_INFO VALUES(100000001, &#39;Hello&#39;);
INSERT INTO USER_INFO VALUES(100000002, &#39;World&#39;);
INSERT INTO USER_INFO VALUES(100000003, &#39;乔丹&#39;);
INSERT INTO USER_INFO VALUES(100000004, &#39;科比&#39;);
INSERT INTO USER_INFO VALUES(100000005, &#39;艾佛森&#39;);
INSERT INTO USER_INFO VALUES(100000006, &#39;麦迪&#39;);
</code></pre>
</li>
</ul>
<p>4、Java 实体类 以及一些工具方法</p>
<pre><code class="java">import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.springframework.data.annotation.Id;
import org.springframework.data.relational.core.mapping.Table;

import java.util.ArrayList;
import java.util.List;
import java.util.UUID;
import java.util.stream.Collectors;
import java.util.stream.Stream;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Table(&quot;USER_INFO&quot;)
public class UserInfo &#123;
    @Id
    private Integer userId;
    private String userName;

    public static List&lt;UserInfo&gt; getUserInfos(int size) &#123;
        return Stream.iterate(1, i -&gt; i + 1)
                .limit(size)
                .map(x -&gt; new UserInfo(x, UUID.randomUUID().toString()))
                .collect(Collectors.toList());
    &#125;

    /**
     * Splits a list into smaller sublists of a specified size.
     *
     * @param source        the original list to be partitioned
     * @param partitionSize the maximum size of each sublist
     * @param &lt;T&gt;           the type of elements in the list
     * @return a list of sublists
     */
    public static &lt;T&gt; List&lt;List&lt;T&gt;&gt; partition(List&lt;T&gt; source, int partitionSize) &#123;
        if (source == null || source.isEmpty() || partitionSize &lt;= 0) &#123;
            throw new IllegalArgumentException(&quot;Invalid input parameters.&quot;);
        &#125;

        List&lt;List&lt;T&gt;&gt; partitions = new ArrayList&lt;&gt;();
        int sourceSize = source.size();
        for (int i = 0; i &lt; sourceSize; i += partitionSize) &#123;
            partitions.add(new ArrayList&lt;&gt;(
                    source.subList(i, Math.min(i + partitionSize, sourceSize))
            ));
        &#125;
        return partitions;
    &#125;
&#125;
</code></pre>
<h2 id="2、CompletableFuture-TransactionManager-实现"><a href="#2、CompletableFuture-TransactionManager-实现" class="headerlink" title="2、CompletableFuture + TransactionManager 实现"></a>2、CompletableFuture + TransactionManager 实现</h2><p>操作示例一：每个线程提交或回滚自己的事务、互不干扰。这里使用 CompletableFuture + TransactionManager 演示无返回值的情况。</p>
<pre><code class="java">import lombok.extern.slf4j.Slf4j;
import org.springframework.data.jdbc.core.JdbcAggregateTemplate;
import org.springframework.stereotype.Component;
import org.springframework.transaction.PlatformTransactionManager;
import org.springframework.transaction.TransactionDefinition;
import org.springframework.transaction.TransactionStatus;
import org.springframework.transaction.support.DefaultTransactionDefinition;

import javax.annotation.Resource;
import java.util.List;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;
import java.util.stream.StreamSupport;

@Slf4j
@Component
public class ThreadTxTransactionManager1 &#123;
    // private static final int availableProcessors = Runtime.getRuntime().availableProcessors();
    private static final int availableProcessors = 5;
    private static final ThreadPoolExecutor executor = new ThreadPoolExecutor(
            availableProcessors,
            availableProcessors * 2,
            60L,
            TimeUnit.SECONDS,
            new LinkedBlockingQueue&lt;&gt;(1024),
            new ThreadPoolExecutor.CallerRunsPolicy());

    @Resource
    private PlatformTransactionManager transactionManager;
    @Resource
    private JdbcAggregateTemplate jdbcAggregateTemplate;

    public void tx() &#123;
        // 模拟需要新增的用户
        List&lt;UserInfo&gt; userInfos = UserInfo.getUserInfos(100_0000);
        // 切分集合, 相当于每个线程处理个集合大小
        List&lt;List&lt;UserInfo&gt;&gt; partitions = UserInfo.partition(userInfos, 20_0000);

        // 记录多线程的耗时
        long startTime = System.currentTimeMillis();

        CompletableFuture.allOf(partitions.stream().map(partition -&gt;
                CompletableFuture.runAsync(() -&gt; &#123;
                    // Spring事务内部由ThreadLocal存储事务绑定信息，因此需要每个线程新开一个事务
                    TransactionStatus transactionStatus = beginNewTransaction();
                    try &#123;
                        log.info(&quot;线程开始启动，线程名 = &#123;&#125;&quot;, Thread.currentThread().getName());

                        // TODO: DB代码 或者 业务代码 的操作, 这里只是简单插入数据
                        partition.forEach(jdbcAggregateTemplate::insert);
                        // 无任何异常提交事务
                        transactionManager.commit(transactionStatus);
                    &#125; catch (Exception e) &#123;
                        log.error(&quot;线程出现异常，线程名 = &#123;&#125;&quot;, Thread.currentThread().getName(), e);
                        // 出现异常回滚事务
                        transactionManager.rollback(transactionStatus);
                    &#125;
                &#125;, executor)).toArray(CompletableFuture[]::new)).join();

        // 记录插入数据总耗时
        log.info(&quot;插入数据总耗时: &#123;&#125;&quot;, System.currentTimeMillis() - startTime);

        // 验证数据是否插入成功
        Iterable&lt;UserInfo&gt; all = jdbcAggregateTemplate.findAll(UserInfo.class);
        long count = StreamSupport.stream(all.spliterator(), false).count();
        log.info(&quot;查询插入数据总数量: &#123;&#125;&quot;, count);
    &#125;

    private TransactionStatus beginNewTransaction() &#123;
        DefaultTransactionDefinition definition = new DefaultTransactionDefinition();
        definition.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRES_NEW);
        return transactionManager.getTransaction(definition);
    &#125;

&#125;
</code></pre>
<pre><code class="java">2024-08-25 14:30:01.647  INFO 22645 --- [pool-6-thread-5] c.e.s.t.t.ThreadTxTransactionManager1    : 线程开始启动，线程名 = pool-6-thread-5
2024-08-25 14:30:01.648  INFO 22645 --- [pool-6-thread-4] c.e.s.t.t.ThreadTxTransactionManager1    : 线程开始启动，线程名 = pool-6-thread-4
2024-08-25 14:30:01.647  INFO 22645 --- [pool-6-thread-2] c.e.s.t.t.ThreadTxTransactionManager1    : 线程开始启动，线程名 = pool-6-thread-2
2024-08-25 14:30:01.647  INFO 22645 --- [pool-6-thread-3] c.e.s.t.t.ThreadTxTransactionManager1    : 线程开始启动，线程名 = pool-6-thread-3
2024-08-25 14:30:01.648  INFO 22645 --- [pool-6-thread-1] c.e.s.t.t.ThreadTxTransactionManager1    : 线程开始启动，线程名 = pool-6-thread-1
2024-08-25 14:30:22.771  INFO 22645 --- [           main] c.e.s.t.t.ThreadTxTransactionManager1    : 插入数据总耗时: 21206
2024-08-25 14:30:28.387  INFO 22645 --- [           main] c.e.s.t.t.ThreadTxTransactionManager1    : 查询插入数据总数量: 1000006
</code></pre>
<p>操作示例二：每个线程提交或回滚自己的事务、互不干扰。这里使用 CompletableFuture + TransactionManager 演示有返回值的情况。</p>
<pre><code class="java">import lombok.extern.slf4j.Slf4j;
import org.springframework.data.jdbc.core.JdbcAggregateTemplate;
import org.springframework.stereotype.Component;
import org.springframework.transaction.PlatformTransactionManager;
import org.springframework.transaction.TransactionDefinition;
import org.springframework.transaction.TransactionStatus;
import org.springframework.transaction.support.DefaultTransactionDefinition;

import javax.annotation.Resource;
import java.util.Collection;
import java.util.List;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;
import java.util.stream.Collectors;
import java.util.stream.StreamSupport;

@Slf4j
@Component
public class ThreadTxTransactionManager2 &#123;
    // private static final int availableProcessors = Runtime.getRuntime().availableProcessors();
    private static final int availableProcessors = 5;
    private static final ThreadPoolExecutor executor = new ThreadPoolExecutor(
            availableProcessors,
            availableProcessors * 2,
            60L,
            TimeUnit.SECONDS,
            new LinkedBlockingQueue&lt;&gt;(1024),
            new ThreadPoolExecutor.CallerRunsPolicy());

    @Resource
    private PlatformTransactionManager transactionManager;
    @Resource
    private JdbcAggregateTemplate jdbcAggregateTemplate;

    public void tx() &#123;
        // 模拟需要新增的用户
        List&lt;UserInfo&gt; userInfos = UserInfo.getUserInfos(100_0000);
        // 切分集合, 相当于每个线程处理个集合大小
        List&lt;List&lt;UserInfo&gt;&gt; partitions = UserInfo.partition(userInfos, 20_0000);

        // 记录多线程的耗时
        long startTime = System.currentTimeMillis();

        List&lt;CompletableFuture&lt;List&lt;UserInfo&gt;&gt;&gt; futures = partitions.stream().map(partition -&gt;
                CompletableFuture.supplyAsync(() -&gt; &#123;
                    // Spring事务内部由ThreadLocal存储事务绑定信息，因此需要每个线程新开一个事务
                    TransactionStatus transactionStatus = beginNewTransaction();
                    try &#123;
                        log.info(&quot;线程开始启动，线程名 = &#123;&#125;&quot;, Thread.currentThread().getName());

                        // TODO: DB代码 或者 业务代码 的操作, 这里只是简单插入数据
                        List&lt;UserInfo&gt; infos = partition.stream()
                                .map(jdbcAggregateTemplate::insert)
                                .collect(Collectors.toList());
                        // 无任何异常提交事务
                        transactionManager.commit(transactionStatus);
                        return infos;
                    &#125; catch (Exception e) &#123;
                        log.error(&quot;线程出现异常，线程名 = &#123;&#125;&quot;, Thread.currentThread().getName(), e);
                        // 出现异常回滚事务
                        transactionManager.rollback(transactionStatus);
                        throw new RuntimeException(e);
                    &#125;
                &#125;, executor)).collect(Collectors.toList());

        List&lt;UserInfo&gt; results = futures.stream()
                .map(CompletableFuture::join)
                .flatMap(Collection::stream)
                .collect(Collectors.toList());
        // 插入数据返回值数量
        log.info(&quot;插入数据总数量: &#123;&#125;&quot;, results.size());

        // 记录插入数据总耗时
        log.info(&quot;插入数据总耗时: &#123;&#125;&quot;, System.currentTimeMillis() - startTime);

        // 验证数据是否插入成功
        Iterable&lt;UserInfo&gt; all = jdbcAggregateTemplate.findAll(UserInfo.class);
        long count = StreamSupport.stream(all.spliterator(), false).count();
        log.info(&quot;查询插入数据总数量: &#123;&#125;&quot;, count);
    &#125;

    private TransactionStatus beginNewTransaction() &#123;
        DefaultTransactionDefinition definition = new DefaultTransactionDefinition();
        definition.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRES_NEW);
        return transactionManager.getTransaction(definition);
    &#125;

&#125;
</code></pre>
<pre><code class="java">2024-08-25 14:31:23.352  INFO 22714 --- [pool-7-thread-1] c.e.s.t.t.ThreadTxTransactionManager2    : 线程开始启动，线程名 = pool-7-thread-1
2024-08-25 14:31:23.353  INFO 22714 --- [pool-7-thread-5] c.e.s.t.t.ThreadTxTransactionManager2    : 线程开始启动，线程名 = pool-7-thread-5
2024-08-25 14:31:23.353  INFO 22714 --- [pool-7-thread-3] c.e.s.t.t.ThreadTxTransactionManager2    : 线程开始启动，线程名 = pool-7-thread-3
2024-08-25 14:31:23.353  INFO 22714 --- [pool-7-thread-4] c.e.s.t.t.ThreadTxTransactionManager2    : 线程开始启动，线程名 = pool-7-thread-4
2024-08-25 14:31:23.353  INFO 22714 --- [pool-7-thread-2] c.e.s.t.t.ThreadTxTransactionManager2    : 线程开始启动，线程名 = pool-7-thread-2
2024-08-25 14:31:46.975  INFO 22714 --- [           main] c.e.s.t.t.ThreadTxTransactionManager2    : 插入数据总数量: 1000000
2024-08-25 14:31:46.979  INFO 22714 --- [           main] c.e.s.t.t.ThreadTxTransactionManager2    : 插入数据总耗时: 23736
2024-08-25 14:31:52.430  INFO 22714 --- [           main] c.e.s.t.t.ThreadTxTransactionManager2    : 查询插入数据总数量: 1000006
</code></pre>
<h2 id="3、CompletableFuture-TransactionTemplate-实现"><a href="#3、CompletableFuture-TransactionTemplate-实现" class="headerlink" title="3、CompletableFuture + TransactionTemplate 实现"></a>3、CompletableFuture + TransactionTemplate 实现</h2><p>操作示例一：每个线程提交或回滚自己的事务、互不干扰。这里使用 CompletableFuture + TransactionTemplate 演示无返回值的情况。</p>
<pre><code class="java">import lombok.extern.slf4j.Slf4j;
import org.springframework.data.jdbc.core.JdbcAggregateTemplate;
import org.springframework.stereotype.Component;
import org.springframework.transaction.support.TransactionTemplate;

import javax.annotation.Resource;
import java.util.List;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;
import java.util.stream.StreamSupport;

@Slf4j
@Component
public class ThreadTxTransactionTemplate1 &#123;
    // private static final int availableProcessors = Runtime.getRuntime().availableProcessors();
    private static final int availableProcessors = 5;
    private static final ThreadPoolExecutor executor = new ThreadPoolExecutor(
            availableProcessors,
            availableProcessors * 2,
            60L,
            TimeUnit.SECONDS,
            new LinkedBlockingQueue&lt;&gt;(1024),
            new ThreadPoolExecutor.CallerRunsPolicy());

    @Resource
    private TransactionTemplate transactionTemplate;
    @Resource
    private JdbcAggregateTemplate jdbcAggregateTemplate;

    public void tx() &#123;
        // 模拟需要新增的用户
        List&lt;UserInfo&gt; userInfos = UserInfo.getUserInfos(100_0000);
        // 切分集合, 相当于每个线程处理个集合大小
        List&lt;List&lt;UserInfo&gt;&gt; partitions = UserInfo.partition(userInfos, 20_0000);

        // 记录多线程的耗时
        long startTime = System.currentTimeMillis();

        CompletableFuture.allOf(partitions.stream().map(partition -&gt;
                CompletableFuture.runAsync(() -&gt; transactionTemplate.executeWithoutResult(transactionStatus -&gt; &#123;
                    try &#123;
                        log.info(&quot;线程开始启动，线程名 = &#123;&#125;&quot;, Thread.currentThread().getName());

                        // TODO: DB代码 或者 业务代码 的操作, 这里只是简单插入数据
                        partition.forEach(jdbcAggregateTemplate::insert);
                        // 无任何异常会自动提交事务
                    &#125; catch (Exception e) &#123;
                        log.error(&quot;线程出现异常，线程名 = &#123;&#125;&quot;, Thread.currentThread().getName(), e);
                        // 出现异常回滚事务
                        transactionStatus.setRollbackOnly();
                    &#125;
                &#125;), executor)).toArray(CompletableFuture[]::new)).join();

        // 记录插入数据总耗时
        log.info(&quot;插入数据总耗时: &#123;&#125;&quot;, System.currentTimeMillis() - startTime);

        // 验证数据是否插入成功
        Iterable&lt;UserInfo&gt; all = jdbcAggregateTemplate.findAll(UserInfo.class);
        long count = StreamSupport.stream(all.spliterator(), false).count();
        log.info(&quot;查询插入数据总数量: &#123;&#125;&quot;, count);
    &#125;

&#125;
</code></pre>
<pre><code class="java">2024-08-25 14:32:26.978  INFO 22778 --- [pool-8-thread-2] c.e.s.t.t.ThreadTxTransactionTemplate1   : 线程开始启动，线程名 = pool-8-thread-2
2024-08-25 14:32:26.978  INFO 22778 --- [pool-8-thread-3] c.e.s.t.t.ThreadTxTransactionTemplate1   : 线程开始启动，线程名 = pool-8-thread-3
2024-08-25 14:32:26.977  INFO 22778 --- [pool-8-thread-5] c.e.s.t.t.ThreadTxTransactionTemplate1   : 线程开始启动，线程名 = pool-8-thread-5
2024-08-25 14:32:26.978  INFO 22778 --- [pool-8-thread-1] c.e.s.t.t.ThreadTxTransactionTemplate1   : 线程开始启动，线程名 = pool-8-thread-1
2024-08-25 14:32:26.977  INFO 22778 --- [pool-8-thread-4] c.e.s.t.t.ThreadTxTransactionTemplate1   : 线程开始启动，线程名 = pool-8-thread-4
2024-08-25 14:32:51.011  INFO 22778 --- [           main] c.e.s.t.t.ThreadTxTransactionTemplate1   : 插入数据总耗时: 24118
2024-08-25 14:32:56.696  INFO 22778 --- [           main] c.e.s.t.t.ThreadTxTransactionTemplate1   : 查询插入数据总数量: 1000006
</code></pre>
<p>操作示例二：每个线程提交或回滚自己的事务、互不干扰。这里使用 CompletableFuture + TransactionTemplate 演示有返回值的情况。</p>
<pre><code class="java">import com.example.springboot.tech.UserInfo;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.jdbc.core.JdbcAggregateTemplate;
import org.springframework.stereotype.Component;
import org.springframework.transaction.PlatformTransactionManager;
import org.springframework.transaction.TransactionDefinition;
import org.springframework.transaction.TransactionStatus;
import org.springframework.transaction.support.DefaultTransactionDefinition;
import org.springframework.transaction.support.TransactionTemplate;

import javax.annotation.Resource;
import java.util.Collection;
import java.util.List;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;
import java.util.stream.Collectors;
import java.util.stream.StreamSupport;

@Slf4j
@Component
public class ThreadTxTransactionTemplate2 &#123;
    // private static final int availableProcessors = Runtime.getRuntime().availableProcessors();
    private static final int availableProcessors = 5;
    private static final ThreadPoolExecutor executor = new ThreadPoolExecutor(
            availableProcessors,
            availableProcessors * 2,
            60L,
            TimeUnit.SECONDS,
            new LinkedBlockingQueue&lt;&gt;(1024),
            new ThreadPoolExecutor.CallerRunsPolicy());

    @Resource
    private TransactionTemplate transactionTemplate;
    @Resource
    private JdbcAggregateTemplate jdbcAggregateTemplate;

    public void tx() &#123;
        // 模拟需要新增的用户
        List&lt;UserInfo&gt; userInfos = UserInfo.getUserInfos(100_0000);
        // 切分集合, 相当于每个线程处理个集合大小
        List&lt;List&lt;UserInfo&gt;&gt; partitions = UserInfo.partition(userInfos, 20_0000);

        // 记录多线程的耗时
        long startTime = System.currentTimeMillis();

        CompletableFuture.allOf(partitions.stream().map(partition -&gt;
                CompletableFuture.runAsync(() -&gt; transactionTemplate.execute(transactionStatus -&gt; &#123;
                    try &#123;
                        log.info(&quot;线程开始启动，线程名 = &#123;&#125;&quot;, Thread.currentThread().getName());

                        // TODO: DB代码 或者 业务代码 的操作, 这里只是简单插入数据
                        List&lt;UserInfo&gt; infos = partition.stream()
                                .map(jdbcAggregateTemplate::insert)
                                .collect(Collectors.toList());
                        return infos;
                        // 无任何异常会自动提交事务
                    &#125; catch (Exception e) &#123;
                        log.error(&quot;线程出现异常，线程名 = &#123;&#125;&quot;, Thread.currentThread().getName(), e);
                        // 出现异常回滚事务
                        transactionStatus.setRollbackOnly();
                        throw new RuntimeException(e);
                    &#125;
                &#125;), executor)).toArray(CompletableFuture[]::new)).join();

        // 记录插入数据总耗时
        log.info(&quot;插入数据总耗时: &#123;&#125;&quot;, System.currentTimeMillis() - startTime);

        // 验证数据是否插入成功
        Iterable&lt;UserInfo&gt; all = jdbcAggregateTemplate.findAll(UserInfo.class);
        long count = StreamSupport.stream(all.spliterator(), false).count();
        log.info(&quot;查询插入数据总数量: &#123;&#125;&quot;, count);
    &#125;

&#125;
</code></pre>
<pre><code class="java">2024-08-25 14:33:50.508  INFO 22842 --- [pool-9-thread-3] c.e.s.t.t.ThreadTxTransactionTemplate2   : 线程开始启动，线程名 = pool-9-thread-3
2024-08-25 14:33:50.507  INFO 22842 --- [pool-9-thread-4] c.e.s.t.t.ThreadTxTransactionTemplate2   : 线程开始启动，线程名 = pool-9-thread-4
2024-08-25 14:33:50.507  INFO 22842 --- [pool-9-thread-1] c.e.s.t.t.ThreadTxTransactionTemplate2   : 线程开始启动，线程名 = pool-9-thread-1
2024-08-25 14:33:50.508  INFO 22842 --- [pool-9-thread-5] c.e.s.t.t.ThreadTxTransactionTemplate2   : 线程开始启动，线程名 = pool-9-thread-5
2024-08-25 14:33:50.508  INFO 22842 --- [pool-9-thread-2] c.e.s.t.t.ThreadTxTransactionTemplate2   : 线程开始启动，线程名 = pool-9-thread-2
2024-08-25 14:34:15.878  INFO 22842 --- [           main] c.e.s.t.t.ThreadTxTransactionTemplate2   : 插入数据总耗时: 25451
2024-08-25 14:34:21.349  INFO 22842 --- [           main] c.e.s.t.t.ThreadTxTransactionTemplate2   : 查询插入数据总数量: 1000006
</code></pre>
<p>注意：因为这里使用的是 CompletableFuture，所有无需使用 CountDownLatch 来控制，如果想使用 CountDownLatch 来控制主线程等待子线程，可以使用 executor.execute() 或者 executor.submit() 配合 CountDownLatch 来实现。这里就不演示了。</p>
<h1 id="Java-多线程数据库事务提交与回滚控制"><a href="#Java-多线程数据库事务提交与回滚控制" class="headerlink" title="Java 多线程数据库事务提交与回滚控制"></a>Java 多线程数据库事务提交与回滚控制</h1><blockquote>
<p>作者：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq273766764">圣心</a>、来源：Java多线程数据库事务提交控制：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq273766764/article/details/119972911">https://blog.csdn.net/qq273766764/article/details/119972911</a></p>
</blockquote>
<p>项目代码基于：H2 数据，开发框架为：SpringBoot、Spring-Data-JDBC。开发语言为：Java 11</p>
<p>项目代码：<a target="_blank" rel="noopener" href="https://gitee.com/john273766764/springboot-mybatis-threads">https://gitee.com/john273766764/springboot-mybatis-threads</a></p>
<p><strong>线程间不是同一个事务</strong>：因为数据库连接 Connection 以及 Spring 事务的参数（事务名、事务是否只读、事务传播行为等）是保存在 ThreadLocal 中，不同的线程中保存的 Connection 是不同的，所以数据库层面对于不同的连接就无法满足事务。</p>
<h2 id="1、项目环境的搭建"><a href="#1、项目环境的搭建" class="headerlink" title="1、项目环境的搭建"></a>1、项目环境的搭建</h2><p>1、导入 Maven 依赖</p>
<pre><code class="xml">&lt;parent&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
    &lt;version&gt;2.5.0&lt;/version&gt;
    &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;
&lt;/parent&gt;

&lt;properties&gt;
    &lt;maven.compiler.source&gt;11&lt;/maven.compiler.source&gt;
    &lt;maven.compiler.target&gt;11&lt;/maven.compiler.target&gt;
&lt;/properties&gt;

&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-data-jdbc&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
    &lt;artifactId&gt;lombok&lt;/artifactId&gt;
    &lt;optional&gt;true&lt;/optional&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.h2database&lt;/groupId&gt;
    &lt;artifactId&gt;h2&lt;/artifactId&gt;
    &lt;scope&gt;runtime&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre>
<p>2、properties 的配置</p>
<pre><code class="properties"># H2 数据库的配置
spring.datasource.driverClassName = org.h2.Driver
spring.datasource.url = jdbc:h2:mem:test_mem
spring.datasource.username = sa
spring.datasource.password = sa

# H2 数据库的访问配置
spring.h2.console.path = /h2
spring.h2.console.settings.web-allow-others = true
spring.h2.console.enabled = true

# 数据库的初始化脚本
spring.sql.init.platform = h2
spring.sql.init.schema-locations = classpath:db/schema.sql
spring.sql.init.data-locations = classpath:db/data.sql

# 日志的打印配置
#logging.level.org.springframework.jdbc.core.JdbcTemplate=DEBUG
#logging.level.org.springframework.jdbc.core.StatementCreatorUtils=TRACE
#logging.level.org.springframework.data.jdbc.repository.query=DEBUG
#logging.level.oorg.springframework.data.jdbc.core.JdbcAggregateTemplate=DEBUG
</code></pre>
<p>3、需要初始化的数据库脚本</p>
<ul>
<li><p>resources&#x2F;db&#x2F;schema.sql</p>
<pre><code class="sql">DROP TABLE IF EXISTS USER_INFO;
CREATE TABLE USER_INFO(USER_ID INT PRIMARY KEY AUTO_INCREMENT, USER_NAME VARCHAR(255));
</code></pre>
</li>
<li><p>resources&#x2F;db&#x2F;data.sql</p>
<pre><code class="sql">INSERT INTO USER_INFO VALUES(100000001, &#39;Hello&#39;);
INSERT INTO USER_INFO VALUES(100000002, &#39;World&#39;);
INSERT INTO USER_INFO VALUES(100000003, &#39;乔丹&#39;);
INSERT INTO USER_INFO VALUES(100000004, &#39;科比&#39;);
INSERT INTO USER_INFO VALUES(100000005, &#39;艾佛森&#39;);
INSERT INTO USER_INFO VALUES(100000006, &#39;麦迪&#39;);
</code></pre>
</li>
</ul>
<p>4、Java 实体类 以及一些工具方法</p>
<pre><code class="java">import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.springframework.data.annotation.Id;
import org.springframework.data.relational.core.mapping.Table;

import java.util.ArrayList;
import java.util.List;
import java.util.UUID;
import java.util.stream.Collectors;
import java.util.stream.Stream;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Table(&quot;USER_INFO&quot;)
public class UserInfo &#123;
    @Id
    private Integer userId;
    private String userName;

    public static List&lt;UserInfo&gt; getUserInfos(int size) &#123;
        return Stream.iterate(1, i -&gt; i + 1)
                .limit(size)
                .map(x -&gt; new UserInfo(x, UUID.randomUUID().toString()))
                .collect(Collectors.toList());
    &#125;

    /**
     * Splits a list into smaller sublists of a specified size.
     *
     * @param source        the original list to be partitioned
     * @param partitionSize the maximum size of each sublist
     * @param &lt;T&gt;           the type of elements in the list
     * @return a list of sublists
     */
    public static &lt;T&gt; List&lt;List&lt;T&gt;&gt; partition(List&lt;T&gt; source, int partitionSize) &#123;
        if (source == null || source.isEmpty() || partitionSize &lt;= 0) &#123;
            throw new IllegalArgumentException(&quot;Invalid input parameters.&quot;);
        &#125;

        List&lt;List&lt;T&gt;&gt; partitions = new ArrayList&lt;&gt;();
        int sourceSize = source.size();
        for (int i = 0; i &lt; sourceSize; i += partitionSize) &#123;
            partitions.add(new ArrayList&lt;&gt;(
                    source.subList(i, Math.min(i + partitionSize, sourceSize))
            ));
        &#125;
        return partitions;
    &#125;
&#125;
</code></pre>
<h2 id="2、循环操作的代码"><a href="#2、循环操作的代码" class="headerlink" title="2、循环操作的代码"></a>2、循环操作的代码</h2><p>先写一个最简单的for循环代码，看看耗时情况怎么样。</p>
<pre><code class="java">import lombok.extern.slf4j.Slf4j;
import org.springframework.data.jdbc.core.JdbcAggregateTemplate;
import org.springframework.stereotype.Service;
import org.springframework.util.StopWatch;

import javax.annotation.Resource;
import java.util.List;

@Slf4j
@Service
public class UserInfoService_1 &#123;

    @Resource
    JdbcAggregateTemplate jdbcAggregateTemplate;

    /***
     * 一条一条依次对 1000000 条数据进行更新操作
     * 耗时：39s, 40s, 42s
     */
    public void saves() &#123;
        // 模拟需要新增的用户
        List&lt;UserInfo&gt; userInfos = UserInfo.getUserInfos(100_0000);

        // 记录耗时
        StopWatch watch = new StopWatch();
        watch.start(&quot;autoTransactional&quot;);

        // 一条一条插入数据
        userInfos.forEach(jdbcAggregateTemplate::insert);

        watch.stop();
        log.info(watch.prettyPrint());
    &#125;
&#125;
</code></pre>
<p>测试代码：</p>
<pre><code class="java">import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

import javax.annotation.Resource;

@SpringBootTest
class ApplicationTests &#123;
    @Resource
    UserInfoService_1 userInfoService1;

    @Test
    void test1() &#123;
        userInfoService1.saves();
    &#125;
&#125;
</code></pre>
<p>输出结果：</p>
<pre><code class="java">2024-08-25 14:48:26.999  INFO 23545 --- [           main] c.e.springboot.tech.UserInfoService_1    : StopWatch &#39;&#39;: running time = 42033113041 ns
---------------------------------------------
ns         %     Task name
---------------------------------------------
42033113041  100%  autoTransactional
</code></pre>
<p>循环修改整体耗时约 <strong>42秒</strong>，且代码中没有手动事务控制应该是自动事务提交，所以每次操作事务都会提交所以操作比较慢，我们先对代码中添加手动事务控制，看查询效率怎样。</p>
<h2 id="3、使用手动事务的操作代码"><a href="#3、使用手动事务的操作代码" class="headerlink" title="3、使用手动事务的操作代码"></a>3、使用手动事务的操作代码</h2><p>修改后的代码如下：</p>
<pre><code class="java">import lombok.extern.slf4j.Slf4j;
import org.springframework.data.jdbc.core.JdbcAggregateTemplate;
import org.springframework.jdbc.datasource.DataSourceTransactionManager;
import org.springframework.stereotype.Service;
import org.springframework.transaction.TransactionDefinition;
import org.springframework.transaction.TransactionStatus;
import org.springframework.util.StopWatch;

import javax.annotation.Resource;
import java.util.List;

@Slf4j
@Service
public class UserInfoService_2 &#123;

    @Resource
    JdbcAggregateTemplate jdbcAggregateTemplate;
    @Resource
    DataSourceTransactionManager dataSourceTransactionManager;
    @Resource
    TransactionDefinition transactionDefinition;

    /***
     * 由于希望更新操作 一次性完成，需要手动控制添加事务
     * 耗时：38s, 37s, 38s
     * 从测试结果可以看出，添加事务后插入数据的效率有明显的提升
     */
    public void saves() &#123;
        // 模拟需要新增的用户
        List&lt;UserInfo&gt; userInfos = UserInfo.getUserInfos(100_0000);

        // 记录耗时
        StopWatch watch = new StopWatch();
        watch.start(&quot;manualTransactional&quot;);

        // 手动开启事务
        TransactionStatus transactionStatus = dataSourceTransactionManager.getTransaction(transactionDefinition);
        try &#123;
            // 插入数据
            userInfos.forEach(jdbcAggregateTemplate::insert);
            // 确保事务只提交一次, 不能先提交事务, 然后再次回滚或者重提提交事务
            dataSourceTransactionManager.commit(transactionStatus);
            log.info(&quot;manual transaction committed&quot;);
        &#125; catch (Exception e) &#123;
            // 如果事务提交失败，这里才会进行回滚
            if (!transactionStatus.isCompleted()) &#123;
                dataSourceTransactionManager.rollback(transactionStatus);
            &#125;
            log.error(&quot;Transaction failed and rolled back&quot;, e);
        &#125; finally &#123;
            watch.stop();
            log.info(watch.prettyPrint());
        &#125;
    &#125;
&#125;
</code></pre>
<p>测试代码</p>
<pre><code class="java">import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;
import javax.annotation.Resource;

@SpringBootTest
class ApplicationTests &#123;
    @Resource
    UserInfoService_2 userInfoService2;

    @Test
    void test2() &#123;
        userInfoService2.saves();
    &#125;
&#125;
</code></pre>
<p>输出结果</p>
<pre><code class="java">2024-08-25 14:50:23.698  INFO 23645 --- [           main] c.e.springboot.tech.UserInfoService_2    : manual transaction committed
2024-08-25 14:50:23.701  INFO 23645 --- [           main] c.e.springboot.tech.UserInfoService_2    : StopWatch &#39;&#39;: running time = 39086357708 ns
---------------------------------------------
ns         %     Task name
---------------------------------------------
39086357708  100%  manualTransactional
</code></pre>
<p>添加手动事务操控制后，整体耗时约 <strong>39秒</strong>，这相对于自动事务提交的代码，快了约3-4秒，<strong>对于大量循环数据库提交操作，添加手动事务可以有效提高操作效率。</strong></p>
<h2 id="4、尝试多线程进行数据修改【两种方案】"><a href="#4、尝试多线程进行数据修改【两种方案】" class="headerlink" title="4、尝试多线程进行数据修改【两种方案】"></a>4、尝试多线程进行数据修改【两种方案】</h2><p><strong>线程间不是同一个事务</strong>：因为数据库连接 Connection 以及 Spring 事务的参数（事务名、事务是否只读、事务传播行为等）是保存在 ThreadLocal 中，不同的线程中保存的 Connection 是不同的，所以数据库层面对于不同的连接就无法满足事务。</p>
<h3 id="1、线程池的最大线程数小于任务列表的数量"><a href="#1、线程池的最大线程数小于任务列表的数量" class="headerlink" title="1、线程池的最大线程数小于任务列表的数量"></a>1、线程池的最大线程数小于任务列表的数量</h3><blockquote>
<p>如下是方案一：线程池的最大线程数大于或等于任务列表的数量。</p>
</blockquote>
<p>添加数据库手动事务后操作效率有明细提高，但还是比较长，接下来尝试多线程提交看是不是能够再快一些。具体代码如下：</p>
<pre><code class="java">import lombok.extern.slf4j.Slf4j;
import org.springframework.data.jdbc.core.JdbcAggregateTemplate;
import org.springframework.jdbc.datasource.DataSourceTransactionManager;
import org.springframework.stereotype.Service;
import org.springframework.transaction.TransactionDefinition;
import org.springframework.transaction.TransactionStatus;
import org.springframework.util.StopWatch;

import javax.annotation.Resource;
import java.util.List;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import java.util.stream.Collectors;

@Slf4j
@Service
public class UserInfoService_3 &#123;

    @Resource
    JdbcAggregateTemplate jdbcAggregateTemplate;
    @Resource
    DataSourceTransactionManager dataSourceTransactionManager;
    @Resource
    TransactionDefinition transactionDefinition;

    /**
     * 线程数量
     */
    public static final int THREAD_COUNT = 5;
    /**
     * 线程池初初始化
     */
    public static final ExecutorService THREAD_POOL = Executors.newFixedThreadPool(THREAD_COUNT);

    /**
     * 使用多线程创建1000000条数据
     * 耗时统计
     *  1 线程数：1      耗时：37s
     *  2 线程数：2      耗时：25s
     *  3 线程数：5      耗时：21s
     *  4 线程数：10     耗时：21s
     *  5 线程数：100    耗时：29s
     */
    public void saves() &#123;
        // 模拟需要新增的用户
        List&lt;UserInfo&gt; userInfos = UserInfo.getUserInfos(100_0000);

        // 每个线程处理的数据量
        int dataPortionLength = (userInfos.size() + THREAD_COUNT - 1) / THREAD_COUNT;

        // 记录耗时
        StopWatch watch = new StopWatch();
        watch.start(&quot;manualTransactional&quot;);

        CountDownLatch threadLatch = new CountDownLatch(THREAD_COUNT);

        for (int i = 0; i &lt; THREAD_COUNT; i++) &#123;
            // 每个线程处理的数据
            List&lt;UserInfo&gt; threadData = userInfos.stream()
                    .skip(i * dataPortionLength)
                    .limit(dataPortionLength)
                    .collect(Collectors.toList());
            THREAD_POOL.execute(() -&gt; this.savaUserInfos(threadData, threadLatch));
            // CompletableFuture.runAsync(() -&gt; this.savaUserInfos(threadData, threadLatch), THREAD_POOL);
        &#125;


        try &#123;
            // 倒计时锁设置超时时间 300s
            boolean await = threadLatch.await(300, TimeUnit.SECONDS);
            // 等待超时，事务回滚
            if (!await) &#123;
               log.error(&quot;CountDownLatch await timeout&quot;);
            &#125;
            log.info(&quot;manual transaction completed&quot;);
        &#125; catch (Throwable e) &#123;
            log.error(e.getMessage(), e);
        &#125;

        log.info(&quot;============================== 主线程完成 ==============================&quot;);
        watch.stop();
        log.info(watch.prettyPrint());
    &#125;

    public void savaUserInfos(List&lt;UserInfo&gt; userInfos, CountDownLatch threadLatch) &#123;
        TransactionStatus transactionStatus = dataSourceTransactionManager.getTransaction(transactionDefinition);
        log.info(&quot;子线程：&#123;&#125;&quot;, Thread.currentThread().getName());
        try &#123;
            userInfos.forEach(jdbcAggregateTemplate::insert);
            dataSourceTransactionManager.commit(transactionStatus);
            log.info(&quot;commited &#123;&#125;&quot;, Thread.currentThread().getName());
        &#125; catch (Throwable e) &#123;
            dataSourceTransactionManager.rollback(transactionStatus);
            log.info(&quot;rollback &#123;&#125;&quot;, Thread.currentThread().getName());
        &#125; finally &#123;
            threadLatch.countDown();
        &#125;
    &#125;
&#125;
</code></pre>
<p>批量测试代码，我们采用了多线程进行提交，修改后测试代码如下：</p>
<pre><code class="java">import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;
import javax.annotation.Resource;

@SpringBootTest
class ApplicationTests &#123;
    @Resource
    UserInfoService_3 userInfoService3;

    @Test
    void test3() &#123;
        userInfoService3.saves();
    &#125;
&#125;
</code></pre>
<p>输出结果</p>
<pre><code class="java">2024-08-25 14:56:43.019  INFO 24605 --- [pool-1-thread-1] c.e.springboot.tech.UserInfoService_3    : 子线程：pool-1-thread-1
2024-08-25 14:56:43.043  INFO 24605 --- [pool-1-thread-2] c.e.springboot.tech.UserInfoService_3    : 子线程：pool-1-thread-2
2024-08-25 14:56:43.063  INFO 24605 --- [pool-1-thread-3] c.e.springboot.tech.UserInfoService_3    : 子线程：pool-1-thread-3
2024-08-25 14:56:43.109  INFO 24605 --- [pool-1-thread-4] c.e.springboot.tech.UserInfoService_3    : 子线程：pool-1-thread-4
2024-08-25 14:56:43.179  INFO 24605 --- [pool-1-thread-5] c.e.springboot.tech.UserInfoService_3    : 子线程：pool-1-thread-5
2024-08-25 14:57:08.310  INFO 24605 --- [pool-1-thread-1] c.e.springboot.tech.UserInfoService_3    : commited pool-1-thread-1
2024-08-25 14:57:08.431  INFO 24605 --- [pool-1-thread-5] c.e.springboot.tech.UserInfoService_3    : commited pool-1-thread-5
2024-08-25 14:57:08.479  INFO 24605 --- [pool-1-thread-3] c.e.springboot.tech.UserInfoService_3    : commited pool-1-thread-3
2024-08-25 14:57:08.500  INFO 24605 --- [pool-1-thread-2] c.e.springboot.tech.UserInfoService_3    : commited pool-1-thread-2
2024-08-25 14:57:08.511  INFO 24605 --- [pool-1-thread-4] c.e.springboot.tech.UserInfoService_3    : commited pool-1-thread-4
2024-08-25 14:57:08.515  INFO 24605 --- [           main] c.e.springboot.tech.UserInfoService_3    : manual transaction completed
2024-08-25 14:57:08.515  INFO 24605 --- [           main] c.e.springboot.tech.UserInfoService_3    : ============================== 主线程完成 ==============================
2024-08-25 14:57:08.520  INFO 24605 --- [           main] c.e.springboot.tech.UserInfoService_3    : StopWatch &#39;&#39;: running time = 21574228917 ns
---------------------------------------------
ns         %     Task name
---------------------------------------------
21574228917  100%  manualTransactional
</code></pre>
<p>我们尝试了不同线程数对提交速度的影响，具体可以看下面表格，多线程修改50000条数据时 不同线程数耗时对比（秒）</p>
<table>
<thead>
<tr>
<th>线程数</th>
<th>1</th>
<th>2</th>
<th>5</th>
<th>10</th>
<th>100</th>
</tr>
</thead>
<tbody><tr>
<td>耗时</td>
<td>37s</td>
<td>25s</td>
<td>21s</td>
<td>21s</td>
<td>29s</td>
</tr>
</tbody></table>
<p><strong>根据表格，我们线程数增大提交速度并非一直增大，在当前情况下约在2-5个线程数时，提交速度最快（实际线程数还是需要根据服务器配置实际测试）</strong>。</p>
<h3 id="2、线程池的最大线程数小于任务列表的数量"><a href="#2、线程池的最大线程数小于任务列表的数量" class="headerlink" title="2、线程池的最大线程数小于任务列表的数量"></a>2、线程池的最大线程数小于任务列表的数量</h3><p>如下为方案二：线程池的最大线程数小于任务列表的数量。</p>
<p>不知道大家有没有注意到，如上的方式都是一次性使用完线程池中的所有线程，并没有让线程池出现等待的情况，也是是线程数大于线程池配置的核心数，下面我们来模拟此种情况。我们线程池配置5个核心数，需要跑的线程有10个。</p>
<pre><code class="java">import lombok.extern.slf4j.Slf4j;
import org.springframework.data.jdbc.core.JdbcAggregateTemplate;
import org.springframework.stereotype.Service;
import org.springframework.transaction.PlatformTransactionManager;
import org.springframework.transaction.TransactionDefinition;
import org.springframework.transaction.TransactionStatus;
import org.springframework.util.StopWatch;

import javax.annotation.Resource;
import java.util.List;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

@Slf4j
@Service
public class UserInfoService_33 &#123;

    @Resource
    JdbcAggregateTemplate jdbcAggregateTemplate;
    @Resource
    PlatformTransactionManager transactionManager;
    @Resource
    TransactionDefinition transactionDefinition;

    /**
     * 线程数量
     */
    public static final int THREAD_COUNT = 5;
    /**
     * 线程池初初始化
     */
    public static final ExecutorService THREAD_POOL = Executors.newFixedThreadPool(THREAD_COUNT);

    /**
     * 使用多线程创建1000000条数据
     * 耗时统计
     * 1 线程数：1      耗时：38s
     * 2 线程数：2      耗时：27s
     * 3 线程数：5      耗时：21s
     * 4 线程数：10     耗时：25s
     * 5 线程数：100    耗时：29s
     */
    public void saves() &#123;
        // 模拟需要新增的用户
        List&lt;UserInfo&gt; userInfos = UserInfo.getUserInfos(100_0000);

        // 切分集合, 相当于每个线程处理个集合大小
        List&lt;List&lt;UserInfo&gt;&gt; partitions = UserInfo.partition(userInfos, 10_0000);

        // 记录耗时
        StopWatch watch = new StopWatch();
        watch.start(&quot;manualTransactional&quot;);

        // 这里使用 Stream + CompletableFuture, join() 等待所有线程执行完毕
        CompletableFuture.allOf(partitions.stream().map(partition -&gt;
                CompletableFuture.runAsync(() -&gt; &#123;
                    TransactionStatus transactionStatus = transactionManager.getTransaction(transactionDefinition);
                    log.info(&quot;子线程：&#123;&#125;&quot;, Thread.currentThread().getName());
                    try &#123;
                        partition.forEach(jdbcAggregateTemplate::insert);
                        transactionManager.commit(transactionStatus);
                        log.info(&quot;commited &#123;&#125;&quot;, Thread.currentThread().getName());
                    &#125; catch (Throwable e) &#123;
                        transactionManager.rollback(transactionStatus);
                        log.info(&quot;rollback &#123;&#125;&quot;, Thread.currentThread().getName());
                    &#125;
                &#125;, THREAD_POOL)
        ).toArray(CompletableFuture[]::new)).join();

        log.info(&quot;============================== 主线程完成 ==============================&quot;);
        watch.stop();
        log.info(watch.prettyPrint());
        // 关闭线程池
        THREAD_POOL.shutdown();
    &#125;

&#125;
</code></pre>
<p>测试代码</p>
<pre><code class="java">import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;
import javax.annotation.Resource;

@SpringBootTest
class ApplicationTests &#123;
    @Resource
    UserInfoService_33 userInfoService33;

    @Test
    void test33() &#123;
        userInfoService33.saves();
    &#125;
&#125;
</code></pre>
<p>输出结果</p>
<pre><code class="java">2024-08-25 15:13:00.670  INFO 25479 --- [pool-2-thread-2] c.e.springboot.tech.UserInfoService_33   : 子线程：pool-2-thread-2
2024-08-25 15:13:00.669  INFO 25479 --- [pool-2-thread-5] c.e.springboot.tech.UserInfoService_33   : 子线程：pool-2-thread-5
2024-08-25 15:13:00.670  INFO 25479 --- [pool-2-thread-1] c.e.springboot.tech.UserInfoService_33   : 子线程：pool-2-thread-1
2024-08-25 15:13:00.669  INFO 25479 --- [pool-2-thread-4] c.e.springboot.tech.UserInfoService_33   : 子线程：pool-2-thread-4
2024-08-25 15:13:00.669  INFO 25479 --- [pool-2-thread-3] c.e.springboot.tech.UserInfoService_33   : 子线程：pool-2-thread-3
2024-08-25 15:13:15.550  INFO 25479 --- [pool-2-thread-5] c.e.springboot.tech.UserInfoService_33   : commited pool-2-thread-5
2024-08-25 15:13:15.564  INFO 25479 --- [pool-2-thread-5] c.e.springboot.tech.UserInfoService_33   : 子线程：pool-2-thread-5
2024-08-25 15:13:15.715  INFO 25479 --- [pool-2-thread-1] c.e.springboot.tech.UserInfoService_33   : commited pool-2-thread-1
2024-08-25 15:13:15.715  INFO 25479 --- [pool-2-thread-4] c.e.springboot.tech.UserInfoService_33   : commited pool-2-thread-4
2024-08-25 15:13:15.716  INFO 25479 --- [pool-2-thread-3] c.e.springboot.tech.UserInfoService_33   : commited pool-2-thread-3
2024-08-25 15:13:15.716  INFO 25479 --- [pool-2-thread-1] c.e.springboot.tech.UserInfoService_33   : 子线程：pool-2-thread-1
2024-08-25 15:13:15.716  INFO 25479 --- [pool-2-thread-4] c.e.springboot.tech.UserInfoService_33   : 子线程：pool-2-thread-4
2024-08-25 15:13:15.716  INFO 25479 --- [pool-2-thread-3] c.e.springboot.tech.UserInfoService_33   : 子线程：pool-2-thread-3
2024-08-25 15:13:16.057  INFO 25479 --- [pool-2-thread-2] c.e.springboot.tech.UserInfoService_33   : commited pool-2-thread-2
2024-08-25 15:13:16.075  INFO 25479 --- [pool-2-thread-2] c.e.springboot.tech.UserInfoService_33   : 子线程：pool-2-thread-2
2024-08-25 15:13:24.485  INFO 25479 --- [pool-2-thread-1] c.e.springboot.tech.UserInfoService_33   : commited pool-2-thread-1
2024-08-25 15:13:24.594  INFO 25479 --- [pool-2-thread-4] c.e.springboot.tech.UserInfoService_33   : commited pool-2-thread-4
2024-08-25 15:13:24.613  INFO 25479 --- [pool-2-thread-5] c.e.springboot.tech.UserInfoService_33   : commited pool-2-thread-5
2024-08-25 15:13:24.617  INFO 25479 --- [pool-2-thread-2] c.e.springboot.tech.UserInfoService_33   : commited pool-2-thread-2
2024-08-25 15:13:24.624  INFO 25479 --- [pool-2-thread-3] c.e.springboot.tech.UserInfoService_33   : commited pool-2-thread-3
2024-08-25 15:13:24.625  INFO 25479 --- [           main] c.e.springboot.tech.UserInfoService_33   : ============================== 主线程完成 ==============================
2024-08-25 15:13:24.628  INFO 25479 --- [           main] c.e.springboot.tech.UserInfoService_33   : StopWatch &#39;&#39;: running time = 24033524417 ns
---------------------------------------------
ns         %     Task name
---------------------------------------------
24033524417  100%  manualTransactional
</code></pre>
<h2 id="5、两个-CountDownLatch-控制多线程事务提交【2PC】"><a href="#5、两个-CountDownLatch-控制多线程事务提交【2PC】" class="headerlink" title="5、两个 CountDownLatch 控制多线程事务提交【2PC】"></a>5、两个 CountDownLatch 控制多线程事务提交【2PC】</h2><blockquote>
<p>解决思路（分布式事务思路）：</p>
<p>既然Spring提供的声明式事务注解@Transactional无法满足多线程间的事务一致性，那可以试试通过编程式事务的方式来解决。主要思路：每个线程都开启各自的事务，待所有线程的业务执行完成，统一提交或回滚。</p>
<p>我的解决方案参考分布式事务2PC（Two-phase commit protocol），中文叫二阶段提交。需要注意的是2PC是同步阻塞协议，各个线程需要等待所有的线程执行完成后才能进行下一步操作，在使用线程池执行任务时，<strong>如果线程池的最大线程数小于任务列表的数量，就会发生“死锁”</strong>，即获取到线程的任务阻塞等待没有获取线程的任务执行完成，而没有获取线程的任务会在阻塞队列中等待空闲线程的调用。这种情况需要使用一阶段的超时机制来“解开”，超时机制会发送回滚命令，线程池收到后进行回滚，但这种情况任务始终无法提交，再次提交结果依然是等到超时再回滚。再使用中需要结合具体业务来对线程池参数以及数据库连接池参数进行合理的设置。如果这里听的优点迷，可以先看下面具体代码实现再来结合这段文字思考。</p>
</blockquote>
<p>由于多线程提交时，每个线程事务时单独的，无法保证一致性，我们尝试给多线程添加事务控制，来保证每个线程都是在插入数据完成后在提交事务，</p>
<p><strong>这里我们使用两个 CountDownLatch 来控制主线程与子线程事务提交，并设置了超时时间为 30 秒</strong>。我们对代码进行了一点修改：</p>
<pre><code class="java">import lombok.extern.slf4j.Slf4j;
import org.springframework.data.jdbc.core.JdbcAggregateTemplate;
import org.springframework.stereotype.Service;
import org.springframework.transaction.PlatformTransactionManager;
import org.springframework.transaction.TransactionDefinition;
import org.springframework.transaction.TransactionStatus;
import org.springframework.util.StopWatch;

import javax.annotation.Resource;
import java.util.List;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.stream.Collectors;

@Slf4j
@Service
public class UserInfoService_4 &#123;

    @Resource
    JdbcAggregateTemplate jdbcAggregateTemplate;
    @Resource
    PlatformTransactionManager transactionManager;
    @Resource
    TransactionDefinition transactionDefinition;

    /**
     * 线程数量
     */
    public static final int THREAD_COUNT = 5;
    /**
     * 线程池初初始化
     */
    public static final ExecutorService THREAD_POOL = Executors.newFixedThreadPool(THREAD_COUNT);

    /**
     * 使用多线程创建1000000条数据
     * 耗时统计
     *  1 线程数：1      耗时：36s
     *  2 线程数：2      耗时：22s
     *  3 线程数：5      耗时：18s
     *  4 线程数：10     耗时：21s
     *  5 线程数：100    耗时：33s
     *  6 线程数：200    耗时：29s
     *  7 线程数：500    耗时：44s
     */
    public void saves() &#123;
        // 模拟需要新增的用户
        List&lt;UserInfo&gt; userInfos = UserInfo.getUserInfos(100_0000);

        // 每个线程处理的数据量
        int dataPortionLength = (userInfos.size() + THREAD_COUNT - 1) / THREAD_COUNT;

        // 记录耗时
        StopWatch watch = new StopWatch();
        watch.start(&quot;manualTransactional&quot;);

        /**
         * 由于每个线程都是单独的事务，需要添加对线程事务的统一控制
         * 我们这边使用两个 CountDownLatch 对子线程的事务进行控制
         */
        // 用于计算子线程提交数量
        CountDownLatch threadLatch = new CountDownLatch(THREAD_COUNT);
        // 用于判断主线程是否提交
        CountDownLatch mainLatch = new CountDownLatch(1);
        // 用于判断子线程任务是否有错误
        AtomicBoolean isError = new AtomicBoolean();

        for (int i = 0; i &lt; THREAD_COUNT; i++) &#123;
            // 每个线程处理的数据
            List&lt;UserInfo&gt; threadData = userInfos.stream()
                    .skip(i * dataPortionLength)
                    .limit(dataPortionLength)
                    .collect(Collectors.toList());
            THREAD_POOL.execute(() -&gt; this.savaUserInfos(threadData, threadLatch, mainLatch, isError));
            // CompletableFuture.runAsync(() -&gt; this.savaUserInfos(threadData, threadLatch), THREAD_POOL);
        &#125;

        try &#123;
            // 倒计时锁设置超时时间 300s
            boolean await = threadLatch.await(300, TimeUnit.SECONDS);
            // 等待超时，事务回滚
            if (!await) &#123;
                isError.set(true);
            &#125;
        &#125; catch (Throwable e) &#123;
            isError.set(true);
            log.error(e.getMessage(), e);
        &#125;
        // 切换到子线程执行
        mainLatch.countDown();
        // 关闭线程池
        THREAD_POOL.shutdown();

        log.info(&quot;============================== 主线程完成 ==============================&quot;);
        watch.stop();
        log.info(watch.prettyPrint());
    &#125;

    public void savaUserInfos(List&lt;UserInfo&gt; userInfos, CountDownLatch threadLatch, CountDownLatch mainLatch, AtomicBoolean isError) &#123;
        TransactionStatus transactionStatus = transactionManager.getTransaction(transactionDefinition);
        log.info(&quot;子线程：&#123;&#125;&quot;, Thread.currentThread().getName());
        try &#123;
            userInfos.forEach(jdbcAggregateTemplate::insert);
        &#125; catch (Throwable e) &#123;
            isError.set(true);
            log.error(&quot;insert error: &quot;, e);
        &#125; finally &#123;
            // 切换到主线程执行
            threadLatch.countDown();
        &#125;
        try &#123;
            mainLatch.await();
        &#125; catch (InterruptedException e) &#123;
            isError.set(true);
            log.error(&quot;mainLatch wait error: &quot;, e);
        &#125;
        // 判断是否有错误，如有错误 就回滚事务
        if (isError.get()) &#123;
            transactionManager.rollback(transactionStatus);
            log.info(&quot;rollback &#123;&#125;&quot;, Thread.currentThread().getName());
        &#125; else &#123;
            transactionManager.commit(transactionStatus);
            log.info(&quot;commited &#123;&#125;&quot;, Thread.currentThread().getName());
        &#125;
    &#125;
&#125;
</code></pre>
<p>测试代码</p>
<pre><code class="java">import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;
import javax.annotation.Resource;

@SpringBootTest
class ApplicationTests &#123;
    @Resource
    UserInfoService_4 userInfoService4;

    @Test
    void test4() &#123;
        userInfoService4.saves();
    &#125;
&#125;
</code></pre>
<p>输出结果</p>
<pre><code class="java">2024-08-25 15:00:31.305  INFO 24810 --- [pool-3-thread-1] c.e.springboot.tech.UserInfoService_4    : 子线程：pool-3-thread-1
2024-08-25 15:00:31.326  INFO 24810 --- [pool-3-thread-2] c.e.springboot.tech.UserInfoService_4    : 子线程：pool-3-thread-2
2024-08-25 15:00:31.342  INFO 24810 --- [pool-3-thread-3] c.e.springboot.tech.UserInfoService_4    : 子线程：pool-3-thread-3
2024-08-25 15:00:31.361  INFO 24810 --- [pool-3-thread-4] c.e.springboot.tech.UserInfoService_4    : 子线程：pool-3-thread-4
2024-08-25 15:00:31.379  INFO 24810 --- [pool-3-thread-5] c.e.springboot.tech.UserInfoService_4    : 子线程：pool-3-thread-5
2024-08-25 15:00:53.607  INFO 24810 --- [           main] c.e.springboot.tech.UserInfoService_4    : ============================== 主线程完成 ==============================
2024-08-25 15:00:53.632  INFO 24810 --- [           main] c.e.springboot.tech.UserInfoService_4    : StopWatch &#39;&#39;: running time = 21372770250 ns
---------------------------------------------
ns         %     Task name
---------------------------------------------
21372770250  100%  manualTransactional
</code></pre>
<hr>
<p>本想再次测试一下不同线程数对执行效率的影响时，发现当线程数超过10个时，执行时就报错。具体错误内容如下：</p>
<pre><code class="java">Exception in thread &quot;pool-1-thread-2&quot; org.springframework.transaction.CannotCreateTransactionException: Could not open JDBC Connection for transaction; nested exception is java.sql.SQLTransientConnectionException: HikariPool-1 - Connection is not available, request timed out after 30055ms.
    at org.springframework.jdbc.datasource.DataSourceTransactionManager.doBegin(DataSourceTransactionManager.java:309)
    at org.springframework.transaction.support.AbstractPlatformTransactionManager.startTransaction(AbstractPlatformTransactionManager.java:400)
    at org.springframework.transaction.support.AbstractPlatformTransactionManager.getTransaction(AbstractPlatformTransactionManager.java:373)
    at com.example.springbootmybatis.service.Impl.StudentServiceImpl.updateStudentsThread(StudentServiceImpl.java:58)
    at com.example.springbootmybatis.StudentTest.lambda$updateStudentWithThreadsAndTrans$3(StudentTest.java:164)
    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
    at java.lang.Thread.run(Thread.java:748)
Caused by: java.sql.SQLTransientConnectionException: HikariPool-1 - Connection is not available, request timed out after 30055ms.
    at com.zaxxer.hikari.pool.HikariPool.createTimeoutException(HikariPool.java:696)
    at com.zaxxer.hikari.pool.HikariPool.getConnection(HikariPool.java:197)
    at com.zaxxer.hikari.pool.HikariPool.getConnection(HikariPool.java:162)
    at com.zaxxer.hikari.HikariDataSource.getConnection(HikariDataSource.java:128)
    at org.springframework.jdbc.datasource.DataSourceTransactionManager.doBegin(DataSourceTransactionManager.java:265)
    ... 7 more
</code></pre>
<p>错误的大致意思时，不能为数据库事务打开 jdbc Connection，连接在30s的时候超时了。由于前面启动的十个线程需要等待主线程完成后才能提交，所以一直占用连接未释放，造成后面的进程创建连接超时。</p>
<p>看错误日志中错误的来源是 <strong>HikariPool</strong> ，我们来重新配置一下这个连接池的参数，将最大连接数修改为100，具体配置如下：</p>
<pre><code class="properties"># 连接池中允许的最小连接数。缺省值：10
spring.datasource.hikari.minimum-idle=10
# 连接池中允许的最大连接数。缺省值：10
spring.datasource.hikari.maximum-pool-size=100
# 自动提交
spring.datasource.hikari.auto-commit=true
# 一个连接idle状态的最大时长（毫秒），超时则被释放（retired），缺省:10分钟
spring.datasource.hikari.idle-timeout=30000
# 一个连接的生命时长（毫秒），超时而且没被使用则被释放（retired），缺省:30分钟，建议设置比数据库超时时长少30秒
spring.datasource.hikari.max-lifetime=1800000
# 等待连接池分配连接的最大时长（毫秒），超过这个时长还没可用的连接则发生SQLException， 缺省:30秒
</code></pre>
<p>再次执行测试发现没有报错，修改线程数为20又执行了一下，同样执行成功了。</p>
<h2 id="6、TransactionStatus-集合控制多线程事务【不推荐】"><a href="#6、TransactionStatus-集合控制多线程事务【不推荐】" class="headerlink" title="6、TransactionStatus 集合控制多线程事务【不推荐】"></a>6、TransactionStatus 集合控制多线程事务【不推荐】</h2><p>在查询了需要教程后我们还可以使用事务集合来进行多线程事务控制，这里需要特别注意的是，事务的开启与提交必须在同一个线程内，如果在线程A开启事务，然后到线程B或者主线程中去提交线程A的事务则会报错：No value for key [HikariDataSource] bound to thread。为了避免这种情况我们只能增加代码的复杂度，使用TransactionResource来装载我们copy的事务资源。必须找到对应线程中的事务资源才能提交事务。主要代码如下：</p>
<pre><code class="java">import lombok.Builder;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.jdbc.core.JdbcAggregateTemplate;
import org.springframework.stereotype.Service;
import org.springframework.transaction.PlatformTransactionManager;
import org.springframework.transaction.TransactionDefinition;
import org.springframework.transaction.TransactionStatus;
import org.springframework.transaction.support.DefaultTransactionDefinition;
import org.springframework.transaction.support.TransactionSynchronization;
import org.springframework.transaction.support.TransactionSynchronizationManager;
import org.springframework.util.StopWatch;

import javax.annotation.Resource;
import javax.sql.DataSource;
import java.util.*;
import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.stream.Collectors;

@Slf4j
@Service
public class UserInfoService_5 &#123;

    @Resource
    JdbcAggregateTemplate jdbcAggregateTemplate;
    @Resource
    PlatformTransactionManager transactionManager;

    /**
     * 使用TransactionStatus集合保存所有线程中的TransactionStatus，最后在主线程中一并提交
     * 这里需要特别注意：
     * 此方式如果按照正常处理会报错：No value for key [HikariDataSource] bound to thread
     * 因为在开启新事务时，事务相关资源都被绑定到了子线程thread-cache-pool-1对应的threadLocalMap内部，
     * 而当执行事务提交代码时，commit内部需要从TransactionSynchronizationManager中获取当前事务的资源，
     * 显然我们无法从main线程对应的threadLocalMap中获取到对应的事务资源，这也就是异常抛出的原因。
     * 
     * 解决方案参考: https://www.cnblogs.com/fix200/p/18066537
     */
    List&lt;TransactionStatus&gt; transactionStatuses = new CopyOnWriteArrayList&lt;&gt;();
    /**
     * 此集合用来装载上面提到的当前事务的资源。提交或者回滚必须先找到对应的资源，不然会报错
     */
    List&lt;TransactionResource&gt; transactionResources = new CopyOnWriteArrayList&lt;&gt;();
    /**
     * 线程数量
     */
    public static final int THREAD_COUNT = 5;
    /**
     * 线程池初初始化
     */
    public static final ExecutorService THREAD_POOL = Executors.newFixedThreadPool(THREAD_COUNT);

    /**
     * 使用多线程创建1000000条数据
     * 耗时统计
     *  1 线程数：1      耗时：36s
     *  2 线程数：2      耗时：22s
     *  3 线程数：5      耗时：18s
     *  4 线程数：10     耗时：21s
     *  5 线程数：100    耗时：33s
     *  6 线程数：200    耗时：29s
     *  7 线程数：500    耗时：44s
     */
    public void saves() &#123;

        // 模拟需要新增的用户
        List&lt;UserInfo&gt; userInfos = UserInfo.getUserInfos(100_0000);

        // 每个线程处理的数据量
        int dataPortionLength = (userInfos.size() + THREAD_COUNT - 1) / THREAD_COUNT;

        // 记录耗时
        StopWatch watch = new StopWatch();
        watch.start(&quot;manualTransactional&quot;);

        // 用于计算子线程提交数量
        CountDownLatch threadLatch = new CountDownLatch(THREAD_COUNT);
        // 用于判断子线程任务是否有错误
        AtomicBoolean isError = new AtomicBoolean(false);

        for (int i = 0; i &lt; THREAD_COUNT; i++) &#123;
            // 每个线程处理的数据
            List&lt;UserInfo&gt; threadData = userInfos.stream()
                    .skip(i * dataPortionLength)
                    .limit(dataPortionLength)
                    .collect(Collectors.toList());
            THREAD_POOL.execute(() -&gt; this.savaUserInfos(threadData, threadLatch, isError));
            // CompletableFuture.runAsync(() -&gt; this.savaUserInfos(threadData, threadLatch), THREAD_POOL);
        &#125;


        try &#123;
            // 倒计时锁设置超时时间 300s
            boolean await = threadLatch.await(300, TimeUnit.SECONDS);
            // 等待超时，事务回滚
            if (!await) &#123;
                isError.set(true);
            &#125;
        &#125; catch (Throwable e) &#123;
            isError.set(true);
            log.error(e.getMessage(), e);
        &#125;

        // 发生了异常则进行回滚操作,否则提交
        if (isError.get()) &#123;
            log.error(&quot;发生异常,全部事务回滚&quot;);
            for (int i = 0; i &lt; transactionStatuses.size(); i++) &#123;
                transactionResources.get(i).autoWiredTransactionResource();
                transactionManager.rollback(transactionStatuses.get(i));
                transactionResources.get(i).removeTransactionResource();
            &#125;
        &#125; else &#123;
            log.info(&quot;全部事务正常提交&quot;);
            for (int i = 0; i &lt; transactionStatuses.size(); i++) &#123;
                transactionResources.get(i).autoWiredTransactionResource();
                transactionManager.commit(transactionStatuses.get(i));
                transactionResources.get(i).removeTransactionResource();
            &#125;
        &#125;

        // 关闭线程池
        THREAD_POOL.shutdown();

        log.info(&quot;============================== 主线程完成 ==============================&quot;);
        watch.stop();
        log.info(watch.prettyPrint());
    &#125;

    public void savaUserInfos(List&lt;UserInfo&gt; userInfos, CountDownLatch threadLatch, AtomicBoolean taskStatus) &#123;
        DefaultTransactionDefinition definition = new DefaultTransactionDefinition();
        // 事物隔离级别，开启新事务，这样会比较安全些。
        definition.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRES_NEW);
        // 开启事务 并获得事务状态
        TransactionStatus transactionStatus = transactionManager.getTransaction(definition);
        // 使用这种方式将事务状态都放在同一个事务里面
        transactionStatuses.add(transactionStatus);
        // 继续事务资源复制,因为在sql执行是会产生新的资源对象
        transactionResources.add(TransactionResource.copyTransactionResource());
        log.info(&quot;子线程：&#123;&#125;&quot;, Thread.currentThread().getName());

        try &#123;
            userInfos.forEach(jdbcAggregateTemplate::insert);
        &#125; catch (Throwable e) &#123;
            taskStatus.set(true);
            log.error(&quot;insert error: &quot;, e);
        &#125; finally &#123;
            // 切换到主线程执行
            threadLatch.countDown();
        &#125;
    &#125;


    /**
     * 保存当前事务资源,用于线程间的事务资源COPY操作
     */
    @Builder
    private static class TransactionResource &#123;
        // 事务结束后默认会移除集合中的DataSource作为key关联的资源记录
        private Map&lt;Object, Object&gt; resources = new HashMap&lt;&gt;();

        // 下面五个属性会在事务结束后被自动清理,无需我们手动清理
        private Set&lt;TransactionSynchronization&gt; synchronizations = new HashSet&lt;&gt;();

        private String currentTransactionName;

        private Boolean currentTransactionReadOnly;

        private Integer currentTransactionIsolationLevel;

        private Boolean actualTransactionActive;

        public static TransactionResource copyTransactionResource() &#123;
            return TransactionResource.builder()
                    // 返回的是不可变集合
                    .resources(TransactionSynchronizationManager.getResourceMap())
                    // 如果需要注册事务监听者,这里记得修改--我们这里不需要,就采用默认负责--spring事务内部默认也是这个值
                    .synchronizations(new LinkedHashSet&lt;&gt;())
                    .currentTransactionName(TransactionSynchronizationManager.getCurrentTransactionName())
                    .currentTransactionReadOnly(TransactionSynchronizationManager.isCurrentTransactionReadOnly())
                    .currentTransactionIsolationLevel(TransactionSynchronizationManager.getCurrentTransactionIsolationLevel())
                    .actualTransactionActive(TransactionSynchronizationManager.isActualTransactionActive())
                    .build();
        &#125;

        /**
         * 装配事务资源，为提交 or 回滚做储备
         */
        public void autoWiredTransactionResource() &#123;
            // 绑定事务资源，注意 绑定是绑定到当前主线程上，记得最后释放交换主线程，再由主线程收回原有事务自选
            resources.forEach(TransactionSynchronizationManager::bindResource);
            // 如果需要注册事务监听者,这里记得修改--我们这里不需要,就采用默认负责--Spring事务内部默认也是这个值
            TransactionSynchronizationManager.initSynchronization();
            TransactionSynchronizationManager.setActualTransactionActive(actualTransactionActive);
            TransactionSynchronizationManager.setCurrentTransactionName(currentTransactionName);
            TransactionSynchronizationManager.setCurrentTransactionIsolationLevel(currentTransactionIsolationLevel);
            TransactionSynchronizationManager.setCurrentTransactionReadOnly(currentTransactionReadOnly);
        &#125;

        public void removeTransactionResource() &#123;
            Map&lt;Object, Object&gt; resourceMap = new HashMap&lt;&gt;(TransactionSynchronizationManager.getResourceMap());
            // 事务结束后默认会移除集合中的DataSource作为key关联的资源记录
            // DataSource如果重复移除,unbindResource时会因为不存在此key关联的事务资源而报错
            resources.keySet().forEach(key -&gt; &#123;
                if (resourceMap.containsKey(key) &amp;&amp; !(key instanceof DataSource)) &#123;
                    TransactionSynchronizationManager.unbindResource(key);
                &#125;
            &#125;);
        &#125;
    &#125;
&#125;
</code></pre>
<p>测试代码：</p>
<pre><code class="java">import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;
import javax.annotation.Resource;

@SpringBootTest
class ApplicationTests &#123;
    @Resource
    UserInfoService_5 userInfoService5;

    @Test
    void test5() &#123;
        userInfoService5.saves();
    &#125;
&#125;
</code></pre>
<p>输出结果：</p>
<pre><code class="java">2024-08-25 15:07:21.902  INFO 25185 --- [pool-4-thread-1] c.e.springboot.tech.UserInfoService_5    : 子线程：pool-4-thread-1
2024-08-25 15:07:21.910  INFO 25185 --- [pool-4-thread-2] c.e.springboot.tech.UserInfoService_5    : 子线程：pool-4-thread-2
2024-08-25 15:07:21.926  INFO 25185 --- [pool-4-thread-3] c.e.springboot.tech.UserInfoService_5    : 子线程：pool-4-thread-3
2024-08-25 15:07:21.957  INFO 25185 --- [pool-4-thread-4] c.e.springboot.tech.UserInfoService_5    : 子线程：pool-4-thread-4
2024-08-25 15:07:22.008  INFO 25185 --- [pool-4-thread-5] c.e.springboot.tech.UserInfoService_5    : 子线程：pool-4-thread-5
2024-08-25 15:07:45.443  INFO 25185 --- [           main] c.e.springboot.tech.UserInfoService_5    : 全部事务正常提交
2024-08-25 15:07:46.424  INFO 25185 --- [           main] c.e.springboot.tech.UserInfoService_5    : ============================== 主线程完成 ==============================
2024-08-25 15:07:46.430  INFO 25185 --- [           main] c.e.springboot.tech.UserInfoService_5    : StopWatch &#39;&#39;: running time = 23609632500 ns
---------------------------------------------
ns         %     Task name
---------------------------------------------
23609632500  100%  manualTransactional
</code></pre>
<p>由于这个中方式去前面方式相同，需要等待线程执行完成后才会提交事务，所有任会占用JDBC连接池，如果线程数量超过连接池最大数量会产生连接超时。所以在使用过程中任要控制线程数量。</p>
<hr>
<p>这里需要特别需要提到为什么不推荐使用此种方式呢？因为一般我们正常业务代码使用线程池的时候，创建的线程数肯定是会大于核心线程数的。这道理第一轮的线程还没有提交，第二轮的线程又再次手动开启了事务【重复开启事务与重复提交事务也是不允许的】。所以这种情况下我们也无法使用到 TransactionStatus 即可控制多线程事务提交</p>
<h2 id="六、使用-union-连接多个-select-实现批量-update"><a href="#六、使用-union-连接多个-select-实现批量-update" class="headerlink" title="六、使用 union 连接多个 select 实现批量 update"></a>六、使用 union 连接多个 select 实现批量 update</h2><p>有些情况写不支持，批量 update，但支持 insert 多条数据，这个时候可尝试将需要更新的数据拼接成多条 select 语句，然后使用 union 连接起来，再使用 update 关联这个数据进行 update，具体代码演示如下：</p>
<pre><code class="sql">update student,(
    (select  1 as id,&#39;teacher_A&#39; as teacher) union
    (select  2 as id,&#39;teacher_A&#39; as teacher) union
    (select  3 as id,&#39;teacher_A&#39; as teacher) union
    (select  4 as id,&#39;teacher_A&#39; as teacher)
    /* ....more data ... */
) as new_teacher
set
    student.teacher=new_teacher.teacher
where
    student.id=new_teacher.id
</code></pre>
<p>这种方式在 Mysql 数据库没有配置 <strong>allowMultiQueries&#x3D;true</strong> 也可以实现批量更新<strong>。</strong></p>
<h2 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h2><ul>
<li>对于大批量数据库操作，使用手动事务提交可以很多程度上提高操作效率</li>
<li>多线程对数据库进行操作时，并非线程数越多操作时间越快，按上述示例大约在2-5个线程时操作时间最快。</li>
<li>对于多线程阻塞事务提交时，线程数量不能过多。</li>
<li>如果能有办法实现批量更新那是最好</li>
</ul>
<h1 id="Spring-多线程事务控制各种案例汇总"><a href="#Spring-多线程事务控制各种案例汇总" class="headerlink" title="Spring 多线程事务控制各种案例汇总"></a>Spring 多线程事务控制各种案例汇总</h1><blockquote>
<p>作者：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_35987023">qq_35987023</a>、来源：Spring 多线程事务控制：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_35987023/article/details/132908628">https://blog.csdn.net/qq_35987023/article/details/132908628</a></p>
</blockquote>
<p>在Java多线程事务控制中，有一些注意事项和实例可以帮助你更好地理解和应用。</p>
<ul>
<li><p>确保线程安全：在多线程环境下，确保代码是线程安全的。这可以通过使用synchronized关键字、Lock接口或Atomic类来实现。</p>
</li>
<li><p>事务的隔离级别：根据需要选择适当的事务隔离级别，以避免并发问题，例如脏读、不可重复读和幻读。</p>
</li>
<li><p>事务的传播行为：了解事务的传播行为，例如事务的提交和回滚如何影响其他事务。</p>
</li>
<li><p>异常处理：在多线程环境下处理异常时，需要特别小心。确保捕获和处理所有异常，并正确地处理事务回滚。</p>
</li>
</ul>
<hr>
<p>Spring 实现事务通过 ThreadLocal 把事务和当前线程进行了绑定。</p>
<p>ThreadLocal 作为本地线程变量载体，保存了当前线程的变量，并确保所有变量是线程安全的。</p>
<p>这些封闭隔离的变量中就包含了数据库连接，Session管理的对象以及当前事务运行的其他必要信息，而开启的新线程是获取不到这些变量和对象的。</p>
<p>也就是说：主线程事务与子线程事务是相互独立的。该怎么验证？</p>
<p>操作示例：验证事务 以及 多线程事务控制编码</p>
<pre><code class="java">import cn.cjf.tt.dao.UserMapper;
import cn.cjf.tt.po.User;
import cn.cjf.tt.service.UserService;
import lombok.SneakyThrows;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.datasource.DataSourceTransactionManager;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;
import org.springframework.transaction.TransactionDefinition;
import org.springframework.transaction.TransactionStatus;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.transaction.support.DefaultTransactionDefinition;

import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.UUID;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.CyclicBarrier;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.atomic.AtomicBoolean;


// 使用Spring整合Junit专用的类加载器
@RunWith(SpringJUnit4ClassRunner.class)
// 加载配置文件或者配置类
@ContextConfiguration(locations = &#123;&quot;classpath:spring.xml&quot;&#125;) // 加载配置文件
public class UserTest &#123;
    @Autowired
    private UserService userService;
    @Autowired
    private DataSourceTransactionManager transactionManager;
    @Autowired
    private UserMapper userMapper;

    /**
     * 验证数据库连接是否正常
     */
    @Test
    public void selectAllUser() &#123;
        List&lt;User&gt; users = userService.selectAllUser();
        for (User i : users) &#123;
            System.out.println(i);
        &#125;
    &#125;

    /**
     * 验证：能否正常插入数据
     */
    public void test() &#123;
        final User user = new User() &#123;&#123;
            this.setUsername("test_" + UUID.randomUUID().toString());
            this.setPassword("123456");
            this.setCreateTime(new Date());
        &#125;&#125;;
        userService.addUser(user);
    &#125;

    /**
     * 验证：线程池子线程中能否正常插入数据
     */
    @Test
    public void testForBatch() throws InterruptedException &#123;
        final ExecutorService service = Executors.newFixedThreadPool(5);
        for (int i = 0; i &lt; 5; i++) &#123;
            service.submit(new Runnable() &#123;
                @SneakyThrows
                @Override
                public void run() &#123;
                    test1();
                &#125;
            &#125;);
        &#125;
        Thread.sleep(5000);
    &#125;

    /**
     * 验证：正常插入数据，抛出异常后，注解事务是否回滚
     */
    @Transactional(rollbackFor = Exception.class)
    @Test
    public void test1() throws Exception &#123;
        final User user = new User() &#123;&#123;
            this.setUsername("test_" + UUID.randomUUID().toString());
            this.setPassword("123456");
            this.setCreateTime(new Date());
        &#125;&#125;;
        userService.addUser(user);
        if (true) &#123;
            throw new Exception();
        &#125;
    &#125;

    /**
     * 验证：正常插入数据，抛出异常后，手动事务是否回滚
     */
    @Test
    public void test11() &#123;
        DefaultTransactionDefinition dd = new DefaultTransactionDefinition();
        final TransactionStatus transaction = transactionManager.getTransaction(dd);
        try &#123;
            final User user = new User() &#123;&#123;
                this.setUsername("test_" + UUID.randomUUID().toString());
                this.setPassword("123456");
                this.setCreateTime(new Date());
            &#125;&#125;;
            userService.addUser(user);
            System.out.println(user);
            if (true) &#123;
                throw new Exception();
            &#125;
            // User(id=13, username=test1694675733277, password=123456, salt=null, token=null, isEnabled=null, createTime=Thu Sep 14 15:15:33 CST 2023, modifiedTime=null)
            transactionManager.commit(transaction);
            System.out.println(&quot;---------------------&quot; + Thread.currentThread().getName() + &quot;事务提交&quot;);
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
            transactionManager.rollback(transaction);
            System.out.println(&quot;---------------------&quot; + Thread.currentThread().getName() + &quot;事务回滚&quot;);
        &#125;
    &#125;


    /**
     * 验证：主线程事务，是否能影响到子线程事务
     */
    @Transactional(rollbackFor = Exception.class)
    @Test
    public void test2() throws Exception &#123;
        final User user = new User() &#123;&#123;
            this.setUsername("test_" + UUID.randomUUID().toString());
            this.setPassword("123456");
            this.setCreateTime(new Date());
        &#125;&#125;;
        userService.addUser(user);
        System.out.println(&quot;---------------------&quot; + Thread.currentThread().getName() + &quot;：&quot; + user);
        final ExecutorService service = Executors.newFixedThreadPool(5);
        List&lt;Integer&gt; idList = new ArrayList&lt;&gt;();
        idList.add(user.getId());
        for (int i = 0; i &lt; 5; i++) &#123;
            service.submit(new Runnable() &#123;
                @Override
                public void run() &#123;
                    final User user = new User() &#123;&#123;
                        this.setUsername("test_" + UUID.randomUUID().toString());
                        this.setPassword("123456");
                        this.setCreateTime(new Date());
                    &#125;&#125;;
                    userService.addUserForTransaction(user);
                    System.out.println(&quot;---------------------&quot; + Thread.currentThread().getName() + &quot;：&quot; + user);
                    final Integer id = user.getId();
                    idList.add(id);
                &#125;
            &#125;);
        &#125;

        Thread.sleep(5000);
        try &#123;
            throw new Exception();
        &#125; finally &#123;
            for (int i = 0; i &lt; idList.size(); i++) &#123;
                final Integer id = idList.get(i);
                final User po = userMapper.selectByPrimaryKey(id);
                if (po == null) &#123;
                    System.out.println(&quot;---------------------id:&quot; + id + &quot;事务回滚&quot;);
                &#125; else &#123;
                    System.out.println(&quot;---------------------id:&quot; + id + &quot;事务提交&quot;);
                &#125;
                // 主线程事务未结束
                // 实际主线程事务回滚了，但子线程事务未回滚
            &#125;
        &#125;
    &#125;

    /**
     * 验证：主线程事务，未能影响到子线程事务，是因为子线程的事务传播行为影响
     */
    @Transactional(rollbackFor = Exception.class)
    @Test
    public void test21() throws Exception &#123;
        final User user = new User() &#123;&#123;
            this.setUsername("test_" + UUID.randomUUID().toString());
            this.setPassword("123456");
            this.setCreateTime(new Date());
        &#125;&#125;;
        userService.addUser(user);
        System.out.println(&quot;---------------------&quot; + Thread.currentThread().getName() + &quot;：&quot; + user);
        final ExecutorService service = Executors.newFixedThreadPool(5);
        List&lt;Integer&gt; idList = new ArrayList&lt;&gt;();
        idList.add(user.getId());
        for (int i = 0; i &lt; 5; i++) &#123;
            service.submit(new Runnable() &#123;
                @Override
                public void run() &#123;
                    final User user = new User() &#123;&#123;
                        this.setUsername("test_" + UUID.randomUUID().toString());
                        this.setPassword("123456");
                        this.setCreateTime(new Date());
                    &#125;&#125;;
                    userService.addUserForNestedTransaction(user);
                    System.out.println(&quot;---------------------&quot; + Thread.currentThread().getName() + &quot;：&quot; + user);
                    final Integer id = user.getId();
                    idList.add(id);
                &#125;
            &#125;);
        &#125;

        Thread.sleep(5000);
        try &#123;
            throw new Exception();
        &#125; finally &#123;
            for (int i = 0; i &lt; idList.size(); i++) &#123;
                final Integer id = idList.get(i);
                final User po = userMapper.selectByPrimaryKey(id);
                if (po == null) &#123;
                    System.out.println(&quot;---------------------id:&quot; + id + &quot;事务回滚&quot;);
                &#125; else &#123;
                    System.out.println(&quot;---------------------id:&quot; + id + &quot;事务提交&quot;);
                &#125;
                // 主线程事务未结束
                // 实际主线程事务回滚了，但子线程事务未回滚
            &#125;
        &#125;
    &#125;

    /**
     * 验证：主线程事务，未能影响到子线程事务
     * 主线程手动控制事务，与注解自动控制事务，结果是否依然是，主线程事务不能影响到子线程事务
     */
    @Test
    public void test22() throws Exception &#123;
        DefaultTransactionDefinition dd = new DefaultTransactionDefinition();
        final TransactionStatus transaction = transactionManager.getTransaction(dd);
        List&lt;Integer&gt; idList = new ArrayList&lt;&gt;();
        try &#123;
            final User user = new User() &#123;&#123;
                this.setUsername("test_" + UUID.randomUUID().toString());
                this.setPassword("123456");
                this.setCreateTime(new Date());
            &#125;&#125;;
            userService.addUser(user);
            System.out.println(&quot;---------------------&quot; + Thread.currentThread().getName() + &quot;：&quot; + user);
            final ExecutorService service = Executors.newFixedThreadPool(5);
            idList.add(user.getId());
            for (int i = 0; i &lt; 5; i++) &#123;
                service.submit(new Runnable() &#123;
                    @Override
                    public void run() &#123;
                        final User user = new User() &#123;&#123;
                            this.setUsername("test_" + UUID.randomUUID().toString());
                            this.setPassword("123456");
                            this.setCreateTime(new Date());
                        &#125;&#125;;
                        userService.addUserForNestedTransaction(user);
                        System.out.println(&quot;---------------------&quot; + Thread.currentThread().getName() + &quot;：&quot; + user);
                        final Integer id = user.getId();
                        idList.add(id);
                    &#125;
                &#125;);
            &#125;

            Thread.sleep(5000);
            if (true) &#123;
                throw new Exception();
            &#125;

            // User(id=13, username=test1694675733277, password=123456, salt=null, token=null, isEnabled=null, createTime=Thu Sep 14 15:15:33 CST 2023, modifiedTime=null)
            System.out.println(&quot;---------------------&quot; + Thread.currentThread().getName() + &quot;事务提交&quot;);
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
            transactionManager.rollback(transaction);
            System.out.println(&quot;---------------------&quot; + Thread.currentThread().getName() + &quot;事务回滚&quot;);
        &#125;

        for (int i = 0; i &lt; idList.size(); i++) &#123;
            final Integer id = idList.get(i);
            final User po = userMapper.selectByPrimaryKey(id);
            if (po == null) &#123;
                System.out.println(&quot;---------------------id:&quot; + id + &quot;事务回滚&quot;);
            &#125; else &#123;
                System.out.println(&quot;---------------------id:&quot; + id + &quot;事务提交&quot;);
            &#125;
            // 主线程事务已结束
            // 主线程事务回滚了，但子线程事务未回滚
        &#125;
    &#125;

    /**
     * 验证：主线程事务，未能影响到子线程事务
     * 主线程手动控制事务，子线程也手动控制事务，结果是否依然是，主线程事务不能影响到子线程事务
     */
    @Test
    public void test23() throws InterruptedException &#123;
        DefaultTransactionDefinition dd = new DefaultTransactionDefinition();
        final TransactionStatus transaction = transactionManager.getTransaction(dd);
        List&lt;Integer&gt; idList = new ArrayList&lt;&gt;();
        try &#123;
            final User user = new User() &#123;&#123;
                this.setUsername("test_" + UUID.randomUUID().toString());
                this.setPassword("123456");
                this.setCreateTime(new Date());
            &#125;&#125;;
            userService.addUser(user);
            idList.add(user.getId());
            final ExecutorService service = Executors.newFixedThreadPool(5);
            for (int i = 0; i &lt; 5; i++) &#123;
                service.submit(new Runnable() &#123;
                    @Override
                    public void run() &#123;
                        DefaultTransactionDefinition dd = new DefaultTransactionDefinition();
                        final TransactionStatus transaction = transactionManager.getTransaction(dd);
                        try &#123;
                            final User user = new User() &#123;&#123;
                                this.setUsername("test_" + UUID.randomUUID().toString());
                                this.setPassword("123456");
                                this.setCreateTime(new Date());
                            &#125;&#125;;
                            userService.addUser(user);
                            System.out.println(user);
                            final Integer id = user.getId();
                            idList.add(id);
                            // User(id=13, username=test1694675733277, password=123456, salt=null, token=null, isEnabled=null, createTime=Thu Sep 14 15:15:33 CST 2023, modifiedTime=null)
                            transactionManager.commit(transaction);
                            System.out.println(&quot;---------------------&quot; + Thread.currentThread().getName() + &quot;事务提交&quot;);
                        &#125; catch (Exception e) &#123;
                            e.printStackTrace();
                            transactionManager.rollback(transaction);
                            System.out.println(&quot;---------------------&quot; + Thread.currentThread().getName() + &quot;事务回滚&quot;);
                        &#125;
                    &#125;
                &#125;);
            &#125;

            Thread.sleep(5000);
            if (true) &#123;
                throw new Exception();
            &#125;

            // User(id=13, username=test1694675733277, password=123456, salt=null, token=null, isEnabled=null, createTime=Thu Sep 14 15:15:33 CST 2023, modifiedTime=null)
            System.out.println(&quot;---------------------&quot; + Thread.currentThread().getName() + &quot;事务提交&quot;);
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
            transactionManager.rollback(transaction);
            System.out.println(&quot;---------------------&quot; + Thread.currentThread().getName() + &quot;事务回滚&quot;);
        &#125;

        for (int i = 0; i &lt; idList.size(); i++) &#123;
            final Integer id = idList.get(i);
            final User po = userMapper.selectByPrimaryKey(id);
            if (po == null) &#123;
                System.out.println(&quot;---------------------id:&quot; + id + &quot;事务回滚&quot;);
            &#125; else &#123;
                System.out.println(&quot;---------------------id:&quot; + id + &quot;事务提交&quot;);
            &#125;
            // 主线程事务已结束
            // 主线程事务回滚了，但子线程事务未回滚
        &#125;
    &#125;

    /**
     * 验证结果：主线程事务不能影响到子线程事务
     * &lt;p&gt;
     * 主线程，子线程控制各自事务，等待一起提交
     */
    @Test
    public void test3() throws InterruptedException &#123;
        DefaultTransactionDefinition dd = new DefaultTransactionDefinition();
        final TransactionStatus transaction = transactionManager.getTransaction(dd);
        List&lt;Integer&gt; idList = new ArrayList&lt;&gt;();
        int time = 5;
        CountDownLatch cdl = new CountDownLatch(time);
        AtomicBoolean flag = new AtomicBoolean(true);
        try &#123;
            final User user = new User() &#123;&#123;
                this.setUsername("test_" + UUID.randomUUID().toString());
                this.setPassword("123456");
                this.setCreateTime(new Date());
            &#125;&#125;;
            userService.addUser(user);
            idList.add(user.getId());
            final ExecutorService service = Executors.newFixedThreadPool(time);
            for (int i = 0; i &lt; time; i++) &#123;
                service.submit(new Runnable() &#123;
                    @SneakyThrows
                    @Override
                    public void run() &#123;
                        DefaultTransactionDefinition dd = new DefaultTransactionDefinition();
                        final TransactionStatus transaction = transactionManager.getTransaction(dd);
                        try &#123;
                            final User user = new User() &#123;&#123;
                                this.setUsername("test_" + UUID.randomUUID().toString());
                                this.setPassword("123456");
                                this.setCreateTime(new Date());
                            &#125;&#125;;
                            userMapper.insertSelective(user);
                            idList.add(user.getId());
                            System.out.println(&quot;---------------&quot; + Thread.currentThread().getName() + &quot;--执行成功&quot;);
                        &#125; catch (Exception e) &#123;
                            e.printStackTrace();
                            System.out.println(&quot;---------------&quot; + Thread.currentThread().getName() + &quot;--执行失败，等待事务回滚&quot;);
                            flag.set(false);
                        &#125; finally &#123;
                            System.out.println(&quot;---------------&quot; + Thread.currentThread().getName() + &quot;--等待&quot;);
                            cdl.countDown();
                            cdl.await();
                            if (flag.get()) &#123;
                                System.out.println(&quot;---------------&quot; + Thread.currentThread().getName() + &quot;--提交事务&quot;);
                                transactionManager.commit(transaction);
                            &#125; else &#123;
                                System.out.println(&quot;---------------&quot; + Thread.currentThread().getName() + &quot;--回滚事务&quot;);
                                transactionManager.rollback(transaction);
                            &#125;

                            System.out.println(&quot;---------------&quot; + Thread.currentThread().getName() + &quot;--End&quot;);
                        &#125;
                    &#125;
                &#125;);
            &#125;

        &#125; catch (Exception e) &#123;
            e.printStackTrace();
            System.out.println(&quot;---------------&quot; + Thread.currentThread().getName() + &quot;--执行失败，等待事务回滚&quot;);
            flag.set(false);
        &#125; finally &#123;
            System.out.println(&quot;---------------&quot; + Thread.currentThread().getName() + &quot;--等待&quot;);
            cdl.await();
            if (flag.get()) &#123;
                System.out.println(&quot;---------------&quot; + Thread.currentThread().getName() + &quot;--提交事务&quot;);
                transactionManager.commit(transaction);
            &#125; else &#123;
                System.out.println(&quot;---------------&quot; + Thread.currentThread().getName() + &quot;--回滚事务&quot;);
                transactionManager.rollback(transaction);
            &#125;
        &#125;

        System.out.println(&quot;---------------&quot; + Thread.currentThread().getName() + &quot;--End&quot;);

        for (int i = 0; i &lt; idList.size(); i++) &#123;
            final Integer id = idList.get(i);
            final User po = userMapper.selectByPrimaryKey(id);
            if (po == null) &#123;
                System.out.println(&quot;---------------------id:&quot; + id + &quot;事务回滚&quot;);
            &#125; else &#123;
                System.out.println(&quot;---------------------id:&quot; + id + &quot;事务提交&quot;);
            &#125;
            // 主线程事务已结束
            // 主线程事务回滚了，子线程事务也回滚
        &#125;
    &#125;

    /**
     * 验证结果：主线程事务不能影响到子线程事务
     * &lt;p&gt;
     * 主线程，子线程控制各自事务，等待一起提交
     * 验证，主线程异常，子线程未异常，事务都回滚了
     */
    @Test
    public void test31() throws InterruptedException &#123;
        DefaultTransactionDefinition dd = new DefaultTransactionDefinition();
        final TransactionStatus transaction = transactionManager.getTransaction(dd);
        List&lt;Integer&gt; idList = new ArrayList&lt;&gt;();
        int time = 5;
        CountDownLatch cdl = new CountDownLatch(time);
        AtomicBoolean flag = new AtomicBoolean(true);
        try &#123;
            final User user = new User() &#123;&#123;
                this.setUsername("test_" + UUID.randomUUID().toString());
                this.setPassword("123456");
                this.setCreateTime(new Date());
            &#125;&#125;;
            userService.addUser(user);
            idList.add(user.getId());
            final ExecutorService service = Executors.newFixedThreadPool(time);
            for (int i = 0; i &lt; time; i++) &#123;
                //                int finalI = i;
                service.submit(new Runnable() &#123;
                    @SneakyThrows
                    @Override
                    public void run() &#123;
                        DefaultTransactionDefinition dd = new DefaultTransactionDefinition();
                        final TransactionStatus transaction = transactionManager.getTransaction(dd);
                        try &#123;
                            final User user = new User() &#123;&#123;
                                this.setUsername("test_" + UUID.randomUUID().toString());
                                this.setPassword("123456");
                                this.setCreateTime(new Date());
                            &#125;&#125;;
                            userMapper.insertSelective(user);
                            idList.add(user.getId());
                            // 最后一个提交的任务，抛出异常；注释掉会全部完成，否则全部回滚
                            //                            if (finalI == time - 1) &#123;
                            //                                throw new RuntimeException();
                            //                            &#125;
                            // User(id=13, username=test1694675733277, password=123456, salt=null, token=null, isEnabled=null, createTime=Thu Sep 14 15:15:33 CST 2023, modifiedTime=null)
                            System.out.println(&quot;---------------&quot; + Thread.currentThread().getName() + &quot;--执行成功&quot;);
                        &#125; catch (Exception e) &#123;
                            e.printStackTrace();
                            System.out.println(&quot;---------------&quot; + Thread.currentThread().getName() + &quot;--执行失败，等待事务回滚&quot;);
                            flag.set(false);
                        &#125; finally &#123;
                            System.out.println(&quot;---------------&quot; + Thread.currentThread().getName() + &quot;--等待&quot;);
                            cdl.countDown();
                            cdl.await();
                            if (flag.get()) &#123;
                                System.out.println(&quot;---------------&quot; + Thread.currentThread().getName() + &quot;--提交事务&quot;);
                                transactionManager.commit(transaction);
                            &#125; else &#123;
                                System.out.println(&quot;---------------&quot; + Thread.currentThread().getName() + &quot;--回滚事务&quot;);
                                transactionManager.rollback(transaction);
                            &#125;

                            System.out.println(&quot;---------------&quot; + Thread.currentThread().getName() + &quot;--End&quot;);
                        &#125;
                    &#125;
                &#125;);
            &#125;

            if (true) &#123;
                throw new Exception();
            &#125;

        &#125; catch (Exception e) &#123;
            e.printStackTrace();
            System.out.println(&quot;---------------&quot; + Thread.currentThread().getName() + &quot;--执行失败，等待事务回滚&quot;);
            flag.set(false);
        &#125; finally &#123;
            System.out.println(&quot;---------------&quot; + Thread.currentThread().getName() + &quot;--等待&quot;);
            cdl.await();
            if (flag.get()) &#123;
                System.out.println(&quot;---------------&quot; + Thread.currentThread().getName() + &quot;--提交事务&quot;);
                transactionManager.commit(transaction);
            &#125; else &#123;
                System.out.println(&quot;---------------&quot; + Thread.currentThread().getName() + &quot;--回滚事务&quot;);
                transactionManager.rollback(transaction);
            &#125;
        &#125;

        System.out.println(&quot;---------------&quot; + Thread.currentThread().getName() + &quot;--End&quot;);

        for (int i = 0; i &lt; idList.size(); i++) &#123;
            final Integer id = idList.get(i);
            final User po = userMapper.selectByPrimaryKey(id);
            if (po == null) &#123;
                System.out.println(&quot;---------------------id:&quot; + id + &quot;事务回滚&quot;);
            &#125; else &#123;
                System.out.println(&quot;---------------------id:&quot; + id + &quot;事务提交&quot;);
            &#125;
            // 主线程事务已结束
            // 主线程事务回滚了，子线程事务也回滚
        &#125;
    &#125;

    /**
     * 验证结果：主线程事务不能影响到子线程事务
     * &lt;p&gt;
     * 主线程，子线程控制各自事务，等待一起提交
     * 验证，主线程未异常，子线程异常，事务都回滚了
     */
    @Test
    public void test32() throws InterruptedException &#123;
        DefaultTransactionDefinition dd = new DefaultTransactionDefinition();
        final TransactionStatus transaction = transactionManager.getTransaction(dd);
        List&lt;Integer&gt; idList = new ArrayList&lt;&gt;();
        int time = 5;
        CountDownLatch cdl = new CountDownLatch(time);
        AtomicBoolean flag = new AtomicBoolean(true);
        try &#123;
            final User user = new User() &#123;&#123;
                this.setUsername("test_" + UUID.randomUUID().toString());
                this.setPassword("123456");
                this.setCreateTime(new Date());
            &#125;&#125;;
            userService.addUser(user);
            idList.add(user.getId());
            final ExecutorService service = Executors.newFixedThreadPool(time);
            for (int i = 0; i &lt; time; i++) &#123;
                int finalI = i;
                service.submit(new Runnable() &#123;
                    @SneakyThrows
                    @Override
                    public void run() &#123;
                        DefaultTransactionDefinition dd = new DefaultTransactionDefinition();
                        final TransactionStatus transaction = transactionManager.getTransaction(dd);
                        try &#123;
                            final User user = new User() &#123;&#123;
                                this.setUsername("test_" + UUID.randomUUID().toString());
                                this.setPassword("123456");
                                this.setCreateTime(new Date());
                            &#125;&#125;;
                            userMapper.insertSelective(user);
                            idList.add(user.getId());
                            // 最后一个提交的任务，抛出异常；注释掉会全部完成，否则全部回滚
                            if (finalI == time - 1) &#123;
                                throw new RuntimeException();
                            &#125;
                            // User(id=13, username=test1694675733277, password=123456, salt=null, token=null, isEnabled=null, createTime=Thu Sep 14 15:15:33 CST 2023, modifiedTime=null)
                            System.out.println(&quot;---------------&quot; + Thread.currentThread().getName() + &quot;--执行成功&quot;);
                        &#125; catch (Exception e) &#123;
                            e.printStackTrace();
                            System.out.println(&quot;---------------&quot; + Thread.currentThread().getName() + &quot;--执行失败，等待事务回滚&quot;);
                            flag.set(false);
                        &#125; finally &#123;
                            System.out.println(&quot;---------------&quot; + Thread.currentThread().getName() + &quot;--等待&quot;);
                            cdl.countDown();
                            cdl.await();
                            if (flag.get()) &#123;
                                System.out.println(&quot;---------------&quot; + Thread.currentThread().getName() + &quot;--提交事务&quot;);
                                transactionManager.commit(transaction);
                            &#125; else &#123;
                                System.out.println(&quot;---------------&quot; + Thread.currentThread().getName() + &quot;--回滚事务&quot;);
                                transactionManager.rollback(transaction);
                            &#125;

                            System.out.println(&quot;---------------&quot; + Thread.currentThread().getName() + &quot;--End&quot;);
                        &#125;
                    &#125;
                &#125;);
            &#125;

            //            if (true) &#123;
            //                throw new Exception();
            //            &#125;

        &#125; catch (Exception e) &#123;
            e.printStackTrace();
            System.out.println(&quot;---------------&quot; + Thread.currentThread().getName() + &quot;--执行失败，等待事务回滚&quot;);
            flag.set(false);
        &#125; finally &#123;
            System.out.println(&quot;---------------&quot; + Thread.currentThread().getName() + &quot;--等待&quot;);
            cdl.await();
            if (flag.get()) &#123;
                System.out.println(&quot;---------------&quot; + Thread.currentThread().getName() + &quot;--提交事务&quot;);
                transactionManager.commit(transaction);
            &#125; else &#123;
                System.out.println(&quot;---------------&quot; + Thread.currentThread().getName() + &quot;--回滚事务&quot;);
                transactionManager.rollback(transaction);
            &#125;
        &#125;

        System.out.println(&quot;---------------&quot; + Thread.currentThread().getName() + &quot;--End&quot;);

        for (int i = 0; i &lt; idList.size(); i++) &#123;
            final Integer id = idList.get(i);
            final User po = userMapper.selectByPrimaryKey(id);
            if (po == null) &#123;
                System.out.println(&quot;---------------------id:&quot; + id + &quot;事务回滚&quot;);
            &#125; else &#123;
                System.out.println(&quot;---------------------id:&quot; + id + &quot;事务提交&quot;);
            &#125;
            // 主线程事务已结束
            // 主线程事务回滚了，子线程事务也回滚
        &#125;
    &#125;
&#125;
</code></pre>
<h1 id="参考文献-鸣谢"><a href="#参考文献-鸣谢" class="headerlink" title="参考文献 &amp; 鸣谢"></a>参考文献 &amp; 鸣谢</h1><ul>
<li>面试必问：分布式事务六种解决方案：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/183753774">https://zhuanlan.zhihu.com/p/183753774</a></li>
<li></li>
</ul>

      
       <hr><span style="font-style: italic;color: gray;"> 转载请注明来源，欢迎对文章中的引用来源进行考证，欢迎指出任何有错误或不够清晰的表达。可以在下面评论区评论，也可以邮件至 8629303@qq.com </span>
    </div>
</article>


<p>
    <a  class="dashang" onclick="dashangToggle()">赏</a>
</p>






    




    </div>
    <div class="copyright">
        <p class="footer-entry">
    ©2017-2024 Sam
</p>
<p class="footer-entry">Built with <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/yelog/hexo-theme-3-hexo" target="_blank">3-hexo</a> theme</p>

    </div>
    <div class="full-toc">
        <button class="full" data-title="切换全屏 快捷键 s"><span class="min "></span></button>
<a class="" id="rocket" ></a>

    </div>
</div>

<div class="hide_box" onclick="dashangToggle()"></div>
<div class="shang_box">
    <a class="shang_close"  onclick="dashangToggle()">×</a>
    <div class="shang_tit">
        <p>喜欢就点赞,疼爱就打赏</p>
    </div>
    <div class="shang_payimg">
        <div class="pay_img">
            <img src="/blog/img/alipay.jpg" class="alipay" title="扫码支持">
            <img src="/blog/img/weixin.jpg" class="weixin" title="扫码支持">
        </div>
    </div>
    <div class="shang_payselect">
        <span><label><input type="radio" name="pay" checked value="alipay">支付宝</label></span><span><label><input type="radio" name="pay" value="weixin">微信</label></span>
    </div>
</div>


</body>
<script src="/blog/js/jquery.pjax.js?v=1.1.0" ></script>

<script src="/blog/js/script.js?v=1.1.0" ></script>
<script>
    var img_resize = 'default';
    function initArticle() {
        /*渲染对应的表格样式*/
        
            $("#post .pjax table").addClass("green_title");
        

        /*渲染打赏样式*/
        
        $("input[name=pay]").on("click", function () {
            if($("input[name=pay]:checked").val()=="weixin"){
                $(".shang_box .shang_payimg .pay_img").addClass("weixin_img");
            } else {
                $(".shang_box .shang_payimg .pay_img").removeClass("weixin_img");
            }
        })
        

        /*高亮代码块行号*/
        
        $('pre code').each(function(){
            var lines = $(this).text().trim().split('\n').length, widther='';
            if (lines>99) {
                widther = 'widther'
            }
            var $numbering = $('<ul/>').addClass('pre-numbering ' + widther).attr("unselectable","on");
            $(this).addClass('has-numbering ' + widther)
                    .parent()
                    .append($numbering);
            for(var i=1;i<=lines;i++){
                $numbering.append($('<li/>').text(i));
            }
        });
        

        /*访问数量*/
        
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js");
        

        /*代码高亮，行号对齐*/
        $('.pre-numbering').css('line-height',$('.has-numbering').css('line-height'));

        
        
    }

    /*打赏页面隐藏与展示*/
    
    function dashangToggle() {
        $(".shang_box").fadeToggle();
        $(".hide_box").fadeToggle();
    }
    

</script>

<!--加入行号的高亮代码块样式-->

<style>
    pre{
        position: relative;
        margin-bottom: 24px;
        border-radius: 10px;
        border: 1px solid #e2dede;
        background: #FFF;
        overflow: hidden;
    }
    code.has-numbering{
        margin-left: 30px;
    }
    code.has-numbering.widther{
        margin-left: 35px;
    }
    .pre-numbering{
        margin: 0;
        position: absolute;
        top: 0;
        left: 0;
        width: 20px;
        padding: 18px 3px 15px 5px;
        border-right: 1px solid #C3CCD0;
        text-align: right;
        color: #AAA;
        background-color: #fafafa;
    }
    .pre-numbering.widther {
        width: 35px;
    }
</style>

<!--自定义样式设置-->
<style>
    
    
    .nav {
        width: 582px;
    }
    .nav.fullscreen {
        margin-left: -582px;
    }
    .nav-left {
        width: 160px;
    }
    
    
    @media screen and (max-width: 1468px) {
        .nav {
            width: 492px;
        }
        .nav.fullscreen {
            margin-left: -492px;
        }
        .nav-left {
            width: 100px;
        }
    }
    
    
    @media screen and (max-width: 1024px) {
        .nav {
            width: 492px;
            margin-left: -492px
        }
        .nav.fullscreen {
            margin-left: 0;
        }
    }
    
    @media screen and (max-width: 426px) {
        .nav {
            width: 100%;
        }
        .nav-left {
            width: 100%;
        }
    }
    
    
    .nav-right .title-list nav a .post-title, .nav-right .title-list #local-search-result a .post-title {
        color: #383636;
    }
    
    
    .nav-right .title-list nav a .post-date, .nav-right .title-list #local-search-result a .post-date {
        color: #5e5e5f;
    }
    
    
    .nav-right nav a.hover, #local-search-result a.hover{
        background-color: #e2e0e0;
    }
    
    

    /*列表样式*/
    

    /* 背景图样式 */
    
    


    /*引用块样式*/
    

    /*文章列表背景图*/
    

    
</style>







</html>
