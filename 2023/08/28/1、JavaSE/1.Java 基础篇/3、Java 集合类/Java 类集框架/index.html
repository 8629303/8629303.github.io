<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Java 类集框架 | Hexo</title>
  <meta name="keywords" content="">
  <meta name="description" content="Java 类集框架 | Hexo">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="description" content="请不要自己写，Spring Boot非常实用的内置功能：https:&#x2F;&#x2F;juejin.cn&#x2F;post&#x2F;7417630844100231206  在 SpringBoot 框架中，内置了许多实用的功能，这些功能可以帮助开发者高效地开发和维护应用程序。 一、请求数据记录器SpringBoot 提供了一个内置的日志记录解决方案，通过 AbstractRequestLoggingFilter 可以记录请">
<meta property="og:type" content="article">
<meta property="og:title" content="SpringBoot2.x 内置功能 - 内置过滤器和 AOP 工具类">
<meta property="og:url" content="http://example.com/2024/10/08/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot2.x%20%E5%86%85%E7%BD%AE%E5%8A%9F%E8%83%BD%20-%20%E5%86%85%E7%BD%AE%E8%BF%87%E6%BB%A4%E5%99%A8%E5%92%8C%20AOP%20%E5%B7%A5%E5%85%B7%E7%B1%BB/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="请不要自己写，Spring Boot非常实用的内置功能：https:&#x2F;&#x2F;juejin.cn&#x2F;post&#x2F;7417630844100231206  在 SpringBoot 框架中，内置了许多实用的功能，这些功能可以帮助开发者高效地开发和维护应用程序。 一、请求数据记录器SpringBoot 提供了一个内置的日志记录解决方案，通过 AbstractRequestLoggingFilter 可以记录请">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2024-10-08T08:44:19.743Z">
<meta property="article:modified_time" content="2024-10-18T10:28:56.825Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">


<link rel="icon" href="/img/avatar.jpg">

<link href="/css/style.css?v=1.1.0" rel="stylesheet">

<link href="/css/hl_theme/atom-light.css?v=1.1.0" rel="stylesheet">

<link href="//cdn.jsdelivr.net/npm/animate.css@4.1.0/animate.min.css" rel="stylesheet">

<script src="//cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
<script src="/js/titleTip.js?v=1.1.0" ></script>

<script src="//cdn.jsdelivr.net/npm/highlightjs@9.16.2/highlight.pack.min.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>

<script src="//cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script>



<script src="//cdn.jsdelivr.net/npm/jquery.cookie@1.4.1/jquery.cookie.min.js" ></script>

<script src="/js/iconfont.js?v=1.1.0" ></script>

<meta name="generator" content="Hexo 7.3.0"></head>
<div style="display: none">
  <input class="theme_disqus_on" value="false">
  <input class="theme_preload_comment" value="">
  <input class="theme_blog_path" value="">
  <input id="theme_shortcut" value="true" />
  <input id="theme_highlight_on" value="true" />
  <input id="theme_code_copy" value="true" />
</div>



<body>
<aside class="nav">
    <div class="nav-left">
        <a href="/"
   class="avatar_target">
    <img class="avatar"
         src="/img/avatar.jpg"/>
</a>
<div class="author">
    <span>John Doe</span>
</div>

<div class="icon">
    
        
            <a title="github"
               href="https://github.com/8629303"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-github"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="email"
               href="mailto:8629303@qq.com"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-email"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="qq"
               href="http://wpa.qq.com/msgrd?v=3&uin=8629303&site=qq&menu=yes"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-qq"></use>
                    </svg>
                
            </a>
        
    
</div>





<ul>
    <li>
        <div class="all active" data-rel="全部文章">全部文章
            
                <small>(172)</small>
            
        </div>
    </li>
    
        
            
        
    
        
            
                
    <li>
        <div data-rel="_posts">
            <i class="fold iconfont icon-right"></i>
            _posts
            <small>(14)</small>
        </div>
        
            <ul class="sub hide">
                
                    
    <li>
        <div data-rel="_posts&lt;---&gt;数据库">
            
            数据库
            <small>(5)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="_posts&lt;---&gt;开发工具">
            
            开发工具
            <small>(8)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="_posts&lt;---&gt;面试篇">
            
            面试篇
            <small>(1)</small>
        </div>
        
    </li>

                
            </ul>
        
    </li>

            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
                
    <li>
        <div data-rel="开发工具">
            <i class="fold iconfont icon-right"></i>
            开发工具
            <small>(8)</small>
        </div>
        
            <ul class="sub hide">
                
                    
    <li>
        <div data-rel="开发工具&lt;---&gt;Maven">
            
            Maven
            <small>(8)</small>
        </div>
        
    </li>

                
            </ul>
        
    </li>

            
        
    
        
            
        
    
        
            
                
    <li>
        <div data-rel="微服务开发">
            <i class="fold iconfont icon-right"></i>
            微服务开发
            <small>(61)</small>
        </div>
        
            <ul class="sub hide">
                
                    
    <li>
        <div data-rel="微服务开发&lt;---&gt;Shiro">
            
            Shiro
            <small>(2)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="微服务开发&lt;---&gt;Spring">
            
            Spring
            <small>(3)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="微服务开发&lt;---&gt;SpringBoot">
            
            SpringBoot
            <small>(44)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="微服务开发&lt;---&gt;SpringCloudAlibaba">
            
            SpringCloudAlibaba
            <small>(1)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="微服务开发&lt;---&gt;SpringDataJPA">
            
            SpringDataJPA
            <small>(4)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="微服务开发&lt;---&gt;SpringMVC">
            
            SpringMVC
            <small>(1)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="微服务开发&lt;---&gt;SpringSecurity">
            
            SpringSecurity
            <small>(1)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="微服务开发&lt;---&gt;SpringTransaction">
            
            SpringTransaction
            <small>(5)</small>
        </div>
        
    </li>

                
            </ul>
        
    </li>

            
        
    
        
            
        
    
        
            
                
    <li>
        <div data-rel="中间件">
            <i class="fold iconfont icon-right"></i>
            中间件
            <small>(8)</small>
        </div>
        
            <ul class="sub hide">
                
                    
    <li>
        <div data-rel="中间件&lt;---&gt;ElasticSearch">
            
            ElasticSearch
            <small>(1)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="中间件&lt;---&gt;MongoDB">
            
            MongoDB
            <small>(2)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="中间件&lt;---&gt;RabbitMQ">
            
            RabbitMQ
            <small>(3)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="中间件&lt;---&gt;Redis">
            
            Redis
            <small>(2)</small>
        </div>
        
    </li>

                
            </ul>
        
    </li>

            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
                
    <li>
        <div data-rel="Java基础篇">
            <i class="fold iconfont icon-right"></i>
            Java基础篇
            <small>(8)</small>
        </div>
        
            <ul class="sub hide">
                
                    
    <li>
        <div data-rel="Java基础篇&lt;---&gt;Java常用类库">
            
            Java常用类库
            <small>(1)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="Java基础篇&lt;---&gt;Java多线程">
            
            Java多线程
            <small>(2)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="Java基础篇&lt;---&gt;Java反射与注解">
            
            Java反射与注解
            <small>(1)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="Java基础篇&lt;---&gt;Java基础语法">
            
            Java基础语法
            <small>(1)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="Java基础篇&lt;---&gt;Java集合类">
            
            Java集合类
            <small>(1)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="Java基础篇&lt;---&gt;JavaIO流">
            
            JavaIO流
            <small>(1)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="Java基础篇&lt;---&gt;JavaNIO流">
            
            JavaNIO流
            <small>(1)</small>
        </div>
        
    </li>

                
            </ul>
        
    </li>

            
        
    
        
            
        
    
        
            
        
    
        
            
                
    <li>
        <div data-rel="Java进阶篇">
            <i class="fold iconfont icon-right"></i>
            Java进阶篇
            <small>(4)</small>
        </div>
        
            <ul class="sub hide">
                
                    
    <li>
        <div data-rel="Java进阶篇&lt;---&gt;Java设计模式">
            
            Java设计模式
            <small>(1)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="Java进阶篇&lt;---&gt;JVM虚拟机">
            
            JVM虚拟机
            <small>(3)</small>
        </div>
        
    </li>

                
            </ul>
        
    </li>

            
        
    
        
            
        
    
        
            
        
    
        
            
                
    <li>
        <div data-rel="Java新特性">
            <i class="fold iconfont icon-right"></i>
            Java新特性
            <small>(16)</small>
        </div>
        
            <ul class="sub hide">
                
                    
    <li>
        <div data-rel="Java新特性&lt;---&gt;Java10新特性">
            
            Java10新特性
            <small>(1)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="Java新特性&lt;---&gt;Java11新特性">
            
            Java11新特性
            <small>(1)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="Java新特性&lt;---&gt;Java12新特性">
            
            Java12新特性
            <small>(1)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="Java新特性&lt;---&gt;Java13新特性">
            
            Java13新特性
            <small>(1)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="Java新特性&lt;---&gt;Java14新特性">
            
            Java14新特性
            <small>(1)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="Java新特性&lt;---&gt;Java15新特性">
            
            Java15新特性
            <small>(1)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="Java新特性&lt;---&gt;Java16新特性">
            
            Java16新特性
            <small>(1)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="Java新特性&lt;---&gt;Java17新特性">
            
            Java17新特性
            <small>(1)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="Java新特性&lt;---&gt;Java18新特性">
            
            Java18新特性
            <small>(1)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="Java新特性&lt;---&gt;Java19新特性">
            
            Java19新特性
            <small>(1)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="Java新特性&lt;---&gt;Java20新特性">
            
            Java20新特性
            <small>(1)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="Java新特性&lt;---&gt;Java8新特性">
            
            Java8新特性
            <small>(4)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="Java新特性&lt;---&gt;Java9新特性">
            
            Java9新特性
            <small>(1)</small>
        </div>
        
    </li>

                
            </ul>
        
    </li>

            
        
    
        
            
        
    
        
            
                
    <li>
        <div data-rel="JavaEE">
            <i class="fold iconfont icon-right"></i>
            JavaEE
            <small>(6)</small>
        </div>
        
            <ul class="sub hide">
                
                    
    <li>
        <div data-rel="JavaEE&lt;---&gt;JavaWeb">
            
            JavaWeb
            <small>(2)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="JavaEE&lt;---&gt;SSM框架">
            
            SSM框架
            <small>(4)</small>
        </div>
        
    </li>

                
            </ul>
        
    </li>

            
        
    
        
            
        
    
        
            
        
    
        
            
                
    <li>
        <div data-rel="JavaSE">
            <i class="fold iconfont icon-right"></i>
            JavaSE
            <small>(34)</small>
        </div>
        
            <ul class="sub hide">
                
                    
    <li>
        <div data-rel="JavaSE&lt;---&gt;Java汇总篇">
            
            Java汇总篇
            <small>(28)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="JavaSE&lt;---&gt;Java新特性">
            
            Java新特性
            <small>(1)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="JavaSE&lt;---&gt;Java性能测试与安全">
            
            Java性能测试与安全
            <small>(5)</small>
        </div>
        
    </li>

                
            </ul>
        
    </li>

            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
                
    <li>
        <div data-rel="Linux">
            <i class="fold iconfont icon-right"></i>
            Linux
            <small>(7)</small>
        </div>
        
            <ul class="sub hide">
                
                    
    <li>
        <div data-rel="Linux&lt;---&gt;虚拟机工具">
            
            虚拟机工具
            <small>(2)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="Linux&lt;---&gt;Docker">
            
            Docker
            <small>(2)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="Linux&lt;---&gt;Kubernetes">
            
            Kubernetes
            <small>(2)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="Linux&lt;---&gt;Nginx">
            
            Nginx
            <small>(1)</small>
        </div>
        
    </li>

                
            </ul>
        
    </li>

            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
                
    <li>
        <div data-rel="Redis">
            <i class="fold iconfont icon-right"></i>
            Redis
            <small>(1)</small>
        </div>
        
            <ul class="sub hide">
                
                    
    <li>
        <div data-rel="Redis&lt;---&gt;backup">
            
            backup
            <small>(1)</small>
        </div>
        
    </li>

                
            </ul>
        
    </li>

            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
                
    <li>
        <div data-rel="SpringTransaction">
            <i class="fold iconfont icon-right"></i>
            SpringTransaction
            <small>(5)</small>
        </div>
        
            <ul class="sub hide">
                
                    
    <li>
        <div data-rel="SpringTransaction&lt;---&gt;多数据源事务处理">
            
            多数据源事务处理
            <small>(3)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="SpringTransaction&lt;---&gt;多线程下事务处理">
            
            多线程下事务处理
            <small>(2)</small>
        </div>
        
    </li>

                
            </ul>
        
    </li>

            
        
    
        
            
        
    
</ul>
<div class="left-bottom">
    <div class="menus">
        
            
            
            
    </div>
    <div>
        
            <a class="about  hasFriend  site_url"
               
               href="/about">关于</a>
        
        <a style="width: 50%"
                
                                           class="friends">友链</a>
        
    </div>
</div>
<input type="hidden" id="yelog_site_posts_number" value="172">

<div style="display: none">
    <span id="busuanzi_value_site_uv"></span>
    <span id="busuanzi_value_site_pv"></span>
</div>

    </div>
    <div class="nav-right">
        <div class="friends-area">
    <div class="friends-title">
        友情链接
        <i class="iconfont icon-left"></i>
    </div>
    <div class="friends-content">
        <ul>
            
            <li><a target="_blank" href="http://yelog.org/">叶落阁</a></li>
            
        </ul>
    </div>
</div>
        <div class="title-list">
    <div class="right-top">
        <div id="default-panel">
            <i class="iconfont icon-search" data-title="搜索 快捷键 i"></i>
            <div class="right-title">全部文章</div>
            <i class="iconfont icon-file-tree" data-title="切换到大纲视图 快捷键 w"></i>
        </div>
        <div id="search-panel">
            <i class="iconfont icon-left" data-title="返回"></i>
            <input id="local-search-input" autocomplete="off"/>
            <label class="border-line" for="input"></label>
            <i class="iconfont icon-case-sensitive" data-title="大小写敏感"></i>
            <i class="iconfont icon-tag" data-title="标签"></i>
        </div>
        <div id="outline-panel" style="display: none">
            <div class="right-title">大纲</div>
            <i class="iconfont icon-list" data-title="切换到文章列表"></i>
        </div>
    </div>

    <div class="tags-list">
    <input id="tag-search" />
    <div class="tag-wrapper">
        
    </div>

</div>

    
    <nav id="title-list-nav">
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2024/10/08/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot2.x%20%E5%86%85%E7%BD%AE%E5%8A%9F%E8%83%BD%20-%20%E5%86%85%E7%BD%AE%E8%BF%87%E6%BB%A4%E5%99%A8%E5%92%8C%20AOP%20%E5%B7%A5%E5%85%B7%E7%B1%BB/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot2.x 内置功能 - 内置过滤器和 AOP 工具类">SpringBoot2.x 内置功能 - 内置过滤器和 AOP 工具类</span>
            <span class="post-date" title="2024-10-08 16:44:19">2024/10/08</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2024/10/08/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%E7%B3%BB%E5%88%97-%E5%85%A8%E7%BD%91%E6%9C%80%E5%85%A8%E7%9A%84%E7%89%88%E6%9C%AC%E5%8F%98%E6%9B%B4%E5%8F%B2/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot系列-全网最全的版本变更史">SpringBoot系列-全网最全的版本变更史</span>
            <span class="post-date" title="2024-10-08 16:38:53">2024/10/08</span>
        </a>
        
        
        <a  class="全部文章 开发工具 Maven "
           href="/2024/10/08/6%E3%80%81%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Maven/Maven%20%E6%95%99%E7%A8%8B%E4%B9%8B%20%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE%20&%20%E9%B8%A3%E8%B0%A2/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Maven 教程之 参考文献 &amp; 鸣谢">Maven 教程之 参考文献 &amp; 鸣谢</span>
            <span class="post-date" title="2024-10-08 15:50:47">2024/10/08</span>
        </a>
        
        
        <a  class="全部文章 _posts 开发工具 "
           href="/2024/10/07/6%E3%80%81%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/GitHub%20%E5%AE%9E%E6%88%98%E6%8A%80%E5%B7%A7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="GitHub 实战技巧">GitHub 实战技巧</span>
            <span class="post-date" title="2024-10-07 15:55:34">2024/10/07</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2024/10/07/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot2.x%20%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AF%87%20-%20%E9%9B%86%E6%88%90%20HirakiCP%20%E4%B8%8E%20Druid%20%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot2.x 数据库篇 - 集成 HirakiCP 与 Druid 数据库连接池">SpringBoot2.x 数据库篇 - 集成 HirakiCP 与 Druid 数据库连接池</span>
            <span class="post-date" title="2024-10-07 14:19:43">2024/10/07</span>
        </a>
        
        
        <a  class="全部文章 _posts 开发工具 "
           href="/2024/09/30/6%E3%80%81%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/MacOS%20%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%8F%8A%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E5%8D%B8%E8%BD%BD/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="MacOS 开发环境搭建及软件安装卸载">MacOS 开发环境搭建及软件安装卸载</span>
            <span class="post-date" title="2024-09-30 23:56:52">2024/09/30</span>
        </a>
        
        
        <a  class="全部文章 开发工具 Maven "
           href="/2024/09/30/6%E3%80%81%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Maven/Maven%20%E6%95%99%E7%A8%8B%E4%B9%8B%20JDK%20%E7%89%88%E6%9C%AC%E9%BB%98%E8%AE%A4%E8%AE%BE%E7%BD%AE%20/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Maven 教程之 JDK 版本默认设置">Maven 教程之 JDK 版本默认设置</span>
            <span class="post-date" title="2024-09-30 16:37:08">2024/09/30</span>
        </a>
        
        
        <a  class="全部文章 开发工具 Maven "
           href="/2024/09/26/6%E3%80%81%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Maven/Maven%20%E6%95%99%E7%A8%8B%E4%B9%8B%20profiles%20%E5%A4%9A%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Maven 教程之 profiles 多环境配置">Maven 教程之 profiles 多环境配置</span>
            <span class="post-date" title="2024-09-26 17:40:34">2024/09/26</span>
        </a>
        
        
        <a  class="全部文章 开发工具 Maven "
           href="/2024/09/25/6%E3%80%81%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Maven/Maven%20%E6%95%99%E7%A8%8B%E4%B9%8B%20plugin%20%E8%AF%A6%E8%A7%A3/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Maven 教程之 plugin 详解">Maven 教程之 plugin 详解</span>
            <span class="post-date" title="2024-09-25 11:32:44">2024/09/25</span>
        </a>
        
        
        <a  class="全部文章 开发工具 Maven "
           href="/2024/09/21/6%E3%80%81%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Maven/Maven%20%E6%95%99%E7%A8%8B%E4%B9%8B%20pom.xml%20%E8%AF%A6%E8%A7%A3/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Maven 教程之 pom.xml 详解">Maven 教程之 pom.xml 详解</span>
            <span class="post-date" title="2024-09-21 16:14:13">2024/09/21</span>
        </a>
        
        
        <a  class="全部文章 开发工具 Maven "
           href="/2024/09/21/6%E3%80%81%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Maven/Maven%20%E6%95%99%E7%A8%8B%E4%B9%8B%20settings.xml%20%E8%AF%A6%E8%A7%A3/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Maven 教程之 settings.xml 详解">Maven 教程之 settings.xml 详解</span>
            <span class="post-date" title="2024-09-21 16:14:09">2024/09/21</span>
        </a>
        
        
        <a  class="全部文章 _posts 面试篇 "
           href="/2024/08/27/0%E3%80%81%E9%9D%A2%E8%AF%95%E7%AF%87/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8%E6%B1%87%E6%80%BB/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="面试宝典汇总">面试宝典汇总</span>
            <span class="post-date" title="2024-08-27 16:20:25">2024/08/27</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/2024/08/26/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E8%87%AA%E5%AE%9A%E4%B9%89%E9%9B%86%E5%90%88%E5%B8%B8%E9%87%8F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 自定义集合常量">Java 自定义集合常量</span>
            <span class="post-date" title="2024-08-26 12:11:54">2024/08/26</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringMVC "
           href="/2024/08/26/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20MVC/SpringMVC%E4%B9%8B@InitBinder%E6%B3%A8%E8%A7%A3%EF%BC%88%E6%97%A5%E6%9C%9F%E8%BD%AC%E6%8D%A2%EF%BC%89/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringMVC之@InitBinder注解（日期转换）">SpringMVC之@InitBinder注解（日期转换）</span>
            <span class="post-date" title="2024-08-26 11:10:28">2024/08/26</span>
        </a>
        
        
        <a  class="全部文章 SpringTransaction 多线程下事务处理 "
           href="/2024/08/21/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Transaction/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8B%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/Java%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BA%8B%E5%8A%A1%E6%8F%90%E4%BA%A4%E7%9A%84%E5%A4%84%E7%90%86/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 多线程事务提交的处理">Java 多线程事务提交的处理</span>
            <span class="post-date" title="2024-08-21 16:32:52">2024/08/21</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2024/08/20/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%20Cache%20%E6%95%B4%E5%90%88%20Redis%20%E7%BC%93%E5%AD%98%E6%A1%86%E6%9E%B6/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot Cache 整合 Redis 缓存框架">SpringBoot Cache 整合 Redis 缓存框架</span>
            <span class="post-date" title="2024-08-20 16:11:47">2024/08/20</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringTransaction "
           href="/2024/08/16/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Transaction/Spring%20%E4%BA%8B%E5%8A%A1%E5%BA%94%E7%94%A8%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Spring 事务应用及源码分析">Spring 事务应用及源码分析</span>
            <span class="post-date" title="2024-08-16 10:33:57">2024/08/16</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringTransaction "
           href="/2024/08/16/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Transaction/Spring%20JDBC%20-%20NamedParameterJdbcTemplate/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Spring JDBC - NamedParameterJdbcTemplate">Spring JDBC - NamedParameterJdbcTemplate</span>
            <span class="post-date" title="2024-08-16 00:18:18">2024/08/16</span>
        </a>
        
        
        <a  class="全部文章 _posts 开发工具 "
           href="/2024/07/18/6%E3%80%81%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Git%20&%20GitHub/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Git &amp; GitHub">Git &amp; GitHub</span>
            <span class="post-date" title="2024-07-18 10:34:58">2024/07/18</span>
        </a>
        
        
        <a  class="全部文章 开发工具 Maven "
           href="/2024/06/28/6%E3%80%81%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Maven/Maven%20%E5%AE%9E%E6%88%98/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Maven 实战">Maven 实战</span>
            <span class="post-date" title="2024-06-28 16:50:35">2024/06/28</span>
        </a>
        
        
        <a  class="全部文章 _posts 数据库 "
           href="/2024/06/26/3%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%9D%A2%E8%AF%95%E5%AE%98%EF%BC%9A%E4%B8%8D%E4%BC%9A%E7%9C%8B%20Explain%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%EF%BC%8C%E7%AE%80%E5%8E%86%E6%95%A2%E5%86%99%20SQL%20%E4%BC%98%E5%8C%96%EF%BC%9F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="面试官：不会看 Explain执行计划，简历敢写 SQL 优化？">面试官：不会看 Explain执行计划，简历敢写 SQL 优化？</span>
            <span class="post-date" title="2024-06-26 19:33:03">2024/06/26</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/2024/04/22/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%AF%87%E4%B9%8B%20IDEA%20-%20VM%20Options%E3%80%81Program%20Arguments%E3%80%81Environment%20Variable%20%E8%A7%A3%E6%9E%90/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 命令行篇之 IDEA - VM Options、Program Arguments、Environment Variable 解析">Java 命令行篇之 IDEA - VM Options、Program Arguments、Environment Variable 解析</span>
            <span class="post-date" title="2024-04-22 10:53:10">2024/04/22</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2024/04/19/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6-%E9%85%8D%E7%BD%AE%E5%A4%96%E9%83%A8%E5%8C%96/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 配置文件-配置外部化">SpringBoot 2.x 配置文件-配置外部化</span>
            <span class="post-date" title="2024-04-19 09:18:55">2024/04/19</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/2024/04/16/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E5%8E%9F%E7%90%86%E7%AF%87%E4%B9%8B%20SPI%20%E6%9C%BA%E5%88%B6/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 原理篇之 SPI 机制">Java 原理篇之 SPI 机制</span>
            <span class="post-date" title="2024-04-16 17:26:15">2024/04/16</span>
        </a>
        
        
        <a  class="全部文章 开发工具 Maven "
           href="/2024/01/14/6%E3%80%81%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Maven/Maven%20%E6%95%99%E7%A8%8B%E4%B9%8B%20mirror%20&%20repository%20%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Maven 教程之 mirror &amp; repository 配置详解">Maven 教程之 mirror &amp; repository 配置详解</span>
            <span class="post-date" title="2024-01-14 22:51:03">2024/01/14</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2023/12/07/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E4%B8%BA%E4%BB%80%E4%B9%88SpringBoot%20jar%20%E5%8F%AF%E4%BB%A5%E7%9B%B4%E6%8E%A5%E8%BF%90%E8%A1%8C/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 为什么SpringBoot jar 可以直接运行">SpringBoot 2.x 为什么SpringBoot jar 可以直接运行</span>
            <span class="post-date" title="2023-12-07 15:13:56">2023/12/07</span>
        </a>
        
        
        <a  class="全部文章 Java基础篇 Java多线程 "
           href="/2023/12/04/1%E3%80%81JavaSE/1.Java%20%E5%9F%BA%E7%A1%80%E7%AF%87/5%E3%80%81Java%20%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%BF%9B%E9%98%B6/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 多线程进阶">Java 多线程进阶</span>
            <span class="post-date" title="2023-12-04 16:37:09">2023/12/04</span>
        </a>
        
        
        <a  class="全部文章 _posts 数据库 "
           href="/2023/11/18/3%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BB%BA%E6%A8%A1%E5%B7%A5%E5%85%B7%E6%B1%87%E6%80%BB/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="数据库建模工具汇总">数据库建模工具汇总</span>
            <span class="post-date" title="2023-11-18 15:31:11">2023/11/18</span>
        </a>
        
        
        <a  class="全部文章 JavaEE SSM框架 "
           href="/2023/10/08/2%E3%80%81JavaEE/2%E3%80%81SSM%E6%A1%86%E6%9E%B6/Mybatis/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Mybatis">Mybatis</span>
            <span class="post-date" title="2023-10-08 19:45:47">2023/10/08</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java性能测试与安全 "
           href="/2023/08/28/1%E3%80%81JavaSE/5.Java%20%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E4%B8%8E%E5%AE%89%E5%85%A8/Java%20%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E7%AF%87%E4%B9%8B%20%E5%8E%8B%E6%B5%8B%E5%B7%A5%E5%85%B7%E6%B1%87%E6%80%BB/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 性能测试篇之 压测工具汇总">Java 性能测试篇之 压测工具汇总</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java性能测试与安全 "
           href="/2023/08/28/1%E3%80%81JavaSE/5.Java%20%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E4%B8%8E%E5%AE%89%E5%85%A8/Java%20%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E7%AF%87%E4%B9%8B%20%E9%AB%98%E5%B9%B6%E5%8F%91%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87%EF%BC%9AQPS%E3%80%81TPS%E3%80%81RT%E3%80%81%E5%B9%B6%E5%8F%91%E6%95%B0%E3%80%81%E5%90%9E%E5%90%90%E9%87%8F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 性能测试篇之 高并发性能指标：QPS、TPS、RT、并发数、吞吐量">Java 性能测试篇之 高并发性能指标：QPS、TPS、RT、并发数、吞吐量</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java性能测试与安全 "
           href="/2023/08/28/1%E3%80%81JavaSE/5.Java%20%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E4%B8%8E%E5%AE%89%E5%85%A8/Java%20%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E7%AF%87%E4%B9%8B%20JMH%20%E5%B7%A5%E5%85%B7%E7%B1%BB/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 性能测试篇之 JMH 工具类">Java 性能测试篇之 JMH 工具类</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java性能测试与安全 "
           href="/2023/08/28/1%E3%80%81JavaSE/5.Java%20%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E4%B8%8E%E5%AE%89%E5%85%A8/Java%20%E5%AE%89%E5%85%A8%E7%AF%87%E4%B9%8B%20API%20%E6%8E%A5%E5%8F%A3%E9%98%B2%E6%AD%A2%E5%8F%82%E6%95%B0%E7%AF%A1%E6%94%B9%E5%92%8C%E9%87%8D%E6%94%BE%E6%94%BB%E5%87%BB/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 安全篇之 API 接口防止参数篡改和重放攻击">Java 安全篇之 API 接口防止参数篡改和重放攻击</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java性能测试与安全 "
           href="/2023/08/28/1%E3%80%81JavaSE/5.Java%20%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E4%B8%8E%E5%AE%89%E5%85%A8/Java%20%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E7%AF%87%E4%B9%8B%2048%E5%BC%A0%E5%9B%BE%E5%AD%A6%E4%BC%9A%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E3%80%81%E5%8E%8B%E6%B5%8B%E5%92%8C%E8%B0%83%E4%BC%98/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 性能测试篇之 48张图学会性能监控、压测和调优">Java 性能测试篇之 48张图学会性能监控、压测和调优</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 _posts 开发工具 "
           href="/2023/08/28/6%E3%80%81%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/IDEA%20%E5%BF%AB%E6%8D%B7%E9%94%AE/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="IDEA 快捷键">IDEA 快捷键</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 _posts 开发工具 "
           href="/2023/08/28/6%E3%80%81%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/IDEA%20%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="IDEA 基本使用">IDEA 基本使用</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 _posts 开发工具 "
           href="/2023/08/28/6%E3%80%81%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/IDEA%20%E6%8F%92%E4%BB%B6%E5%AE%89%E8%A3%85/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="IDEA 插件安装">IDEA 插件安装</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 _posts 开发工具 "
           href="/2023/08/28/6%E3%80%81%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/PostMan%20%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="PostMan 工具的使用">PostMan 工具的使用</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 _posts 开发工具 "
           href="/2023/08/28/6%E3%80%81%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Git/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Git">Git</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E4%BC%98%E5%8C%96%E7%AF%87%E4%B9%8B%20%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3%20%E6%A0%A1%E9%AA%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 优化篇之 自定义注解 校验数据库表中的数据不可重复">Java 优化篇之 自定义注解 校验数据库表中的数据不可重复</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E5%B7%A5%E5%85%B7%E7%AF%87%E4%B9%8B%20API%20%E6%8E%A5%E5%8F%A3%E5%85%8D%E8%B4%B9%20JSONPlaceholder/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 工具篇之 API 接口免费 JSONPlaceholder">Java 工具篇之 API 接口免费 JSONPlaceholder</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E5%B7%A5%E5%85%B7%E7%AF%87%E4%B9%8B%20%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E7%BB%9F%E8%AE%A1%E4%BB%A3%E7%A0%81%E8%80%97%E6%97%B6/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 工具篇之 如何优雅的统计代码耗时">Java 工具篇之 如何优雅的统计代码耗时</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B9%8B%20%E4%B8%8D%E5%8F%AF%E4%B8%8D%E7%9F%A5%E7%9A%84%207%20%E4%B8%AA%20JDK%20%E5%91%BD%E4%BB%A4/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 命令行之 不可不知的 7 个 JDK 命令">Java 命令行之 不可不知的 7 个 JDK 命令</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%AF%87%E4%B9%8B%20Window%20%E5%90%8E%E5%8F%B0%E5%90%AF%E5%8A%A8%20JAR%20%E7%A8%8B%E5%BA%8F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 命令行篇之 Window 后台启动 JAR 程序">Java 命令行篇之 Window 后台启动 JAR 程序</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E5%B7%A5%E5%85%B7%E7%AF%87%E4%B9%8B%20Lombok/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 工具篇之 Lombok">Java 工具篇之 Lombok</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E5%B7%A5%E5%85%B7%E7%AF%87%E4%B9%8B%20API%20%E6%96%87%E6%A1%A3%E5%B7%A5%E5%85%B7%20Swagger3.x-2.x/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 工具篇之 API 文档工具 Swagger3.x-2.x">Java 工具篇之 API 文档工具 Swagger3.x-2.x</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E5%B7%A5%E5%85%B7%E7%AF%87%E4%B9%8B%20%E6%8E%8C%E6%8F%A114%E7%A7%8DUML%E5%9B%BE/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 工具篇之 掌握14种UML图">Java 工具篇之 掌握14种UML图</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E5%B7%A5%E5%85%B7%E7%B1%BB%E4%B9%8B%20%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B7%A5%E5%85%B7%E7%B1%BB/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 工具类之 自定义工具类">Java 工具类之 自定义工具类</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20Bean%20%E4%B9%8B%20DTO%E3%80%81VO%E3%80%81PO%E3%80%81DO%E3%80%81BO%20%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java Bean 之 DTO、VO、PO、DO、BO 类的区别">Java Bean 之 DTO、VO、PO、DO、BO 类的区别</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20JSON%20%E7%AF%87%E4%B9%8B%20Jackson/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java JSON 篇之 Jackson">Java JSON 篇之 Jackson</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20JSON%20%E7%AF%87%E4%B9%8B%20Gson/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java JSON 篇之 Gson">Java JSON 篇之 Gson</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Curl%20%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%91%BD%E4%BB%A4%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Curl 的使用及命令参数说明">Curl 的使用及命令参数说明</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20JSON%20%E7%AF%87%E4%B9%8B%20FastJson/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java JSON 篇之 FastJson">Java JSON 篇之 FastJson</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Redis backup "
           href="/2023/08/28/5%E3%80%81%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/backup/Redis6/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Redis6">Redis6</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 中间件 Redis "
           href="/2023/08/28/5%E3%80%81%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/Redis-%E6%9C%80%E5%85%A8%E5%AE%9E%E6%88%98/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Redis-最全实战">Redis-最全实战</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 中间件 Redis "
           href="/2023/08/28/5%E3%80%81%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/Redis-%E4%BB%A3%E7%A0%81%E5%AE%9E%E6%88%98/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Redis-代码实战">Redis-代码实战</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 中间件 RabbitMQ "
           href="/2023/08/28/5%E3%80%81%E4%B8%AD%E9%97%B4%E4%BB%B6/RabbitMQ/RabbitMQ-3.8.14/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="RabbitMQ-3.8.14">RabbitMQ-3.8.14</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 中间件 RabbitMQ "
           href="/2023/08/28/5%E3%80%81%E4%B8%AD%E9%97%B4%E4%BB%B6/RabbitMQ/RabbitMQ-3.7.x/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="RabbitMQ-3.7.x">RabbitMQ-3.7.x</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 中间件 RabbitMQ "
           href="/2023/08/28/5%E3%80%81%E4%B8%AD%E9%97%B4%E4%BB%B6/RabbitMQ/RabbitMQ-3.8.14-%E5%8D%9A%E5%AE%A2%E7%89%88/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="RabbitMQ-3.8.14-博客版">RabbitMQ-3.8.14-博客版</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 中间件 MongoDB "
           href="/2023/08/28/5%E3%80%81%E4%B8%AD%E9%97%B4%E4%BB%B6/MongoDB/MongDB-4.4.2/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="MongDB-4.4.2">MongDB-4.4.2</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 中间件 MongoDB "
           href="/2023/08/28/5%E3%80%81%E4%B8%AD%E9%97%B4%E4%BB%B6/MongoDB/MongDB-4.4.2-%E5%8D%9A%E5%AE%A2%E7%89%88/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="MongDB-4.4.2-博客版">MongDB-4.4.2-博客版</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 中间件 ElasticSearch "
           href="/2023/08/28/5%E3%80%81%E4%B8%AD%E9%97%B4%E4%BB%B6/ElasticSearch/ElasticSearch7.6.x%E5%AE%9E%E6%88%98/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="ElasticSearch7.6.x实战">ElasticSearch7.6.x实战</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Linux 虚拟机工具 "
           href="/2023/08/28/4%E3%80%81Linux/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%B7%A5%E5%85%B7/Virtualbox%E7%BD%91%E7%BB%9C%E8%AE%BE%E7%BD%AE%E6%88%96%E9%85%8D%E7%BD%AE/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Virtualbox网络设置或配置">Virtualbox网络设置或配置</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Linux 虚拟机工具 "
           href="/2023/08/28/4%E3%80%81Linux/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%B7%A5%E5%85%B7/Virtualbox%E5%AE%89%E8%A3%85Centos7%E5%AE%9E%E6%88%98/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Virtualbox安装Centos7实战">Virtualbox安装Centos7实战</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Linux Kubernetes "
           href="/2023/08/28/4%E3%80%81Linux/Kubernetes/Minikube-k8s/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Minikube-k8s">Minikube-k8s</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Linux Kubernetes "
           href="/2023/08/28/4%E3%80%81Linux/Kubernetes/k0s%20%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B%EF%BC%9A%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%20Kubernetes%20%E9%9B%86%E7%BE%A4/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="k0s 使用教程：如何快速搭建 Kubernetes 集群">k0s 使用教程：如何快速搭建 Kubernetes 集群</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Linux Nginx "
           href="/2023/08/28/4%E3%80%81Linux/Nginx/Nginx-1.8.0/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Nginx-1.8.0">Nginx-1.8.0</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Linux Docker "
           href="/2023/08/28/4%E3%80%81Linux/Docker/Docker%E5%88%9D%E7%BA%A7%E5%88%B0%E5%AE%9E%E6%88%98/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Docker初级到实战">Docker初级到实战</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Linux Docker "
           href="/2023/08/28/4%E3%80%81Linux/Docker/Docker&Docker-Compose%E5%AE%9E%E6%88%98-%E5%93%88%E5%96%BD%E6%B2%83%E5%BE%B7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Docker&amp;Docker-Compose实战-哈喽沃德">Docker&amp;Docker-Compose实战-哈喽沃德</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 Spring "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring/Spring%20Bean%20%E7%9A%84%E5%8A%A8%E6%80%81%E5%88%9B%E5%BB%BA%E8%8E%B7%E5%8F%96%E5%88%A0%E9%99%A4/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Spring Bean 的动态创建获取删除">Spring Bean 的动态创建获取删除</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 Spring "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring/Spring%20Bean%20%E7%9A%8412%E7%A7%8D%E5%AE%9A%E4%B9%89%E6%96%B9%E6%B3%95/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Spring Bean 的12种定义方法">Spring Bean 的12种定义方法</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 Spring "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring/Spring%20Bean%20%E6%B3%A8%E5%85%A5%E7%9A%843%E7%A7%8D%E6%96%B9%E5%BC%8F,%20%E4%B8%BA%E4%BD%95%E5%AE%98%E6%96%B9%E5%BB%BA%E8%AE%AE%E4%BD%BF%E7%94%A8%E6%9E%84%E9%80%A0%E5%99%A8%E6%B3%A8%E5%85%A5/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Spring Bean 注入的3种方式, 为何官方建议使用构造器注入">Spring Bean 注入的3种方式, 为何官方建议使用构造器注入</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 SpringTransaction 多数据源事务处理 "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Transaction/%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/Spring%20%E5%AE%9E%E7%8E%B0%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E5%AE%9E%E6%88%98/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Spring 实现多数据源实战">Spring 实现多数据源实战</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 SpringTransaction 多数据源事务处理 "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Transaction/%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/Spring%20%E8%A7%A3%E5%86%B3%E5%8D%95%E6%9C%BA%E7%8E%AF%E5%A2%83%E4%B8%8B%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E7%9A%84%E4%BA%8B%E5%8A%A1%E9%97%AE%E9%A2%98/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Spring 解决单机环境下多数据源的事务问题">Spring 解决单机环境下多数据源的事务问题</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 SpringTransaction 多数据源事务处理 "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Transaction/%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/Spring%20%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81%E6%95%B0%E6%8D%AE%E6%BA%90%E3%80%81%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E5%88%87%E6%8D%A2%E6%96%B9%E5%BC%8F%E3%80%81%E5%A4%9A%E6%95%B0%E6%8D%AE%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Spring 实现动态数据源、多数据源切换方式、多数据事务管理">Spring 实现动态数据源、多数据源切换方式、多数据事务管理</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringTransaction "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Transaction/Spring%20%E4%BA%8B%E5%8A%A1%E5%8E%9F%E7%90%86%E6%B7%B1%E5%85%A5%E4%B8%8E%E5%88%86%E6%9E%90/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Spring 事务原理深入与分析">Spring 事务原理深入与分析</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringSecurity "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Security/SpringSecurity/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringSecurity">SpringSecurity</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringTransaction "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Transaction/JDBC/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="JDBC">JDBC</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringTransaction "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Transaction/Spring%20JDBC%20-%20JdbcTemplate/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Spring JDBC - JdbcTemplate">Spring JDBC - JdbcTemplate</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 SpringTransaction 多线程下事务处理 "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Transaction/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8B%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/JDBC%E6%89%B9%E5%A4%84%E7%90%86%E5%AE%9E%E7%8E%B0%E6%89%8B%E5%8A%A8%E4%BA%8B%E5%8A%A1%E6%8F%92%E5%85%A51000%E4%B8%87%E6%95%B0%E6%8D%AE%EF%BC%88%E5%8D%95%E7%BA%BF%E7%A8%8B%20&%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%89/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="JDBC批处理实现手动事务插入1000万数据（单线程 &amp; 多线程）">JDBC批处理实现手动事务插入1000万数据（单线程 &amp; 多线程）</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringDataJPA "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Data%20JPA/SpringData%20JPA%20%E7%B1%BB%E5%9B%BE%E5%8F%8A%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringData JPA 类图及使用方法整理">SpringData JPA 类图及使用方法整理</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringDataJPA "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Data%20JPA/SpringData%20JPA/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringData JPA">SpringData JPA</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringDataJPA "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Data%20JPA/Spring%20Data%20JPA%20%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E6%88%98/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Spring Data JPA 原理与实战">Spring Data JPA 原理与实战</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringDataJPA "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Data%20JPA/Hibernata%20JPA/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Hibernata JPA">Hibernata JPA</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringCloudAlibaba "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Cloud%20Alibaba/SpringCloud%20Alibaba/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringCloud Alibaba">SpringCloud Alibaba</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot2.x%20%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AF%87%20-%20%E6%95%B4%E5%90%88H2%E6%95%B0%E6%8D%AE%E5%BA%93/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot2.x 数据库篇 - 整合H2数据库">SpringBoot2.x 数据库篇 - 整合H2数据库</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot2.x%20%E9%A1%B9%E7%9B%AE%E7%BB%9F%E4%B8%80%E6%9E%9A%E4%B8%BE%E8%BD%AC%E6%8D%A2%E5%AE%9E%E8%B7%B5/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot2.x 项目统一枚举转换实践">SpringBoot2.x 项目统一枚举转换实践</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AD%A6/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot从零开始学">SpringBoot从零开始学</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%E9%85%8D%E7%BD%AE%E5%B1%9E%E6%80%A7%E4%B9%8BDataSource/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot配置属性之DataSource">SpringBoot配置属性之DataSource</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SprinigBoot%E6%96%87%E7%AB%A0%E6%91%98%E8%A6%81%E5%8F%8A%E8%BD%AC%E8%BD%BD/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SprinigBoot文章摘要及转载">SprinigBoot文章摘要及转载</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/%E4%BB%A3%E7%A0%81%E5%AE%A1%E6%9F%A5%E7%9A%84%E5%BF%85%E8%A6%81%E6%80%A7%E5%92%8C%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="代码审查的必要性和最佳实践">代码审查的必要性和最佳实践</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6-%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%B9%8B@Value%E8%BF%9B%E9%98%B6/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 配置文件-读取配置文件之@Value进阶">SpringBoot 2.x 配置文件-读取配置文件之@Value进阶</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6-%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9A%84N%E7%A7%8D%E6%96%B9%E5%BC%8F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 配置文件-读取配置文件的N种方式">SpringBoot 2.x 配置文件-读取配置文件的N种方式</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E7%BB%9F%E4%B8%80%E6%8E%A5%E5%8F%A3%E8%BF%94%E5%9B%9E%E6%A0%BC%E5%BC%8F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 统一接口返回格式">SpringBoot 2.x 统一接口返回格式</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6-%E8%AF%BB%E5%8F%96%20Resources%20%E6%96%87%E4%BB%B6%E4%B9%8B%E6%97%A0%E6%B3%95%E8%AF%BB%E5%8F%96Jar%E5%8C%85classpath%E4%B8%8B%E7%9A%84%E6%96%87%E4%BB%B6/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 配置文件-读取 Resources 文件之无法读取Jar包classpath下的文件">SpringBoot 2.x 配置文件-读取 Resources 文件之无法读取Jar包classpath下的文件</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6-%E8%AF%BB%E5%8F%96%20Resources%20%E6%96%87%E4%BB%B6%E7%9A%84N%E7%A7%8D%E6%96%B9%E5%BC%8F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 配置文件-读取 Resources 文件的N种方式">SpringBoot 2.x 配置文件-读取 Resources 文件的N种方式</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B%E7%AF%87-%E6%8B%A6%E6%88%AA%E5%99%A8%E8%BF%87%E6%BB%A4%E5%99%A8%E4%B8%8E%E7%9B%91%E5%90%AC%E5%99%A8/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 切面编程篇-拦截器过滤器与监听器">SpringBoot 2.x 切面编程篇-拦截器过滤器与监听器</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E5%AE%89%E5%85%A8%E5%AF%86%E7%A0%81%E5%AD%A6%E4%B9%8B%E5%8A%A0%E8%A7%A3%E5%AF%86%E7%AE%97%E6%B3%95/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 安全密码学之加解密算法">SpringBoot 2.x 安全密码学之加解密算法</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3%E5%A4%A7%E5%85%A8/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 常用注解大全">SpringBoot 2.x 常用注解大全</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3%E8%AF%A6%E8%A7%A3/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 常用注解详解">SpringBoot 2.x 常用注解详解</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E5%90%AF%E5%8A%A8%E6%97%B6%E5%8A%A0%E8%BD%BD%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84N%E7%A7%8D%E6%96%B9%E5%BC%8F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 启动时加载初始化的N种方式">SpringBoot 2.x 启动时加载初始化的N种方式</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%8F%8A%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E8%BF%87%E7%A8%8B/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 启动流程及自动装配过程">SpringBoot 2.x 启动流程及自动装配过程</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E5%8A%A8%E6%80%81%E8%A3%85%E9%85%8DBean%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 动态装配Bean的三种方式">SpringBoot 2.x 动态装配Bean的三种方式</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E5%88%A9%E5%99%A8-1%20JUnit5/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 单元测试利器-1 JUnit5">SpringBoot 2.x 单元测试利器-1 JUnit5</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E5%88%A9%E5%99%A8-3%20MockMvc/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 单元测试利器-3 MockMvc">SpringBoot 2.x 单元测试利器-3 MockMvc</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E5%88%A9%E5%99%A8-2%20Mockito/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 单元测试利器-2 Mockito">SpringBoot 2.x 单元测试利器-2 Mockito</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E5%88%86%E7%89%87%E4%B8%8A%E4%BC%A0%E3%80%81%E6%96%AD%E7%82%B9%E7%BB%AD%E4%BC%A0%E3%80%81%E5%A4%A7%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E3%80%81%E7%A7%92%E4%BC%A0/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 分片上传、断点续传、大文件上传、秒传">SpringBoot 2.x 分片上传、断点续传、大文件上传、秒传</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20Validation%20%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C%EF%BC%88TODO%EF%BC%89/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x Validation 参数校验（TODO）">SpringBoot 2.x Validation 参数校验（TODO）</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20WebMvcConfigurer%20%E8%AF%A6%E8%A7%A3%E3%80%90SpringMVC%E3%80%91/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x WebMvcConfigurer 详解【SpringMVC】">SpringBoot 2.x WebMvcConfigurer 详解【SpringMVC】</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20YML%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x YML配置文件详解">SpringBoot 2.x YML配置文件详解</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E5%88%86%E5%B8%83%E5%BC%8F%E5%85%A8%E5%B1%80%E5%94%AF%E4%B8%80ID%E7%94%9F%E6%88%90%E6%96%B9%E6%A1%88/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 分布式全局唯一ID生成方案">SpringBoot 2.x 分布式全局唯一ID生成方案</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20JWT%20%E6%A6%82%E5%BF%B5%E7%AF%87/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x JWT 概念篇">SpringBoot 2.x JWT 概念篇</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20Jar%20%E5%8C%85%E5%90%AF%E5%8A%A8%E3%80%81%E5%81%9C%E6%AD%A2%E3%80%81%E9%87%8D%E5%90%AF%E8%84%9A%E6%9C%AC/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x Jar 包启动、停止、重启脚本">SpringBoot 2.x Jar 包启动、停止、重启脚本</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20Java%20%E5%AE%9E%E7%8E%B0%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E7%9A%848%E7%A7%8D%E6%96%B9%E5%BC%8F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x Java 实现异步编程的8种方式">SpringBoot 2.x Java 实现异步编程的8种方式</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20Java%20%E7%A8%8B%E5%BA%8F%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0%E6%80%BB%E7%BB%93/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x Java 程序命令行参数总结">SpringBoot 2.x Java 程序命令行参数总结</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20@ConfigurationProperties%E4%BB%A5%E5%8F%8A@NestedConfigurationProperty%E7%9A%84%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x @ConfigurationProperties以及@NestedConfigurationProperty的使用详解">SpringBoot 2.x @ConfigurationProperties以及@NestedConfigurationProperty的使用详解</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20@ControllerAdvice%E4%B8%89%E7%A7%8D%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x @ControllerAdvice三种使用场景">SpringBoot 2.x @ControllerAdvice三种使用场景</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20HTTP%20Content-Type%20%E8%AF%A6%E8%A7%A3/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x HTTP Content-Type 详解">SpringBoot 2.x HTTP Content-Type 详解</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20HTTP%20Headers%20%E5%A4%B4%E4%BF%A1%E6%81%AF%E8%AF%BB%E5%8F%96/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x HTTP Headers 头信息读取">SpringBoot 2.x HTTP Headers 头信息读取</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20JWT%20%E5%AE%9E%E6%88%98%E7%AF%87/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x JWT 实战篇">SpringBoot 2.x JWT 实战篇</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%20%E6%8E%A5%E5%8F%A3%E5%B9%82%E7%AD%89%E6%80%A7%E5%AE%9E%E7%8E%B0/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x  接口幂等性实现">SpringBoot 2.x  接口幂等性实现</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/Spring%20IO%20Platform%EF%BC%9A%E8%A7%A3%E5%86%B3%E4%BE%9D%E8%B5%96%E7%89%88%E6%9C%AC%E5%86%B2%E7%AA%81/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Spring IO Platform：解决依赖版本冲突">Spring IO Platform：解决依赖版本冲突</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B%E7%AF%87-AOP%20%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%8E%9F%E7%90%86/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 切面编程篇-AOP 的使用及原理">SpringBoot 2.x 切面编程篇-AOP 的使用及原理</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE SSM框架 "
           href="/2023/08/28/2%E3%80%81JavaEE/2%E3%80%81SSM%E6%A1%86%E6%9E%B6/SpringMVC/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringMVC">SpringMVC</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 Shiro "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Shiro/Shiro%E6%9D%83%E9%99%90%E5%AE%9E%E6%88%98%E8%AF%BE%E7%A8%8B/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Shiro权限实战课程">Shiro权限实战课程</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 Shiro "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Shiro/Shiro%E6%9D%83%E9%99%90%E5%AE%9E%E6%88%98/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Shiro权限实战">Shiro权限实战</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE SSM框架 "
           href="/2023/08/28/2%E3%80%81JavaEE/2%E3%80%81SSM%E6%A1%86%E6%9E%B6/Spring/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Spring">Spring</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE SSM框架 "
           href="/2023/08/28/2%E3%80%81JavaEE/2%E3%80%81SSM%E6%A1%86%E6%9E%B6/MybatisPlus/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="MybatisPlus">MybatisPlus</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE JavaWeb "
           href="/2023/08/28/2%E3%80%81JavaEE/1%E3%80%81JavaWeb/%E4%BD%A0%E8%BF%98%E5%9C%A8%E4%B8%BA%20HTTP%20%E7%9A%84%E8%BF%99%E4%BA%9B%E6%A6%82%E5%BF%B5%E5%A4%B4%E7%96%BC%E5%90%97/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="你还在为 HTTP 的这些概念头疼吗">你还在为 HTTP 的这些概念头疼吗</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE JavaWeb "
           href="/2023/08/28/2%E3%80%81JavaEE/1%E3%80%81JavaWeb/Cookie%E3%80%81Session%E3%80%81Token%E3%80%81JWT%E7%BB%88%E4%BA%8E%E8%AE%B2%E6%B8%85%E6%A5%9A%E4%BA%86/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Cookie、Session、Token、JWT终于讲清楚了">Cookie、Session、Token、JWT终于讲清楚了</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 _posts 数据库 "
           href="/2023/08/28/3%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL-%E9%AB%98%E7%BA%A7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="MySQL-高级">MySQL-高级</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 _posts 数据库 "
           href="/2023/08/28/3%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL-%E5%88%9D%E7%BA%A7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="MySQL-初级">MySQL-初级</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 _posts 数据库 "
           href="/2023/08/28/3%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93/H2%20Database/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="H2 Database">H2 Database</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E4%BC%98%E5%8C%96%E7%AF%87%E4%B9%8B%20%E6%B3%A8%E8%A7%A3%20+%20%E5%8F%8D%E5%B0%84%E6%B6%88%E9%99%A4%E9%87%8D%E5%A4%8D%E4%BB%A3%E7%A0%81/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 优化篇之 注解 + 反射消除重复代码">Java 优化篇之 注解 + 反射消除重复代码</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E4%BC%98%E5%8C%96%E7%AF%87%E4%B9%8B%20%E5%BB%B6%E6%97%B6%E9%98%9F%E5%88%97%20-%20%E8%AE%A2%E5%8D%95%E8%B6%85%E6%97%B6%E8%87%AA%E5%8A%A8%E5%8F%96%E6%B6%88%E7%9A%84N%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 优化篇之 延时队列 - 订单超时自动取消的N种实现方式">Java 优化篇之 延时队列 - 订单超时自动取消的N种实现方式</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E9%9B%86%E5%90%88%E7%AF%87%E4%B9%8B%20%E8%8E%B7%E5%8F%96%E4%B8%A4%E4%B8%AA%E9%9B%86%E5%90%88List%E7%9A%84%E4%BA%A4%E9%9B%86%E3%80%81%E8%A1%A5%E9%9B%86%E3%80%81%E5%B9%B6%E9%9B%86%E3%80%81%E5%B7%AE%E9%9B%86%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 集合篇之 获取两个集合List的交集、补集、并集、差集的几种方式">Java 集合篇之 获取两个集合List的交集、补集、并集、差集的几种方式</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E4%BC%98%E5%8C%96%E7%AF%87%E4%B9%8B%20if-else%20%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 优化篇之 if-else 代码优化方案">Java 优化篇之 if-else 代码优化方案</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E9%9B%86%E5%90%88%E7%AF%87%E4%B9%8B%20Lambda%20%E5%AE%9E%E7%8E%B0%E8%B6%85%E5%BC%BA%E6%8E%92%E5%BA%8F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 集合篇之 Lambda 实现超强排序">Java 集合篇之 Lambda 实现超强排序</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4%E5%90%84%E7%B1%BB%E5%9E%8B%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 日期时间各类型相互转换">Java 日期时间各类型相互转换</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 动态代理">Java 动态代理</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E5%9F%BA%E6%9C%AC%E5%8A%9F%E7%AF%87%E4%B9%8B%20for%E3%80%81for-each%E3%80%81forEach()%20%E7%9A%84%20break%E3%80%81continue%E3%80%81return/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 基本功篇之 for、for-each、forEach() 的 break、continue、return">Java 基本功篇之 for、for-each、forEach() 的 break、continue、return</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6%E8%AF%A6%E8%A7%A3/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 日志框架详解">Java 日志框架详解</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java新特性 "
           href="/2023/08/28/1%E3%80%81JavaSE/3.Java%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%20%E6%96%B0%E7%89%B9%E6%80%A7%E6%A6%82%E8%BF%B0%E5%8F%8A%E7%89%88%E6%9C%AC%E5%8F%91%E8%A1%8C%E5%8F%B2/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 新特性概述及版本发行史">Java 新特性概述及版本发行史</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20Bean%20%E4%B9%8B%20Record%20%E7%B1%BB/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java Bean 之 Record 类">Java Bean 之 Record 类</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E4%BC%98%E5%8C%96%E7%AF%87%E4%B9%8B%20GZIP%E5%8E%8B%E7%BC%A9%E5%AD%97%E7%AC%A6%E4%B8%B2/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 优化篇之 GZIP压缩字符串">Java 优化篇之 GZIP压缩字符串</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java进阶篇 JVM虚拟机 "
           href="/2023/08/28/1%E3%80%81JavaSE/2.Java%20%E8%BF%9B%E9%98%B6%E7%AF%87/JVM%20%E8%99%9A%E6%8B%9F%E6%9C%BA/Java%20GC%20%E6%80%BB%E7%BB%93/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java GC 总结">Java GC 总结</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java新特性 Java9新特性 "
           href="/2023/08/28/1%E3%80%81JavaSE/3.Java%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%209%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%209%20%E6%96%B0%E7%89%B9%E6%80%A7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 9 新特性">Java 9 新特性</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java新特性 Java8新特性 "
           href="/2023/08/28/1%E3%80%81JavaSE/3.Java%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%208%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%208%20%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8B%20Stream%20%E6%B5%81/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 8 新特性之 Stream 流">Java 8 新特性之 Stream 流</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java新特性 Java8新特性 "
           href="/2023/08/28/1%E3%80%81JavaSE/3.Java%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%208%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%208%20%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8B%20Optional%20%E7%B1%BB/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 8 新特性之 Optional 类">Java 8 新特性之 Optional 类</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java新特性 Java8新特性 "
           href="/2023/08/28/1%E3%80%81JavaSE/3.Java%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%208%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%208%20%E6%96%B0%E7%89%B9%E6%80%A7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 8 新特性">Java 8 新特性</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java新特性 Java8新特性 "
           href="/2023/08/28/1%E3%80%81JavaSE/3.Java%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%208%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%208%20%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8B%20DateTime%20API/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 8 新特性之 DateTime API">Java 8 新特性之 DateTime API</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java新特性 Java18新特性 "
           href="/2023/08/28/1%E3%80%81JavaSE/3.Java%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2018%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2018%20%E6%96%B0%E7%89%B9%E6%80%A7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 18 新特性">Java 18 新特性</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java新特性 Java20新特性 "
           href="/2023/08/28/1%E3%80%81JavaSE/3.Java%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2020%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2020%20%E6%96%B0%E7%89%B9%E6%80%A7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 20 新特性">Java 20 新特性</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java新特性 Java19新特性 "
           href="/2023/08/28/1%E3%80%81JavaSE/3.Java%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2019%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2019%20%E6%96%B0%E7%89%B9%E6%80%A7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 19 新特性">Java 19 新特性</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java新特性 Java17新特性 "
           href="/2023/08/28/1%E3%80%81JavaSE/3.Java%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2017%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2017%20%E6%96%B0%E7%89%B9%E6%80%A7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 17 新特性">Java 17 新特性</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java新特性 Java15新特性 "
           href="/2023/08/28/1%E3%80%81JavaSE/3.Java%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2015%E6%96%B0%E7%89%B9%E6%80%A7/Java%2015%20%E6%96%B0%E7%89%B9%E6%80%A7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 15 新特性">Java 15 新特性</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java新特性 Java16新特性 "
           href="/2023/08/28/1%E3%80%81JavaSE/3.Java%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2016%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2016%20%E6%96%B0%E7%89%B9%E6%80%A7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 16 新特性">Java 16 新特性</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java新特性 Java13新特性 "
           href="/2023/08/28/1%E3%80%81JavaSE/3.Java%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2013%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2013%20%E6%96%B0%E7%89%B9%E6%80%A7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 13 新特性">Java 13 新特性</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java新特性 Java14新特性 "
           href="/2023/08/28/1%E3%80%81JavaSE/3.Java%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2014%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2014%20%E6%96%B0%E7%89%B9%E6%80%A7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 14 新特性">Java 14 新特性</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java新特性 Java10新特性 "
           href="/2023/08/28/1%E3%80%81JavaSE/3.Java%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2010%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2010%20%E6%96%B0%E7%89%B9%E6%80%A7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 10 新特性">Java 10 新特性</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java新特性 Java11新特性 "
           href="/2023/08/28/1%E3%80%81JavaSE/3.Java%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2011%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2011%20%E6%96%B0%E7%89%B9%E6%80%A7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 11 新特性">Java 11 新特性</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java新特性 Java12新特性 "
           href="/2023/08/28/1%E3%80%81JavaSE/3.Java%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2012%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2012%20%E6%96%B0%E7%89%B9%E6%80%A7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 12 新特性">Java 12 新特性</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java基础篇 Java基础语法 "
           href="/2023/08/28/1%E3%80%81JavaSE/1.Java%20%E5%9F%BA%E7%A1%80%E7%AF%87/1%E3%80%81Java%20%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/Java%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 面向对象编程">Java 面向对象编程</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java基础篇 Java集合类 "
           href="/2023/08/28/1%E3%80%81JavaSE/1.Java%20%E5%9F%BA%E7%A1%80%E7%AF%87/3%E3%80%81Java%20%E9%9B%86%E5%90%88%E7%B1%BB/Java%20%E7%B1%BB%E9%9B%86%E6%A1%86%E6%9E%B6/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 类集框架">Java 类集框架</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java基础篇 Java常用类库 "
           href="/2023/08/28/1%E3%80%81JavaSE/1.Java%20%E5%9F%BA%E7%A1%80%E7%AF%87/2%E3%80%81Java%20%E5%B8%B8%E7%94%A8%E7%B1%BB%E5%BA%93/Java%20%E5%B8%B8%E7%94%A8%E7%B1%BB%E5%BA%93/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 常用类库">Java 常用类库</span>
            <span class="post-date" title="2023-08-28 09:23:44">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java基础篇 Java多线程 "
           href="/2023/08/28/1%E3%80%81JavaSE/1.Java%20%E5%9F%BA%E7%A1%80%E7%AF%87/5%E3%80%81Java%20%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 多线程基础">Java 多线程基础</span>
            <span class="post-date" title="2023-08-28 09:23:44">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java基础篇 Java反射与注解 "
           href="/2023/08/28/1%E3%80%81JavaSE/1.Java%20%E5%9F%BA%E7%A1%80%E7%AF%87/4%E3%80%81Java%20%E5%8F%8D%E5%B0%84%E4%B8%8E%E6%B3%A8%E8%A7%A3/Java%20%E5%8F%8D%E5%B0%84%E4%B8%8E%E6%B3%A8%E8%A7%A3/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 反射与注解">Java 反射与注解</span>
            <span class="post-date" title="2023-08-28 09:23:44">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java基础篇 JavaNIO流 "
           href="/2023/08/28/1%E3%80%81JavaSE/1.Java%20%E5%9F%BA%E7%A1%80%E7%AF%87/7%E3%80%81Java%20NIO%20%E6%B5%81/Java%20NIO%20%E6%B5%81/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java NIO 流">Java NIO 流</span>
            <span class="post-date" title="2023-08-28 09:23:44">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java基础篇 JavaIO流 "
           href="/2023/08/28/1%E3%80%81JavaSE/1.Java%20%E5%9F%BA%E7%A1%80%E7%AF%87/6%E3%80%81Java%20IO%20%E6%B5%81/Java%20IO%20%E6%B5%81/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java IO 流">Java IO 流</span>
            <span class="post-date" title="2023-08-28 09:23:44">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java进阶篇 Java设计模式 "
           href="/2023/08/28/1%E3%80%81JavaSE/2.Java%20%E8%BF%9B%E9%98%B6%E7%AF%87/Java%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/Java%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 设计模式">Java 设计模式</span>
            <span class="post-date" title="2023-08-28 09:23:44">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java进阶篇 JVM虚拟机 "
           href="/2023/08/28/1%E3%80%81JavaSE/2.Java%20%E8%BF%9B%E9%98%B6%E7%AF%87/JVM%20%E8%99%9A%E6%8B%9F%E6%9C%BA/7%20%E6%AE%B5%E5%B0%8F%E4%BB%A3%E7%A0%81%EF%BC%8C%E7%8E%A9%E8%BD%ACJava%E7%A8%8B%E5%BA%8F%E5%B8%B8%E8%A7%81%E7%9A%84%E5%B4%A9%E6%BA%83%E5%9C%BA%E6%99%AF/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="7 段小代码，玩转Java程序常见的崩溃场景">7 段小代码，玩转Java程序常见的崩溃场景</span>
            <span class="post-date" title="2023-08-28 09:23:44">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java进阶篇 JVM虚拟机 "
           href="/2023/08/28/1%E3%80%81JavaSE/2.Java%20%E8%BF%9B%E9%98%B6%E7%AF%87/JVM%20%E8%99%9A%E6%8B%9F%E6%9C%BA/JVM%20%E8%99%9A%E6%8B%9F%E6%9C%BA/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="JVM 虚拟机">JVM 虚拟机</span>
            <span class="post-date" title="2023-08-28 09:23:44">2023/08/28</span>
        </a>
        
        <div id="no-item-tips">

        </div>
    </nav>
    <div id="outline-list">
    </div>
</div>

    </div>
    <div class="hide-list">
        <div class="semicircle" data-title="切换全屏 快捷键 s">
            <div class="brackets first"><</div>
            <div class="brackets">&gt;</div>
        </div>
    </div>
</aside>
<div id="post">
    <div class="pjax">
        <article id="post-1、JavaSE/1.Java 基础篇/3、Java 集合类/Java 类集框架" class="article article-type-post" itemscope itemprop="blogPost">
    
        <h1 class="article-title">Java 类集框架</h1>
    
    <div class="article-meta">
        
        
        
        <span class="book">
            <i class="iconfont icon-category"></i>
            
            
            <a  data-rel="Java基础篇">Java基础篇</a> > 
            
            <a  data-rel="Java基础篇&lt;---&gt;Java集合类">Java集合类</a>
            
        </span>
        
        
    </div>
    <div class="article-meta">
        
            发布时间 : <time class="date" title='最后更新: 2024-10-18 18:28:56'>2023-08-28 09:23</time>
        
    </div>
    <div class="article-meta">
        
        
        <span id="busuanzi_container_page_pv">
            阅读 :<span id="busuanzi_value_page_pv">
                <span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </span>
        </span>
        
        
    </div>
    
    <div class="toc-ref">
    
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B1%BB%E9%9B%86%E7%AE%80%E4%BB%8B"><span class="toc-text">类集简介</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81Java-%E7%B1%BB%E9%9B%86%E6%A1%86%E6%9E%B6%E7%AE%80%E4%BB%8B"><span class="toc-text">1、Java 类集框架简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81Collection-%E9%9B%86%E5%90%88%E6%8E%A5%E5%8F%A3"><span class="toc-text">2、Collection 集合接口</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#List-%E9%9B%86%E5%90%88"><span class="toc-text">List 集合</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81List-%E6%8E%A5%E5%8F%A3%E7%AE%80%E4%BB%8B"><span class="toc-text">1、List 接口简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81ArrayList-%E5%AD%90%E7%B1%BB"><span class="toc-text">2、ArrayList 子类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81ArrayList-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-text">3、ArrayList 源码分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81ArrayList-%E4%BF%9D%E5%AD%98%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB"><span class="toc-text">3、ArrayList 保存自定义类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81LinkedList-%E5%AD%90%E7%B1%BB"><span class="toc-text">4、LinkedList 子类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81LinkedList-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-text">5、LinkedList 源码分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81Vector-%E5%AD%90%E7%B1%BB"><span class="toc-text">6、Vector 子类</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Set-%E9%9B%86%E5%90%88"><span class="toc-text">Set 集合</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81Set-%E6%8E%A5%E5%8F%A3%E7%AE%80%E4%BB%8B"><span class="toc-text">1、Set 接口简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81HashSet-%E5%AD%90%E7%B1%BB"><span class="toc-text">2、HashSet 子类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81TreeSet-%E5%AD%90%E7%B1%BB"><span class="toc-text">3、TreeSet 子类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81TreeSet-%E6%8E%92%E5%BA%8F%E8%AF%B4%E6%98%8E"><span class="toc-text">4、TreeSet 排序说明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81%E5%85%B3%E4%BA%8E%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%E8%AF%B4%E6%98%8E"><span class="toc-text">5、关于重复元素说明</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E8%BE%93%E5%87%BA"><span class="toc-text">集合输出</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81Iterator-%E8%BE%93%E5%87%BA%EF%BC%88%E6%A0%B8%E5%BF%83%EF%BC%89"><span class="toc-text">1、Iterator 输出（核心）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81ListIterator-%E8%BE%93%E5%87%BA"><span class="toc-text">2、ListIterator 输出</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81Enumeration-%E8%BE%93%E5%87%BA"><span class="toc-text">3、Enumeration 输出</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81Foreach-%E8%BE%93%E5%87%BA"><span class="toc-text">4、Foreach 输出</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Map-%E9%9B%86%E5%90%88"><span class="toc-text">Map 集合</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81Map-%E6%8E%A5%E5%8F%A3%E7%AE%80%E4%BB%8B"><span class="toc-text">1、Map 接口简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81HashMap-%E5%AD%90%E7%B1%BB"><span class="toc-text">2、HashMap 子类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81LinkedHashMap-%E5%AD%90%E7%B1%BB"><span class="toc-text">3、LinkedHashMap 子类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81HashTable-%E5%AD%90%E7%B1%BB"><span class="toc-text">4、HashTable 子类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81TreeMap-%E5%AD%90%E7%B1%BB"><span class="toc-text">5、TreeMap 子类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81Map-Entry-%E6%8E%A5%E5%8F%A3"><span class="toc-text">6、Map.Entry 接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E3%80%81Map-%E9%9B%86%E5%90%88%E7%9A%84%E8%BE%93%E5%87%BA"><span class="toc-text">7、Map 集合的输出</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8%E3%80%81%E5%85%B3%E4%BA%8E-Key-%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-text">8、关于 Key 的定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9%E3%80%81Java-8-Map-%E6%96%B9%E6%B3%95"><span class="toc-text">9、Java 8 Map 方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81getOrDefault-%EF%BC%9Aget-%E4%B8%8D%E5%88%B0%E9%94%AE%E5%88%99%E8%BF%94%E5%9B%9E%E9%BB%98%E8%AE%A4%E5%80%BC"><span class="toc-text">1、getOrDefault()：get 不到键则返回默认值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81putIfAbsent-%EF%BC%9A%E9%94%AE%E4%B8%8D%E5%AD%98%E5%9C%A8%E6%97%B6%E6%89%A7%E8%A1%8C-put-%E6%96%B9%E6%B3%95"><span class="toc-text">2、putIfAbsent()：键不存在时执行 put 方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81replace%EF%BC%9A%E5%BD%93-key-%E5%AD%98%E5%9C%A8%E6%97%B6%E6%89%8D%E6%89%A7%E8%A1%8C-put-%E6%96%B9%E6%B3%95"><span class="toc-text">3、replace：当 key 存在时才执行 put 方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81replaceAll%EF%BC%9A%E4%BD%BF%E7%94%A8%E5%87%BD%E6%95%B0%E9%87%8D%E5%86%99-value"><span class="toc-text">4、replaceAll：使用函数重写 value</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81compute%EF%BC%9A%E6%A0%B9%E6%8D%AE-value-%E6%9D%A5%E9%87%8D%E5%86%99%E8%AE%A1%E7%AE%97"><span class="toc-text">5、compute：根据 value 来重写计算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81computeIfAbsent%EF%BC%9A%E5%BD%93-value-%E4%B8%8D%E5%AD%98%E5%9C%A8%E6%97%B6%E9%87%8D%E6%96%B0%E8%AE%A1%E7%AE%97"><span class="toc-text">6、computeIfAbsent：当 value 不存在时重新计算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%E3%80%81computeIfPresent%EF%BC%9A%E5%BD%93-value-%E5%AD%98%E5%9C%A8%E6%97%B6%E9%87%8D%E6%96%B0%E8%AE%A1%E7%AE%97"><span class="toc-text">7、computeIfPresent：当 value 存在时重新计算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8%E3%80%81merge%EF%BC%9A%E5%90%88%E5%B9%B6%E6%96%B0%E6%97%A7%E4%B8%A4%E4%B8%AA%E5%80%BC"><span class="toc-text">8、merge：合并新旧两个值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9%E3%80%81Java8-%E4%B8%AD-Map-%E7%9A%84-10-%E4%B8%AA%E5%B8%B8%E7%94%A8%E6%96%B0%E6%96%B9%E6%B3%95"><span class="toc-text">9、Java8 中 Map 的 10 个常用新方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97"><span class="toc-text">栈与队列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81Stack-%E6%A0%88"><span class="toc-text">1、Stack 栈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81Queue-%E9%98%9F%E5%88%97"><span class="toc-text">2、Queue 队列</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Properties-%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-text">Properties 工具类</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Collections-%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-text">Collections 工具类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E6%8E%92%E5%BA%8F%E6%93%8D%E4%BD%9C"><span class="toc-text">1、排序操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E6%9F%A5%E6%89%BE%E6%9B%BF%E6%8D%A2"><span class="toc-text">2、查找替换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E5%90%8C%E6%AD%A5%E6%8E%A7%E5%88%B6"><span class="toc-text">3、同步控制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E4%B8%8D%E5%8F%AF%E5%8F%98%E9%9B%86%E5%90%88"><span class="toc-text">4、不可变集合</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81%E5%85%B6%E5%AE%83%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">5、其它常用方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE-%E9%B8%A3%E8%B0%A2"><span class="toc-text">6、参考文献 &amp; 鸣谢</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java-%E9%9B%86%E5%90%88%E6%B1%87%E6%80%BB%E7%AF%87"><span class="toc-text">Java 集合汇总篇</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81List%E6%8E%A5%E5%8F%A3%E4%B8%8E%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0%E7%B1%BB"><span class="toc-text">1、List接口与接口实现类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81Set%E6%8E%A5%E5%8F%A3%E4%B8%8E%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0%E7%B1%BB"><span class="toc-text">2、Set接口与接口实现类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81Map%E6%8E%A5%E5%8F%A3%E4%B8%8E%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0%E7%B1%BB"><span class="toc-text">3、Map接口与接口实现类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95"><span class="toc-text">4、线程安全处理方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81ArrayList%E3%80%81LinkedList%E5%92%8CVector%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">5、ArrayList、LinkedList和Vector的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81HashMap%E5%92%8CHashTable%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">6、HashMap和HashTable的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E3%80%81HashMap%E5%92%8CHashTable%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">7、HashMap和HashTable的区别</span></a></li></ol></li></ol>
    
<style>
    .left-col .switch-btn,
    .left-col .switch-area {
        display: none;
    }
    .toc-level-3 i,
    .toc-level-3 ol {
        display: none !important;
    }
</style>
</div>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="类集简介"><a href="#类集简介" class="headerlink" title="类集简介"></a>类集简介</h1><h2 id="1、Java-类集框架简介"><a href="#1、Java-类集框架简介" class="headerlink" title="1、Java 类集框架简介"></a>1、Java 类集框架简介</h2><p>从JDK1.2开始Java引入了类集开发框架，所谓的类集指的就是一套动态对象数组的实现方案，在实际的开发之中没有任何项的开发可以离开数组，但是传统的数组实现起来非常的繁琐，而且长度是其致命伤，正是因为长度的问题，所以传统的数组是不可能大范围使用的，但是我们的开发又不可能离开数组，所以最初就只能依靠一些数据结构来实现动态的数组处理，而其中最为重要的两个结构：链表、树，但是面对这些数据结构的实现又不得不面对如下的一些问题：</p>
<ol>
<li>数据结构的代码实现困难,对于一般的开发者是无法进行使用的</li>
<li>对于链表或二叉树当进行更新处理的时候的维护是非常麻烦的</li>
<li>对于链表或二叉树还需要尽可能保证其操作的性能</li>
</ol>
<p>正是因为这样的原因，所以从JDK1.2开始Java引入了类集，主要就是对常见的数据结构进行完整的实现包装，并且提供有一系列的接口与实现子类来帮助用户减少数据结构所带来的开发困难，但是最初的类集实现由于Java本身的技术所限，所以对于数据的控制并不严格，全部采用了 Object 类型进行数据接收，而在JDK1.5之后由于泛型技术的推广，所以类集本身也得到了良好的改进，可以直接利用泛型来保存相同类型的数据，并且随着数据量的不断增加，从JDK1.8开始类集中的实现算法也得到了良好的性能提升。</p>
<p>在整个类集框架里面提供有如下的几个核心接口：Collection、Lits、Set、Map、Iterator、ListIterator、Enumeration、Queue</p>
<p><img src="/Java-%E7%B1%BB%E9%9B%86%E6%A1%86%E6%9E%B6.assets/image-20241017215310348.png"></p>
<h2 id="2、Collection-集合接口"><a href="#2、Collection-集合接口" class="headerlink" title="2、Collection 集合接口"></a>2、Collection 集合接口</h2><p>java.util.Collection是（单值）集合操作的最大的父接口，在该接口中定义有所有的单值数据的处理操作，这个接口中定义了如下的核心操作方法：<br>单值集合：每次操作只能保存一个数据对象。</p>
<pre><code class="java">public boolean add(E e);                          // 向集合保存数据
public boolean addAll(Collection&lt;? extends E&gt; c); // 追加一组数据
public void clear();                              // 清空集合，让根节点为空，同时执行GC处理
public boolean contains(Object o);                // 查询数据是否存在，需要equals()方法支持
public boolean remove(Object o);                  // 数据删除，需要equals()方法支持
public int size();                                // 获取数据长度，最大值为：Integer.MAX_VALUE
public Object[] toArray();                        // 将集合变为对象数组返回
public Iterator&lt;E&gt; iterator();                    // 将集合变为Iterator接口返回
public ListIterator&lt;E&gt; listIterator();            // 将集合变为ListIterator接口返回
</code></pre>
<p>在进行集合操作时，有两个方法最为常用：【增加】add()、【输出】iterator()</p>
<p>在JDK1.5版本之前，Collection只是一个独立的接口，但是从JDK1.5后，提供了Iterable父接口，并且在JDK1.8后针对于Iterable接口也得到了一些扩充。另外，在JDK1.2~JDK1.4的时代里面，如果要进行集合的使用往往会直接操作Collection接口，但是从JDK1.5时代开始更多的情况下选择的都是Collection的两个子接口：允许重复的List子接口、不允许重复的Set子接口；</p>
<p>Collection接口结构：</p>
<p><img src="/Java-%E7%B1%BB%E9%9B%86%E6%A1%86%E6%9E%B6.assets/image-20241017215310349.png"></p>
<h1 id="List-集合"><a href="#List-集合" class="headerlink" title="List 集合"></a>List 集合</h1><p>本节介绍了List接口的使用，在List子接口中有三个常用子类：ArrayList、Vector、LinkedList，之后会做详细说明。</p>
<h2 id="1、List-接口简介"><a href="#1、List-接口简介" class="headerlink" title="1、List 接口简介"></a>1、List 接口简介</h2><p>List是Collection的子接口，其最大的特点是允许保存有重复元素数据，该接口的定义如下：</p>
<pre><code class="java">public interface List&lt;E&gt; extends Collection&lt;E&gt; &#123;&#125;
</code></pre>
<p>但是需要清楚的是List子接口对于Collection接口进行了方法扩充：</p>
<pre><code class="java">public E get(int index);                                 // 获取指定索引上的数据
public E set(int index, E element);                      // 修改指定索引数据
public Iterator&lt;E&gt; iterator();                           // 返回Iterator接口对象
public ListIterator&lt;E&gt; listIterator();                   // 返回ListIterator接口对象
public static &lt;E&gt; List&lt;E&gt; of(E... elements);             // 将数据转为List集合（JDK1.9）
public default void forEach(Consumer&lt;? super T&gt; action); // 使用foreach结合消费型接口输出
</code></pre>
<p>但是List本身依然属于一个接口，那么对于接口要想使用则一定要使用子类来完成定义，在List子接口中有三个常用子类：ArrayList、Vector、LinkedList</p>
<p><img src="/Java-%E7%B1%BB%E9%9B%86%E6%A1%86%E6%9E%B6.assets/image-20241017215310350.png"></p>
<p>操作示例：观察List中的静态方法（JDK1.9后的方法）从JDK1.9开始，List子接口里面追加有一些 statIc方法，以方便用户的处理</p>
<pre><code class="java">import java.util.List;
public class JavaAPIDemo &#123;
    public static void main(String[] args) throws Exception &#123;
        List&lt;String&gt; all = List.of(&quot;Hello&quot;, &quot;World&quot;, &quot;饿了么？&quot;);
        System.out.println(all);
        System.out.println(all.getClass());
    &#125;
&#125;

// 输出内容
[Hello, World, 饿了么？]
class java.util.ImmutableCollections$ListN
</code></pre>
<p>这些操作方法并不是List的传统用法，是在新版本JDK1.9之后添加的新功能。</p>
<h2 id="2、ArrayList-子类"><a href="#2、ArrayList-子类" class="headerlink" title="2、ArrayList 子类"></a>2、ArrayList 子类</h2><p>ArrayList是List子接口中使用最多的一个子类，但是这个子类在使用时也是有前提要求的，所以本次来对这个类的相关定义以及源代码组成进行分析，在Java里面ArrayList类的定义如下：</p>
<pre><code class="java">public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable &#123;&#125;
</code></pre>
<p>ArrayList的继承结构</p>
<p><img src="/Java-%E7%B1%BB%E9%9B%86%E6%A1%86%E6%9E%B6.assets/image-20241017215310351.png"></p>
<p>操作示例 1：使用ArrayList实例化List父接口</p>
<pre><code class="java">import java.util.ArrayList;
import java.util.List;
public class JavaAPIDemo &#123;
    public static void main(String[] args) &#123;
        // 为List父接口进行实例化
        List&lt;String&gt; all = new ArrayList&lt;&gt;();
        all.add(&quot;Hello&quot;) ;
        all.add(&quot;Hello&quot;) ;	// 重复数据
        all.add(&quot;World&quot;) ;
        all.add(&quot;XXXX&quot;) ;
        System.out.println(all);
    &#125;
&#125;

// 输出内容
[Hello, Hello, World, XXXX]
</code></pre>
<p>通过本程序可以发现List存储的特征：</p>
<ol>
<li>保存的顺序就是其存储顺序</li>
<li>List集合里面允许存在有重复数据</li>
</ol>
<p>操作示例 2：利用forEach()进行输出（不是标准输出）在JDK1.8之后Iterable父接口中定义forEach()方法输出支持：</p>
<pre><code class="java">import java.util.ArrayList;
import java.util.List;
public class JavaAPIDemo &#123;
    public static void main(String[] args) &#123;
        // 为List父接口进行实例化
        List&lt;String&gt; all = new ArrayList&lt;&gt;();
        all.add(&quot;Hello&quot;);
        all.add(&quot;Hello&quot;);    // 重复数据
        all.add(&quot;World&quot;);
        all.add(&quot;XXXX&quot;);
        all.forEach(str -&gt; System.out.print(str + &quot;、&quot;));
    &#125;
&#125;

// 输出内容
Hello、Hello、World、XXXX、
</code></pre>
<p>需要注意的是：此种输出并不是正常开发情况下要考虑的操作形式。</p>
<p>操作示例 3：观察List集合的其它操作方法</p>
<pre><code class="java">import java.util.ArrayList;
import java.util.List;
public class JavaAPIDemo &#123;
    public static void main(String[] args) &#123;
        // 为List父接口进行实例化
        List&lt;String&gt; all = new ArrayList&lt;&gt;();
        System.out.println(&quot;集合是否为空？&quot; + all.isEmpty() + &quot;、集合元素个数：&quot; + all.size());
        all.add(&quot;Hello&quot;) ;
        all.add(&quot;Hello&quot;) ;	// 重复数据
        all.add(&quot;World&quot;) ;
        all.add(&quot;XXXX&quot;) ;
        all.remove(&quot;Hello&quot;) ; // 删除元素
        System.out.println(&quot;集合是否为空？&quot; + all.isEmpty() + &quot;、集合元素个数：&quot; + all.size());
        all.forEach(str -&gt; System.out.print(str + &quot;、&quot;));
    &#125;
&#125;

// 输出内容
集合是否为空？true、集合元素个数：0
集合是否为空？false、集合元素个数：3
Hello、World、XXXX、
</code></pre>
<p>如果以方法的功能为例，那么ArrayList中操作支持与之前编写的链表形式是非常相似的，但是它并不是使用链表来实现的，通过类名称实际上就已经可以清楚的发现了，ArrayList应该封装的是一个数组。</p>
<h2 id="3、ArrayList-源码分析"><a href="#3、ArrayList-源码分析" class="headerlink" title="3、ArrayList 源码分析"></a>3、ArrayList 源码分析</h2><p>ArrayList构造：public ArrayList()</p>
<pre><code class="java">public ArrayList() &#123;
    this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;
&#125;
private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;
</code></pre>
<p>ArrayList构造：public ArrayList(int initialCapacity)</p>
<pre><code class="java">public ArrayList(int initialCapacity) &#123;
    if (initialCapacity &gt; 0) &#123;
        this.elementData = new Object[initialCapacity];
    &#125; else if (initialCapacity == 0) &#123;
        this.elementData = EMPTY_ELEMENTDATA;
    &#125; else &#123;
        throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+ initialCapacity);
    &#125;
&#125;
</code></pre>
<p>通过有参构造方法可以发现，在ArrayList中所包含的数据实际上就是一个对象数组。在进行数据追加时发现ArrayList集合中保存的对象数组长度不够的时候将会开辟新的数组，同时将原始的旧数组内容拷贝到新数组中，而后数组的开辟操作：</p>
<pre><code class="java">private int newCapacity(int minCapacity) &#123;
    // overflow-conscious code
    int oldCapacity = elementData.length;
    int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);
    if (newCapacity - minCapacity &lt;= 0) &#123;
        if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA)
            return Math.max(DEFAULT_CAPACITY, minCapacity);
        if (minCapacity &lt; 0) // overflow
            throw new OutOfMemoryError();
        return minCapacity;
    &#125;
    return (newCapacity - MAX_ARRAY_SIZE &lt;= 0) ? newCapacity  : hugeCapacity(minCapacity);
&#125;
</code></pre>
<p>如果在实例化ArrayList类对象时没有传递初始化的长度，则默认情况下会使用空数组，但是如果在进行数据增加时，发现数组容量不够，则会判断当前的增长容量与默认的容量的大小，使用较大的一个数值进行新的数组开辟，所以可以得出结论：</p>
<ol>
<li>JDK1.9之前：ArrayList默认的构造实际上就会默认开辟大小为10的数组</li>
<li>JDK1.9之后：ArrayList默认的构造只会使用默认的空数组，使用的时候才会开辟数组，默认的开辟长度为10</li>
</ol>
<p>当 ArrayList之中保存的容量不足的时候会采用成倍的方式进行增长，原始长度为10，那么下次的增长就是20，一次类推。在使用ArrayList子类的时候一定要估算出你的数据量会有多少，如果超过了10个，那么使用有参构造方法创建，以避免垃圾数组产生。</p>
<h2 id="3、ArrayList-保存自定义类"><a href="#3、ArrayList-保存自定义类" class="headerlink" title="3、ArrayList 保存自定义类"></a>3、ArrayList 保存自定义类</h2><p>通过之前的分析已经清楚了ArrayList子类的实现原理以及List核心操作，但是在测试的时候使用的是系统提供的String类，这是一个设计非常完善的类，而对于类集而言也可以实现自定义类对象的保存。</p>
<p>操作示例：实现自定义类对象的保存</p>
<pre><code class="java">import java.util.ArrayList;
import java.util.List;
class Person &#123;
    private String name ;
    private int age ;
    public Person(String name,int age) &#123;
        this.name = name ;
        this.age = age ;
    &#125;
    @Override
    public boolean equals(Object obj) &#123;
        if (this == obj) &#123;
            return true ;
        &#125;
        if (obj == null) &#123;
            return false ;
        &#125;
        if (!(obj instanceof Person)) &#123;
            return false ;
        &#125;
        Person per = (Person) obj ;
        return this.name.equals(per.name) &amp;&amp; this.age == per.age ;
    &#125;
    @Override
    public String toString() &#123;
        return &quot;姓名：&quot; + this.name + &quot;、年龄：&quot; + this.age ;
    &#125;
&#125;
public class JavaAPIDemo &#123;
    public static void main(String[] args) &#123;
        List&lt;Person&gt; all = new ArrayList&lt;&gt;();
        all.add(new Person(&quot;张三&quot;,30)) ;
        all.add(new Person(&quot;李四&quot;,16)) ;
        all.add(new Person(&quot;小强&quot;,78)) ;
        System.out.println(all.contains(new Person(&quot;小强&quot;,78)));
        all.remove(new Person(&quot;小强&quot;,78)) ;
        all.forEach(System.out::println);
    &#125;
&#125;

// 输出内容
true
姓名：张三、年龄：30
姓名：李四、年龄：16
</code></pre>
<p>在使用List保存自定义对象时，如果需要使用到contains()、remove()方法进行查询或删除处理时一定要保证类中已经覆写了equals()方法。</p>
<h2 id="4、LinkedList-子类"><a href="#4、LinkedList-子类" class="headerlink" title="4、LinkedList 子类"></a>4、LinkedList 子类</h2><p>在List接口中还有一个比较常用的子类：LinkedList，这个类通过名称就可以发现其特点：基于链表的实现。那么首先观察一下LinkedList的定义：</p>
<pre><code class="java">public class LinkedList&lt;E&gt; extends AbstractSequentialList&lt;E&gt; implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, Serializable &#123;&#125;
</code></pre>
<p>LinkedList 类结构如下：</p>
<p><img src="/Java-%E7%B1%BB%E9%9B%86%E6%A1%86%E6%9E%B6.assets/image-20241017215310352.png"></p>
<p>操作示例 1：使用LinkedList实现集合操作</p>
<pre><code class="java">import java.util.LinkedList;
import java.util.List;
public class JavaAPIDemo &#123;
    public static void main(String[] args) &#123;
        List&lt;String&gt; all = new LinkedList&lt;&gt;();
        all.add(&quot;Hello&quot;);
        all.add(&quot;Hello&quot;); // 重复数据
        all.add(&quot;Wolrd&quot;);
        all.add(&quot;XXXX&quot;);
        all.forEach(System.out::println);
    &#125;
&#125;

// 输出内容
Hello
Hello
Wolrd
XXXX
</code></pre>
<h2 id="5、LinkedList-源码分析"><a href="#5、LinkedList-源码分析" class="headerlink" title="5、LinkedList 源码分析"></a>5、LinkedList 源码分析</h2><p>如果现在只是观察程序的功能会发现和ArrayList使用是完全一样的，但是其内部实现机制是完全不同的，首先观察LinkedList构造方法里面并没有提供像ArrayList那样的初始化大小的方法，而只是提供了无参构造处理：“public LinkedList()”。随后观察add()方法的具体实现。</p>
<pre><code class="java">/**
 * 在之前编写自定义链表时，是判断了传入数据是否为null，如果为null则不进行保存，
 * 但在LinkedList中并没有做这样的处理，而是所有的数据都可以保存,而后此方法调用了linkLast()方法（在最后一个节点后追加）
 */
public boolean add(E e) &#123;
    linkLast(e);
    return true;
&#125;
</code></pre>
<pre><code class="java">/**
 * 在LinkedList类中保存的数据都是利用Node节点进行的封装处理，同时为了提高程序执行性能，
 * 每一次都会保存上一个追加的节点（最后一个节点），就可以在增加数据的时候避免递归处理，在增加数据时要进行数据保存个数的追加
 */
void linkLast(E e) &#123;
    final Node&lt;E&gt; l = last;
    final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null);
    last = newNode;
    if (l == null)
        first = newNode;
    else
        l.next = newNode;
    size++;
    modCount++;
&#125; 
</code></pre>
<p>通过上面的分析：可以发现LinkedList封装的就是一个链表实现。</p>
<p><strong>面试题：</strong>请问ArrayList与LinkedList有什么区别？</p>
<ol>
<li>ArrayList是数组实现的集合操作，而LinkedList是链表实现的集合操作</li>
<li>在使用List集合中的get()方法根据索引获取数据时，ArrayList的时间复杂度为“O(1)”、而LinkedList时间复杂度为“O(n)”（n为集合的长度）</li>
<li>ArrayList在使用时默认的初始化对象数组的大小长度为10，如果空间不足则会采用2倍形式进行容量的扩充，如果保存大数据量的时候有可能会造成垃圾的产生以及性能的下降，但是这时候可以使用LinkedList类保存</li>
</ol>
<h2 id="6、Vector-子类"><a href="#6、Vector-子类" class="headerlink" title="6、Vector 子类"></a>6、Vector 子类</h2><p>Vector是一个原始古老的程序类，这个类是在JDK1.0时提供的。到了JDK1.2时由于许多开发者已经习惯于使用Vector，并且许多系统类也是基于Vector实现的，考虑到其使用的广泛性，所以类集框架将其保留了下来，并让其多实现了一个List接口，观察Vector的定义结构：</p>
<pre><code class="java">public class Vector&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, Serializable &#123;&#125;
</code></pre>
<p>继承结构与ArrayList是相同的，所以来讲Vector这个类继承结构如下：</p>
<p><img src="/Java-%E7%B1%BB%E9%9B%86%E6%A1%86%E6%9E%B6.assets/image-20241017215310353.png"></p>
<p>操作示例 1：Vector的使用</p>
<pre><code class="java">import java.util.List;
import java.util.Vector;
public class JavaAPIDemo &#123;
    public static void main(String[] args) &#123;
        // 为List父接口进行实例化
        List&lt;String&gt; all = new Vector&lt;&gt;();
        all.add(&quot;Hello&quot;);
        all.add(&quot;Hello&quot;); // 重复数据
        all.add(&quot;World&quot;);
        all.add(&quot;XXXX&quot;);
        all.forEach(System.out::println);
    &#125;
&#125;

// 输出内容
Hello
Hello
World
XXXX
</code></pre>
<p>下面可以进一步的观察Vector类实现：</p>
<pre><code class="java">public Vector() &#123;
    this(10);
&#125;
public Vector(int initialCapacity) &#123;
    this(initialCapacity, 0);
&#125;
public Vector(int initialCapacity, int capacityIncrement) &#123;
    super();
    if (initialCapacity &lt; 0)
        throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+ initialCapacity);
    this.elementData = new Object[initialCapacity];
    this.capacityIncrement = capacityIncrement;
&#125;
</code></pre>
<p>PS：Vector类如果使用的是无参构造方法，则一定会默认开辟一个10个长度的数组，而后其余的实现操作与ArrayList是相同的。通过源代码分析可以发现，Vector类中的操作方法采用的都是synchronized同步处理，而ArrayList并没有进行同步处理，所以Vector类中的方法在多线程访问的时候属于线程安全的，但是性能不如ArrayList高。</p>
<h1 id="Set-集合"><a href="#Set-集合" class="headerlink" title="Set 集合"></a>Set 集合</h1><p>本节介绍了Set接口继承关系以及特征，介绍了两个常用的子类：HashSet、TreeSet的使用。</p>
<h2 id="1、Set-接口简介"><a href="#1、Set-接口简介" class="headerlink" title="1、Set 接口简介"></a>1、Set 接口简介</h2><p>Set集合最大的特点就是不允许保存重复元素,其也是 Collection子接口。</p>
<p>在JDK1.9以前Set集合与Collection集合的定义并无差别，Set继续使用了Collection接口中提供的方法进行操作，但是从JDK1.9后，Set集合也像List集合一样扩充了一些static方法，Set集合的定义如下：</p>
<pre><code class="java">public interface Set&lt;E&gt; extends Collection&lt;E&gt; &#123;&#125;
</code></pre>
<p>需要注意的是Set集合并不像List集合那样扩充了许多的新方法，所以无法使用List集合中提供的get()方法，也就是说无法实现指定索引数据的获取，Set接口的继承关系如下。</p>
<p><img src="/Java-%E7%B1%BB%E9%9B%86%E6%A1%86%E6%9E%B6.assets/image-20241017215310354.png"></p>
<p>从JDK1.9后，Set集合也提供了像List集合中类似的of()的静态方法。下面就使用此方法进行Set集合特点的验证。</p>
<p>操作示例 1：验证Set集合特征</p>
<pre><code class="java">import java.util.Set;
public class JavaAPIDemo &#123;
    public static void main(String[] args) &#123;
        // 进行Set集合数据的保存，并且设置有重复的内容
        Set&lt;String&gt; all = Set.of(&quot;Hello&quot;, &quot;World&quot;, &quot;XXXX&quot;, &quot;Hello&quot;, &quot;World&quot;);
        // 直接输出
        all.forEach(System.out::println);
    &#125;
&#125;
// 运行会报异常：因为出现重复元素
// 输出内容
Exception in thread &quot;main&quot; java.lang.IllegalArgumentException: duplicate element: Hello
    at java.base/java.util.ImmutableCollections$SetN.&lt;init&gt;(ImmutableCollections.java:587)
    at java.base/java.util.Set.of(Set.java:541)
    at JavaAPIDemo.main(JavaAPIDemo.java:5)
</code></pre>
<p>当使用of()这个新方法的时候，如果发现集合中存在重复元素则会直接抛出异常。这与传统的Set集合不保存重复元素的特点相一致，只不过自己抛出了异常而已。</p>
<p>Set集合的常规使用形式一定是依靠子类进行实例化的，所以Set接口之中有两个常用的子类：HashSet、TreeSet</p>
<h2 id="2、HashSet-子类"><a href="#2、HashSet-子类" class="headerlink" title="2、HashSet 子类"></a>2、HashSet 子类</h2><p>HashSet是Set接口中使用最多的一个子类，其最大的特点就是保存的数据是无序的，而HashSet子类的继承关系如下：</p>
<pre><code class="java">public class HashSet&lt;E&gt; extends AbstractSet&lt;E&gt; implements Set&lt;E&gt;, Cloneable, Serializable &#123;&#125;
</code></pre>
<p>这种继承的形式和之前的ArrayList是非常相似的，那么现在来观察一下HashSet子类的继承结构：</p>
<p><img src="/Java-%E7%B1%BB%E9%9B%86%E6%A1%86%E6%9E%B6.assets/image-20241017215310355.png"></p>
<p>操作示例 1：观察HashSet子类</p>
<pre><code class="java">import java.util.HashSet;
import java.util.Set;
public class JavaAPIDemo &#123;
    public static void main(String[] args) &#123;
        Set&lt;String&gt; all = new HashSet&lt;&gt;();
        all.add(&quot;XXXX&quot;);
        all.add(&quot;NiHao&quot;);
        all.add(&quot;Hello&quot;);
        all.add(&quot;Hello&quot;); // 重复元素
        all.add(&quot;World&quot;);
        all.forEach(System.out::println);
    &#125;
&#125;

// 输出内容
NiHao
Hello
XXXX
World
</code></pre>
<p>通过执行结果就可以发现HashSet的操作特点：不允许保存重复元素（Set接口定义的），另外一个特点就是HashSet中保存的数据是无序的。</p>
<h2 id="3、TreeSet-子类"><a href="#3、TreeSet-子类" class="headerlink" title="3、TreeSet 子类"></a>3、TreeSet 子类</h2><p>Set接口的另外一个子接口就是TreeSet，与HashSet最大区别在于TreeSet集合里面保存的数据是有序的，首先来观察TreeSet类的定义：</p>
<pre><code class="java">public class TreeSet&lt;E&gt; extends AbstractSet&lt;E&gt; implements NavigableSet&lt;E&gt;, Cloneable, Serializable &#123;&#125;
</code></pre>
<p>在这个子类中依然继承了AbstractSet父抽象类，同时又实现了一个NavigableSet父接口。TreeSet子类继承结果：</p>
<p><img src="/Java-%E7%B1%BB%E9%9B%86%E6%A1%86%E6%9E%B6.assets/image-20241017215310356.png"></p>
<p>操作示例 1：使用TreeSet子类</p>
<pre><code class="java">import java.util.Set;
import java.util.TreeSet;
public class JavaAPIDemo &#123;
    public static void main(String[] args) &#123;
        Set&lt;String&gt; all = new TreeSet&lt;&gt;();
        all.add(&quot;XXXX&quot;);
        all.add(&quot;NiHao&quot;) ;
        all.add(&quot;Hello&quot;);
        all.add(&quot;Hello&quot;); // 重复元素
        all.add(&quot;World&quot;);
        all.forEach(System.out::println);
    &#125;
&#125;
// 输出结果（是有序的，默认是升序）
Hello
NiHao
World
XXXX
</code></pre>
<p>当利用TreeSet保存数据的时候，所有的数据将按照数据的升序进行自动排序处理。</p>
<h2 id="4、TreeSet-排序说明"><a href="#4、TreeSet-排序说明" class="headerlink" title="4、TreeSet 排序说明"></a>4、TreeSet 排序说明</h2><p>经过分析后发现，TreeSet子类中保存的数据是允许排序的，但是这个类必须要实现Comparable接口，只有实现了此接口才能够确认出对象的大小关系。</p>
<p><strong>提示</strong>：TreeSet本质上是利用TreeMap子类实现的集合数据的存储，而TreeMap（树）就需要根据Comparable来确定对象的大小关系。</p>
<p>操作示例 1：使用自定义的类实现排序的处理操作（实现自定义类排序）</p>
<pre><code class="java">import java.util.Set;
import java.util.TreeSet;

/**
 * 比较器
 */
class Person implements Comparable &lt;Person&gt; &#123;
    private String name ;
    private int age ;
    public Person(String name,int age) &#123;
        this.name = name ;
        this.age = age ;
    &#125;
    @Override
    public String toString() &#123;
        return &quot;姓名：&quot; + this.name + &quot;、年龄：&quot; + this.age ;
    &#125;
    @Override
    public int compareTo(Person per) &#123;
        if (this.age &lt; per.age) &#123;
            return -1 ;
        &#125; else if (this.age &gt; per.age) &#123;
            return 1 ;
        &#125; else &#123;
            return this.name.compareTo(per.name) ;
        &#125;
    &#125;
&#125;

public class JavaAPIDemo &#123;
    public static void main(String[] args) &#123;
        // 为Set父接口进行实例化
        Set&lt;Person&gt; all = new TreeSet&lt;&gt;();
        all.add(new Person(&quot;张三&quot;,19)) ;
        all.add(new Person(&quot;李四&quot;,19)) ;	// 年龄相同，但是姓名不同
        all.add(new Person(&quot;王五&quot;,20)) ;	// 数据重复
        all.add(new Person(&quot;王五&quot;,20)) ;	// 数据重复
        all.add(new Person(&quot;小强&quot;,78)) ;
        all.forEach(System.out::println);
    &#125;
&#125;

// 输出内容
姓名：张三、年龄：19
姓名：李四、年龄：19
姓名：王五、年龄：20
姓名：小强、年龄：78
</code></pre>
<p>在使用自定义类对象进行比较处理的时候，一定要将该类中所有属性都依次进行大小关系的匹配，否则某一个或者几个属性相同的时候也会被认为是重复数据，所以TreeSet是利用了Comparable接口来确认重复数据的。</p>
<p>由于TreeSet在操作过程之中需要将类中的所有属性进行比对，这样的实现难度太高了，那么在实际的开发中应该首选HashSet子类进行存储。</p>
<h2 id="5、关于重复元素说明"><a href="#5、关于重复元素说明" class="headerlink" title="5、关于重复元素说明"></a>5、关于重复元素说明</h2><p>TreeSet类是利用了Comparable接口来实现了重复元素的判断，但是Set集合的整体特征就是不允许保存重复元素。但是HashSet判断重复元素的方式并不是利用Comparable接口完成的，它利用的是Object类中提供的方法实现的：</p>
<pre><code class="java">public int hashCode();             // 对象编码
public boolean equals(Object obj); // 对象比较
</code></pre>
<p>在进行重复元素判断的时候首先利用hashCode()进行编码的匹配，如果该编码不存在则表示数据不存在，证明没有重复，如果该编码存在，则进一步进行对象比较处理，如果发现重复了，则此数据是不允许保存的。</p>
<p>在进行重复元素判断的时候首先利用hashCode()进行编码的匹配，如果该编码不存在，则表示数据不存在，证明没有重复，如果该编码存在，则进一步进行对象比较处理，如果发现重复了，则此数据是不允许保存的。如果使用的是IDE开发工具，则可以帮助开发者自动创建HashCode()与equals()方法。</p>
<p>操作示例 1：实现重复元素处理</p>
<pre><code class="java">import java.util.HashSet;
import java.util.Set;

/**
 * 比较器
 */
class Person &#123;
    private String name ;
    private int age ;
    public Person(String name,int age) &#123;
        this.name = name ;
        this.age = age ;
    &#125;

    @Override
    public int hashCode() &#123;
        final int prime = 31;
        int result = 1;
        result = prime * result + age;
        result = prime * result + ((name == null) ? 0 : name.hashCode());
        return result;
    &#125;

    @Override
    public boolean equals(Object obj) &#123;
        if (this == obj) return true;
        if (obj == null) return false;
        if (getClass() != obj.getClass())
            return false;
        Person other = (Person) obj;
        if (age != other.age)
            return false;
        if (name == null) &#123;
            if (other.name != null)
                return false;
        &#125; else if (!name.equals(other.name))
            return false;
        return true;
    &#125;
    @Override
    public String toString() &#123;
        return &quot;姓名：&quot; + this.name + &quot;、年龄：&quot; + this.age ;
    &#125;
&#125;

public class JavaAPIDemo &#123;
    public static void main(String[] args) &#123;
        Set&lt;Person&gt; all = new HashSet&lt;&gt;();
        all.add(new Person(&quot;张三&quot;,19)) ;
        all.add(new Person(&quot;李四&quot;,19)) ;	// 年龄相同，但是姓名不同
        all.add(new Person(&quot;王五&quot;,20)) ;	// 数据重复
        all.add(new Person(&quot;王五&quot;,20)) ;	// 数据重复
        all.add(new Person(&quot;小强&quot;,78)) ;
        all.forEach(System.out::println);
    &#125;
&#125;

// 输出内容
姓名：小强、年龄：78
姓名：李四、年龄：19
姓名：王五、年龄：20
姓名：张三、年龄：19
</code></pre>
<p>在Java中真正的重复元素的判断处理利用的就是hashCode()和equals()两个方法共同作用完成的，而只有在排序要求的情况下（TreeSet）才会利用Comparable接口来实现。</p>
<h1 id="集合输出"><a href="#集合输出" class="headerlink" title="集合输出"></a>集合输出</h1><p>本节需要掌握集合输出的四种形式：Iterator 迭代输出、ListIterator 双向迭代输出、Enumeration 枚举输出、foreach 输出。</p>
<p>集合输出实际上从JDK1.8开始就在Iterable接口中提供了一个forEach()方法，但是这种方法输出并不是传统意义上集合输出形式，并且也很难在实际的开发之中出现，对于集合操作而言，一共有四种输出形式：</p>
<ol>
<li>Iterator迭代输出（95%）</li>
<li>ListIterator双向迭代输出（0.1%）</li>
<li>Enumeration枚举输出（4.9%）</li>
<li>foreach输出（与Iterator相当）</li>
</ol>
<h2 id="1、Iterator-输出（核心）"><a href="#1、Iterator-输出（核心）" class="headerlink" title="1、Iterator 输出（核心）"></a>1、Iterator 输出（核心）</h2><p>通过Collection接口的继承关系可以发现，从JDK1.5开始其多继承了一个Iterable父接口，并且在这个接口里面定义有一个iterator()操作方法，通过此方法可以获取Iterator接口对象（在JDK1.5之前，这一方法直接定义在Collection接口之中）</p>
<p>在Iterator接口里面定义有如下的方法：</p>
<pre><code class="java">public Iterator&lt;T&gt; iterator(); // 获取Iterator接口对象
public boolean hasNext();      // 判断是否有数据
public E next();               // 取出当前数据
default void remove();         // 删除当前数据
</code></pre>
<p>在之前使用的 java.util.Scanner 类就是 Iterator 接口的子类，所以此时（Iterator接口）类继承关系如下：</p>
<p><img src="/Java-%E7%B1%BB%E9%9B%86%E6%A1%86%E6%9E%B6.assets/image-20241017215310357.png"></p>
<p>操作示例 1：使用Iterator输出</p>
<pre><code class="java">import java.util.Iterator;
import java.util.Set;
public class JavaAPIDemo &#123;
    public static void main(String[] args) &#123;
        Set&lt;String&gt; all = Set.of(&quot;Hello&quot;, &quot;World&quot;, &quot;XXXX&quot;);
        // 实例化Iterator接口对象
        Iterator&lt;String&gt; iter = all.iterator();
        while (iter.hasNext()) &#123;
            String str = iter.next() ;
            System.out.println(str);
        &#125;
    &#125;
&#125;

// 输出内容
XXXX
World
Hello
</code></pre>
<p>但是对于Iterator接口中的remove()方法的使用需要特别注意一下（如果不是必须不要使用）。实际上在Collection接口中定义有数据的删除操作方法，但是在进行迭代输出的过程中如果你使用了Collection中的remove()方法会导致迭代失败。</p>
<p>操作示例 2：采用Collection集合中remove()方法删除</p>
<pre><code class="java">import java.util.Set;
import java.util.Iterator;
import java.util.HashSet;
public class JavaAPIDemo &#123;
    public static void main(String[] args) &#123;
        Set&lt;String&gt; all = new HashSet&lt;&gt;();
        all.add(&quot;Hello&quot;);
        all.add(&quot;World&quot;);
        all.add(&quot;MLDN&quot;);
        // 实例化Iterator接口对象
        Iterator&lt;String&gt; iter = all.iterator();
        while (iter.hasNext()) &#123;
            String str = iter.next();
            if (&quot;World&quot;.equals(str)) &#123;
                // Collection集合方法
                all.remove(&quot;World&quot;);
            &#125;else &#123;
                //  Hello   Exception in thread &quot;main&quot; java.util.ConcurrentModificationException
                System.out.println(str);
            &#125;
        &#125;
    &#125;
&#125;

// 输出内容（会报错）
Hello
Exception in thread &quot;main&quot; java.util.ConcurrentModificationException
    at java.base/java.util.HashMap$HashIterator.nextNode(HashMap.java:1493)
    at java.base/java.util.HashMap$KeyIterator.next(HashMap.java:1516)
    at JavaAPIDemo.main(JavaAPIDemo.java:13)
</code></pre>
<p><strong>PS：此时无法进行数据的删除处理操作，那么此时就只能够利用Iterator接口中的remove()方法删除。</strong></p>
<p>操作示例 3：使用Iterator接口删除方法</p>
<pre><code class="java">import java.util.HashSet;
import java.util.Iterator;
import java.util.Set;
public class JavaAPIDemo &#123;
    public static void main(String[] args) &#123;
        Set&lt;String&gt; all = new HashSet&lt;&gt;();
        all.add(&quot;Hello&quot;);
        all.add(&quot;World&quot;);
        all.add(&quot;MLDN&quot;);
        // 实例化Iterator接口对象
        Iterator&lt;String&gt; iter = all.iterator();
        while (iter.hasNext()) &#123;
            String str = iter.next();
            if (&quot;World&quot;.equals(str)) &#123;
                // 删除当前的数据
                iter.remove();
            &#125; else &#123;
                System.out.println(str);
            &#125;
        &#125;
        System.out.println(&quot;删除后集合： &quot; + all);
    &#125;

&#125;

// 输出内容
Hello
MLDN
删除后集合： [Hello, MLDN]
</code></pre>
<p>此时程序执行后没有出现任何的错误，并且可以成功的删除原始集合中的数据。</p>
<p><strong>面试题：请解释Collection.remove()与Iterator.remove()的区别？</strong></p>
<ol>
<li>在进行迭代输出的时候，如果使用了Collection.remove()则会造成并发更新的异常，导致程序删除出错</li>
<li>而此时只能够利用Iterator接口中remove()方法实现正常的删除处理</li>
</ol>
<h2 id="2、ListIterator-输出"><a href="#2、ListIterator-输出" class="headerlink" title="2、ListIterator 输出"></a>2、ListIterator 输出</h2><p>使用Iterator进行的迭代输出操作有一个特点：只允许由前向后输出，而如果现在需要进行双向迭代处理，那么就必须依靠Iterator的子接口：ListIterator接口来实现了。需要注意的是，如果想要获取ListIterator接口对象，Collection中并没有定义相关的处理方法，但是List子接口有，也就是说这个输出的接口是专门为List集合准备的。ListIterator 继承 Iterator：</p>
<pre><code class="java">public interface ListIterator&lt;E&gt; extends Iterator&lt;E&gt; &#123;&#125;
</code></pre>
<p>ListIterator接口类继承结构：</p>
<p><img src="/Java-%E7%B1%BB%E9%9B%86%E6%A1%86%E6%9E%B6.assets/image-20241017215310358.png"></p>
<p>ListIterator接口中定义有如下方法（如下是ListIterator比Iterator多的方法，因为ListIterator继承Iterator所以也包含了Iterator内的方法）：</p>
<pre><code class="java">public boolean hasPrevious(); // 判断是否有前一个元素（迭代器当前位置，反向遍历集合是否含有元素）
public E previous();          // 获取当前元素（迭代器当前位置，反向遍历集合，下一个元素）
public int previousIndex();   // 迭代器当前位置，反向遍历集合，返回下一个元素的下标
public int nextIndex();       // 迭代器当前位置，返回下一个元素的下标
public void add(E e);         // 将指定的元素插入列表，插入位置为迭代器当前位置之前
public void set(E e);         // 迭代器返回的最后一个元素替换参数e
</code></pre>
<p>操作示例 1：实现双向迭代</p>
<pre><code class="java">import java.util.ArrayList;
import java.util.List;
import java.util.ListIterator;
public class JavaAPIDemo &#123;
    public static void main(String[] args) &#123;
        List&lt;String&gt; all = new ArrayList&lt;&gt;();
        all.add(&quot;Hello&quot;);
        all.add(&quot;World&quot;);
        all.add(&quot;XXXX&quot;);
        ListIterator&lt;String&gt; iter = all.listIterator();
        System.out.print(&quot;由前向后输出：&quot;);
        while (iter.hasNext()) &#123;
            System.out.print(iter.next() + &quot;、&quot;);
        &#125;
        System.out.print(&quot;\n由后向前输出：&quot;);
        while (iter.hasPrevious()) &#123;
            System.out.print(iter.previous() + &quot;、&quot;);
        &#125;
    &#125;
&#125;

// 输出内容
由前向后输出：Hello、World、XXXX、
由后向前输出：XXXX、World、Hello、
</code></pre>
<p>PS：如果想实现由后向前的遍历，那么首先要实现的是由前向后实现遍历处理。</p>
<p><strong>面试题：Iterator 和 ListIterator 有什么区别？</strong><a target="_blank" rel="noopener" href="https://blog.csdn.net/meism5/article/details/89921602">https://blog.csdn.net/meism5/article/details/89921602</a></p>
<ol>
<li>ListIterator 继承 Iterator</li>
<li>ListIterator 比 Iterator多6个方法：add、set、hasPrevious、previous、previousIndex、nextIndex</li>
<li>使用范围不同，Iterator可以迭代所有集合；ListIterator 只能用于List及其子类</li>
<li>ListIterator 有 add 方法，可以向 List 中添加对象；Iterator 不能</li>
<li>ListIterator 有 hasPrevious() 和 previous() 方法，可以实现逆向遍历；Iterator不可以</li>
<li>ListIterator 有 nextIndex() 和previousIndex() 方法，可定位当前索引的位置；Iterator不可以</li>
<li>ListIterator 有 set()方法，可以实现对 List 的修改；Iterator 仅能遍历，不能修改</li>
</ol>
<h2 id="3、Enumeration-输出"><a href="#3、Enumeration-输出" class="headerlink" title="3、Enumeration 输出"></a>3、Enumeration 输出</h2><p>Enumeration是在JDK1.0的时候就使用的输出接口，这个输出接口主要是为了Vector类提供服务的，一直到后续的JDK的发展，Enumeration依然只为Vector一个类服务，所以要想获取Enumeration接口对象，那么必须依靠Vector类提供的方法：</p>
<pre><code class="java">public Enumeration&lt;E&gt; elements(); // 获取Enumeration
public boolean hasMoreElements(); // 判断是否有下一个元素
public E nextElement();           // 获取当前元素
</code></pre>
<p>Enumeration接口类继承结构：</p>
<p><img src="/Java-%E7%B1%BB%E9%9B%86%E6%A1%86%E6%9E%B6.assets/image-20241017215310359.png"></p>
<p>操作示例 1：使用Enumeration输出</p>
<pre><code class="java">import java.util.Enumeration;
import java.util.Vector;
public class JavaAPIDemo &#123;
    public static void main(String[] args) &#123;
        Vector&lt;String&gt; all = new Vector&lt;&gt;();
        all.add(&quot;Hello&quot;) ;
        all.add(&quot;World&quot;) ;
        all.add(&quot;XXXX&quot;) ;
        Enumeration&lt;String&gt; enu = all.elements() ;
        while (enu.hasMoreElements()) &#123;
            String str = enu.nextElement() ;
            System.out.print(str + &quot;、&quot;);
        &#125;
    &#125; 
&#125;

// 输出内容
Hello、World、XXXX、
</code></pre>
<p>由于该接口出现的时间比较长了，所以在一些比较早的开发过程中，也有部分的方法只支持Enumeration输出操作，但随着类方法的不断完善，大部分的操作都能直接利用Iterator实现了。</p>
<h2 id="4、Foreach-输出"><a href="#4、Foreach-输出" class="headerlink" title="4、Foreach 输出"></a>4、Foreach 输出</h2><p>除了使用迭代接口实现输出之外，从JDK1.5开始加强型for循环也可以实现集合的输出了。这种输出的形式与数组的输出操作形式类似。</p>
<p>操作示例：使用foreach输出</p>
<pre><code class="java">import java.util.ArrayList;
import java.util.List;
public class JavaAPIDemo &#123;
    public static void main(String[] args) &#123;
        List&lt;String&gt; all = new ArrayList&lt;&gt;();
        all.add(&quot;Hello&quot;);
        all.add(&quot;World&quot;);
        all.add(&quot;XXXX&quot;);
        for (String str : all) &#123;
            System.out.print(str + &quot;、&quot;); 
        &#125;
    &#125;
&#125;

// 输出内容
Hello、World、XXXX、
</code></pre>
<p>这种输出最初出现时很多人并不建议使用，因为标准的集合操作还是以Iterator为主，但是毕竟JDK1.5都已经推出十多年了，很多语法也开始被大部分人所习惯。</p>
<h1 id="Map-集合"><a href="#Map-集合" class="headerlink" title="Map 集合"></a>Map 集合</h1><p>本节介绍了Map接口以及它的子类HashMap、LinkedHashMap、HashTable、TreeMap，需要掌握他们的基本用法。</p>
<h2 id="1、Map-接口简介"><a href="#1、Map-接口简介" class="headerlink" title="1、Map 接口简介"></a>1、Map 接口简介</h2><p>在之前已经学习了Collection接口以及其对应的子接口，可以发现在Collection接口之中所保存的数据全部都只是单个对象，而在数据结构中除了可以进行单个对象的保存外，也可以进行二元偶对象的保存（key&#x3D;value）的形式来存储，而存储二元偶对象的核心意义在于需要通过key获取对应的value。在开发中，Collection集合保存数据的目的是为了输出，Map集合保存数据的目的是为了进行key的查找。</p>
<p>Map接口是进行二元偶对象保存的最大父接口。该接口定义如下：</p>
<pre><code class="java">public interface Map&lt;K,V&gt; &#123;&#125;
</code></pre>
<p>该接口为一个独立的父接口，并且在进行接口对象实例化的时候需要设置Key与Value的类型，也就是在整体操作的时候需要保存两个内容，在Map接口中定义有许多操作方法，但是需要记住以下的核心操作方法：</p>
<pre><code class="java">public V put(K key,V vvalue)              // 向集合之中保存数据
public V get(Object key)                  // 根据key查询数据
public V remove(Object key)               // 根据key删除掉指定的数据
boolean remove(Object key, Object value)  // 当指定的 key 与 value 在映射集中存在, 且为绑定的键值对关系时, 才移除
boolean containsKey(Object key)           // 查询指定key是否存在
boolean containsValue(Object value)       // 查找指定value是否存在
public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()     // 将Map集合转为Set
public Set&lt;K&gt; keySet()                    // 将Map集合中的key转为Set集合
Collection&lt;V&gt; values()                    // 返回Map中所有的value
</code></pre>
<p>操作示例 1：观察Map集合的特点。从JDK1.9之后Map接口里面也扩充了一些静态方法供用户使用</p>
<pre><code class="java">import java.util.Map;
public class JavaAPIDemo &#123;
    public static void main(String[] args) &#123;
        // &#123;one=1,two=2&#125;
        Map&lt;String, Integer&gt; map1 = Map.of(&quot;one&quot;, 1, &quot;two&quot;, 2);
        System.out.println(map1);

        // Exception in thread &quot;main&quot; java.lang.IllegalArgumentException: duplicate key: one
        Map&lt;String, Integer&gt; map2 = Map.of(&quot;one&quot;, 1, &quot;two&quot;, 2, &quot;one&quot;, 101);
        //System.out.println(map2);

        // Exception in thread &quot;main&quot; java.lang.NullPointerException
        Map&lt;String, Integer&gt; map3 = Map.of(&quot;one&quot;, 1, &quot;two&quot;, 2, null, 0);
        System.out.println(map3);
    &#125;
&#125;

// 输出内容
&#123;one=1, two=2&#125;
Exception in thread &quot;main&quot; java.lang.IllegalArgumentException: duplicate key: one
    at java.base/java.util.ImmutableCollections$MapN.&lt;init&gt;(ImmutableCollections.java:805)
    at java.base/java.util.Map.of(Map.java:1349)
    at JavaAPIDemo.main(JavaAPIDemo.java:9)
</code></pre>
<p>在Map集合之中数据的保存就是按照“key&#x3D;value”的形式存储的，并且使用of()方法操作时里面的数据是不允许重复，如果重复则会出现“IllegalArgumentException”异常，如果设置的内容为null，则会出现“NullPointerException”异常。</p>
<p>对于现在见到的of()方法严格意义上来说并不是Map集合的标准用法，因为正常的开发中需要通过Map集合的子类来进行接口对象的实例化，而常用的子类：HashMap、HashTable、TreeMap、LinkedHashMap。</p>
<h2 id="2、HashMap-子类"><a href="#2、HashMap-子类" class="headerlink" title="2、HashMap 子类"></a>2、HashMap 子类</h2><p>HashMap是Map接口中最为常见的一个子类,该类的主要特点是无序存储，通过Java文档首先来观察一下HashMap子类的定义：</p>
<pre><code class="java">public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable &#123;&#125;
</code></pre>
<p>该类的定义继承形式符合之前的集合定义形式，依然提供有抽象类并且依然需要重复实现Map接口。HashMap子类结构：</p>
<p><img src="/Java-%E7%B1%BB%E9%9B%86%E6%A1%86%E6%9E%B6.assets/image-20241017215310360.png"></p>
<p>操作示例 1：HashMap集合的使用</p>
<pre><code class="java">import java.util.HashMap;
import java.util.Map;
public class JavaAPIDemo &#123;
    public static void main(String[] args) &#123;
        Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;() ;
        map.put(&quot;one&quot;, 1) ;
        map.put(&quot;two&quot;, 2) ;
        map.put(&quot;one&quot;, 101) ;	            // key重复
        map.put(null, 0) ;		            // key为null
        map.put(&quot;zero&quot;, null) ;             // value为null
        System.out.println(map.get(&quot;one&quot;));	// key存在
        System.out.println(map.get(null));	// key存在
        System.out.println(map.get(&quot;ten&quot;));	// key不存在
    &#125;
&#125;

// 输出内容
101
0
null
</code></pre>
<p>以上的操作形式为Map集合使用的最标准的处理形式，通过代码可以发现，通过HashMap实例化的Map接口可以针对key或者value保存null的数据，同时也可以发现即便保存数据的key重复，那么也不会出现错误，而是出现内容的替换。</p>
<p>但是对于Map接口中提供的put()方法本身是提供有返回值的，那么这个返回值指的是在重复key的情况下返回旧的value。</p>
<p>操作示例 2：观察put()方法。</p>
<pre><code class="java">import java.util.HashMap;
import java.util.Map;
public class JavaAPIDemo &#123;
    public static void main(String[] args) &#123;
        Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;() ;
        System.out.println(map.put(&quot;one&quot;, 1));	// key不重复，返回null
        System.out.println(map.put(&quot;one&quot;, 101));// key重复，返回旧数据
    &#125;
&#125;

// 输出内容
null
1
</code></pre>
<p>可以发现：在设置了相同key的内容的时候，put()方法会返回原始的数据内容。</p>
<p>HashMap 源码分析：</p>
<p>清楚了HashMap基本功能后就研究一下HashMap中的源代码。HashMap之中肯定需要存储大量的数据，那么对于数据的存储看看HashMap是如果操作：</p>
<pre><code class="java">// 当使用无参构造的时候会出现有一个loadFactor属性，并且该属性的默认内容为0.75
static final float DEFAULT_LOAD_FACTOR = 0.75f;
public HashMap() &#123;
    this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted
&#125;
</code></pre>
<pre><code class="java">/**
 * 在使用put()方法进行数据保存的时候会调用一个putVal()方法,同时会将key进行hash处理(生成一个hash码),
 * 而对于putVal()方法里面会发现依然会提供有一个Node节点类进行数据的保存,
 * 而在使用putVal()方法操作的过程之中会调用有个resize()方法可以进行容量的扩充。
 */
public V put(K key, V value) &#123;
    return putVal(hash(key), key, value, false, true);
&#125;
</code></pre>
<p><strong>面试题 1：在进行HashMap的put()操作时，如何实现容量扩充？</strong></p>
<ol>
<li>在HashMap类里面提供有一个“DEFAULT_INITIAL_CAPACITY”常量，作为初始化的容量配置，而后这个常量的默认大小为16个元素，也就是说默认可以保存的最大内容是16</li>
<li>当保存的内容的容量超过了与个阈值（DEFAULT_LOAD_FACTOR &#x3D; 0.75f），相当于 “容量 * 阈值 &#x3D; 12 ” 保存12个元素的时候就会进行容量的扩充</li>
<li>在进行扩充的时候HashMap采用的是成倍的扩充模式，即：每一次都扩充2倍的容量</li>
</ol>
<p><strong>面试题 2：请解释HashMap的工作原理（JDK1.8之后开始的）</strong></p>
<ol>
<li>在HashMap之中进行数据存在的依然是利用Node类完成的，那么这种情况下就证明可以使用的数据结构只有两种：链表（时间复杂度“O（n）”）、二叉树（时间复杂度“O（logn）”）</li>
<li>从JDK1.8开始，HashMap的实现出现了改变，因为其要适应于大数据时代的海量数据问题，所以对其存储发生了变化，并且在HashMap类的内部提供有一个常量：“static final int TREEIFY_THRESHOLD &#x3D; 8;”，在使用HashMap进行数据保存时，如果保存的数据没有超过阈值8（TREEIFY_THRESHOLD），那么会按照链表的形式进行存储，如果超过了阈值，则会将链表转为红黑树以实现树的平衡，并且利用左旋与右旋保证数据的查询性能。</li>
</ol>
<h2 id="3、LinkedHashMap-子类"><a href="#3、LinkedHashMap-子类" class="headerlink" title="3、LinkedHashMap 子类"></a>3、LinkedHashMap 子类</h2><p>HashMap虽然是Map集合中最为常用的子类，但是其本身保存的数据都是无序的（有序与否对Map没有影响），如果现在希望Map集合中的保存的数据的顺序为其增加顺序，则就可以更换子类为LinkedHashMap（基于链表实现的），观察LinkedHashMap类的定义形式：</p>
<pre><code class="java">public class LinkedHashMap&lt;K, V&gt; extends HashMap&lt;K, V&gt; implements Map&lt;K, V&gt; &#123;&#125;
</code></pre>
<p>既然是链表保存，所以一般在使用LinkedHashMap类时数据量不要特别大，因为会造成时间复杂度攀升，通过继承的结构可以发现LinkedHashMap是HashMap的子类，LinkedHashMap类继承关系如下：</p>
<p><img src="/Java-%E7%B1%BB%E9%9B%86%E6%A1%86%E6%9E%B6.assets/image-20241017215310361.png"></p>
<p>操作示例：使用LinkedHashMap</p>
<pre><code class="java">import java.util.LinkedHashMap;
import java.util.Map;
public class JavaAPIDemo &#123;
    public static void main(String[] args) &#123;
        Map&lt;String, Integer&gt; map = new LinkedHashMap&lt;&gt;() ;
        map.put(&quot;one&quot;, 1) ;
        map.put(&quot;two&quot;, 2) ;
        map.put(&quot;one&quot;, 101) ;	// key重复
        map.put(null, 0) ;		// key为null
        map.put(&quot;zero&quot;, null) ; // value为null
        System.out.println(map);	// key不存在
    &#125;
&#125;

// 输出内容
&#123;one=101, two=2, null=0, zero=null&#125;
</code></pre>
<h2 id="4、HashTable-子类"><a href="#4、HashTable-子类" class="headerlink" title="4、HashTable 子类"></a>4、HashTable 子类</h2><p>HashTable类是从JDK1.0时提供的，与Vector、Enumeration属于最早的一批动态数组的实现类，后来为了将其继续保留下来，所以让其多实现了一个Map接口，HashTable类的定义如下：</p>
<pre><code class="java">public class Hashtable&lt;K, V&gt; extends Dictionary&lt;K, V&gt; implements Map&lt;K, V&gt;, Cloneable, Serializable &#123;&#125;
</code></pre>
<p>HashTable的继承结构如下：</p>
<p><img src="/Java-%E7%B1%BB%E9%9B%86%E6%A1%86%E6%9E%B6.assets/image-20241017215310362.png"></p>
<p>操作示例：观察HashTable子类的使用</p>
<pre><code class="java">import java.util.Hashtable;
import java.util.Map;
public class JavaAPIDemo &#123;
    public static void main(String[] args) &#123;
        Map&lt;String, Integer&gt; map = new Hashtable&lt;&gt;();
        map.put(&quot;one&quot;, 1);
        map.put(&quot;two&quot;, 2);
        map.put(&quot;one&quot;, 101);
        // map.put(null, 0);       // 不能为空
        // map.put(&quot;zero&quot;,null);   //不能为空，Exception in thread &quot;main&quot; java.lang.NullPointerException
        System.out.println(map);   // &#123;two=2, one=101&#125;
    &#125;
&#125;

// 输出内容
&#123;two=2, one=101&#125;
</code></pre>
<p>通过观察可以发现在HashTable中进行数据存储时设置的key或value都不允许为null，否则会出现NullPointerException异常。</p>
<p><strong>面试题：</strong>请解释HashMap与HashTable的区别？</p>
<ol>
<li>HashMap中的方法都属于异步操作（非线程安全），HashMap允许保存有null的数据</li>
<li>HashTable中的方法都属于同步方法（线程安全），HashTable不允许保存null，否则会出现NullPointerException异常</li>
</ol>
<h2 id="5、TreeMap-子类"><a href="#5、TreeMap-子类" class="headerlink" title="5、TreeMap 子类"></a>5、TreeMap 子类</h2><p>TreeMap属于有序的Map集合类型，它可以按照key进行排序，所以来讲在使用这个子类的时候一定要配合Comparable接口共同使用，TreeMap子类的定义如下：</p>
<pre><code class="java">public class TreeMap&lt;K, V&gt; extends AbstractMap&lt;K, V&gt; implements NavigableMap&lt;K, V&gt;, Cloneable, Serializable &#123;&#125;
</code></pre>
<p>TreeMap继承结构：</p>
<p><img src="/Java-%E7%B1%BB%E9%9B%86%E6%A1%86%E6%9E%B6.assets/image-20241017215310363.png"></p>
<p>TreeMap 默认排序规则：按照key的字典顺序来排序（升序），也可以自定义排序规则：要实现Comparator接口。操作示例：使用TreeMap实现排序</p>
<pre><code class="java">import java.util.Comparator;
import java.util.Map;
import java.util.TreeMap;
public class JavaAPIDemo &#123;
    public static void main(String[] args) &#123;
        System.out.println(&quot;---------------- 默认 排序结果（根据key排序）-----------------&quot;);
        Map&lt;String, Integer&gt; map1 = new TreeMap&lt;&gt;();
        map1.put(&quot;C&quot;, 3);
        map1.put(&quot;A&quot;, 1);
        map1.put(&quot;B&quot;, 2);
        System.out.println(map1);

        System.out.println(&quot;---------------- 自定义 排序结果（根据key排序）-----------------&quot;);
        // TreeMap&lt;Integer, Integer&gt; map2 = new TreeMap&lt;&gt;((a, b) -&gt; b - a); // lambda形式
        TreeMap&lt;Integer, Integer&gt; map2 = new TreeMap&lt;&gt;(new Comparator&lt;Integer&gt;() &#123;
            /*
             * int compare(Object o1, Object o2) 返回一个基本类型的整型，
             * 返回负数表示：o1 小于o2，
             * 返回0 表示：o1和o2相等，
             * 返回正数表示：o1大于o2。
             */
            @Override
            public int compare(Integer a, Integer b) &#123;
                return b - a; // key倒序排序
            &#125;
        &#125;);
        map2.put(3, 3);
        map2.put(1, 1);
        map2.put(2, 2);

        System.out.println(map2);
    &#125;
&#125;

// 输出内容
&#123;A=1, B=2, C=3&#125;
</code></pre>
<p>在使用TreeMap的时候可以根据key实现数据的排序处理，但是对于key是不允许设置为null的（因为需要依靠Comparable接口对象中的compareTo方法排序，如果传入的对象为null，那么调用方法返回的就是NullPointerException），而value允许为null。</p>
<hr>
<blockquote>
<p>TreeMap按照value进行排序</p>
</blockquote>
<p>TreeMap底层是根据红黑树的数据结构构建的，默认是根据key的自然排序来组织（比如integer的大小，String的字典排序）。所以，TreeMap只能根据key来排序，是不能根据value来排序的（否则key来排序根本就不能形成TreeMap）。</p>
<p>今天有个需求，就是要根据treeMap中的value排序。所以网上看了一下，大致的思路是把TreeMap的EntrySet转换成list，然后使用Collections.sor排序。代码：</p>
<pre><code class="java">import java.util.*;
public class JavaAPIDemo &#123;
    public static void main(String[] args) &#123;
        Map map = new TreeMap&lt;&gt;();&#123;&#123;
            map.put("d", "dddd");
            map.put("a", "aaaa");
            map.put("b", "bbbb");
            map.put("c", "cccc");
        &#125;&#125;
        List&lt;Map.Entry&lt;String, String&gt;&gt; list = new ArrayList&lt;&gt;(map.entrySet());
        System.out.println(&quot;升序排序&quot;)
        Collections.sort(list, Comparator.comparing(Map.Entry::getValue)); // 升序排序
        list.forEach(e -&gt; System.out.println(e.getKey()+&quot;:&quot;+e.getValue()));
        System.out.println(&quot;降序排序&quot;)
        Collections.reverse(list);// 降序排序
        list.forEach(e -&gt; System.out.println(e.getKey()+&quot;:&quot;+e.getValue()));
    &#125;
&#125;

// 输出结果
升序排序
a:aaaa
b:bbbb
c:cccc
d:dddd
降序排序
d:dddd
c:cccc
b:bbbb
a:aaaa
</code></pre>
<h2 id="6、Map-Entry-接口"><a href="#6、Map-Entry-接口" class="headerlink" title="6、Map.Entry 接口"></a>6、Map.Entry 接口</h2><p>虽然已经清楚了整个的Map集合的基本操作形式，但是依然需要有一个核心的问题要解决，Map集合里面是如何进行数据存储的？对于List而言（LinkedList子类）依靠的是链表的形式实现数据存储，那么在进行数据存储的时候一定要将数据保存在一个Node节点之中，虽然在HashMap里面也可以见到Node类型定义，通过源码定义可以发现，HashMap类中的Node内部类本身实现了Map.Entry接口：</p>
<pre><code class="java">static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;&#125;
</code></pre>
<p>所以可以得出结论：所有的key和value数据都被封装在Map.Entry接口之中，接口定义如下：</p>
<pre><code class="java">public static interface Map.Entry&lt;K,V&gt; &#123;&#125;
</code></pre>
<p>并且这个接口内提供有几个重要方法：</p>
<pre><code class="java">public interface Entry&lt;K, V&gt; &#123;
    K getKey();	        // 获得key、
    V getValue();       // 获取value
    V setValue(V var1); //设置value
&#125;
</code></pre>
<p><img src="/Java-%E7%B1%BB%E9%9B%86%E6%A1%86%E6%9E%B6.assets/image-20241017215310364.png"></p>
<p>在JDK1.9以前的开发版本之中，使用者基本上都不会去考虑创建Map.Entry的对象，实际上在正常的开发过程之中使用者也不需要关心Map.Entry对象创建，可是从JDK1.9之后，Map接口里面追加有一个新的方法：</p>
<pre><code class="java">public static &lt;K, V&gt; Map.Entry&lt;K, V&gt; entry(K k, V v) // 创建Map.Entry对象
</code></pre>
<p>操作示例：创建Map.Entry对象</p>
<pre><code class="java">import java.util.Map;
public class JavaAPIDemo &#123;
    public static void main(String[] args) &#123;
        Map.Entry&lt;String, Integer&gt; entry = Map.entry(&quot;one&quot;, 1);
        System.out.println(&quot;获取Key：&quot; + entry.getKey());
        System.out.println(&quot;获取Value：&quot; + entry.getValue());
        System.out.println(entry.getClass().getName()); // 观察使用的子类
    &#125;
&#125;
</code></pre>
<p>通过分析可以发现在整个的Map集合里面，Map.Entry的主要作用就是作为一个Key和Value的包装类型使用，而大部分况下在进行数据存储的时候都会将key和 value包装为一个Map.Entry对象进行使用。</p>
<h2 id="7、Map-集合的输出"><a href="#7、Map-集合的输出" class="headerlink" title="7、Map 集合的输出"></a>7、Map 集合的输出</h2><p>对于集合的输出而言，最标准的做法就是利用Iterator接口来完成，但是需要明确一点的是在Map集合里面并没有一个方法可以直接返回Iterator接口对象，所以这种情况下就必须分析不直接提供Iterator接口实例化的方法的原因，下面对Collection与Map集合的存储结构进行一个比较：</p>
<p><img src="/Java-%E7%B1%BB%E9%9B%86%E6%A1%86%E6%9E%B6.assets/image-20241017215310365.png"></p>
<p>发现在Map集合里面保存的实际上是一组Map.Entry接口对象（里面包装的是Key与Value），所以整个来讲Map依然买现的是单值的保存，这样在Map集合里面提供有一个方法：将全部的Map集合转为Set集：<code>public Set&lt;Map.Enty&lt;K, V&gt;&gt; entrySet()</code></p>
<pre><code class="java">public Set&lt;Map.Enty&lt;K, V&gt;&gt; entrySet(); // 将全部的Map集合转为Set集
</code></pre>
<p><img src="/Java-%E7%B1%BB%E9%9B%86%E6%A1%86%E6%9E%B6.assets/image-20241017215310366.png"></p>
<p>经过分析可以发现如果要想使用Iterator实现Map集合的输出则必须按照如下步骤处理：</p>
<ol>
<li>利用Map接口中提供的entrySet()方法将Map集合转为Set集合</li>
<li>利用Set接口中的iterator()方法将Set集合转为Iterator接口实例</li>
<li>利用Iterator进行迭代输出获取每一组的Map.Entry对象，随后通过getKey()与getValue()方法获取数据</li>
</ol>
<p>操作示例 1：利用Iterator输出Map集合</p>
<pre><code class="java">import java.util.*;
public class JavaAPIDemo &#123;
    public static void main(String[] args) &#123;
        Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;();
        map.put(&quot;one&quot;, 1);
        map.put(&quot;two&quot;, 2);
        Set&lt;Map.Entry&lt;String,Integer&gt;&gt; set = map.entrySet(); // 将Map集合变为Set集合
        Iterator&lt;Map.Entry&lt;String,Integer&gt;&gt; iter = set.iterator();
        while (iter.hasNext()) &#123;
            Map.Entry&lt;String, Integer&gt; me = iter.next() ;
            System.out.println(me.getKey() + &quot; = &quot; + me.getValue());
        &#125;
    &#125;
&#125;

// 输出内容
one = 1
two = 2
</code></pre>
<p>操作示例 2：使用foreach输出</p>
<pre><code class="java">import java.util.*;
public class JavaAPIDemo &#123;
    public static void main(String[] args) &#123;
        Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;();
        map.put(&quot;one&quot;, 1);
        map.put(&quot;two&quot;, 2);
        // 将Map集合变为Set集合
        Set&lt;Map.Entry&lt;String,Integer&gt;&gt; set = map.entrySet() ;
        for (Map.Entry&lt;String, Integer&gt; entry : set) &#123;
            System.out.println(entry.getKey() + &quot; = &quot; + entry.getValue());
        &#125;
    &#125;
&#125;

// 输出内容
one = 1
two = 2
</code></pre>
<h2 id="8、关于-Key-的定义"><a href="#8、关于-Key-的定义" class="headerlink" title="8、关于 Key 的定义"></a>8、关于 Key 的定义</h2><p>在使用Map集合的时候可以发现对于Key和Value的类型实际上都可以由使用者任意决定，那么也就意味着现在依然可以使用自定义的类来进行Key类型的设置。对于自定义Key类型所在的类中一定要覆写hashCode()与equals()方法，否则无法查找到。</p>
<pre><code class="java">/**
 * 在进行数据保存的时候发现会自动使用传入的key的数据生成个hash码,也就是说存储的时候是有这个Hash数值。
 */
public V put(K key, V value) &#123;
    return putVal(hash(key), key, value, false, true);
&#125;

/**
 * 在根据key获取数据的时候依然要将传入的key通过hash()方法来获取其对应的hash码,
 * 那么也就证明,查询的过程之中首先要利用 hashCode()来进行数据查询,
 * 当使用 getNode()方法查询的时候还需要使用到equals()方法
 */
public V get(Object key) &#123;
    Node&lt;K,V&gt; e;
    return (e = getNode(hash(key), key)) == null ? null : e.value;
&#125;
</code></pre>
<p>操作示例：使用自定义类作为Key类型</p>
<pre><code class="java">import java.util.HashMap;
import java.util.Map;
class Person &#123;
    private String name;
    private int age;

    public Person(String name, int age) &#123;
        this.name = name;
        this.age = age;
    &#125;
    @Override
    public int hashCode() &#123;
        final int prime = 31;
        int result = 1;
        result = prime * result + age;
        result = prime * result + ((name == null) ? 0 : name.hashCode());
        return result;
    &#125;
    @Override
    public boolean equals(Object obj) &#123;
        if (this == obj)
            return true;
        if (obj == null)
            return false;
        if (getClass() != obj.getClass())
            return false;
        Person other = (Person) obj;
        if (age != other.age)
            return false;
        if (name == null) &#123;
            if (other.name != null)
                return false;
        &#125; else if (!name.equals(other.name))
            return false;
        return true;
    &#125;
&#125;

public class JavaAPIDemo &#123;
    public static void main(String[] args) &#123;
        Map&lt;Person, String&gt; map = new HashMap&lt;&gt;();
        map.put(new Person(&quot;小强&quot;, 78), &quot;林弱&quot;); // 使用自定义类作为Key
        System.out.println(map.get(new Person(&quot;小强&quot;, 78))); // 通过key找到value
    &#125;
&#125;

// 输出内容
林弱
</code></pre>
<p>虽然允许你使用自定义的类作为Key的类型，但是也需要注意一点，在实际的开发之中对于Map集合的Key常用的类型就是：String、Long、 Integer，尽量使用系统类。</p>
<p><strong>面试题：</strong>如果在进行HashMap进行数据操作的时候出现了Hash冲突（Hash码相同），HashMap是如何解决的?</p>
<p>当出现了Hash冲突之后为了保证程序的正常执行，会在冲突的位置上将所有Hash冲突的内容转为链表保存。</p>
<p><img src="/Java-%E7%B1%BB%E9%9B%86%E6%A1%86%E6%9E%B6.assets/image-20241017215310367.png"></p>
<h2 id="9、Java-8-Map-方法"><a href="#9、Java-8-Map-方法" class="headerlink" title="9、Java 8 Map 方法"></a>9、Java 8 Map 方法</h2><h3 id="1、getOrDefault-：get-不到键则返回默认值"><a href="#1、getOrDefault-：get-不到键则返回默认值" class="headerlink" title="1、getOrDefault()：get 不到键则返回默认值"></a>1、getOrDefault()：get 不到键则返回默认值</h3><pre><code class="java">default V getOrDefault(Object key, V defaultValue)
</code></pre>
<ul>
<li><strong>key</strong> ：对应Map的key</li>
<li><strong>defaultValue</strong> ：传入的默认值</li>
</ul>
<p>返回值：</p>
<ul>
<li>如果Map中这个 key 存在，则返回这个 key 对应的 value</li>
<li>如果Map中这个 key 不存在，则把传入的 defaultValue 作为返回值</li>
</ul>
<pre><code class="java">Map&lt;String, String&gt; map = new HashMap&lt;&gt;();
map.put(&quot;key1&quot;, &quot;value1&quot;);
String value1 = map.getOrDefault(&quot;key1&quot;, &quot;defaultValue&quot;);
System.out.println(value1); // 输出 value1
// 当不存在key2时，返回指定默认值
String value2 = map.getOrDefault(&quot;key2&quot;, &quot;defaultValue&quot;);
System.out.println(value2); // 输出 defaultValue
</code></pre>
<h3 id="2、putIfAbsent-：键不存在时执行-put-方法"><a href="#2、putIfAbsent-：键不存在时执行-put-方法" class="headerlink" title="2、putIfAbsent()：键不存在时执行 put 方法"></a>2、putIfAbsent()：键不存在时执行 put 方法</h3><pre><code class="java">default V putIfAbsent(K key, V value)
</code></pre>
<ul>
<li><strong>key</strong> ：对应Map的key</li>
<li><strong>value</strong> ：将要放入map的值</li>
</ul>
<p>返回值：</p>
<ul>
<li>如果Map中 key 对应的 value 存在，则返回value</li>
<li>如果Map中 key 对应的 value 为 null，返回null ，并且添加从key到传入的value的映射</li>
</ul>
<pre><code class="java">Map&lt;String, String&gt; map = new HashMap&lt;&gt;();
map.put(&quot;key1&quot;, &quot;value1&quot;);
map.putIfAbsent(&quot;key1&quot;, &quot;newValue&quot;);
String value = map.get(&quot;key1&quot;);
System.out.println(value); // 输出 value1
</code></pre>
<h3 id="3、replace：当-key-存在时才执行-put-方法"><a href="#3、replace：当-key-存在时才执行-put-方法" class="headerlink" title="3、replace：当 key 存在时才执行 put 方法"></a>3、replace：当 key 存在时才执行 put 方法</h3><pre><code class="java">default V replace(K key, V value)
</code></pre>
<ul>
<li><strong>key</strong> ：对应Map的key</li>
<li><strong>value</strong> ：将要放入map的值</li>
</ul>
<p>返回值：</p>
<ul>
<li>如果Map中 key 对应的 value 存在，才会执行put方法。</li>
<li>如果Map中 key 对应的 value 为 null，则返回null。</li>
</ul>
<pre><code class="java">Map&lt;String, String&gt; map = new HashMap&lt;&gt;();
map.put(&quot;key1&quot;, &quot;value1&quot;);
map.replace(&quot;key1&quot;, &quot;newValue&quot;);
System.out.println(map); // &#123;&quot;key1&quot;:&quot;newValue&quot;&#125;
System.out.println(map.replace(&quot;key2&quot;, &quot;value2&quot;)); // null
</code></pre>
<hr>
<pre><code class="java">default boolean replace(K key, V oldValue, V newValue)
</code></pre>
<ul>
<li>key：对应Map的key</li>
<li>oldValue：旧的 value 值</li>
<li>newValue：新的 value 值</li>
</ul>
<p>返回值：</p>
<ul>
<li>如果 oldValue 不存在，对 key 对应对 value 执行替换，返回 boolean。如果存在则替换，并返回 boolean。</li>
<li>如果 key 不存在，则不做任何操作，返回 false</li>
</ul>
<pre><code class="java">Map&lt;String, String&gt; map = new HashMap&lt;&gt;();
map.put(&quot;key1&quot;, &quot;oldValue&quot;);
boolean replace1 = map.replace(&quot;key1&quot;, &quot;xxxValue&quot;, &quot;newValue&quot;);
System.out.println(replace1); // false
System.out.println(map);      // &#123;key1=oldValue&#125;
boolean replace2  = map.replace(&quot;key1&quot;, &quot;oldValue&quot;, &quot;newValue&quot;);
System.out.println(replace2); // true
System.out.println(map);      // &#123;key1=newValue&#125;
// key 不存在
boolean replace3 = map.replace(&quot;key2&quot;, &quot;oldValue2&quot;, &quot;newValue2&quot;);
System.out.println(replace3); // false
</code></pre>
<h3 id="4、replaceAll：使用函数重写-value"><a href="#4、replaceAll：使用函数重写-value" class="headerlink" title="4、replaceAll：使用函数重写 value"></a>4、replaceAll：使用函数重写 value</h3><pre><code class="java">default void replaceAll(BiFunction&lt;? super K, ? super V, ? extends V&gt; function)
</code></pre>
<ul>
<li>function ：函数式接口实例，生成映射对函数</li>
</ul>
<p>返回值：无，只会对映射集中的值做替换处理。</p>
<p>replaceAll() 方法将 映射集中的所有映射Value替换成给定的函数所执行的结果</p>
<pre><code class="java">// 假设我们定义一个订单号对应的金额的映射
Map&lt;String, Integer&gt; hashMap = new HashMap&lt;&gt;();
hashMap.put(&quot;S2021123100001&quot;, 200);
hashMap.put(&quot;S2021123100002&quot;, 400);
hashMap.put(&quot;S2021123100003&quot;, 600);

// replaceAll之前: &#123;S2021123100001=200, S2021123100002=400, S2021123100003=600&#125;
System.out.println(&quot;replaceAll之前: &quot; + hashMap);
hashMap.replaceAll((k, v) -&gt; v == null ? -1 : v * 100);

// replaceAll之后: &#123;S2021123100001=20000, S2021123100002=40000, S2021123100003=60000&#125;
System.out.println(&quot;replaceAll之后: &quot; + hashMap);
</code></pre>
<h3 id="5、compute：根据-value-来重写计算"><a href="#5、compute：根据-value-来重写计算" class="headerlink" title="5、compute：根据 value 来重写计算"></a>5、compute：根据 value 来重写计算</h3><pre><code class="java">default V compute(K key, BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction)
</code></pre>
<ul>
<li><strong>key</strong> ：对应Map的key</li>
<li><strong>remappingFunction</strong> ：重新映射函数，用于重新计算值</li>
</ul>
<p>返回值：</p>
<ul>
<li>如果 key 对应的 value 不存在，则返回该 null。</li>
<li>如果 key 对应的 value 存在，则返回通过 remappingFunction 重新计算值，如果计算后的值newValue不为null ，则把计算后的值newValue返回，并且把计算后的值newValue更新到映射中；如果计算后的值newValue为null ，则返回null，并且把当前key 对应的映射从集合中删除。</li>
</ul>
<pre><code class="java">// 假设我们定义一个订单号对应的金额的映射
Map&lt;String, Integer&gt; hashMap = new HashMap&lt;&gt;();
hashMap.put(&quot;S2021123100001&quot;, 200);
hashMap.put(&quot;S2021123100002&quot;, 400);
hashMap.put(&quot;S2021123100003&quot;, 600);

System.out.println(&quot;----------------模拟操作不存在的订单----------------&quot;);
// 模拟操作不存在的订单
Integer noneExistValue = hashMap.compute(&quot;S2021123100004&quot;, (key, value) -&gt; &#123;
    if (value == null) &#123;
        return value;
    &#125;
    return value * 80 / 100;
&#125;);
System.out.println(&quot;操作一个不存在的key结果：&quot; + noneExistValue);
System.out.println(&quot;最终hashMap的值：&quot; + hashMap);

System.out.println(&quot;----------------模拟订单存在，总价打个8折----------------&quot;);
// 模拟订单存在，总价打个8折
Integer existValue = hashMap.compute(&quot;S2021123100001&quot;, (key, value) -&gt; &#123;
    if (value == null) &#123;
        return value;
    &#125;
    return value * 80 / 100;
&#125;);
System.out.println(&quot;操作一个存在的key,计算结果不为空的结果：&quot; + existValue);
System.out.println(&quot;最终hashMap的值：&quot; + hashMap);

System.out.println(&quot;----------------模拟操作返回null----------------&quot;);
// 模拟操作返回null
Integer nullValue = hashMap.compute(&quot;S2021123100003&quot;, (key, value) -&gt; null);
System.out.println(&quot;操作一个不存在的key，计算结果为空的结果：&quot; + nullValue);
System.out.println(&quot;最终hashMap的值：&quot; + hashMap);
</code></pre>
<pre><code class="java">----------------模拟操作不存在的订单----------------
操作一个不存在的key结果：null
最终hashMap的值：&#123;S2021123100001=200, S2021123100002=400, S2021123100003=600&#125;
----------------模拟订单存在，总价打个8折----------------
操作一个存在的key,计算结果不为空的结果：160
最终hashMap的值：&#123;S2021123100001=160, S2021123100002=400, S2021123100003=600&#125;
----------------模拟操作返回null----------------
操作一个不存在的key，计算结果为空的结果：null
最终hashMap的值：&#123;S2021123100001=160, S2021123100002=400&#125;
</code></pre>
<h3 id="6、computeIfAbsent：当-value-不存在时重新计算"><a href="#6、computeIfAbsent：当-value-不存在时重新计算" class="headerlink" title="6、computeIfAbsent：当 value 不存在时重新计算"></a>6、computeIfAbsent：当 value 不存在时重新计算</h3><pre><code class="java">default V computeIfAbsent(K key, Function&lt;? super K, ? extends V&gt; mappingFunction) 
</code></pre>
<ul>
<li><strong>key</strong> ：对应Map的key</li>
<li><strong>mappingFunction</strong> ：重新映射函数，用于重新计算值，得到newValue</li>
</ul>
<p>返回值：</p>
<ul>
<li>如果Map中 key 对应的 value 存在，返回 value</li>
<li>如果Map中 key 对应的 value 不存在，则通过remappingFunction 重新计算值，如果新计算的值newValue不为null，并保存从key 到计算后的值newValue的一个映射；如果新计算的值newValue为null，则不会加入映射</li>
</ul>
<p>有这样一个常见的应用场景，当一批用户按年龄分组之后，新用户怎么加入到分组中？通常我们这样做的：</p>
<pre><code class="java">// 假设我们定义水果英文和中文的映射
Map&lt;String, String&gt; map = new HashMap&lt;&gt;();
map.put(&quot;Apple&quot;, &quot;苹果&quot;);
map.put(&quot;Orange&quot;, &quot;橘子&quot;);
map.put(&quot;Banana&quot;, &quot;香蕉&quot;);

System.out.println(&quot;----------------模拟key存在----------------&quot;);
String orange = map.computeIfAbsent(&quot;Orange&quot;, key -&gt; &quot;西瓜&quot;);
System.out.println(&quot;操作存在的key的结果：&quot; + orange);
System.out.println(&quot;最终map的值：&quot; + map);

System.out.println(&quot;----------------模拟key不存在，计算后的值不为null（增加映射）----------------&quot;);
String watermelon = map.computeIfAbsent(&quot;watermelon&quot;, key -&gt; &quot;西瓜&quot;);
System.out.println(&quot;操作不存在的key,计算后的值不为null的结果：&quot; + watermelon);
System.out.println(&quot;最终map的值：&quot; + map);

System.out.println(&quot;----------------模拟key不存在，计算后的值为null----------------&quot;);
String strawberry = map.computeIfAbsent(&quot;strawberry&quot;, key -&gt; null);
System.out.println(&quot;操作不存在的key,计算后的值为null的结果：&quot; + strawberry);
System.out.println(&quot;最终map的值：&quot; + map);
</code></pre>
<pre><code class="java">----------------模拟key存在----------------
操作存在的key的结果：橘子
最终map的值：&#123;Apple=苹果, Orange=橘子, Banana=香蕉&#125;
----------------模拟key不存在，计算后的值不为null（增加映射）----------------
操作不存在的key,计算后的值不为null的结果：西瓜
最终map的值：&#123;Apple=苹果, watermelon=西瓜, Orange=橘子, Banana=香蕉&#125;
----------------模拟key不存在，计算后的值为null----------------
操作不存在的key,计算后的值为null的结果：null
最终map的值：&#123;Apple=苹果, watermelon=西瓜, Orange=橘子, Banana=香蕉&#125;
</code></pre>
<h3 id="7、computeIfPresent：当-value-存在时重新计算"><a href="#7、computeIfPresent：当-value-存在时重新计算" class="headerlink" title="7、computeIfPresent：当 value 存在时重新计算"></a>7、computeIfPresent：当 value 存在时重新计算</h3><pre><code class="java">default V computeIfPresent(K key, BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction)
</code></pre>
<ul>
<li><strong>key</strong> ：对应Map的key</li>
<li><strong>mappingFunction</strong> ：重新映射函数，用于重新计算值，得到newValue</li>
</ul>
<p>返回值：</p>
<ul>
<li>如果Map中 key 对应的 value 不存在，则返回该 null</li>
<li>如果Map中 key 对应的 value 存在，则通过 remappingFunction 重新计算值，如果新计算的值不为null，则更新从key 到计算后的值newValue的一个映射；如果新计算的值为null，则删除key 到value的映射</li>
</ul>
<pre><code class="java">// 假设我们定义一个订单号对应的金额的映射
Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;();
map.put(&quot;S2021123100001&quot;, 200);
map.put(&quot;S2021123100002&quot;, 400);
map.put(&quot;S2021123100003&quot;, 600);

System.out.println(&quot;----------------模拟key存在----------------&quot;);
// 假设抽取到的订单，就给总价打个8折
Integer existValue = map.computeIfPresent(&quot;S2021123100001&quot;, (key, value) -&gt; value * 80 / 100);
System.out.println(&quot;操作一个存在的key结果：&quot; + existValue);
System.out.println(&quot;最终map的值：&quot; + map);

System.out.println(&quot;----------------模拟key不存在，，计算结果不为null----------------&quot;);
Integer noneExistValue = map.computeIfPresent(&quot;S2021123100004&quot;, (key, value) -&gt; value * 80 / 100);
System.out.println(&quot;操作一个不存在的key,计算结果不为null结果：&quot; + noneExistValue);
System.out.println(&quot;最终map的值：&quot; + map);

System.out.println(&quot;----------------模拟key存在，计算结果为null（删除映射）----------------&quot;);
Integer existKeyWithNullValue = map.computeIfPresent(&quot;S2021123100002&quot;, (key, value) -&gt; null);
System.out.println(&quot;操作一个存在的key,计算结果为null结果：&quot; + existKeyWithNullValue);
System.out.println(&quot;最终map的值：&quot; + map);
</code></pre>
<pre><code class="java">----------------模拟key存在----------------
操作一个存在的key结果：160
最终map的值：&#123;S2021123100001=160, S2021123100002=400, S2021123100003=600&#125;
----------------模拟key不存在，，计算结果不为null----------------
操作一个不存在的key,计算结果不为null结果：null
最终map的值：&#123;S2021123100001=160, S2021123100002=400, S2021123100003=600&#125;
----------------模拟key存在，计算结果为null（删除映射）----------------
操作一个存在的key,计算结果为null结果：null
最终map的值：&#123;S2021123100001=160, S2021123100003=600&#125;
</code></pre>
<h3 id="8、merge：合并新旧两个值"><a href="#8、merge：合并新旧两个值" class="headerlink" title="8、merge：合并新旧两个值"></a>8、merge：合并新旧两个值</h3><pre><code class="java">default V merge(K key, V value, BiFunction&lt;? super V, ? super V, ? extends V&gt; remappingFunction)
</code></pre>
<ul>
<li><strong>key</strong> ：对应Map的key</li>
<li><strong>value</strong> ：使用者传入的值</li>
<li><strong>mappingFunction</strong> ：重新映射函数，用于重新计算值，得到newValue</li>
</ul>
<p>返回值：</p>
<ul>
<li>如果Map中不存在指定的key时，便将传入的value设置为key的值，</li>
<li>如果Map中key存在value时，执行一个方法该方法接收key的旧值oldValue和传入的value，执行自定义的方法</li>
</ul>
<pre><code class="java">Employee[] employeeArray = &#123;
    new Employee(&quot;BAT001&quot;, &quot;胡昊天&quot;, &quot;销售部&quot;, 28, 3500),
    new Employee(&quot;BAT002&quot;, &quot;王大锤&quot;, &quot;销售部&quot;, 27, 3000),
    new Employee(&quot;BAT003&quot;, &quot;唐二鹏&quot;, &quot;研发部&quot;, 32, 9900),
    new Employee(&quot;BAT004&quot;, &quot;王一林&quot;, &quot;研发部&quot;, 30, 9000),
    new Employee(&quot;BAT005&quot;, &quot;梁南生&quot;, &quot;研发部&quot;, 27, 8000),
    new Employee(&quot;BAT006&quot;, &quot;包三雅&quot;, &quot;财务部&quot;, 25, 6000),
    new Employee(&quot;BAT007&quot;, &quot;罗考聪&quot;, &quot;测试部&quot;, 35, 7400),
    new Employee(&quot;BAT008&quot;, &quot;徐浪生&quot;, &quot;测试部&quot;, 24, 7000),
    new Employee(&quot;BAT009&quot;, &quot;胡俊伟&quot;, &quot;研发部&quot;, 24, 4500),
    new Employee(&quot;BAT010&quot;, &quot;胡健儿&quot;, &quot;人事部&quot;, 23, 4000),
    new Employee(&quot;BAT011&quot;, &quot;陶建伟&quot;, &quot;运维部&quot;, 25, 8000),
    new Employee(&quot;BAT012&quot;, &quot;张萌萌&quot;, &quot;行政部&quot;, 20, 3500)
&#125;;
List&lt;Employee&gt; list = Arrays.asList(employeeArray);
Map&lt;String, Double&gt; hashMap = new HashMap&lt;&gt;();
System.out.println(&quot;-------------------java8 写法（易理解）-------------------&quot;);
list.stream().forEach(studentScore -&gt; 
    hashMap.merge(studentScore.getDepartment(), studentScore.getSalary(), (oldValue, newValue) -&gt; oldValue + newValue));
System.out.println(&quot;最终hashMap的值：&quot; + hashMap.toString());
System.out.println(&quot;-------------------java8 精简写法-------------------&quot;);
Map&lt;String, Double&gt; map = new HashMap&lt;&gt;();
list.stream().forEach(studentScore -&gt; map.merge(studentScore.getDepartment(), studentScore.getSalary(), Double::sum));
System.out.println(&quot;最终map的值：&quot; + map.toString());
</code></pre>
<pre><code class="java">-------------------java8 写法（易理解）-------------------
最终hashMap的值：&#123;销售部=6500.0, 测试部=14400.0, 财务部=6000.0, 人事部=4000.0, 研发部=31400.0, 行政部=3500.0, 运维部=8000.0&#125;
-------------------java8 精简写法-------------------
最终map的值：&#123;销售部=6500.0, 测试部=14400.0, 财务部=6000.0, 人事部=4000.0, 研发部=31400.0, 行政部=3500.0, 运维部=8000.0&#125;
</code></pre>
<h3 id="9、Java8-中-Map-的-10-个常用新方法"><a href="#9、Java8-中-Map-的-10-个常用新方法" class="headerlink" title="9、Java8 中 Map 的 10 个常用新方法"></a>9、Java8 中 Map 的 10 个常用新方法</h3><pre><code class="java">import java.util.HashMap;
import java.util.Map;
import java.util.function.BiFunction;

/**
 * Java8中的Map的新方法
 */
public class MainTest &#123;
    public static void main(String[] args) &#123;
        //map 新特性
        Map&lt;Integer,String&gt; map = new HashMap&lt;Integer,String&gt;();
        for(int i=0; i&lt;6; i++)&#123;
            map.put(i,&quot;val_&quot;+i);
        &#125;
        map.put(10,null);

        //1:遍历
        map.forEach((key,value) -&gt; System.out.println(key+&quot;:&quot;+value));

        //2:V getOrDefault(key,defaultValue):获取key值,如果key不存在则用defaultValue
        System.out.println(&quot;3--&gt;&quot;+map.getOrDefault(3,&quot;val_66&quot;));//3--&gt;val_3
        System.out.println(&quot;10--&gt;&quot;+map.getOrDefault(10,&quot;val_66&quot;));//10--&gt;null
        System.out.println(&quot;11--&gt;&quot;+map.getOrDefault(11,&quot;val_66&quot;));//11--&gt;val_66

        //3:V putIfAbsent(K key, V value):根据key匹配Node,如果匹配不到则增加key-value,返回null,如果匹配到Node,如果oldValue不等于null则不进行value覆盖，返回oldValue
        System.out.println(map.putIfAbsent(3,&quot;val_66&quot;));//val_3
        System.out.println(map.putIfAbsent(10,&quot;val_66&quot;));//null
        System.out.println(map.putIfAbsent(11,&quot;val_66&quot;));//null
        System.out.println(map.get(3)+&quot;--&quot;+map.get(10)+&quot;--&quot;+map.get(11));//val_3--val_66--val_66

        //4:boolean remove(Object key, Object value):根据key匹配node，如果value也相同则删除
        System.out.println(map.size());//8
        map.remove(10,&quot;66&quot;);
        map.remove(11,&quot;val_66&quot;);
        System.out.println(map.size());//7
        System.out.println(map.toString());//&#123;0=val_0, 1=val_1, 2=val_2, 3=val_3, 4=val_4, 5=val_5, 10=val_66&#125;

        //5:boolean replace(K key, V oldValue, V newValue):根据key匹配node,如果value也相同则使用newValue覆盖返回true，否则返回false
        map.put(11,null);
        map.replace(3,&quot;3&quot;,&quot;33&quot;);
        map.replace(10,&quot;val_66&quot;,&quot;val_666666&quot;);
        map.replace(11,null,&quot;val_11&quot;);
        map.replace(11,null,&quot;val_11&quot;);
        System.out.println(map.toString());//&#123;0=val_0, 1=val_1, 2=val_2, 3=val_3, 4=val_4, 5=val_5, 10=val_666666, 11=val_11&#125;
        /** 6:
         * void replaceAll(BiFunction function)：调用此方法时重写BiFunction的Object apply(Object o, Object o2)方法，
         * 其中o为key，o2为value，根据重写方法逻辑进行重新赋值。
         */
        map.replaceAll((key,value) -&gt; &#123;
            if(key == 2)&#123;
                return value+&quot;222&quot;;
            &#125;
            return value;
        &#125;);
        System.out.println(map.toString());//&#123;0=val_0, 1=val_1, 2=val_2222, 3=val_3, 4=val_4, 5=val_5, 10=val_666666, 11=val_11&#125;
        /** 7:
         * V compute(K key,BiFunction remappingFunction)：根据key做匹配，根据BiFunction的apply返回做存储的value。
         * 匹配到Node做value替换，匹配不到新增node。apply的返回值如果为null则删除该节点，否则即为要存储的value。
         */
        System.out.println(&quot;---------------------- compute -----------------------&quot;);
        System.out.println(map.compute(3,new BiFunction() &#123;
            @Override
            public Object apply(Object key, Object value) &#123;
                return key+&quot;:&quot;+value;
            &#125;
        &#125;));//3:val_3 -》用返回值覆盖原来的值，这里用了java7的编码方式，以下均采用java8的lanbda表达式
        System.out.println(map.compute(10,(key,value) -&gt; &#123;return value.split(&quot;_&quot;)[1];&#125;));//666666 -》用返回值覆盖原来的值
        System.out.println(map.compute(6,(key,value) -&gt;  null));//null -》返回值为null，则删除该key值
        System.out.println(map.toString());//&#123;0=val_0, 1=val_1, 2=val_2, 3=3:val_3, 4=val_4, 5=val_5, 10=666666, 11=val_11&#125;
        /** 8:
         * merge(K key, V value,BiFunctionsuper V, ? super V, ? extends V&gt; remappingFunction):
         * 功能大部分与compute相同，不同之处在于BiFunction中apply的参数，入参为oldValue、value，
         * 调用merge时根据两个value进行逻辑处理并返回value。
         */
        System.out.println(map.merge(3,&quot;val_3&quot;,(value,newValue) -&gt; newValue));//val_3  --》返回值覆盖原来的value
        System.out.println(map.merge(10,&quot;33334&quot;,(a,b) -&gt; (Integer.valueOf(a)+Integer.valueOf(b))+&quot;&quot;));//700000
        System.out.println(map.merge(8,&quot;88&quot;,(oldValue,newValue) -&gt; oldValue+newValue));//88 -》key不存在则新增
        System.out.println(map.merge(11,&quot;11&quot;,(old,newValue) -&gt; null));//null -》返回值为null,删除该节点
        System.out.println(map.toString());//&#123;0=val_0, 1=val_1, 2=val_2, 3=val_3, 4=val_4, 5=val_5, 8=88, 10=700000&#125;
        /** 9:
         * computeIfAbsent(K key,Functionsuper K, ? extends V&gt; mappingFunction):
         * 根据key做匹配Node，（匹配不到则新建然后重排）
         * 如果Node有value，则直接返回oldValue，
         * 如果没有value则根据Function接口的apply方法获取value，返回value。
         * Function接口的apply的入参为key，调用computeIfAbsent时重写Function接口可以根据key进行逻辑处理，
         * apply的返回值即为要存储的value。
         */
        System.out.println(&quot;----------------------computeIfAbsent------------------------&quot;);
        map.put(8,null);
        System.out.println(map.toString());//&#123;0=val_0, 1=val_1, 2=val_2, 3=val_3, 4=val_4, 5=val_5, 8=null, 10=700000&#125;
        System.out.println(map.computeIfAbsent(0,key -&gt; key+&quot;000&quot;));//val_0  -》key值存在，直接返回oldValue
        System.out.println(map.computeIfAbsent(7,key -&gt; &quot;value_&quot;+key));//value_7 -》key匹配不到，直接新增，返回值为value
        System.out.println(map.computeIfAbsent(8,key -&gt; &quot;88&quot;));//88 -》key匹配到了，value为null，返回值作为value
        System.out.println(map.toString());//&#123;0=val_0, 1=val_1, 2=val_2, 3=val_3, 4=val_4, 5=val_5, 7=value_7, 8=88, 10=700000&#125;
        /** 10:
         * V computeIfPresent(K key,BiFunction remappingFunction)：
         * 根据key做匹配，如果匹配不上则返回null,匹配上根据BiFunction的apply方法获取value，返回value。
         * BiFunction接口的apply的入参为key、oldValue，调用computeIfPresent时重写Function接口
         * 可以根据key和oldValue进行逻辑处理，apply的返回值如果为null则删除该节点，否则即为要存储的value。
         */
        map.remove(7);
        map.remove(8);
        map.replace(10,null);
        map.remove(0,&quot;val_0&quot;);//value匹配到了删除
        map.remove(1,&quot;val_0&quot;);//value匹配失败，不会删除
        System.out.println(map.toString());//&#123;1=val_1, 2=val_2, 3=val_3, 4=val_4, 5=val_5, 10=null&#125;
        System.out.println(map.computeIfPresent(3,(key,value) -&gt; key+&quot;:&quot;+value));//3:val_3 -》key存在，根据返回值修改value
        System.out.println(map.computeIfPresent(0,(key, value) -&gt; &quot;0000&quot;));//null -》key不存在，返回null,不做任何操作
        System.out.println(map.computeIfPresent(1,(key, value) -&gt; null));//null -》key存在，根据返回值修改value
        System.out.println(map.computeIfPresent(10,(key,value) -&gt; &quot;val_10&quot;));//null -》oldValue值为null，删除节点
        System.out.println(map.toString());//&#123;2=val_2, 3=3:val_3, 4=val_4, 5=val_5, 10=null&#125;
        /** 比较
         * compute：根据key做匹配，key,value为参数，匹配到Node做value替换，匹配不到新增node。apply的返回值为null则删除该节点。
         * merge：oldValue，newValue作为为参数，其它功能于compute类似
         * computeIfAbsent：根据key匹配，参数为key,存在且value不为null，不做修改，为null用返回值作为value，不存在则新增
         * computeIfPresent：key,value作为参数，存在,原来的值为null不做操作，否则返回值作为新的value覆盖原来；不存在，不做操作；返回值为null删除该节点
         *
         */
    &#125;
&#125;
</code></pre>
<h1 id="栈与队列"><a href="#栈与队列" class="headerlink" title="栈与队列"></a>栈与队列</h1><h2 id="1、Stack-栈"><a href="#1、Stack-栈" class="headerlink" title="1、Stack 栈"></a>1、Stack 栈</h2><p>栈是一种先进后出的数据结构。例如：在文本编辑器上都有撤销功能，那么每次使用的时候你会发现，最后一次的编辑操作永远是最先撤销，那么这个功能就是利用栈来实现的，栈的基本操作形式如下。</p>
<p><img src="/Java-%E7%B1%BB%E9%9B%86%E6%A1%86%E6%9E%B6.assets/image-20241017215310368.png"></p>
<pre><code class="java">public class Stack&lt;E&gt; extends Vector&lt;E&gt; &#123;&#125;
</code></pre>
<p>可以发现Stack是Vector子类，但是它使用的并不是Vector类之中所提供的方法，而是采用如下的两个方法：</p>
<pre><code class="java">public E push(E item); // 数据入栈
public E pop(); // 数据出栈（弹出）
</code></pre>
<p>操作示例：Stack操作</p>
<pre><code class="java">import java.util.Stack;
public class JavaAPIDemo &#123;
    public static void main(String[] args) &#123;
        Stack&lt;String&gt; all = new Stack&lt;&gt;() ;
        all.push(&quot;A&quot;) ;
        all.push(&quot;B&quot;) ;
        all.push(&quot;C&quot;) ;
        System.out.println(all.pop());
        System.out.println(all.pop());
        System.out.println(all.pop());
        System.out.println(all.pop()); // 无数据、EmptyStackException
    &#125;
&#125;

// 输出内容
C
B
A
Exception in thread &quot;main&quot; java.util.EmptyStackException
    at java.base/java.util.Stack.peek(Stack.java:102)
    at java.base/java.util.Stack.pop(Stack.java:84)
    at JavaAPIDemo.main(JavaAPIDemo.java:11)
</code></pre>
<p>通过此时的操作可以发现，所有的保存之后将按照倒序的形式进行弹出，如果栈已经空了，则会抛出空栈异常。</p>
<p><img src="/Java-%E7%B1%BB%E9%9B%86%E6%A1%86%E6%9E%B6.assets/image-20241017215310369.png"></p>
<h2 id="2、Queue-队列"><a href="#2、Queue-队列" class="headerlink" title="2、Queue 队列"></a>2、Queue 队列</h2><p>Queue描述的是一个队列，而队列的主要特点是实现先进先出的操作形式。其基本的操作形式如下：</p>
<p><img src="/Java-%E7%B1%BB%E9%9B%86%E6%A1%86%E6%9E%B6.assets/image-20241017215310370.png"></p>
<p>如果将队列应用在多线程的“生产者与消费者”的模型处理上，那么对于生产者过快的情况下就没有必要等待消费者获取数据了，可以将所有的内容直接保存在队列之中，队列的实现可以使用LinkedList子类来完成，观察这个类的定义。</p>
<pre><code class="java">public interface Queue&lt;E&gt; extends Collection&lt;E&gt; &#123;&#125;
</code></pre>
<p><img src="/Java-%E7%B1%BB%E9%9B%86%E6%A1%86%E6%9E%B6.assets/image-20241017215310371.png"></p>
<p>队列的使用主要依靠Queue接口之中提供的方法来处理，提供有如下的方法：</p>
<pre><code class="java">public boolean offer(E e); // 向队列中追加数据，可以直接使用add()方法
public E poll();           // 通过队列获取数据，弹出后删除数据
</code></pre>
<p>操作示例 1：实现队列操作</p>
<pre><code class="java">import java.util.LinkedList;
import java.util.Queue;
public class JavaAPIDemo &#123;
    public static void main(String[] args) &#123;
        Queue&lt;String&gt; queue = new LinkedList&lt;&gt;() ;
        // queue.add(&quot;X&quot;); // 也可以使用父类的add()方法
        queue.offer(&quot;X&quot;) ;	// 追加队列数据，通过队尾追加
        queue.offer(&quot;A&quot;) ;	// 追加队列数据，通过队尾追加
        queue.offer(&quot;Z&quot;) ;	// 追加队列数据，通过队尾追加
        System.out.println(queue.poll()); // 弹出数据、X
        System.out.println(queue.poll()); // 弹出数据、A
        System.out.println(queue.poll()); // 弹出数据、Z
    &#125;
&#125;

// 输出内容
X
A
Z
</code></pre>
<p>除了Linkedlist子类之外，还有一个优先级队列的概念，可以使用PriorityQueue实现优先级队列（比较功能）</p>
<p><img src="/Java-%E7%B1%BB%E9%9B%86%E6%A1%86%E6%9E%B6.assets/image-20241017215310372.png"></p>
<p>操作示例 2：使用优先级队列</p>
<pre><code class="java">import java.util.PriorityQueue;
import java.util.Queue;
public class JavaAPIDemo &#123;
    public static void main(String[] args) &#123;
        Queue&lt;String&gt; queue = new PriorityQueue&lt;&gt;() ;
        queue.offer(&quot;X&quot;) ;	// 追加队列数据，通过队尾追加
        queue.offer(&quot;A&quot;) ;	// 追加队列数据，通过队尾追加
        queue.offer(&quot;Z&quot;) ;	// 追加队列数据，通过队尾追加
        System.out.println(queue.poll()); // 弹出数据、X
        System.out.println(queue.poll()); // 弹出数据、A
        System.out.println(queue.poll()); // 弹出数据、Z
    &#125;
&#125;

// 输出内容
A
X
Z
</code></pre>
<p>对于队列的选用原则也是需要根据实际的项目环境来决定的。</p>
<h1 id="Properties-工具类"><a href="#Properties-工具类" class="headerlink" title="Properties 工具类"></a>Properties 工具类</h1><p>在之前讲解国际化程序的时候讲解过资源文件（*.properties），那么这类文件的存储结构是按照“key&#x3D; value”的形式存储的，而这种结构的保存形式与Map集合很相似的，但是唯一的区别在于其所保存的内容只能够是字符串，所以为了可以方便的描述属性的定义，java.util包里面提供有Properties类型，此类是Hashtable的子类。</p>
<pre><code class="java">public class Properties extends Hashtable&lt;Object, Object&gt; &#123;&#125;
</code></pre>
<p>可以发现在继承Hashtable的时候为Hashtable中定义的泛型为Object，Properties是不需要操作泛型的，因为它可以操作的类型只能是String类型，在Properties之中如果要想实现属性的操作可以采用如下的方法：</p>
<pre><code class="java">public Object setProperty(String key, String value);        // 设置属性
public String getProperty(String key);                      // 取得属性，key不存在返回null
public String getProperty(String key, String defaultValue); // 取得属性，不存在返回默认值
public void store(OutputStream, String comments);           // 输出属性内容（到输出流中）
public void load(InputStream instream);                     // 通过输入流读取属性内容
</code></pre>
<p>操作示例 1：观察属性的设置和取得</p>
<pre><code class="java">import java.util.Properties;
public class JavaAPIDemo &#123;
    public static void main(String[] args) &#123;
        Properties prop = new Properties();
        // 设置的内容只允许是字符串
        prop.setProperty(&quot;name&quot;, &quot;Sam&quot;);
        prop.setProperty(&quot;age&quot;, &quot;18&quot;);
        System.out.println(prop.getProperty(&quot;name&quot;));
        System.out.println(prop.getProperty(&quot;work&quot;));
        System.out.println(prop.getProperty(&quot;work&quot;, &quot;Java&quot;));
    &#125;
&#125;

// 输出内容
Sam
null
Java
</code></pre>
<p>通过代码可以发现Properties里面可以像Map集合那样进行内容的设置与获取，但是唯一的差别是它只能够操作String类型，另外需要注意的是，之所以会提供有Properties类还有一个最重要的功能是它可以通过输出流输出属性，也可以使用输入流读取属性内容。</p>
<p>操作示例 2：将属性内容保存在文件之中</p>
<pre><code class="java">import java.io.File;
import java.io.FileOutputStream;
import java.util.Properties;
public class JavaAPIDemo &#123;
    public static void main(String[] args) throws Exception &#123;
        Properties prop = new Properties();
        // 设置的内容只允许是字符串
        prop.setProperty(&quot;name&quot;, &quot;Sam&quot;);
        prop.setProperty(&quot;age&quot;, &quot;18&quot;);
        prop.setProperty(&quot;address&quot;, &quot;中国&quot;);
        prop.store(new FileOutputStream(&quot;D:\\info.properties&quot;), &quot;中文注释会被编码-English&quot;);
    &#125;
&#125;

// 输出到文件中的内容
#\u4E2D\u6587\u6CE8\u91CA\u4F1A\u88AB\u7F16\u7801-English
#Wed Nov 10 15:36:57 CST 2021
address=\u4E2D\u56FD
name=Sam
age=18
</code></pre>
<p>通过程序的执行可以发现,的确可以实现资源文件的输入处理，但是如果输出的是中文则自动帮助用户进行处理。</p>
<p>操作示例 3：读取资源文件</p>
<pre><code class="java">import java.io.FileInputStream;
import java.util.Properties;
public class JavaAPIDemo &#123;
    public static void main(String[] args) throws Exception &#123;
        Properties prop = new Properties() ;
        prop.load(new FileInputStream(&quot;D:\\info.properties&quot;));
        System.out.println(prop.getProperty(&quot;name&quot;));
    &#125;
&#125;

// 输出内容
Sam
</code></pre>
<p>使用Properties类型的最大特点是可以进行资源内容的输入与输出的处理操作，但是在实际的开发之中Properties往往用于读取配置资源的信息，这一点主要是在标准设计之中做程序初始化准备的时候使用。</p>
<h1 id="Collections-工具类"><a href="#Collections-工具类" class="headerlink" title="Collections 工具类"></a>Collections 工具类</h1><blockquote>
<p>参考：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/guweiwei/p/6511974.html">https://www.cnblogs.com/guweiwei/p/6511974.html</a></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/kYKfGibLLwE-gylsclSuvg">https://mp.weixin.qq.com/s/kYKfGibLLwE-gylsclSuvg</a></li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/K8PAFANbS_rBim0Uy9oOmQ">https://mp.weixin.qq.com/s/K8PAFANbS_rBim0Uy9oOmQ</a></li>
</ul>
</blockquote>
<p>Collections是java提供的一组集合数据的操作工具类，也就是说利用它可以实现各个集合的操作。</p>
<p><img src="/Java-%E7%B1%BB%E9%9B%86%E6%A1%86%E6%9E%B6.assets/image-20241017215310373.png"></p>
<p><strong>Collections工具类常用方法：</strong></p>
<h2 id="1、排序操作"><a href="#1、排序操作" class="headerlink" title="1、排序操作"></a>1、排序操作</h2><p>（主要针对List接口相关）</p>
<pre><code class="java">public static &lt;T extends Comparable&lt;? super T&gt;&gt; void sort(List&lt;T&gt; list); // 对List里的元素根据自然升序排序
public static &lt;T&gt; void sort(List&lt;T&gt; list, Comparator&lt;? super T&gt; c); // 自定义比较器进行排序
public static void reverse(List&lt;?&gt; list); // 反转指定List集合中元素的顺序
public static void shuffle(List&lt;?&gt; list); // 使用默认随机源对List中的元素进行随机排序（洗牌）
public static void swap(List&lt;?&gt; list, int i, int j); // 将指定List集合中i处元素和j出元素进行交换
public static void rotate(List&lt;?&gt; list, int distance); // 将所有元素向右移位指定长度，如果distance等于size那么结果不变

/**********************简单方法名**************************/
sort(List list)：对List里的元素根据自然升序排序
sort(List list, Comparator c)：自定义比较器进行排序
reverse(List list)：反转指定List集合中元素的顺序
shuffle(List list)：使用默认随机源对List中的元素进行随机排序（洗牌）
swap(List list, int i, int j)：将指定List集合中i处元素和j出元素进行交换
rotate(List list, int distance)：移动列表中的元素，负数向左移动，正数向右移动（集合中的元素向后移m个位置，在后面被遮盖的元素循环到前面来）
</code></pre>
<p>操作示例：</p>
<pre><code class="java">import java.util.*;
public class JavaAPIDemo &#123;
    public static void main(String[] args) &#123;
        List&lt;String&gt; list = new ArrayList&lt;&gt;(List.of(&quot;C&quot;, &quot;B&quot;, &quot;A&quot;, &quot;D&quot; ,&quot;F&quot;, &quot;E&quot;));
        // 默认正序排序
        Collections.sort(list);
        System.out.println(list); // [A, B, C, D, E, F]
        // 自定义倒序排序
        Collections.sort(list,Collections.reverseOrder()); // [F, E, D, C, B, A]
        System.out.println(list);
        // 反转集合
        Collections.reverse(list);
        System.out.println(list); // [A, B, C, D, E, F]
        // 替换集合中左边0与5的位置
        Collections.swap(list, 0, 5);
        System.out.println(list); // [F, B, C, D, E, A]
        // 将所有元素向右移位1个位置，如果参数为负数，则是向左移动
        Collections.rotate(list, 1);
        System.out.println(list); // [A, F, B, C, D, E]
        // 随机排序集合，每次输出都不一样
        Collections.shuffle(list);
        System.out.println(list); // [D, B, E, A, C, F]
    &#125;
&#125;

// 输出内容
[A, B, C, D, E, F]
[F, E, D, C, B, A]
[A, B, C, D, E, F]
[F, B, C, D, E, A]
[A, F, B, C, D, E]
[D, B, E, A, C, F]
</code></pre>
<h2 id="2、查找替换"><a href="#2、查找替换" class="headerlink" title="2、查找替换"></a>2、查找替换</h2><p>查找和替换（主要针对Collection接口相关）</p>
<pre><code class="java">public static &lt;T&gt; void copy(List&lt;? super T&gt; dest, List&lt;? extends T&gt; src); // 将集合src中的元素全部复制到dest中,并且覆盖相应索引的元素
public static int indexOfSubList(List&lt;?&gt; source, List&lt;?&gt; target); // 查找target在source中首次出现位置的索引
public static int lastIndexOfSubList(List&lt;?&gt; source, List&lt;?&gt; target); // 查找target在source中末次出现位置的索引
public static &lt;T extends Object &amp; Comparable&lt;? super T&gt;&gt; T max(Collection&lt;? extends T&gt; coll); // 返回最大元素
public static &lt;T&gt; T max(Collection&lt;? extends T&gt; coll, Comparator&lt;? super T&gt; comp); // 根据自定义比较器，返回最大元素
public static &lt;T extends Object &amp; Comparable&lt;? super T&gt;&gt; T min(Collection&lt;? extends T&gt; coll); // 返回最小元素
public static &lt;T&gt; T min(Collection&lt;? extends T&gt; coll, Comparator&lt;? super T&gt; comp); // 根据自定义比较器，返回最小元素
public static &lt;T&gt; void fill(List&lt;? super T&gt; list, T obj); // 使用指定对象填充
public static int frequency(Collection&lt;?&gt; c, Object o); // 返回指定集合中指定对象出现的次数
public static &lt;T&gt; boolean replaceAll(List&lt;T&gt; list, T oldVal, T newVal); // 替换集合中指定元素
public static &lt;T&gt; int binarySearch(List&lt;? extends Comparable&lt;? super T&gt;&gt; list, T key); // 查找指定集合中的元素,返回该元素的索引(二分法)
    
/**********************简单方法名**************************/
copy(List dest, List src)：将集合src中的元素全部复制到dest中,并且覆盖相应索引的元素
indexOfSubList(List source, List target)：查找target在source中首次出现位置的索引
lastIndexOfSubList(List source, List target)：查找target在source中末次出现位置的索引
max(Collection coll)：返回最大元素
max(Collection coll, Comparator comp)：根据自定义比较器，返回最大元素
min(Collection coll)：返回最小元素
min(Collection coll, Comparator comp)：根据自定义比较器，返回最小元素
fill(List list, Object obj)：使用指定对象填充（用对象obj替换集合list中的所有元素）
frequency(Collection Object o)：返回指定集合中指定对象出现的次数
replaceAll(List list, Object old, Object new)：替换集合中指定元素
binarySearch(List list, Object key)：使用二分搜索法，以获得指定对象在List中的索引，前提是集合已经排序
</code></pre>
<p>操作示例：</p>
<pre><code class="java">import java.util.*;
public class JavaAPIDemo &#123;
    public static void main(String[] args) &#123;
        &#123;
            // 将集合src中的元素全部复制到dest中,并且覆盖相应索引的元素
            List&lt;String&gt; dest = new ArrayList&lt;&gt;(List.of(&quot;C&quot;, &quot;B&quot;, &quot;A&quot;, &quot;D&quot; ,&quot;F&quot;, &quot;E&quot;));
            List&lt;String&gt; src = new ArrayList&lt;&gt;(List.of(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;));
            Collections.copy(dest, src);
            System.out.println(dest); // [1, 2, 3, D, F, E]
        &#125;
        &#123;
            // 查找subList在list中首次出现位置的索引
            List&lt;String&gt; initList = new ArrayList&lt;&gt;(List.of(&quot;C&quot;, &quot;B&quot;, &quot;A&quot;, &quot;D&quot; ,&quot;F&quot;, &quot;E&quot;));
            System.out.println(Collections.indexOfSubList(initList, List.of(&quot;A&quot;, &quot;D&quot;))); // 2
            System.out.println(Collections.indexOfSubList(initList, List.of(&quot;A&quot;, &quot;F&quot;))); // -1
            // 查找subList在list中末次次出现位置的索引
            System.out.println(Collections.indexOfSubList(initList, List.of(&quot;A&quot;, &quot;D&quot;))); // 2
            System.out.println(Collections.indexOfSubList(initList, List.of(&quot;A&quot;, &quot;F&quot;))); // -1
        &#125;
        &#123;
            // 返回集合中最大和最小元素
            List&lt;String&gt; initList = new ArrayList&lt;&gt;(List.of(&quot;C&quot;, &quot;B&quot;, &quot;A&quot;, &quot;D&quot; ,&quot;F&quot;, &quot;E&quot;));
            System.out.println(Collections.min(initList)); // A
            System.out.println(Collections.max(initList)); // F
            // 返回指定集合中指定对象出现的次数
            System.out.println(Collections.frequency(initList, &quot;A&quot;)); // 1
            // 查找指定集合中的元素，返回所查找元素的索引，PS：前提是集合已经排序
            Collections.sort(initList);
            System.out.println(Collections.binarySearch(initList, &quot;C&quot;)); // 2
        &#125;
        &#123;
            // 用对象obj替换集合list中的所有元素
            List&lt;String&gt; initList = new ArrayList&lt;&gt;(List.of(&quot;C&quot;, &quot;B&quot;, &quot;A&quot;, &quot;D&quot; ,&quot;F&quot;, &quot;E&quot;));
            Collections.fill(initList, &quot;fill&quot;);
            System.out.println(initList); // [fill, fill, fill, fill, fill, fill]
        &#125;
        &#123;
            // 替换批定元素为某元素,若要替换的值存在刚返回true,反之返回false
            List&lt;String&gt; initList = new ArrayList&lt;&gt;(List.of(&quot;C&quot;, &quot;B&quot;, &quot;A&quot;, &quot;D&quot; ,&quot;E&quot;, &quot;E&quot;));
            Collections.replaceAll(initList, &quot;E&quot;, &quot;X&quot;);
            System.out.println(initList); // [C, B, A, D, X, X]
        &#125;
    &#125;
&#125;
</code></pre>
<h2 id="3、同步控制"><a href="#3、同步控制" class="headerlink" title="3、同步控制"></a>3、同步控制</h2><p>同步控制Collections：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_38192427/article/details/116330109">https://blog.csdn.net/weixin_38192427/article/details/116330109</a></p>
<p>同步控制Collections工具类中提供了多个synchronizedXxx()方法，该方法返回指定集合对象对应的同步对象，从而解决多线程并发访问集合时线程的安全问题。HashSet、ArrayList、HashMap都是线程不安全的，如果需要考虑同步，则使用这些方法。这些方法主要有：</p>
<pre><code class="java">public static &lt;T&gt; Collection&lt;T&gt; synchronizedCollection(Collection&lt;T&gt; c);
public static &lt;T&gt; List&lt;T&gt; synchronizedList(List&lt;T&gt; list);
public static &lt;T&gt; Set&lt;T&gt; synchronizedSet(Set&lt;T&gt; s);
public static &lt;T&gt; SortedSet&lt;T&gt; synchronizedSortedSet(SortedSet&lt;T&gt; s);
public static &lt;T&gt; NavigableSet&lt;T&gt; synchronizedNavigableSet(NavigableSet&lt;T&gt; s);
public static &lt;K,V&gt; Map&lt;K,V&gt; synchronizedMap(Map&lt;K,V&gt; m);
public static &lt;K,V&gt; SortedMap&lt;K,V&gt; synchronizedSortedMap(SortedMap&lt;K,V&gt; m);
public static &lt;K,V&gt; NavigableMap&lt;K,V&gt; synchronizedNavigableMap(NavigableMap&lt;K,V&gt; m);

SynchronizedXxx(Xxx x); // 创建一个SynchronizedXxx，并将指定的集合x作为内部集合,此方法会将SynchronizedXxx实例本身作为互斥体（mutex）
SynchronizedXxx(Xxx x, Object mutex); // 创建一个SynchronizedXxx，并将指定的集合作为内部集合，将指定的对象作为互斥体（mutex）
</code></pre>
<p>SynchronizedMap类解读：</p>
<blockquote>
<p>1、SynchronizedMap概述</p>
<ul>
<li>SynchronizedMap是集合工具类Collections的一个静态内部类</li>
<li>SynchronizedMap实现了Map接口，同时实现了接口Serializable，支持序列化</li>
<li>在多线程的情况下，能够保证线程的安全</li>
</ul>
<p>2、SynchronizedMap的获取示例</p>
<pre><code class="java">Map&lt;Integer, String&gt; map = new HashMap&lt;&gt;();
Map&lt;Integer, String&gt; synchronizedMap = Collections.synchronizedMap(map);

// Collections 调用的 synchronizedMap 方法如下
public static &lt;K,V&gt; Map&lt;K,V&gt; synchronizedMap(Map&lt;K,V&gt; m) &#123;
    return new SynchronizedMap&lt;&gt;(m);
&#125;
</code></pre>
<p>3、SynchronizedMap源码解读</p>
<pre><code class="java">private static class SynchronizedMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Serializable &#123;
    // 1、类的基本属性
    private final Map&lt;K,V&gt; m;     // 被 final 修饰的普通 Map 对象
    final Object      mutex;        // 互斥锁对象

    // 2、构造函数
    // 不指定锁对象
    SynchronizedMap(Map&lt;K,V&gt; m) &#123;
        // 不指定锁对象时，锁对象就是 SynchronizedMap 本身
        this.m = Objects.requireNonNull(m);
        mutex = this;
    &#125;
    // 自定义锁对象
    SynchronizedMap(Map&lt;K,V&gt; m, Object mutex) &#123;
        // 锁对象为传入的 mutex
        this.m = m;
        this.mutex = mutex;
    &#125;

    // 3、常见的 API 方法
    public int size() &#123;
        synchronized (mutex) &#123;return m.size();&#125;
    &#125;
    public boolean isEmpty() &#123;
        synchronized (mutex) &#123;return m.isEmpty();&#125;
    &#125;
    public boolean containsKey(Object key) &#123;
        synchronized (mutex) &#123;return m.containsKey(key);&#125;
    &#125;
    public boolean containsValue(Object value) &#123;
        synchronized (mutex) &#123;return m.containsValue(value);&#125;
    &#125;
    public V get(Object key) &#123;
        synchronized (mutex) &#123;return m.get(key);&#125;
    &#125;
    public V put(K key, V value) &#123;
        synchronized (mutex) &#123;return m.put(key, value);&#125;
    &#125;
    // ...等等方法
&#125;
</code></pre>
<ul>
<li>可以发现它的所有方法都是加了synchronized互斥锁关键字</li>
<li>此外SynchronizedMap还重写了Map中的一些方法，也都是加了synchronized互斥锁关键字</li>
</ul>
<p>4、SynchronizedMap，Hashtable与ConcurrentHashMap 对比：</p>
<ul>
<li>相同点：1）三者都实现了Map接口。2）在多线程的情况下，都可以保证线程的安全</li>
<li>不同点：<ol>
<li>底层使用的数据结构：Hashtable使用了 数组 + 链表，ConcurrentHashMap 使用了数组 + 链表 + 红黑树</li>
<li>默认的初始容量：HashTable是 11，ConcurrentHashMap是 16</li>
<li>保证线程安全的机制：SynchronizedMap和Hashtable都是为每个方法加了synchronized互斥锁关键字，ConcurrentHashMap使用了 Synchronized + CAS + Volatile机制来保证线程安全</li>
<li>多线程的情况下执行效率：ConcurrentHashMap执行效率要高于SynchronizedMap和Hashtable</li>
</ol>
</li>
</ul>
</blockquote>
<p>SynchronizedList类解读：</p>
<blockquote>
<p>1、SynchronizedList 概述</p>
<ul>
<li>SynchronizedList是集合工具类Collections的一个静态内部类</li>
<li>SynchronizedList实现了List接口</li>
<li>在多线程的情况下，能够保证线程的安全</li>
</ul>
<p>2、SynchronizedList的获取示例</p>
<pre><code class="java">List&lt;Integer&gt; newList = new ArrayList&lt;&gt;();
List&lt;Integer&gt; synchronizedList = Collections.synchronizedList(newList);

// Collections 调用 synchronizedList 方法如下
public static &lt;T&gt; List&lt;T&gt; synchronizedList(List&lt;T&gt; list) &#123;
    return (list instanceof RandomAccess ?
            new SynchronizedRandomAccessList&lt;&gt;(list) :
            new SynchronizedList&lt;&gt;(list));
&#125;
</code></pre>
<p>3、SynchronizedList源码解读</p>
<pre><code class="java">static class SynchronizedList&lt;E&gt;
        extends SynchronizedCollection&lt;E&gt;
        implements List&lt;E&gt; &#123;
        private static final long serialVersionUID = -7754090372962971524L;

    // 1、类的基本属性
    final List&lt;E&gt; list;

    // 2、构造函数
    SynchronizedList(List&lt;E&gt; list) &#123;
        super(list);
        this.list = list;
    &#125;
    // 指定互斥锁对象，并调用父类 SynchronizedCollection 的构造函数
    SynchronizedList(List&lt;E&gt; list, Object mutex) &#123;
        super(list, mutex);
        this.list = list;
    &#125;

    // 3、常用API
    public E get(int index) &#123;
        synchronized (mutex) &#123;return list.get(index);&#125;
    &#125;
    public E set(int index, E element) &#123;
        synchronized (mutex) &#123;return list.set(index, element);&#125;
    &#125;
    public void add(int index, E element) &#123;
        synchronized (mutex) &#123;list.add(index, element);&#125;
    &#125;
    public E remove(int index) &#123;
        synchronized (mutex) &#123;return list.remove(index);&#125;
    &#125;
    // 其父类 SynchronizedCollection 的方法
    public int size() &#123;
        synchronized (mutex) &#123;return c.size();&#125;
    &#125;
    // ...等等方法
&#125;
</code></pre>
<ul>
<li>可以看到添加、删除、修改、查询等操作都通过 synchronized 实现了同步锁来保证这些操作是线程安全的</li>
<li>在迭代器操作是没有添加同步锁的，因此使用迭代器进行操作使会出现线程不安全的情况，但我们也可以手动添加同步锁来实现迭代的时候线程安全</li>
</ul>
<p>4、SynchronizedList，Vector与CopyOnWriteArrayList 对比：</p>
<ul>
<li>相同点：三者都是线程安全的List</li>
<li>不同点：<ol>
<li>扩容机制：Vector 每次扩容的大小都是原来数组大小的 2 倍，而 CopyOnWriteArrayList 不需要扩容，通过 COW 思想就能使数组容量满足要求</li>
<li>保证线程安全机制：SynchronizedList 和 Vector 的每个方法都进行了加锁，而 CopyOnWriteArrayList 的读操作是不加锁的，因此 CopyOnWriteArrayList 的读性能远高于 SynchronizedList 和 Vector</li>
<li>在多线程的读多写少的情况下执行效率：CopyOnWriteArrayList 要高于 SynchronizedList 和 Vector</li>
</ol>
</li>
</ul>
</blockquote>
<p>SynchronizedSet类解读：</p>
<blockquote>
<p>1、synchronizedSet 概述</p>
<ul>
<li>SynchronizedSet 是集合工具类 Collections 的一个静态内部类</li>
<li>SynchronizedSet 实现了 Set 接口</li>
<li>在多线程的情况下，能够保证线程的安全</li>
</ul>
<p>2、SynchronizedSet 的获取示例</p>
<pre><code class="java">Set&lt;String&gt; set = new HashSet&lt;&gt;();
Set&lt;String&gt; synchronizedSet = Collections.synchronizedSet(set);

// Collections 调用 synchronizedSet 方法如下
public static &lt;T&gt; Set&lt;T&gt; synchronizedSet(Set&lt;T&gt; s) &#123;
    return new SynchronizedSet&lt;&gt;(s);
&#125;
</code></pre>
<p>3、SynchronizedSet 源码解读</p>
<pre><code class="java">static class SynchronizedSet&lt;E&gt; extends SynchronizedCollection&lt;E&gt; implements Set&lt;E&gt; &#123;
    SynchronizedSet(Set&lt;E&gt; s) &#123;
        super(s);
    &#125;
    SynchronizedSet(Set&lt;E&gt; s, Object mutex) &#123;
        super(s, mutex);
    &#125;
    public boolean equals(Object o) &#123;
        if (this == o)
            return true;
        synchronized (mutex) &#123;return c.equals(o);&#125;
    &#125;
    public int hashCode() &#123;
        synchronized (mutex) &#123;return c.hashCode();&#125;
    &#125;
&#125;

// 在 synchronizedSet 中只有 equals() 和 hashCode() 方法，所以我们看其父类 SynchronizedCollection的方法
public int size() &#123;
    synchronized (mutex) &#123;return c.size();&#125;
&#125;
public boolean isEmpty() &#123;
    synchronized (mutex) &#123;return c.isEmpty();&#125;
&#125;
public boolean contains(Object o) &#123;
    synchronized (mutex) &#123;return c.contains(o);&#125;
&#125;
public Iterator&lt;E&gt; iterator() &#123;
    return c.iterator(); 
&#125;
public boolean add(E e) &#123;
    synchronized (mutex) &#123;return c.add(e);&#125;
&#125;      
public boolean remove(Object o) &#123;
    synchronized (mutex) &#123;return c.remove(o);&#125;
&#125;
public boolean addAll(Collection&lt;? extends E&gt; coll) &#123;
    synchronized (mutex) &#123;return c.addAll(coll);&#125;
&#125;
public boolean removeAll(Collection&lt;?&gt; coll) &#123;
    synchronized (mutex) &#123;return c.removeAll(coll);&#125;
&#125;     
@Override
public void forEach(Consumer&lt;? super E&gt; consumer) &#123;
    synchronized (mutex) &#123;c.forEach(consumer);&#125;
&#125;
@Override
public Stream&lt;E&gt; stream() &#123;
    return c.stream(); 
&#125;
</code></pre>
<ul>
<li>可以看到添加、删除等操作都通过 synchronized 实现了同步锁来保证这些操作是线程安全的</li>
<li>在迭代器操作是没有添加同步锁的，因此使用迭代器进行操作使会出现线程不安全的情况，但我们也可以手动添加同步锁来实现迭代的时候线程安全</li>
</ul>
<p>4、SynchronizedSet 与 CopyOnWriteArraySet 对比：</p>
<ul>
<li>相同点：二者都是线程安全的Set</li>
<li>不同点：<ol>
<li>实现机制：CopyOnWriteArraySet 是通过 CopyOnWriteArrayList 实现的。而CopyOnWriteArrayList 本质是个动态数组，所以 CopyOnWriteArraySet 相当于通过动态数组实现的 Set，而 SynchronizedSet 的实现依据于如何创建 SynchronizedSet 的实例</li>
<li>保证线程安全的机制：CopyOnWriteArraySet 通过 volatile 和 ReentrantLock 来实现的，而 SynchronizedSet 是通过给添加、删除等方法添加 synchronized 同步锁来保证的</li>
<li>在多线程的读多写少的情况下执行效率：CopyOnWriteArraySet 要高于 SynchronizedSet</li>
</ol>
</li>
</ul>
</blockquote>
<h2 id="4、不可变集合"><a href="#4、不可变集合" class="headerlink" title="4、不可变集合"></a>4、不可变集合</h2><p>设置不可变集合，Collections有三类方法可返回一个不可变集合：</p>
<ol>
<li>emptyXxx()：返回一个空的不可变的集合对象</li>
<li>singletonXxx()：返回一个只包含指定对象的，不可变的集合对象</li>
<li>unmodifiableXxx()：返回指定集合对象的不可变视图</li>
</ol>
<pre><code class="java">// emptyXxx()：返回一个空的不可变的集合
public static &lt;T&gt; ListIterator&lt;T&gt; emptyListIterator();
public static &lt;T&gt; Enumeration&lt;T&gt; emptyEnumeration();
public static final &lt;T&gt; Set&lt;T&gt; emptySet();
public static &lt;E&gt; SortedSet&lt;E&gt; emptySortedSet();
public static &lt;E&gt; NavigableSet&lt;E&gt; emptyNavigableSet();
public static final &lt;T&gt; List&lt;T&gt; emptyList();
public static final &lt;K,V&gt; Map&lt;K,V&gt; emptyMap();
public static final &lt;K,V&gt; SortedMap&lt;K,V&gt; emptySortedMap();
public static final &lt;K,V&gt; NavigableMap&lt;K,V&gt; emptyNavigableMap();

// singletonXxx()：返回一个只包含指定对象的，不可变的集合
public static &lt;T&gt; Set&lt;T&gt; singleton(T o);
public static &lt;T&gt; List&lt;T&gt; singletonList(T o);
public static &lt;K,V&gt; Map&lt;K,V&gt; singletonMap(K key, V value);

// unmodifiableXxx()：返回指定集合对象的不可变视图
public static &lt;T&gt; Collection&lt;T&gt; unmodifiableCollection(Collection&lt;? extends T&gt; c);
public static &lt;T&gt; Set&lt;T&gt; unmodifiableSet(Set&lt;? extends T&gt; s);
public static &lt;T&gt; SortedSet&lt;T&gt; unmodifiableSortedSet(SortedSet&lt;T&gt; s);
public static &lt;T&gt; NavigableSet&lt;T&gt; unmodifiableNavigableSet(NavigableSet&lt;T&gt; s);
public static &lt;T&gt; List&lt;T&gt; unmodifiableList(List&lt;? extends T&gt; list);
public static &lt;K,V&gt; Map&lt;K,V&gt; unmodifiableMap(Map&lt;? extends K, ? extends V&gt; m);
public static &lt;K,V&gt; SortedMap&lt;K,V&gt; unmodifiableSortedMap(SortedMap&lt;K, ? extends V&gt; m);
public static &lt;K,V&gt; NavigableMap&lt;K,V&gt; unmodifiableNavigableMap(NavigableMap&lt;K, ? extends V&gt; m);
</code></pre>
<p>操作示例：</p>
<pre><code class="java">import java.util.*;
public class JavaAPIDemo &#123;
    public static void main(String[] args) &#123;
        // 1、emptyXxx()：返回一个空的不可变的集合
        try &#123;
            List&lt;String&gt; emptyList = Collections.emptyList();
            // 抛出：java.lang.UnsupportedOperationException
            emptyList.add(&quot;X&quot;);
        &#125; catch (UnsupportedOperationException e) &#123;
            e.printStackTrace();
        &#125;

        // 2、singletonXxx()：返回一个只包含指定对象的，不可变的集合
        try &#123;
            List&lt;String&gt; singletonList = Collections.singletonList(&quot;X&quot;);
            System.out.println(singletonList.get(0));
            // 抛出：java.lang.UnsupportedOperationException
            singletonList.add(&quot;&quot;);
        &#125; catch (UnsupportedOperationException e) &#123;
            e.printStackTrace();
        &#125;

        // 3、unmodifiableXxx()：返回指定集合对象的不可变视图
        try &#123;
            // 初始化集合
            List&lt;String&gt; list = new ArrayList&lt;&gt;(List.of(&quot;C&quot;, &quot;B&quot;, &quot;A&quot;, &quot;D&quot; ,&quot;F&quot;, &quot;E&quot;));
            List&lt;String&gt; unmodList = Collections.unmodifiableList(list);
            // 抛出：java.lang.UnsupportedOperationException
            unmodList.add(&quot;再加个试试！&quot;);
        &#125; catch (UnsupportedOperationException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;

// 输出内容
java.lang.UnsupportedOperationException
    at java.base/java.util.AbstractList.add(AbstractList.java:153)
    at java.base/java.util.AbstractList.add(AbstractList.java:111)
    at JavaAPIDemo.main(JavaAPIDemo.java:8)
X
java.lang.UnsupportedOperationException
    at java.base/java.util.AbstractList.add(AbstractList.java:153)
    at java.base/java.util.AbstractList.add(AbstractList.java:111)
    at JavaAPIDemo.main(JavaAPIDemo.java:18)
java.lang.UnsupportedOperationException
    at java.base/java.util.Collections$UnmodifiableCollection.add(Collections.java:1060)
    at JavaAPIDemo.main(JavaAPIDemo.java:29)
</code></pre>
<h2 id="5、其它常用方法"><a href="#5、其它常用方法" class="headerlink" title="5、其它常用方法"></a>5、其它常用方法</h2><pre><code class="java">public static &lt;T&gt; boolean addAll(Collection&lt;? super T&gt; c, T... elements); // 将所有指定元素添加(追加)到指定collection中
public static boolean disjoint(Collection&lt;?&gt; c1, Collection&lt;?&gt; c2); // 如果两个指定collection中没有相同的元素则返回true
public static &lt;T&gt; List&lt;T&gt; nCopies(int n, T o); // 返回大小为n的List，其中的所有引用都指向o，List是不可变得（与fill方法类似）
public static &lt;T&gt; Comparator&lt;T&gt; reverseOrder(); // 返回一个比较器，它强行反转指定比较器的顺序
</code></pre>
<p>操作示例：</p>
<pre><code class="java">import java.util.*;
public class JavaAPIDemo &#123;
    public static void main(String[] args) &#123;
        // 初始化集合List
        List&lt;String&gt; list = new ArrayList&lt;&gt;(List.of(&quot;你好&quot;));
        List&lt;String&gt; list1 = new ArrayList&lt;&gt;(List.of(&quot;list1&quot;));
        List&lt;String&gt; list2 = new ArrayList&lt;&gt;();

        // addAll增加变长参数
        Collections.addAll(list1, &quot;大家好&quot;, &quot;你好&quot;,&quot;我也好&quot;);
        Collections.addAll(list2, &quot;大家好&quot;, &quot;a李四&quot;,&quot;我也好&quot;);
        System.out.println(list1); // [list1, 大家好, 你好, 我也好]
        System.out.println(list2); // [大家好, a李四, 我也好]

        // disjoint检查两个Collection是否的交集
        boolean b1 = Collections.disjoint(list, list1);
        boolean b2 = Collections.disjoint(list, list2);
        System.out.println(b1 + &quot;\t&quot; + b2); // false	true

        // 生产大小为5，内容全为 中国 的不可变的List集合
        System.out.println(Collections.nCopies(5, &quot;中国&quot;)); // [中国, 中国, 中国, 中国, 中国]
        
        // 利用reverseOrder倒序
        Collections.sort(list1, Collections.reverseOrder());
        System.out.println(list1); // [我也好, 大家好, 你好, list1]
    &#125;
&#125;
</code></pre>
<p><strong>面试题：</strong>请解释Collection与Collections的区别？</p>
<ol>
<li>Collection 是集合接口，允许保存单值对象</li>
<li>Collections 是集合操作的工具类</li>
</ol>
<h2 id="6、参考文献-鸣谢"><a href="#6、参考文献-鸣谢" class="headerlink" title="6、参考文献 &amp; 鸣谢"></a>6、参考文献 &amp; 鸣谢</h2><ol>
<li>Java集合的详细研究：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/guweiwei/category/960786.html">https://www.cnblogs.com/guweiwei/category/960786.html</a></li>
<li>集合源码入门教程：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/chanshuyi/category/1366321.html">https://www.cnblogs.com/chanshuyi/category/1366321.html</a></li>
</ol>
<h1 id="Java-集合汇总篇"><a href="#Java-集合汇总篇" class="headerlink" title="Java 集合汇总篇"></a>Java 集合汇总篇</h1><h2 id="1、List接口与接口实现类"><a href="#1、List接口与接口实现类" class="headerlink" title="1、List接口与接口实现类"></a>1、List接口与接口实现类</h2><blockquote>
<p>有序、不唯一</p>
</blockquote>
<p>ArrayList：</p>
<ol>
<li>内部是通过数组实现的，允许对元素进行快速随机访问。</li>
<li>当数组大小不满足时需要增加存储能力，就要将已经有数组的数据复制到新的存储空间中。</li>
<li>适合随机查找和遍历，不适合插入和删除。当从 ArrayList 的中间位置插入或者删除元素时，需要对数组进行复制、移动、代价比较高。</li>
</ol>
<p>LinkedList：</p>
<ol>
<li>LinkedList 是用链表结构存储数据的。</li>
<li>很适合数据的动态插入和删除，随机访问和遍历速度比较慢。</li>
<li>有List 接口中没有定义的方法，专门用于操作表头和表尾元素，可以当作堆栈、队列和双向队列使用。</li>
</ol>
<p>Vector（线程安全）：</p>
<ul>
<li>通过数组实现的。</li>
<li>默认情况下 Vector 每次扩容时容量都会翻倍。</li>
<li>支持线程的同步，即某一时刻只有一个线程能够写 Vector，避免多线程同时写而引起的不一致性，但实现同步需要很高的花费，因此访问它比 ArrayList 慢</li>
</ul>
<p>CopyOnWriteArrayList：</p>
<ol>
<li>写操作在一个复制的数组上进行，读操作还是在原始数组中进行，读写分离，互不影响。</li>
<li>写操作需要加锁，防止并发写入时导致写入数据丢失。</li>
<li>写操作结束之后需要把原始数组指向新的复制数组。</li>
<li>在写操作的同时允许读操作，大大提高了读操作的性能，因此很适合读多写少的应用场景。</li>
<li>内存占用：在写操作时需要复制一个新的数组，使得内存占用为原来的两倍左右。</li>
<li>数据不一致：读操作不能读取实时性的数据，因为部分写操作的数据还未同步到读数组中。</li>
</ol>
<h2 id="2、Set接口与接口实现类"><a href="#2、Set接口与接口实现类" class="headerlink" title="2、Set接口与接口实现类"></a>2、Set接口与接口实现类</h2><blockquote>
<p>无序、不可重复</p>
</blockquote>
<p> HashSet：</p>
<ol>
<li>哈希表边存放的是哈希值。</li>
<li>HashSet这个类实现了Set集合，实际为一个HashMap的实例。</li>
<li>HashSet 存储元素的顺序并不是按照存入时的顺序。而是按照哈希值来存的所以取数据也是按照哈希值取得。元素的哈希值是通过元素的hashcode 方法来获取的, HashSet 首先判断两个元素的哈希值，如果哈希值一样（哈希冲突，也叫哈希碰撞），接着会比较equals 方法 如果 equls 结果为 true，HashSet 就视为同一个元素。如果 equals 为 false 就不是同一个元素。HashSet 通过 hashCode 值来确定元素在内存中的位置。 一个 hashCode 位置上可以存放多个元素。</li>
</ol>
<p>LinkedHashSet：</p>
<ol>
<li>能保证怎么存就怎么取的set集合对象。</li>
<li>LinkedHashSet是一个哈希表和链表的结合，且是一个双向链表。</li>
<li>LinkedHashSet 底层使用 LinkedHashMap 来保存所有元素。</li>
<li>继承与 HashSet，其所有的方法操作上又与 HashSet 相同。</li>
</ol>
<p>TreeSet：</p>
<ol>
<li>TreeSet是使用二叉树的原理对新添加的对象按照指定的顺序排序（升序、降序），每增加一个对象都会进行排序，将对象插入的二叉树指定的位置。</li>
<li>Integer 和 String 对象都可以进行默认的 TreeSet 排序，而自定义类的对象是不可以的， 自己定义的类必须实现 Comparable 接口，并且覆写相应的 compareTo()函数，才可以正常使用。</li>
<li>在覆写 compare()函数时，要返回相应的值才能使 TreeSet 按照一定的规则来排序。</li>
<li>比较此对象与指定对象的顺序。如果该对象小于、等于或大于指定对象，则分别返回负整数、零或正整数。</li>
</ol>
<h2 id="3、Map接口与接口实现类"><a href="#3、Map接口与接口实现类" class="headerlink" title="3、Map接口与接口实现类"></a>3、Map接口与接口实现类</h2><blockquote>
<p>不能包含重复的键、每个键最多只能映射到一个值</p>
</blockquote>
<p>LinkedHashMap：</p>
<ol>
<li>迭代顺序可以是插入顺序。</li>
<li>Key和Value都允许空，Key重复会覆盖、Value允许重复。</li>
<li>LinkedHashMap 是 HashMap 的一个子类，保存了记录的插入顺序，在用 Iterator 遍历。</li>
<li>LinkedHashMap 时，先得到的记录肯定是先插入的，也可以在构造时带参数，按照访问次序排序。</li>
</ol>
<p>HashMap：</p>
<ol>
<li>HashMap 根据键的 hashCode 值存储数据，大多数情况下可以直接定位到它的值，因而具有很快的访问速度，但遍历顺序却是不确定的。</li>
<li>HashMap 最多只允许一条记录的键为 null，允许多条记录的值为 null。</li>
<li>HashMap 非线程安全，即任一时刻可以有多个线程同时写 HashMap，可能会导致数据的不一致。</li>
<li>如果需要满足线程安全，可以用 Collections 的 synchronizedMap 方法使 HashMap 具有线程安全的能力，或者使用 ConcurrentHashMap。</li>
</ol>
<p>TreeMap：</p>
<ol>
<li>TreeMap 实现 SortedMap 接口，能够把它保存的记录根据键排序，默认是按键值的升序排序，也可以指定排序的比较器，当用 Iterator 遍历 TreeMap 时，得到的记录是排过序的。如果使用排序的映射，建议使用 TreeMap。</li>
<li>key 必须实现 Comparable 接口或者在构造 TreeMap 传入自定义的Comparator，否则会在运行时抛出 java.lang.ClassCastException 类型的异常。</li>
</ol>
<p>Hashtable（线程安全）：</p>
<ol>
<li>Hashtable 是遗留类，很多映射的常用功能与 HashMap 类似。</li>
<li>承自 Dictionary 类。</li>
<li>是线程安全的，任一时间只有一个线程能写 Hashtable。</li>
<li>并发性不如 ConcurrentHashMap，因为 ConcurrentHashMap 引入了分段锁。 Hashtable 不建议在新代码中使用，不需要线程安全的场合可以用 HashMap 替换，需要线程安全的场合可以用 ConcurrentHashMap 替换。</li>
</ol>
<p>ConcurrentHashMap 线程安全（Segment 继承 ReentrantLock 加锁）：</p>
<ol>
<li>ConcurrentHashMap 和 HashMap 思路是差不多的。</li>
<li>支持并发操作。</li>
<li>整个 ConcurrentHashMap 由一个个 Segment 组成， Segment 代表”部分“或”一段“的意思，所以很多地方都会将其描述为分段锁。注意，行文中，我很多地方用了“槽”来代表一个segment。</li>
</ol>
<h2 id="4、线程安全处理方法"><a href="#4、线程安全处理方法" class="headerlink" title="4、线程安全处理方法"></a>4、线程安全处理方法</h2><pre><code class="java">// Collections.synchronizedXxx()
List&lt;String&gt; list = new ArrayList&lt;&gt;();
List&lt;String&gt; synList = Collections.synchronizedList(list);

Map&lt;String,String&gt; map = new HashMap&lt;&gt;();
Map&lt;String,String&gt; synMap = Collections.synchronizedMap(map);

Set&lt;String&gt; set = new HashSet&lt;&gt;();
Set&lt;String&gt; synset = Collections.synchronizedSet(set);
</code></pre>
<h2 id="5、ArrayList、LinkedList和Vector的区别"><a href="#5、ArrayList、LinkedList和Vector的区别" class="headerlink" title="5、ArrayList、LinkedList和Vector的区别"></a>5、ArrayList、LinkedList和Vector的区别</h2><ul>
<li><p>ArrayList: 可以看作是能够自动增长容量的数组。</p>
</li>
<li><p>ArrayList底层的实现是Array, 数组扩容实现。</p>
</li>
<li><p>ArrayList根据下标查询快，但是根据值查数据速度和LinkList一样。</p>
</li>
<li><p>ArrayList线程不安全，效率高。</p>
</li>
<li><p>LinkList是一个双链表,在添加和删除元素时具有比ArrayList更好的性能。</p>
</li>
<li><p>LinkList线程不安全，效率高。</p>
</li>
<li><p>LinkList是一个双链表,在添加和删除元素时具有比ArrayList更好的性能。</p>
</li>
<li><p>LinkList线程不安全，效率高。</p>
</li>
</ul>
<h2 id="6、HashMap和HashTable的区别"><a href="#6、HashMap和HashTable的区别" class="headerlink" title="6、HashMap和HashTable的区别"></a>6、HashMap和HashTable的区别</h2><ol>
<li><p>HashMap是线程不安全的，所以效率远远高于Hashtable，当需要多线程操作的时候可以使用线程安全的ConcurrentHashMap，ConcurrentHashMap虽然也是线程安全的，但是它的效率比Hashtable要高好多倍。因为ConcurrentHashMap使用了分段锁，并不对整个数据进行锁定。</p>
</li>
<li><p>HashMap：key可以为null，但是这样的key只能有一个，因为必须保证key的唯一性可以有多个key值对应的value为null。</p>
</li>
<li><p>Hashtable是线程安全的，它的每个方法上都有synchronized 关键字。</p>
</li>
<li><p>Hashtable：key和value都不能为null。</p>
</li>
</ol>
<h2 id="7、HashMap和HashTable的区别"><a href="#7、HashMap和HashTable的区别" class="headerlink" title="7、HashMap和HashTable的区别"></a>7、HashMap和HashTable的区别</h2><ul>
<li>List：有序、不唯一。</li>
<li>Set ：无序、唯一。</li>
<li>Map：不能包含重复的键、每个键最多只能映射到一个值、元素存储循序是无序的、以键值对存储数据。</li>
</ul>

      
       <hr><span style="font-style: italic;color: gray;"> 转载请注明来源，欢迎对文章中的引用来源进行考证，欢迎指出任何有错误或不够清晰的表达。可以在下面评论区评论，也可以邮件至 8629303@qq.com </span>
    </div>
</article>


<p>
    <a  class="dashang" onclick="dashangToggle()">赏</a>
</p>






    




    </div>
    <div class="copyright">
        <p class="footer-entry">
    ©2017-2024 Sam
</p>
<p class="footer-entry">Built with <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/yelog/hexo-theme-3-hexo" target="_blank">3-hexo</a> theme</p>

    </div>
    <div class="full-toc">
        <button class="full" data-title="切换全屏 快捷键 s"><span class="min "></span></button>
<a class="" id="rocket" ></a>

    </div>
</div>

<div class="hide_box" onclick="dashangToggle()"></div>
<div class="shang_box">
    <a class="shang_close"  onclick="dashangToggle()">×</a>
    <div class="shang_tit">
        <p>喜欢就点赞,疼爱就打赏</p>
    </div>
    <div class="shang_payimg">
        <div class="pay_img">
            <img src="/img/alipay.jpg" class="alipay" title="扫码支持">
            <img src="/img/weixin.jpg" class="weixin" title="扫码支持">
        </div>
    </div>
    <div class="shang_payselect">
        <span><label><input type="radio" name="pay" checked value="alipay">支付宝</label></span><span><label><input type="radio" name="pay" value="weixin">微信</label></span>
    </div>
</div>


</body>
<script src="/js/jquery.pjax.js?v=1.1.0" ></script>

<script src="/js/script.js?v=1.1.0" ></script>
<script>
    var img_resize = 'default';
    function initArticle() {
        /*渲染对应的表格样式*/
        
            $("#post .pjax table").addClass("green_title");
        

        /*渲染打赏样式*/
        
        $("input[name=pay]").on("click", function () {
            if($("input[name=pay]:checked").val()=="weixin"){
                $(".shang_box .shang_payimg .pay_img").addClass("weixin_img");
            } else {
                $(".shang_box .shang_payimg .pay_img").removeClass("weixin_img");
            }
        })
        

        /*高亮代码块行号*/
        
        $('pre code').each(function(){
            var lines = $(this).text().trim().split('\n').length, widther='';
            if (lines>99) {
                widther = 'widther'
            }
            var $numbering = $('<ul/>').addClass('pre-numbering ' + widther).attr("unselectable","on");
            $(this).addClass('has-numbering ' + widther)
                    .parent()
                    .append($numbering);
            for(var i=1;i<=lines;i++){
                $numbering.append($('<li/>').text(i));
            }
        });
        

        /*访问数量*/
        
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js");
        

        /*代码高亮，行号对齐*/
        $('.pre-numbering').css('line-height',$('.has-numbering').css('line-height'));

        
        
    }

    /*打赏页面隐藏与展示*/
    
    function dashangToggle() {
        $(".shang_box").fadeToggle();
        $(".hide_box").fadeToggle();
    }
    

</script>

<!--加入行号的高亮代码块样式-->

<style>
    pre{
        position: relative;
        margin-bottom: 24px;
        border-radius: 10px;
        border: 1px solid #e2dede;
        background: #FFF;
        overflow: hidden;
    }
    code.has-numbering{
        margin-left: 30px;
    }
    code.has-numbering.widther{
        margin-left: 35px;
    }
    .pre-numbering{
        margin: 0;
        position: absolute;
        top: 0;
        left: 0;
        width: 20px;
        padding: 18px 3px 15px 5px;
        border-right: 1px solid #C3CCD0;
        text-align: right;
        color: #AAA;
        background-color: #fafafa;
    }
    .pre-numbering.widther {
        width: 35px;
    }
</style>

<!--自定义样式设置-->
<style>
    
    
    .nav {
        width: 582px;
    }
    .nav.fullscreen {
        margin-left: -582px;
    }
    .nav-left {
        width: 160px;
    }
    
    
    @media screen and (max-width: 1468px) {
        .nav {
            width: 492px;
        }
        .nav.fullscreen {
            margin-left: -492px;
        }
        .nav-left {
            width: 100px;
        }
    }
    
    
    @media screen and (max-width: 1024px) {
        .nav {
            width: 492px;
            margin-left: -492px
        }
        .nav.fullscreen {
            margin-left: 0;
        }
    }
    
    @media screen and (max-width: 426px) {
        .nav {
            width: 100%;
        }
        .nav-left {
            width: 100%;
        }
    }
    
    
    .nav-right .title-list nav a .post-title, .nav-right .title-list #local-search-result a .post-title {
        color: #383636;
    }
    
    
    .nav-right .title-list nav a .post-date, .nav-right .title-list #local-search-result a .post-date {
        color: #5e5e5f;
    }
    
    
    .nav-right nav a.hover, #local-search-result a.hover{
        background-color: #e2e0e0;
    }
    
    

    /*列表样式*/
    

    /* 背景图样式 */
    
    


    /*引用块样式*/
    

    /*文章列表背景图*/
    

    
</style>







</html>
