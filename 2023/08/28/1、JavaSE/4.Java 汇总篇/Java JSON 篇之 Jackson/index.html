<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Java JSON 篇之 Jackson | Hexo</title>
  <meta name="keywords" content="">
  <meta name="description" content="Java JSON 篇之 Jackson | Hexo">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="description" content="请不要自己写，Spring Boot非常实用的内置功能：https:&#x2F;&#x2F;juejin.cn&#x2F;post&#x2F;7417630844100231206  在 SpringBoot 框架中，内置了许多实用的功能，这些功能可以帮助开发者高效地开发和维护应用程序。 一、请求数据记录器SpringBoot 提供了一个内置的日志记录解决方案，通过 AbstractRequestLoggingFilter 可以记录请">
<meta property="og:type" content="article">
<meta property="og:title" content="SpringBoot2.x 内置功能 - 内置过滤器和 AOP 工具类">
<meta property="og:url" content="https://8629303.github.io/2024/10/08/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot2.x%20%E5%86%85%E7%BD%AE%E5%8A%9F%E8%83%BD%20-%20%E5%86%85%E7%BD%AE%E8%BF%87%E6%BB%A4%E5%99%A8%E5%92%8C%20AOP%20%E5%B7%A5%E5%85%B7%E7%B1%BB/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="请不要自己写，Spring Boot非常实用的内置功能：https:&#x2F;&#x2F;juejin.cn&#x2F;post&#x2F;7417630844100231206  在 SpringBoot 框架中，内置了许多实用的功能，这些功能可以帮助开发者高效地开发和维护应用程序。 一、请求数据记录器SpringBoot 提供了一个内置的日志记录解决方案，通过 AbstractRequestLoggingFilter 可以记录请">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2024-10-08T08:44:19.743Z">
<meta property="article:modified_time" content="2024-10-20T16:34:49.614Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">


<link rel="icon" href="/img/avatar.jpg">

<link href="/css/style.css?v=1.1.0" rel="stylesheet">

<link href="/css/hl_theme/atom-light.css?v=1.1.0" rel="stylesheet">

<link href="//cdn.jsdelivr.net/npm/animate.css@4.1.0/animate.min.css" rel="stylesheet">

<script src="//cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
<script src="/js/titleTip.js?v=1.1.0" ></script>

<script src="//cdn.jsdelivr.net/npm/highlightjs@9.16.2/highlight.pack.min.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>

<script src="//cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script>



<script src="//cdn.jsdelivr.net/npm/jquery.cookie@1.4.1/jquery.cookie.min.js" ></script>

<script src="/js/iconfont.js?v=1.1.0" ></script>

<meta name="generator" content="Hexo 7.3.0"></head>
<div style="display: none">
  <input class="theme_disqus_on" value="false">
  <input class="theme_preload_comment" value="">
  <input class="theme_blog_path" value="">
  <input id="theme_shortcut" value="true" />
  <input id="theme_highlight_on" value="true" />
  <input id="theme_code_copy" value="true" />
</div>



<body>
<aside class="nav">
    <div class="nav-left">
        <a href="/"
   class="avatar_target">
    <img class="avatar"
         src="/img/avatar.jpg"/>
</a>
<div class="author">
    <span>John Doe</span>
</div>

<div class="icon">
    
        
            <a title="github"
               href="https://github.com/8629303"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-github"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="email"
               href="mailto:8629303@qq.com"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-email"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="qq"
               href="http://wpa.qq.com/msgrd?v=3&uin=8629303&site=qq&menu=yes"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-qq"></use>
                    </svg>
                
            </a>
        
    
</div>





<ul>
    <li>
        <div class="all active" data-rel="全部文章">全部文章
            
                <small>(172)</small>
            
        </div>
    </li>
    
        
            
                
    <li>
        <div data-rel="数据库">
            
            数据库
            <small>(5)</small>
        </div>
        
    </li>

            
        
    
        
            
        
    
        
            
        
    
        
            
                
    <li>
        <div data-rel="开发工具">
            <i class="fold iconfont icon-right"></i>
            开发工具
            <small>(16)</small>
        </div>
        
            <ul class="sub hide">
                
                    
    <li>
        <div data-rel="开发工具&lt;---&gt;Maven">
            
            Maven
            <small>(8)</small>
        </div>
        
    </li>

                
            </ul>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="面试篇">
            
            面试篇
            <small>(1)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="微服务开发">
            <i class="fold iconfont icon-right"></i>
            微服务开发
            <small>(61)</small>
        </div>
        
            <ul class="sub hide">
                
                    
    <li>
        <div data-rel="微服务开发&lt;---&gt;Shiro">
            
            Shiro
            <small>(2)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="微服务开发&lt;---&gt;Spring">
            
            Spring
            <small>(3)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="微服务开发&lt;---&gt;SpringBoot">
            
            SpringBoot
            <small>(44)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="微服务开发&lt;---&gt;SpringCloudAlibaba">
            
            SpringCloudAlibaba
            <small>(1)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="微服务开发&lt;---&gt;SpringDataJPA">
            
            SpringDataJPA
            <small>(4)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="微服务开发&lt;---&gt;SpringMVC">
            
            SpringMVC
            <small>(1)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="微服务开发&lt;---&gt;SpringSecurity">
            
            SpringSecurity
            <small>(1)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="微服务开发&lt;---&gt;SpringTransaction">
            
            SpringTransaction
            <small>(5)</small>
        </div>
        
    </li>

                
            </ul>
        
    </li>

            
        
    
        
            
        
    
        
            
                
    <li>
        <div data-rel="中间件">
            <i class="fold iconfont icon-right"></i>
            中间件
            <small>(8)</small>
        </div>
        
            <ul class="sub hide">
                
                    
    <li>
        <div data-rel="中间件&lt;---&gt;ElasticSearch">
            
            ElasticSearch
            <small>(1)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="中间件&lt;---&gt;MongoDB">
            
            MongoDB
            <small>(2)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="中间件&lt;---&gt;RabbitMQ">
            
            RabbitMQ
            <small>(3)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="中间件&lt;---&gt;Redis">
            
            Redis
            <small>(2)</small>
        </div>
        
    </li>

                
            </ul>
        
    </li>

            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
                
    <li>
        <div data-rel="Java基础篇">
            <i class="fold iconfont icon-right"></i>
            Java基础篇
            <small>(8)</small>
        </div>
        
            <ul class="sub hide">
                
                    
    <li>
        <div data-rel="Java基础篇&lt;---&gt;Java常用类库">
            
            Java常用类库
            <small>(1)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="Java基础篇&lt;---&gt;Java多线程">
            
            Java多线程
            <small>(2)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="Java基础篇&lt;---&gt;Java反射与注解">
            
            Java反射与注解
            <small>(1)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="Java基础篇&lt;---&gt;Java基础语法">
            
            Java基础语法
            <small>(1)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="Java基础篇&lt;---&gt;Java集合类">
            
            Java集合类
            <small>(1)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="Java基础篇&lt;---&gt;JavaIO流">
            
            JavaIO流
            <small>(1)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="Java基础篇&lt;---&gt;JavaNIO流">
            
            JavaNIO流
            <small>(1)</small>
        </div>
        
    </li>

                
            </ul>
        
    </li>

            
        
    
        
            
        
    
        
            
        
    
        
            
                
    <li>
        <div data-rel="Java进阶篇">
            <i class="fold iconfont icon-right"></i>
            Java进阶篇
            <small>(4)</small>
        </div>
        
            <ul class="sub hide">
                
                    
    <li>
        <div data-rel="Java进阶篇&lt;---&gt;Java设计模式">
            
            Java设计模式
            <small>(1)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="Java进阶篇&lt;---&gt;JVM虚拟机">
            
            JVM虚拟机
            <small>(3)</small>
        </div>
        
    </li>

                
            </ul>
        
    </li>

            
        
    
        
            
        
    
        
            
        
    
        
            
                
    <li>
        <div data-rel="Java新特性">
            <i class="fold iconfont icon-right"></i>
            Java新特性
            <small>(16)</small>
        </div>
        
            <ul class="sub hide">
                
                    
    <li>
        <div data-rel="Java新特性&lt;---&gt;Java10新特性">
            
            Java10新特性
            <small>(1)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="Java新特性&lt;---&gt;Java11新特性">
            
            Java11新特性
            <small>(1)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="Java新特性&lt;---&gt;Java12新特性">
            
            Java12新特性
            <small>(1)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="Java新特性&lt;---&gt;Java13新特性">
            
            Java13新特性
            <small>(1)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="Java新特性&lt;---&gt;Java14新特性">
            
            Java14新特性
            <small>(1)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="Java新特性&lt;---&gt;Java15新特性">
            
            Java15新特性
            <small>(1)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="Java新特性&lt;---&gt;Java16新特性">
            
            Java16新特性
            <small>(1)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="Java新特性&lt;---&gt;Java17新特性">
            
            Java17新特性
            <small>(1)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="Java新特性&lt;---&gt;Java18新特性">
            
            Java18新特性
            <small>(1)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="Java新特性&lt;---&gt;Java19新特性">
            
            Java19新特性
            <small>(1)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="Java新特性&lt;---&gt;Java20新特性">
            
            Java20新特性
            <small>(1)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="Java新特性&lt;---&gt;Java8新特性">
            
            Java8新特性
            <small>(4)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="Java新特性&lt;---&gt;Java9新特性">
            
            Java9新特性
            <small>(1)</small>
        </div>
        
    </li>

                
            </ul>
        
    </li>

            
        
    
        
            
        
    
        
            
                
    <li>
        <div data-rel="JavaEE">
            <i class="fold iconfont icon-right"></i>
            JavaEE
            <small>(6)</small>
        </div>
        
            <ul class="sub hide">
                
                    
    <li>
        <div data-rel="JavaEE&lt;---&gt;JavaWeb">
            
            JavaWeb
            <small>(2)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="JavaEE&lt;---&gt;SSM框架">
            
            SSM框架
            <small>(4)</small>
        </div>
        
    </li>

                
            </ul>
        
    </li>

            
        
    
        
            
        
    
        
            
        
    
        
            
                
    <li>
        <div data-rel="JavaSE">
            <i class="fold iconfont icon-right"></i>
            JavaSE
            <small>(34)</small>
        </div>
        
            <ul class="sub hide">
                
                    
    <li>
        <div data-rel="JavaSE&lt;---&gt;Java汇总篇">
            
            Java汇总篇
            <small>(28)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="JavaSE&lt;---&gt;Java新特性">
            
            Java新特性
            <small>(1)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="JavaSE&lt;---&gt;Java性能测试与安全">
            
            Java性能测试与安全
            <small>(5)</small>
        </div>
        
    </li>

                
            </ul>
        
    </li>

            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
                
    <li>
        <div data-rel="Linux">
            <i class="fold iconfont icon-right"></i>
            Linux
            <small>(7)</small>
        </div>
        
            <ul class="sub hide">
                
                    
    <li>
        <div data-rel="Linux&lt;---&gt;虚拟机工具">
            
            虚拟机工具
            <small>(2)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="Linux&lt;---&gt;Docker">
            
            Docker
            <small>(2)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="Linux&lt;---&gt;Kubernetes">
            
            Kubernetes
            <small>(2)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="Linux&lt;---&gt;Nginx">
            
            Nginx
            <small>(1)</small>
        </div>
        
    </li>

                
            </ul>
        
    </li>

            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
                
    <li>
        <div data-rel="Redis">
            <i class="fold iconfont icon-right"></i>
            Redis
            <small>(1)</small>
        </div>
        
            <ul class="sub hide">
                
                    
    <li>
        <div data-rel="Redis&lt;---&gt;backup">
            
            backup
            <small>(1)</small>
        </div>
        
    </li>

                
            </ul>
        
    </li>

            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
                
    <li>
        <div data-rel="SpringTransaction">
            <i class="fold iconfont icon-right"></i>
            SpringTransaction
            <small>(5)</small>
        </div>
        
            <ul class="sub hide">
                
                    
    <li>
        <div data-rel="SpringTransaction&lt;---&gt;多数据源事务处理">
            
            多数据源事务处理
            <small>(3)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="SpringTransaction&lt;---&gt;多线程下事务处理">
            
            多线程下事务处理
            <small>(2)</small>
        </div>
        
    </li>

                
            </ul>
        
    </li>

            
        
    
        
            
        
    
        
            
        
    
</ul>
<div class="left-bottom">
    <div class="menus">
        
            
            
            
    </div>
    <div>
        
            <a class="about  hasFriend  site_url"
               
               href="/about">关于</a>
        
        <a style="width: 50%"
                
                                           class="friends">友链</a>
        
    </div>
</div>
<input type="hidden" id="yelog_site_posts_number" value="172">

<div style="display: none">
    <span id="busuanzi_value_site_uv"></span>
    <span id="busuanzi_value_site_pv"></span>
</div>

    </div>
    <div class="nav-right">
        <div class="friends-area">
    <div class="friends-title">
        友情链接
        <i class="iconfont icon-left"></i>
    </div>
    <div class="friends-content">
        <ul>
            
            <li><a target="_blank" href="http://yelog.org/">叶落阁</a></li>
            
        </ul>
    </div>
</div>
        <div class="title-list">
    <div class="right-top">
        <div id="default-panel">
            <i class="iconfont icon-search" data-title="搜索 快捷键 i"></i>
            <div class="right-title">全部文章</div>
            <i class="iconfont icon-file-tree" data-title="切换到大纲视图 快捷键 w"></i>
        </div>
        <div id="search-panel">
            <i class="iconfont icon-left" data-title="返回"></i>
            <input id="local-search-input" autocomplete="off"/>
            <label class="border-line" for="input"></label>
            <i class="iconfont icon-case-sensitive" data-title="大小写敏感"></i>
            <i class="iconfont icon-tag" data-title="标签"></i>
        </div>
        <div id="outline-panel" style="display: none">
            <div class="right-title">大纲</div>
            <i class="iconfont icon-list" data-title="切换到文章列表"></i>
        </div>
    </div>

    <div class="tags-list">
    <input id="tag-search" />
    <div class="tag-wrapper">
        
    </div>

</div>

    
    <nav id="title-list-nav">
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/blog/2024/10/08/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot2.x%20%E5%86%85%E7%BD%AE%E5%8A%9F%E8%83%BD%20-%20%E5%86%85%E7%BD%AE%E8%BF%87%E6%BB%A4%E5%99%A8%E5%92%8C%20AOP%20%E5%B7%A5%E5%85%B7%E7%B1%BB/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot2.x 内置功能 - 内置过滤器和 AOP 工具类">SpringBoot2.x 内置功能 - 内置过滤器和 AOP 工具类</span>
            <span class="post-date" title="2024-10-08 16:44:19">2024/10/08</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/blog/2024/10/08/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%E7%B3%BB%E5%88%97-%E5%85%A8%E7%BD%91%E6%9C%80%E5%85%A8%E7%9A%84%E7%89%88%E6%9C%AC%E5%8F%98%E6%9B%B4%E5%8F%B2/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot系列-全网最全的版本变更史">SpringBoot系列-全网最全的版本变更史</span>
            <span class="post-date" title="2024-10-08 16:38:53">2024/10/08</span>
        </a>
        
        
        <a  class="全部文章 开发工具 Maven "
           href="/blog/2024/10/08/6%E3%80%81%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Maven/Maven%20%E6%95%99%E7%A8%8B%E4%B9%8B%20%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE%20&%20%E9%B8%A3%E8%B0%A2/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Maven 教程之 参考文献 &amp; 鸣谢">Maven 教程之 参考文献 &amp; 鸣谢</span>
            <span class="post-date" title="2024-10-08 15:50:47">2024/10/08</span>
        </a>
        
        
        <a  class="全部文章 开发工具 "
           href="/blog/2024/10/07/6%E3%80%81%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/GitHub%20%E5%AE%9E%E6%88%98%E6%8A%80%E5%B7%A7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="GitHub 实战技巧">GitHub 实战技巧</span>
            <span class="post-date" title="2024-10-07 15:55:34">2024/10/07</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/blog/2024/10/07/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot2.x%20%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AF%87%20-%20%E9%9B%86%E6%88%90%20HirakiCP%20%E4%B8%8E%20Druid%20%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot2.x 数据库篇 - 集成 HirakiCP 与 Druid 数据库连接池">SpringBoot2.x 数据库篇 - 集成 HirakiCP 与 Druid 数据库连接池</span>
            <span class="post-date" title="2024-10-07 14:19:43">2024/10/07</span>
        </a>
        
        
        <a  class="全部文章 开发工具 "
           href="/blog/2024/09/30/6%E3%80%81%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/MacOS%20%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%8F%8A%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E5%8D%B8%E8%BD%BD/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="MacOS 开发环境搭建及软件安装卸载">MacOS 开发环境搭建及软件安装卸载</span>
            <span class="post-date" title="2024-09-30 23:56:52">2024/09/30</span>
        </a>
        
        
        <a  class="全部文章 开发工具 Maven "
           href="/blog/2024/09/30/6%E3%80%81%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Maven/Maven%20%E6%95%99%E7%A8%8B%E4%B9%8B%20JDK%20%E7%89%88%E6%9C%AC%E9%BB%98%E8%AE%A4%E8%AE%BE%E7%BD%AE%20/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Maven 教程之 JDK 版本默认设置">Maven 教程之 JDK 版本默认设置</span>
            <span class="post-date" title="2024-09-30 16:37:08">2024/09/30</span>
        </a>
        
        
        <a  class="全部文章 开发工具 Maven "
           href="/blog/2024/09/26/6%E3%80%81%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Maven/Maven%20%E6%95%99%E7%A8%8B%E4%B9%8B%20profiles%20%E5%A4%9A%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Maven 教程之 profiles 多环境配置">Maven 教程之 profiles 多环境配置</span>
            <span class="post-date" title="2024-09-26 17:40:34">2024/09/26</span>
        </a>
        
        
        <a  class="全部文章 开发工具 Maven "
           href="/blog/2024/09/25/6%E3%80%81%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Maven/Maven%20%E6%95%99%E7%A8%8B%E4%B9%8B%20plugin%20%E8%AF%A6%E8%A7%A3/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Maven 教程之 plugin 详解">Maven 教程之 plugin 详解</span>
            <span class="post-date" title="2024-09-25 11:32:44">2024/09/25</span>
        </a>
        
        
        <a  class="全部文章 开发工具 Maven "
           href="/blog/2024/09/21/6%E3%80%81%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Maven/Maven%20%E6%95%99%E7%A8%8B%E4%B9%8B%20pom.xml%20%E8%AF%A6%E8%A7%A3/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Maven 教程之 pom.xml 详解">Maven 教程之 pom.xml 详解</span>
            <span class="post-date" title="2024-09-21 16:14:13">2024/09/21</span>
        </a>
        
        
        <a  class="全部文章 开发工具 Maven "
           href="/blog/2024/09/21/6%E3%80%81%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Maven/Maven%20%E6%95%99%E7%A8%8B%E4%B9%8B%20settings.xml%20%E8%AF%A6%E8%A7%A3/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Maven 教程之 settings.xml 详解">Maven 教程之 settings.xml 详解</span>
            <span class="post-date" title="2024-09-21 16:14:09">2024/09/21</span>
        </a>
        
        
        <a  class="全部文章 面试篇 "
           href="/blog/2024/08/27/0%E3%80%81%E9%9D%A2%E8%AF%95%E7%AF%87/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8%E6%B1%87%E6%80%BB/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="面试宝典汇总">面试宝典汇总</span>
            <span class="post-date" title="2024-08-27 16:20:25">2024/08/27</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/blog/2024/08/26/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E8%87%AA%E5%AE%9A%E4%B9%89%E9%9B%86%E5%90%88%E5%B8%B8%E9%87%8F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 自定义集合常量">Java 自定义集合常量</span>
            <span class="post-date" title="2024-08-26 12:11:54">2024/08/26</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringMVC "
           href="/blog/2024/08/26/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20MVC/SpringMVC%E4%B9%8B@InitBinder%E6%B3%A8%E8%A7%A3%EF%BC%88%E6%97%A5%E6%9C%9F%E8%BD%AC%E6%8D%A2%EF%BC%89/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringMVC之@InitBinder注解（日期转换）">SpringMVC之@InitBinder注解（日期转换）</span>
            <span class="post-date" title="2024-08-26 11:10:28">2024/08/26</span>
        </a>
        
        
        <a  class="全部文章 SpringTransaction 多线程下事务处理 "
           href="/blog/2024/08/21/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Transaction/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8B%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/Java%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BA%8B%E5%8A%A1%E6%8F%90%E4%BA%A4%E7%9A%84%E5%A4%84%E7%90%86/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 多线程事务提交的处理">Java 多线程事务提交的处理</span>
            <span class="post-date" title="2024-08-21 16:32:52">2024/08/21</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/blog/2024/08/20/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%20Cache%20%E6%95%B4%E5%90%88%20Redis%20%E7%BC%93%E5%AD%98%E6%A1%86%E6%9E%B6/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot Cache 整合 Redis 缓存框架">SpringBoot Cache 整合 Redis 缓存框架</span>
            <span class="post-date" title="2024-08-20 16:11:47">2024/08/20</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringTransaction "
           href="/blog/2024/08/16/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Transaction/Spring%20%E4%BA%8B%E5%8A%A1%E5%BA%94%E7%94%A8%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Spring 事务应用及源码分析">Spring 事务应用及源码分析</span>
            <span class="post-date" title="2024-08-16 10:33:57">2024/08/16</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringTransaction "
           href="/blog/2024/08/16/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Transaction/Spring%20JDBC%20-%20NamedParameterJdbcTemplate/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Spring JDBC - NamedParameterJdbcTemplate">Spring JDBC - NamedParameterJdbcTemplate</span>
            <span class="post-date" title="2024-08-16 00:18:18">2024/08/16</span>
        </a>
        
        
        <a  class="全部文章 开发工具 "
           href="/blog/2024/07/18/6%E3%80%81%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Git%20&%20GitHub/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Git &amp; GitHub">Git &amp; GitHub</span>
            <span class="post-date" title="2024-07-18 10:34:58">2024/07/18</span>
        </a>
        
        
        <a  class="全部文章 开发工具 Maven "
           href="/blog/2024/06/28/6%E3%80%81%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Maven/Maven%20%E5%AE%9E%E6%88%98/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Maven 实战">Maven 实战</span>
            <span class="post-date" title="2024-06-28 16:50:35">2024/06/28</span>
        </a>
        
        
        <a  class="全部文章 数据库 "
           href="/blog/2024/06/26/3%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%9D%A2%E8%AF%95%E5%AE%98%EF%BC%9A%E4%B8%8D%E4%BC%9A%E7%9C%8B%20Explain%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%EF%BC%8C%E7%AE%80%E5%8E%86%E6%95%A2%E5%86%99%20SQL%20%E4%BC%98%E5%8C%96%EF%BC%9F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="面试官：不会看 Explain执行计划，简历敢写 SQL 优化？">面试官：不会看 Explain执行计划，简历敢写 SQL 优化？</span>
            <span class="post-date" title="2024-06-26 19:33:03">2024/06/26</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/blog/2024/04/22/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%AF%87%E4%B9%8B%20IDEA%20-%20VM%20Options%E3%80%81Program%20Arguments%E3%80%81Environment%20Variable%20%E8%A7%A3%E6%9E%90/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 命令行篇之 IDEA - VM Options、Program Arguments、Environment Variable 解析">Java 命令行篇之 IDEA - VM Options、Program Arguments、Environment Variable 解析</span>
            <span class="post-date" title="2024-04-22 10:53:10">2024/04/22</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/blog/2024/04/19/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6-%E9%85%8D%E7%BD%AE%E5%A4%96%E9%83%A8%E5%8C%96/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 配置文件-配置外部化">SpringBoot 2.x 配置文件-配置外部化</span>
            <span class="post-date" title="2024-04-19 09:18:55">2024/04/19</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/blog/2024/04/16/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E5%8E%9F%E7%90%86%E7%AF%87%E4%B9%8B%20SPI%20%E6%9C%BA%E5%88%B6/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 原理篇之 SPI 机制">Java 原理篇之 SPI 机制</span>
            <span class="post-date" title="2024-04-16 17:26:15">2024/04/16</span>
        </a>
        
        
        <a  class="全部文章 开发工具 Maven "
           href="/blog/2024/01/14/6%E3%80%81%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Maven/Maven%20%E6%95%99%E7%A8%8B%E4%B9%8B%20mirror%20&%20repository%20%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Maven 教程之 mirror &amp; repository 配置详解">Maven 教程之 mirror &amp; repository 配置详解</span>
            <span class="post-date" title="2024-01-14 22:51:03">2024/01/14</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/blog/2023/12/07/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E4%B8%BA%E4%BB%80%E4%B9%88SpringBoot%20jar%20%E5%8F%AF%E4%BB%A5%E7%9B%B4%E6%8E%A5%E8%BF%90%E8%A1%8C/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 为什么SpringBoot jar 可以直接运行">SpringBoot 2.x 为什么SpringBoot jar 可以直接运行</span>
            <span class="post-date" title="2023-12-07 15:13:56">2023/12/07</span>
        </a>
        
        
        <a  class="全部文章 Java基础篇 Java多线程 "
           href="/blog/2023/12/04/1%E3%80%81JavaSE/1.Java%20%E5%9F%BA%E7%A1%80%E7%AF%87/5%E3%80%81Java%20%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%BF%9B%E9%98%B6/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 多线程进阶">Java 多线程进阶</span>
            <span class="post-date" title="2023-12-04 16:37:09">2023/12/04</span>
        </a>
        
        
        <a  class="全部文章 数据库 "
           href="/blog/2023/11/18/3%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BB%BA%E6%A8%A1%E5%B7%A5%E5%85%B7%E6%B1%87%E6%80%BB/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="数据库建模工具汇总">数据库建模工具汇总</span>
            <span class="post-date" title="2023-11-18 15:31:11">2023/11/18</span>
        </a>
        
        
        <a  class="全部文章 JavaEE SSM框架 "
           href="/blog/2023/10/08/2%E3%80%81JavaEE/2%E3%80%81SSM%E6%A1%86%E6%9E%B6/Mybatis/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Mybatis">Mybatis</span>
            <span class="post-date" title="2023-10-08 19:45:47">2023/10/08</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java性能测试与安全 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/5.Java%20%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E4%B8%8E%E5%AE%89%E5%85%A8/Java%20%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E7%AF%87%E4%B9%8B%20%E5%8E%8B%E6%B5%8B%E5%B7%A5%E5%85%B7%E6%B1%87%E6%80%BB/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 性能测试篇之 压测工具汇总">Java 性能测试篇之 压测工具汇总</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java性能测试与安全 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/5.Java%20%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E4%B8%8E%E5%AE%89%E5%85%A8/Java%20%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E7%AF%87%E4%B9%8B%20%E9%AB%98%E5%B9%B6%E5%8F%91%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87%EF%BC%9AQPS%E3%80%81TPS%E3%80%81RT%E3%80%81%E5%B9%B6%E5%8F%91%E6%95%B0%E3%80%81%E5%90%9E%E5%90%90%E9%87%8F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 性能测试篇之 高并发性能指标：QPS、TPS、RT、并发数、吞吐量">Java 性能测试篇之 高并发性能指标：QPS、TPS、RT、并发数、吞吐量</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java性能测试与安全 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/5.Java%20%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E4%B8%8E%E5%AE%89%E5%85%A8/Java%20%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E7%AF%87%E4%B9%8B%20JMH%20%E5%B7%A5%E5%85%B7%E7%B1%BB/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 性能测试篇之 JMH 工具类">Java 性能测试篇之 JMH 工具类</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java性能测试与安全 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/5.Java%20%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E4%B8%8E%E5%AE%89%E5%85%A8/Java%20%E5%AE%89%E5%85%A8%E7%AF%87%E4%B9%8B%20API%20%E6%8E%A5%E5%8F%A3%E9%98%B2%E6%AD%A2%E5%8F%82%E6%95%B0%E7%AF%A1%E6%94%B9%E5%92%8C%E9%87%8D%E6%94%BE%E6%94%BB%E5%87%BB/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 安全篇之 API 接口防止参数篡改和重放攻击">Java 安全篇之 API 接口防止参数篡改和重放攻击</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java性能测试与安全 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/5.Java%20%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E4%B8%8E%E5%AE%89%E5%85%A8/Java%20%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E7%AF%87%E4%B9%8B%2048%E5%BC%A0%E5%9B%BE%E5%AD%A6%E4%BC%9A%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E3%80%81%E5%8E%8B%E6%B5%8B%E5%92%8C%E8%B0%83%E4%BC%98/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 性能测试篇之 48张图学会性能监控、压测和调优">Java 性能测试篇之 48张图学会性能监控、压测和调优</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 开发工具 "
           href="/blog/2023/08/28/6%E3%80%81%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/IDEA%20%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="IDEA 基本使用">IDEA 基本使用</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 开发工具 "
           href="/blog/2023/08/28/6%E3%80%81%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/IDEA%20%E5%BF%AB%E6%8D%B7%E9%94%AE/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="IDEA 快捷键">IDEA 快捷键</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 开发工具 "
           href="/blog/2023/08/28/6%E3%80%81%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/IDEA%20%E6%8F%92%E4%BB%B6%E5%AE%89%E8%A3%85/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="IDEA 插件安装">IDEA 插件安装</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 开发工具 "
           href="/blog/2023/08/28/6%E3%80%81%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/PostMan%20%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="PostMan 工具的使用">PostMan 工具的使用</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 开发工具 "
           href="/blog/2023/08/28/6%E3%80%81%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Git/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Git">Git</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E4%BC%98%E5%8C%96%E7%AF%87%E4%B9%8B%20%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3%20%E6%A0%A1%E9%AA%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 优化篇之 自定义注解 校验数据库表中的数据不可重复">Java 优化篇之 自定义注解 校验数据库表中的数据不可重复</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E5%B7%A5%E5%85%B7%E7%AF%87%E4%B9%8B%20API%20%E6%8E%A5%E5%8F%A3%E5%85%8D%E8%B4%B9%20JSONPlaceholder/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 工具篇之 API 接口免费 JSONPlaceholder">Java 工具篇之 API 接口免费 JSONPlaceholder</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E5%B7%A5%E5%85%B7%E7%AF%87%E4%B9%8B%20%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E7%BB%9F%E8%AE%A1%E4%BB%A3%E7%A0%81%E8%80%97%E6%97%B6/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 工具篇之 如何优雅的统计代码耗时">Java 工具篇之 如何优雅的统计代码耗时</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B9%8B%20%E4%B8%8D%E5%8F%AF%E4%B8%8D%E7%9F%A5%E7%9A%84%207%20%E4%B8%AA%20JDK%20%E5%91%BD%E4%BB%A4/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 命令行之 不可不知的 7 个 JDK 命令">Java 命令行之 不可不知的 7 个 JDK 命令</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%AF%87%E4%B9%8B%20Window%20%E5%90%8E%E5%8F%B0%E5%90%AF%E5%8A%A8%20JAR%20%E7%A8%8B%E5%BA%8F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 命令行篇之 Window 后台启动 JAR 程序">Java 命令行篇之 Window 后台启动 JAR 程序</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E5%B7%A5%E5%85%B7%E7%AF%87%E4%B9%8B%20API%20%E6%96%87%E6%A1%A3%E5%B7%A5%E5%85%B7%20Swagger3.x-2.x/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 工具篇之 API 文档工具 Swagger3.x-2.x">Java 工具篇之 API 文档工具 Swagger3.x-2.x</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E5%B7%A5%E5%85%B7%E7%AF%87%E4%B9%8B%20Lombok/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 工具篇之 Lombok">Java 工具篇之 Lombok</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E5%B7%A5%E5%85%B7%E7%AF%87%E4%B9%8B%20%E6%8E%8C%E6%8F%A114%E7%A7%8DUML%E5%9B%BE/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 工具篇之 掌握14种UML图">Java 工具篇之 掌握14种UML图</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E5%B7%A5%E5%85%B7%E7%B1%BB%E4%B9%8B%20%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B7%A5%E5%85%B7%E7%B1%BB/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 工具类之 自定义工具类">Java 工具类之 自定义工具类</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20Bean%20%E4%B9%8B%20DTO%E3%80%81VO%E3%80%81PO%E3%80%81DO%E3%80%81BO%20%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java Bean 之 DTO、VO、PO、DO、BO 类的区别">Java Bean 之 DTO、VO、PO、DO、BO 类的区别</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20JSON%20%E7%AF%87%E4%B9%8B%20Jackson/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java JSON 篇之 Jackson">Java JSON 篇之 Jackson</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20JSON%20%E7%AF%87%E4%B9%8B%20Gson/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java JSON 篇之 Gson">Java JSON 篇之 Gson</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Curl%20%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%91%BD%E4%BB%A4%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Curl 的使用及命令参数说明">Curl 的使用及命令参数说明</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20JSON%20%E7%AF%87%E4%B9%8B%20FastJson/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java JSON 篇之 FastJson">Java JSON 篇之 FastJson</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Redis backup "
           href="/blog/2023/08/28/5%E3%80%81%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/backup/Redis6/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Redis6">Redis6</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 中间件 Redis "
           href="/blog/2023/08/28/5%E3%80%81%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/Redis-%E6%9C%80%E5%85%A8%E5%AE%9E%E6%88%98/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Redis-最全实战">Redis-最全实战</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 中间件 Redis "
           href="/blog/2023/08/28/5%E3%80%81%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/Redis-%E4%BB%A3%E7%A0%81%E5%AE%9E%E6%88%98/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Redis-代码实战">Redis-代码实战</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 中间件 RabbitMQ "
           href="/blog/2023/08/28/5%E3%80%81%E4%B8%AD%E9%97%B4%E4%BB%B6/RabbitMQ/RabbitMQ-3.8.14/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="RabbitMQ-3.8.14">RabbitMQ-3.8.14</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 中间件 RabbitMQ "
           href="/blog/2023/08/28/5%E3%80%81%E4%B8%AD%E9%97%B4%E4%BB%B6/RabbitMQ/RabbitMQ-3.7.x/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="RabbitMQ-3.7.x">RabbitMQ-3.7.x</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 中间件 RabbitMQ "
           href="/blog/2023/08/28/5%E3%80%81%E4%B8%AD%E9%97%B4%E4%BB%B6/RabbitMQ/RabbitMQ-3.8.14-%E5%8D%9A%E5%AE%A2%E7%89%88/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="RabbitMQ-3.8.14-博客版">RabbitMQ-3.8.14-博客版</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 中间件 MongoDB "
           href="/blog/2023/08/28/5%E3%80%81%E4%B8%AD%E9%97%B4%E4%BB%B6/MongoDB/MongDB-4.4.2-%E5%8D%9A%E5%AE%A2%E7%89%88/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="MongDB-4.4.2-博客版">MongDB-4.4.2-博客版</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 中间件 MongoDB "
           href="/blog/2023/08/28/5%E3%80%81%E4%B8%AD%E9%97%B4%E4%BB%B6/MongoDB/MongDB-4.4.2/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="MongDB-4.4.2">MongDB-4.4.2</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 中间件 ElasticSearch "
           href="/blog/2023/08/28/5%E3%80%81%E4%B8%AD%E9%97%B4%E4%BB%B6/ElasticSearch/ElasticSearch7.6.x%E5%AE%9E%E6%88%98/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="ElasticSearch7.6.x实战">ElasticSearch7.6.x实战</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Linux 虚拟机工具 "
           href="/blog/2023/08/28/4%E3%80%81Linux/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%B7%A5%E5%85%B7/Virtualbox%E7%BD%91%E7%BB%9C%E8%AE%BE%E7%BD%AE%E6%88%96%E9%85%8D%E7%BD%AE/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Virtualbox网络设置或配置">Virtualbox网络设置或配置</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Linux 虚拟机工具 "
           href="/blog/2023/08/28/4%E3%80%81Linux/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%B7%A5%E5%85%B7/Virtualbox%E5%AE%89%E8%A3%85Centos7%E5%AE%9E%E6%88%98/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Virtualbox安装Centos7实战">Virtualbox安装Centos7实战</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Linux Kubernetes "
           href="/blog/2023/08/28/4%E3%80%81Linux/Kubernetes/Minikube-k8s/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Minikube-k8s">Minikube-k8s</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Linux Kubernetes "
           href="/blog/2023/08/28/4%E3%80%81Linux/Kubernetes/k0s%20%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B%EF%BC%9A%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%20Kubernetes%20%E9%9B%86%E7%BE%A4/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="k0s 使用教程：如何快速搭建 Kubernetes 集群">k0s 使用教程：如何快速搭建 Kubernetes 集群</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Linux Nginx "
           href="/blog/2023/08/28/4%E3%80%81Linux/Nginx/Nginx-1.8.0/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Nginx-1.8.0">Nginx-1.8.0</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Linux Docker "
           href="/blog/2023/08/28/4%E3%80%81Linux/Docker/Docker%E5%88%9D%E7%BA%A7%E5%88%B0%E5%AE%9E%E6%88%98/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Docker初级到实战">Docker初级到实战</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Linux Docker "
           href="/blog/2023/08/28/4%E3%80%81Linux/Docker/Docker&Docker-Compose%E5%AE%9E%E6%88%98-%E5%93%88%E5%96%BD%E6%B2%83%E5%BE%B7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Docker&amp;Docker-Compose实战-哈喽沃德">Docker&amp;Docker-Compose实战-哈喽沃德</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 Spring "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring/Spring%20Bean%20%E7%9A%8412%E7%A7%8D%E5%AE%9A%E4%B9%89%E6%96%B9%E6%B3%95/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Spring Bean 的12种定义方法">Spring Bean 的12种定义方法</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 Spring "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring/Spring%20Bean%20%E7%9A%84%E5%8A%A8%E6%80%81%E5%88%9B%E5%BB%BA%E8%8E%B7%E5%8F%96%E5%88%A0%E9%99%A4/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Spring Bean 的动态创建获取删除">Spring Bean 的动态创建获取删除</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 Spring "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring/Spring%20Bean%20%E6%B3%A8%E5%85%A5%E7%9A%843%E7%A7%8D%E6%96%B9%E5%BC%8F,%20%E4%B8%BA%E4%BD%95%E5%AE%98%E6%96%B9%E5%BB%BA%E8%AE%AE%E4%BD%BF%E7%94%A8%E6%9E%84%E9%80%A0%E5%99%A8%E6%B3%A8%E5%85%A5/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Spring Bean 注入的3种方式, 为何官方建议使用构造器注入">Spring Bean 注入的3种方式, 为何官方建议使用构造器注入</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 SpringTransaction 多数据源事务处理 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Transaction/%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/Spring%20%E8%A7%A3%E5%86%B3%E5%8D%95%E6%9C%BA%E7%8E%AF%E5%A2%83%E4%B8%8B%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E7%9A%84%E4%BA%8B%E5%8A%A1%E9%97%AE%E9%A2%98/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Spring 解决单机环境下多数据源的事务问题">Spring 解决单机环境下多数据源的事务问题</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 SpringTransaction 多数据源事务处理 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Transaction/%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/Spring%20%E5%AE%9E%E7%8E%B0%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E5%AE%9E%E6%88%98/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Spring 实现多数据源实战">Spring 实现多数据源实战</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 SpringTransaction 多数据源事务处理 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Transaction/%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/Spring%20%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81%E6%95%B0%E6%8D%AE%E6%BA%90%E3%80%81%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E5%88%87%E6%8D%A2%E6%96%B9%E5%BC%8F%E3%80%81%E5%A4%9A%E6%95%B0%E6%8D%AE%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Spring 实现动态数据源、多数据源切换方式、多数据事务管理">Spring 实现动态数据源、多数据源切换方式、多数据事务管理</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringTransaction "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Transaction/Spring%20%E4%BA%8B%E5%8A%A1%E5%8E%9F%E7%90%86%E6%B7%B1%E5%85%A5%E4%B8%8E%E5%88%86%E6%9E%90/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Spring 事务原理深入与分析">Spring 事务原理深入与分析</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringSecurity "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Security/SpringSecurity/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringSecurity">SpringSecurity</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringTransaction "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Transaction/JDBC/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="JDBC">JDBC</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringTransaction "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Transaction/Spring%20JDBC%20-%20JdbcTemplate/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Spring JDBC - JdbcTemplate">Spring JDBC - JdbcTemplate</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 SpringTransaction 多线程下事务处理 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Transaction/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8B%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/JDBC%E6%89%B9%E5%A4%84%E7%90%86%E5%AE%9E%E7%8E%B0%E6%89%8B%E5%8A%A8%E4%BA%8B%E5%8A%A1%E6%8F%92%E5%85%A51000%E4%B8%87%E6%95%B0%E6%8D%AE%EF%BC%88%E5%8D%95%E7%BA%BF%E7%A8%8B%20&%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%89/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="JDBC批处理实现手动事务插入1000万数据（单线程 &amp; 多线程）">JDBC批处理实现手动事务插入1000万数据（单线程 &amp; 多线程）</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringDataJPA "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Data%20JPA/SpringData%20JPA%20%E7%B1%BB%E5%9B%BE%E5%8F%8A%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringData JPA 类图及使用方法整理">SpringData JPA 类图及使用方法整理</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringDataJPA "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Data%20JPA/SpringData%20JPA/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringData JPA">SpringData JPA</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringDataJPA "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Data%20JPA/Spring%20Data%20JPA%20%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E6%88%98/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Spring Data JPA 原理与实战">Spring Data JPA 原理与实战</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringDataJPA "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Data%20JPA/Hibernata%20JPA/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Hibernata JPA">Hibernata JPA</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringCloudAlibaba "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Cloud%20Alibaba/SpringCloud%20Alibaba/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringCloud Alibaba">SpringCloud Alibaba</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot2.x%20%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AF%87%20-%20%E6%95%B4%E5%90%88H2%E6%95%B0%E6%8D%AE%E5%BA%93/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot2.x 数据库篇 - 整合H2数据库">SpringBoot2.x 数据库篇 - 整合H2数据库</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AD%A6/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot从零开始学">SpringBoot从零开始学</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SprinigBoot%E6%96%87%E7%AB%A0%E6%91%98%E8%A6%81%E5%8F%8A%E8%BD%AC%E8%BD%BD/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SprinigBoot文章摘要及转载">SprinigBoot文章摘要及转载</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot2.x%20%E9%A1%B9%E7%9B%AE%E7%BB%9F%E4%B8%80%E6%9E%9A%E4%B8%BE%E8%BD%AC%E6%8D%A2%E5%AE%9E%E8%B7%B5/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot2.x 项目统一枚举转换实践">SpringBoot2.x 项目统一枚举转换实践</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%E9%85%8D%E7%BD%AE%E5%B1%9E%E6%80%A7%E4%B9%8BDataSource/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot配置属性之DataSource">SpringBoot配置属性之DataSource</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/%E4%BB%A3%E7%A0%81%E5%AE%A1%E6%9F%A5%E7%9A%84%E5%BF%85%E8%A6%81%E6%80%A7%E5%92%8C%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="代码审查的必要性和最佳实践">代码审查的必要性和最佳实践</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6-%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%B9%8B@Value%E8%BF%9B%E9%98%B6/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 配置文件-读取配置文件之@Value进阶">SpringBoot 2.x 配置文件-读取配置文件之@Value进阶</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6-%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9A%84N%E7%A7%8D%E6%96%B9%E5%BC%8F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 配置文件-读取配置文件的N种方式">SpringBoot 2.x 配置文件-读取配置文件的N种方式</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E7%BB%9F%E4%B8%80%E6%8E%A5%E5%8F%A3%E8%BF%94%E5%9B%9E%E6%A0%BC%E5%BC%8F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 统一接口返回格式">SpringBoot 2.x 统一接口返回格式</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6-%E8%AF%BB%E5%8F%96%20Resources%20%E6%96%87%E4%BB%B6%E4%B9%8B%E6%97%A0%E6%B3%95%E8%AF%BB%E5%8F%96Jar%E5%8C%85classpath%E4%B8%8B%E7%9A%84%E6%96%87%E4%BB%B6/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 配置文件-读取 Resources 文件之无法读取Jar包classpath下的文件">SpringBoot 2.x 配置文件-读取 Resources 文件之无法读取Jar包classpath下的文件</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6-%E8%AF%BB%E5%8F%96%20Resources%20%E6%96%87%E4%BB%B6%E7%9A%84N%E7%A7%8D%E6%96%B9%E5%BC%8F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 配置文件-读取 Resources 文件的N种方式">SpringBoot 2.x 配置文件-读取 Resources 文件的N种方式</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B%E7%AF%87-%E6%8B%A6%E6%88%AA%E5%99%A8%E8%BF%87%E6%BB%A4%E5%99%A8%E4%B8%8E%E7%9B%91%E5%90%AC%E5%99%A8/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 切面编程篇-拦截器过滤器与监听器">SpringBoot 2.x 切面编程篇-拦截器过滤器与监听器</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E5%AE%89%E5%85%A8%E5%AF%86%E7%A0%81%E5%AD%A6%E4%B9%8B%E5%8A%A0%E8%A7%A3%E5%AF%86%E7%AE%97%E6%B3%95/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 安全密码学之加解密算法">SpringBoot 2.x 安全密码学之加解密算法</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3%E8%AF%A6%E8%A7%A3/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 常用注解详解">SpringBoot 2.x 常用注解详解</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3%E5%A4%A7%E5%85%A8/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 常用注解大全">SpringBoot 2.x 常用注解大全</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E5%90%AF%E5%8A%A8%E6%97%B6%E5%8A%A0%E8%BD%BD%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84N%E7%A7%8D%E6%96%B9%E5%BC%8F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 启动时加载初始化的N种方式">SpringBoot 2.x 启动时加载初始化的N种方式</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%8F%8A%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E8%BF%87%E7%A8%8B/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 启动流程及自动装配过程">SpringBoot 2.x 启动流程及自动装配过程</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E5%8A%A8%E6%80%81%E8%A3%85%E9%85%8DBean%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 动态装配Bean的三种方式">SpringBoot 2.x 动态装配Bean的三种方式</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E5%88%A9%E5%99%A8-1%20JUnit5/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 单元测试利器-1 JUnit5">SpringBoot 2.x 单元测试利器-1 JUnit5</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E5%88%A9%E5%99%A8-3%20MockMvc/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 单元测试利器-3 MockMvc">SpringBoot 2.x 单元测试利器-3 MockMvc</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E5%88%A9%E5%99%A8-2%20Mockito/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 单元测试利器-2 Mockito">SpringBoot 2.x 单元测试利器-2 Mockito</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E5%88%86%E7%89%87%E4%B8%8A%E4%BC%A0%E3%80%81%E6%96%AD%E7%82%B9%E7%BB%AD%E4%BC%A0%E3%80%81%E5%A4%A7%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E3%80%81%E7%A7%92%E4%BC%A0/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 分片上传、断点续传、大文件上传、秒传">SpringBoot 2.x 分片上传、断点续传、大文件上传、秒传</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20Validation%20%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C%EF%BC%88TODO%EF%BC%89/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x Validation 参数校验（TODO）">SpringBoot 2.x Validation 参数校验（TODO）</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20WebMvcConfigurer%20%E8%AF%A6%E8%A7%A3%E3%80%90SpringMVC%E3%80%91/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x WebMvcConfigurer 详解【SpringMVC】">SpringBoot 2.x WebMvcConfigurer 详解【SpringMVC】</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20YML%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x YML配置文件详解">SpringBoot 2.x YML配置文件详解</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E5%88%86%E5%B8%83%E5%BC%8F%E5%85%A8%E5%B1%80%E5%94%AF%E4%B8%80ID%E7%94%9F%E6%88%90%E6%96%B9%E6%A1%88/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 分布式全局唯一ID生成方案">SpringBoot 2.x 分布式全局唯一ID生成方案</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20JWT%20%E6%A6%82%E5%BF%B5%E7%AF%87/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x JWT 概念篇">SpringBoot 2.x JWT 概念篇</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20Jar%20%E5%8C%85%E5%90%AF%E5%8A%A8%E3%80%81%E5%81%9C%E6%AD%A2%E3%80%81%E9%87%8D%E5%90%AF%E8%84%9A%E6%9C%AC/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x Jar 包启动、停止、重启脚本">SpringBoot 2.x Jar 包启动、停止、重启脚本</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20Java%20%E5%AE%9E%E7%8E%B0%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E7%9A%848%E7%A7%8D%E6%96%B9%E5%BC%8F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x Java 实现异步编程的8种方式">SpringBoot 2.x Java 实现异步编程的8种方式</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20Java%20%E7%A8%8B%E5%BA%8F%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0%E6%80%BB%E7%BB%93/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x Java 程序命令行参数总结">SpringBoot 2.x Java 程序命令行参数总结</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20@ConfigurationProperties%E4%BB%A5%E5%8F%8A@NestedConfigurationProperty%E7%9A%84%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x @ConfigurationProperties以及@NestedConfigurationProperty的使用详解">SpringBoot 2.x @ConfigurationProperties以及@NestedConfigurationProperty的使用详解</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20@ControllerAdvice%E4%B8%89%E7%A7%8D%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x @ControllerAdvice三种使用场景">SpringBoot 2.x @ControllerAdvice三种使用场景</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20HTTP%20Content-Type%20%E8%AF%A6%E8%A7%A3/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x HTTP Content-Type 详解">SpringBoot 2.x HTTP Content-Type 详解</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20HTTP%20Headers%20%E5%A4%B4%E4%BF%A1%E6%81%AF%E8%AF%BB%E5%8F%96/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x HTTP Headers 头信息读取">SpringBoot 2.x HTTP Headers 头信息读取</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20JWT%20%E5%AE%9E%E6%88%98%E7%AF%87/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x JWT 实战篇">SpringBoot 2.x JWT 实战篇</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%20%E6%8E%A5%E5%8F%A3%E5%B9%82%E7%AD%89%E6%80%A7%E5%AE%9E%E7%8E%B0/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x  接口幂等性实现">SpringBoot 2.x  接口幂等性实现</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/Spring%20IO%20Platform%EF%BC%9A%E8%A7%A3%E5%86%B3%E4%BE%9D%E8%B5%96%E7%89%88%E6%9C%AC%E5%86%B2%E7%AA%81/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Spring IO Platform：解决依赖版本冲突">Spring IO Platform：解决依赖版本冲突</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B%E7%AF%87-AOP%20%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%8E%9F%E7%90%86/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 切面编程篇-AOP 的使用及原理">SpringBoot 2.x 切面编程篇-AOP 的使用及原理</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE SSM框架 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/2%E3%80%81SSM%E6%A1%86%E6%9E%B6/SpringMVC/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringMVC">SpringMVC</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 Shiro "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Shiro/Shiro%E6%9D%83%E9%99%90%E5%AE%9E%E6%88%98%E8%AF%BE%E7%A8%8B/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Shiro权限实战课程">Shiro权限实战课程</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 Shiro "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Shiro/Shiro%E6%9D%83%E9%99%90%E5%AE%9E%E6%88%98/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Shiro权限实战">Shiro权限实战</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE SSM框架 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/2%E3%80%81SSM%E6%A1%86%E6%9E%B6/Spring/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Spring">Spring</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE SSM框架 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/2%E3%80%81SSM%E6%A1%86%E6%9E%B6/MybatisPlus/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="MybatisPlus">MybatisPlus</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE JavaWeb "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/1%E3%80%81JavaWeb/%E4%BD%A0%E8%BF%98%E5%9C%A8%E4%B8%BA%20HTTP%20%E7%9A%84%E8%BF%99%E4%BA%9B%E6%A6%82%E5%BF%B5%E5%A4%B4%E7%96%BC%E5%90%97/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="你还在为 HTTP 的这些概念头疼吗">你还在为 HTTP 的这些概念头疼吗</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE JavaWeb "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/1%E3%80%81JavaWeb/Cookie%E3%80%81Session%E3%80%81Token%E3%80%81JWT%E7%BB%88%E4%BA%8E%E8%AE%B2%E6%B8%85%E6%A5%9A%E4%BA%86/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Cookie、Session、Token、JWT终于讲清楚了">Cookie、Session、Token、JWT终于讲清楚了</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 数据库 "
           href="/blog/2023/08/28/3%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL-%E9%AB%98%E7%BA%A7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="MySQL-高级">MySQL-高级</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 数据库 "
           href="/blog/2023/08/28/3%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL-%E5%88%9D%E7%BA%A7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="MySQL-初级">MySQL-初级</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 数据库 "
           href="/blog/2023/08/28/3%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93/H2%20Database/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="H2 Database">H2 Database</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E4%BC%98%E5%8C%96%E7%AF%87%E4%B9%8B%20%E5%BB%B6%E6%97%B6%E9%98%9F%E5%88%97%20-%20%E8%AE%A2%E5%8D%95%E8%B6%85%E6%97%B6%E8%87%AA%E5%8A%A8%E5%8F%96%E6%B6%88%E7%9A%84N%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 优化篇之 延时队列 - 订单超时自动取消的N种实现方式">Java 优化篇之 延时队列 - 订单超时自动取消的N种实现方式</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E4%BC%98%E5%8C%96%E7%AF%87%E4%B9%8B%20%E6%B3%A8%E8%A7%A3%20+%20%E5%8F%8D%E5%B0%84%E6%B6%88%E9%99%A4%E9%87%8D%E5%A4%8D%E4%BB%A3%E7%A0%81/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 优化篇之 注解 + 反射消除重复代码">Java 优化篇之 注解 + 反射消除重复代码</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E9%9B%86%E5%90%88%E7%AF%87%E4%B9%8B%20%E8%8E%B7%E5%8F%96%E4%B8%A4%E4%B8%AA%E9%9B%86%E5%90%88List%E7%9A%84%E4%BA%A4%E9%9B%86%E3%80%81%E8%A1%A5%E9%9B%86%E3%80%81%E5%B9%B6%E9%9B%86%E3%80%81%E5%B7%AE%E9%9B%86%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 集合篇之 获取两个集合List的交集、补集、并集、差集的几种方式">Java 集合篇之 获取两个集合List的交集、补集、并集、差集的几种方式</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E4%BC%98%E5%8C%96%E7%AF%87%E4%B9%8B%20if-else%20%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 优化篇之 if-else 代码优化方案">Java 优化篇之 if-else 代码优化方案</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4%E5%90%84%E7%B1%BB%E5%9E%8B%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 日期时间各类型相互转换">Java 日期时间各类型相互转换</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E9%9B%86%E5%90%88%E7%AF%87%E4%B9%8B%20Lambda%20%E5%AE%9E%E7%8E%B0%E8%B6%85%E5%BC%BA%E6%8E%92%E5%BA%8F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 集合篇之 Lambda 实现超强排序">Java 集合篇之 Lambda 实现超强排序</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 动态代理">Java 动态代理</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E5%9F%BA%E6%9C%AC%E5%8A%9F%E7%AF%87%E4%B9%8B%20for%E3%80%81for-each%E3%80%81forEach()%20%E7%9A%84%20break%E3%80%81continue%E3%80%81return/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 基本功篇之 for、for-each、forEach() 的 break、continue、return">Java 基本功篇之 for、for-each、forEach() 的 break、continue、return</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6%E8%AF%A6%E8%A7%A3/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 日志框架详解">Java 日志框架详解</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20Bean%20%E4%B9%8B%20Record%20%E7%B1%BB/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java Bean 之 Record 类">Java Bean 之 Record 类</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E4%BC%98%E5%8C%96%E7%AF%87%E4%B9%8B%20GZIP%E5%8E%8B%E7%BC%A9%E5%AD%97%E7%AC%A6%E4%B8%B2/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 优化篇之 GZIP压缩字符串">Java 优化篇之 GZIP压缩字符串</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java新特性 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/3.Java%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%20%E6%96%B0%E7%89%B9%E6%80%A7%E6%A6%82%E8%BF%B0%E5%8F%8A%E7%89%88%E6%9C%AC%E5%8F%91%E8%A1%8C%E5%8F%B2/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 新特性概述及版本发行史">Java 新特性概述及版本发行史</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java进阶篇 JVM虚拟机 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/2.Java%20%E8%BF%9B%E9%98%B6%E7%AF%87/JVM%20%E8%99%9A%E6%8B%9F%E6%9C%BA/Java%20GC%20%E6%80%BB%E7%BB%93/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java GC 总结">Java GC 总结</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java新特性 Java9新特性 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/3.Java%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%209%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%209%20%E6%96%B0%E7%89%B9%E6%80%A7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 9 新特性">Java 9 新特性</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java新特性 Java8新特性 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/3.Java%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%208%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%208%20%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8B%20Optional%20%E7%B1%BB/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 8 新特性之 Optional 类">Java 8 新特性之 Optional 类</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java新特性 Java8新特性 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/3.Java%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%208%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%208%20%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8B%20Stream%20%E6%B5%81/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 8 新特性之 Stream 流">Java 8 新特性之 Stream 流</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java新特性 Java8新特性 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/3.Java%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%208%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%208%20%E6%96%B0%E7%89%B9%E6%80%A7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 8 新特性">Java 8 新特性</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java新特性 Java8新特性 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/3.Java%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%208%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%208%20%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8B%20DateTime%20API/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 8 新特性之 DateTime API">Java 8 新特性之 DateTime API</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java新特性 Java20新特性 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/3.Java%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2020%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2020%20%E6%96%B0%E7%89%B9%E6%80%A7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 20 新特性">Java 20 新特性</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java新特性 Java18新特性 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/3.Java%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2018%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2018%20%E6%96%B0%E7%89%B9%E6%80%A7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 18 新特性">Java 18 新特性</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java新特性 Java19新特性 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/3.Java%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2019%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2019%20%E6%96%B0%E7%89%B9%E6%80%A7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 19 新特性">Java 19 新特性</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java新特性 Java17新特性 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/3.Java%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2017%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2017%20%E6%96%B0%E7%89%B9%E6%80%A7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 17 新特性">Java 17 新特性</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java新特性 Java15新特性 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/3.Java%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2015%E6%96%B0%E7%89%B9%E6%80%A7/Java%2015%20%E6%96%B0%E7%89%B9%E6%80%A7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 15 新特性">Java 15 新特性</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java新特性 Java16新特性 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/3.Java%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2016%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2016%20%E6%96%B0%E7%89%B9%E6%80%A7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 16 新特性">Java 16 新特性</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java新特性 Java13新特性 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/3.Java%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2013%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2013%20%E6%96%B0%E7%89%B9%E6%80%A7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 13 新特性">Java 13 新特性</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java新特性 Java14新特性 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/3.Java%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2014%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2014%20%E6%96%B0%E7%89%B9%E6%80%A7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 14 新特性">Java 14 新特性</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java新特性 Java12新特性 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/3.Java%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2012%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2012%20%E6%96%B0%E7%89%B9%E6%80%A7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 12 新特性">Java 12 新特性</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java新特性 Java11新特性 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/3.Java%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2011%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2011%20%E6%96%B0%E7%89%B9%E6%80%A7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 11 新特性">Java 11 新特性</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java新特性 Java10新特性 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/3.Java%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2010%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2010%20%E6%96%B0%E7%89%B9%E6%80%A7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 10 新特性">Java 10 新特性</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java基础篇 Java基础语法 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/1.Java%20%E5%9F%BA%E7%A1%80%E7%AF%87/1%E3%80%81Java%20%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/Java%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 面向对象编程">Java 面向对象编程</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java基础篇 Java集合类 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/1.Java%20%E5%9F%BA%E7%A1%80%E7%AF%87/3%E3%80%81Java%20%E9%9B%86%E5%90%88%E7%B1%BB/Java%20%E7%B1%BB%E9%9B%86%E6%A1%86%E6%9E%B6/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 类集框架">Java 类集框架</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java基础篇 Java常用类库 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/1.Java%20%E5%9F%BA%E7%A1%80%E7%AF%87/2%E3%80%81Java%20%E5%B8%B8%E7%94%A8%E7%B1%BB%E5%BA%93/Java%20%E5%B8%B8%E7%94%A8%E7%B1%BB%E5%BA%93/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 常用类库">Java 常用类库</span>
            <span class="post-date" title="2023-08-28 09:23:44">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java基础篇 Java多线程 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/1.Java%20%E5%9F%BA%E7%A1%80%E7%AF%87/5%E3%80%81Java%20%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 多线程基础">Java 多线程基础</span>
            <span class="post-date" title="2023-08-28 09:23:44">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java基础篇 Java反射与注解 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/1.Java%20%E5%9F%BA%E7%A1%80%E7%AF%87/4%E3%80%81Java%20%E5%8F%8D%E5%B0%84%E4%B8%8E%E6%B3%A8%E8%A7%A3/Java%20%E5%8F%8D%E5%B0%84%E4%B8%8E%E6%B3%A8%E8%A7%A3/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 反射与注解">Java 反射与注解</span>
            <span class="post-date" title="2023-08-28 09:23:44">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java基础篇 JavaNIO流 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/1.Java%20%E5%9F%BA%E7%A1%80%E7%AF%87/7%E3%80%81Java%20NIO%20%E6%B5%81/Java%20NIO%20%E6%B5%81/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java NIO 流">Java NIO 流</span>
            <span class="post-date" title="2023-08-28 09:23:44">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java基础篇 JavaIO流 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/1.Java%20%E5%9F%BA%E7%A1%80%E7%AF%87/6%E3%80%81Java%20IO%20%E6%B5%81/Java%20IO%20%E6%B5%81/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java IO 流">Java IO 流</span>
            <span class="post-date" title="2023-08-28 09:23:44">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java进阶篇 Java设计模式 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/2.Java%20%E8%BF%9B%E9%98%B6%E7%AF%87/Java%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/Java%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 设计模式">Java 设计模式</span>
            <span class="post-date" title="2023-08-28 09:23:44">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java进阶篇 JVM虚拟机 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/2.Java%20%E8%BF%9B%E9%98%B6%E7%AF%87/JVM%20%E8%99%9A%E6%8B%9F%E6%9C%BA/7%20%E6%AE%B5%E5%B0%8F%E4%BB%A3%E7%A0%81%EF%BC%8C%E7%8E%A9%E8%BD%ACJava%E7%A8%8B%E5%BA%8F%E5%B8%B8%E8%A7%81%E7%9A%84%E5%B4%A9%E6%BA%83%E5%9C%BA%E6%99%AF/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="7 段小代码，玩转Java程序常见的崩溃场景">7 段小代码，玩转Java程序常见的崩溃场景</span>
            <span class="post-date" title="2023-08-28 09:23:44">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java进阶篇 JVM虚拟机 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/2.Java%20%E8%BF%9B%E9%98%B6%E7%AF%87/JVM%20%E8%99%9A%E6%8B%9F%E6%9C%BA/JVM%20%E8%99%9A%E6%8B%9F%E6%9C%BA/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="JVM 虚拟机">JVM 虚拟机</span>
            <span class="post-date" title="2023-08-28 09:23:44">2023/08/28</span>
        </a>
        
        <div id="no-item-tips">

        </div>
    </nav>
    <div id="outline-list">
    </div>
</div>

    </div>
    <div class="hide-list">
        <div class="semicircle" data-title="切换全屏 快捷键 s">
            <div class="brackets first"><</div>
            <div class="brackets">&gt;</div>
        </div>
    </div>
</aside>
<div id="post">
    <div class="pjax">
        <article id="post-1、JavaSE/4.Java 汇总篇/Java JSON 篇之 Jackson" class="article article-type-post" itemscope itemprop="blogPost">
    
        <h1 class="article-title">Java JSON 篇之 Jackson</h1>
    
    <div class="article-meta">
        
        
        
        <span class="book">
            <i class="iconfont icon-category"></i>
            
            
            <a  data-rel="JavaSE">JavaSE</a> > 
            
            <a  data-rel="JavaSE&lt;---&gt;Java汇总篇">Java汇总篇</a>
            
        </span>
        
        
    </div>
    <div class="article-meta">
        
            发布时间 : <time class="date" title='最后更新: 2024-10-21 00:34:49'>2023-08-28 09:23</time>
        
    </div>
    <div class="article-meta">
        
        
        <span id="busuanzi_container_page_pv">
            阅读 :<span id="busuanzi_value_page_pv">
                <span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </span>
        </span>
        
        
    </div>
    
    <div class="toc-ref">
    
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81Jackson-%E7%AE%80%E4%BB%8B"><span class="toc-text">一、Jackson 简介</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81Jackson-%E4%BE%9D%E8%B5%96"><span class="toc-text">二、Jackson 依赖</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81ObjectMapper"><span class="toc-text">三、ObjectMapper</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E4%BB%8EJSON%E4%B8%AD%E8%8E%B7%E5%8F%96Java%E5%AF%B9%E8%B1%A1%EF%BC%88%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%89"><span class="toc-text">1、从JSON中获取Java对象（反序列化）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81Jackson-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E7%A4%BA%E4%BE%8B"><span class="toc-text">1、Jackson 快速入门示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81JSON%E5%AD%97%E6%AE%B5%E5%92%8CJava%E5%B1%9E%E6%80%A7%E5%A6%82%E4%BD%95%E5%8C%B9%E9%85%8D"><span class="toc-text">2、JSON字段和Java属性如何匹配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81JSON-%E5%AD%97%E7%AC%A6%E4%B8%B2-%C2%BB%C2%BB-Java-%E5%AF%B9%E8%B1%A1"><span class="toc-text">3、JSON 字符串 »» Java 对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81JSON-%E5%AD%97%E7%AC%A6%E8%BE%93%E5%85%A5%E6%B5%81-%C2%BB%C2%BB-Java-%E5%AF%B9%E8%B1%A1"><span class="toc-text">4、JSON 字符输入流 »» Java 对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81JSON-%E5%AD%97%E8%8A%82%E8%BE%93%E5%85%A5%E6%B5%81-%C2%BB%C2%BB-Java-%E5%AF%B9%E8%B1%A1"><span class="toc-text">5、JSON 字节输入流 »» Java 对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81JSON-%E6%96%87%E4%BB%B6-%C2%BB%C2%BB-Java-%E5%AF%B9%E8%B1%A1"><span class="toc-text">6、JSON 文件 »» Java 对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%E3%80%81JSON-via-URL-%C2%BB%C2%BB-Java-%E5%AF%B9%E8%B1%A1"><span class="toc-text">7、JSON via URL »» Java 对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8%E3%80%81JSON-%E6%95%B0%E7%BB%84-%C2%BB%C2%BB-Java-%E5%AF%B9%E8%B1%A1%E6%95%B0%E7%BB%84"><span class="toc-text">8、JSON 数组 »» Java 对象数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9%E3%80%81JSON-%E6%95%B0%E7%BB%84-%C2%BB%C2%BB-List-%E5%AF%B9%E8%B1%A1"><span class="toc-text">9、JSON 数组 »» List 对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10%E3%80%81JSON-%E5%AD%97%E7%AC%A6%E4%B8%B2-%C2%BB%C2%BB-Map-%E5%AF%B9%E8%B1%A1"><span class="toc-text">10、JSON 字符串 »» Map 对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11%E3%80%81%E5%BF%BD%E7%95%A5%E6%9C%AA%E7%9F%A5%E7%9A%84JSON%E5%AD%97%E6%AE%B5"><span class="toc-text">11、忽略未知的JSON字段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12%E3%80%81%E4%B8%8D%E5%85%81%E8%AE%B8%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%BAnull"><span class="toc-text">12、不允许基本类型为null</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-text">13、自定义反序列化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E5%B0%86Java%E5%AF%B9%E8%B1%A1%E5%86%99%E5%85%A5JSON%E4%B8%AD%EF%BC%88%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%89"><span class="toc-text">2、将Java对象写入JSON中（序列化）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81Java%E5%AF%B9%E8%B1%A1-%C2%BB%C2%BB-JSON"><span class="toc-text">1、Java对象 »» JSON</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-text">2、自定义序列化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81Jackson-%E6%97%A5%E6%9C%9F%E8%BD%AC%E5%8C%96"><span class="toc-text">3、Jackson 日期转化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81Date-%C2%AB%C2%BB-Long"><span class="toc-text">1、Date «» Long</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81Date-%C2%AB%C2%BB-String"><span class="toc-text">2、Date «» String</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81LocalDateTime-%E7%B1%BB%E5%9E%8B"><span class="toc-text">3、LocalDateTime 类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E6%97%B6%E9%97%B4%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%B3%A8%E8%A7%A3"><span class="toc-text">4、时间格式化注解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81Jackson-JSON-%E6%A0%91%E6%A8%A1%E5%9E%8B"><span class="toc-text">4、Jackson JSON 树模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81Jackson-Tree-Model-%E7%A4%BA%E4%BE%8B"><span class="toc-text">1、Jackson Tree Model 示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81Jackson-JsonNode-%E7%B1%BB"><span class="toc-text">2、Jackson JsonNode 类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81Java-%E5%AF%B9%E8%B1%A1-%C2%BB%C2%BB-JsonNode"><span class="toc-text">3、Java 对象  »» JsonNode</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81JsonNode-%C2%BB%C2%BB-Java-%E5%AF%B9%E8%B1%A1"><span class="toc-text">4、JsonNode »» Java 对象</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E3%80%81JsonNode"><span class="toc-text">四、JsonNode</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81JsonNode-vs-ObjectNode"><span class="toc-text">1、JsonNode vs ObjectNode</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81JSON%E8%BD%ACJsonNode"><span class="toc-text">2、JSON转JsonNode</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81JsonNode%E8%BD%ACJSON"><span class="toc-text">3、JsonNode转JSON</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E8%8E%B7%E5%8F%96JsonNode%E5%AD%97%E6%AE%B5"><span class="toc-text">4、获取JsonNode字段</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81%E8%B7%AF%E5%BE%84%E4%B8%AD%E8%8E%B7%E5%8F%96JsonNode%E5%AD%97%E6%AE%B5"><span class="toc-text">5、路径中获取JsonNode字段</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81%E8%BD%AC%E6%8D%A2JsonNode%E5%AD%97%E6%AE%B5"><span class="toc-text">6、转换JsonNode字段</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E3%80%81%E5%88%9B%E5%BB%BAObjectNode%E5%AF%B9%E8%B1%A1"><span class="toc-text">7、创建ObjectNode对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8%E3%80%81Set-ObjectNode%E5%AD%97%E6%AE%B5"><span class="toc-text">8、Set ObjectNode字段</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9%E3%80%81Put-ObjectNode%E5%AD%97%E6%AE%B5"><span class="toc-text">9、Put ObjectNode字段</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10%E3%80%81Get-ObjectNode%E5%AD%97%E6%AE%B5"><span class="toc-text">10、Get ObjectNode字段</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11%E3%80%81%E5%88%A0%E9%99%A4ObjectNode%E5%AD%97%E6%AE%B5"><span class="toc-text">11、删除ObjectNode字段</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12%E3%80%81%E5%BE%AA%E7%8E%AFObjectNode%E5%AD%97%E6%AE%B5"><span class="toc-text">12、循环ObjectNode字段</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13%E3%80%81%E5%BE%AA%E7%8E%AFJsonNode%E5%AD%97%E6%AE%B5"><span class="toc-text">13、循环JsonNode字段</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94%E3%80%81JsonParser"><span class="toc-text">五、JsonParser</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAJsonParser"><span class="toc-text">1、创建一个JsonParser</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E7%94%A8JsonParser%E8%BD%AC%E5%8C%96JSON"><span class="toc-text">2、用JsonParser转化JSON</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AD%E3%80%81JsonGenerator"><span class="toc-text">六、JsonGenerator</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAJsonGenerator"><span class="toc-text">1、创建一个JsonGenerator</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81JsonGenerator%E7%94%9F%E6%88%90JSON"><span class="toc-text">2、JsonGenerator生成JSON</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E5%85%B3%E9%97%ADJsonGenerator"><span class="toc-text">3、关闭JsonGenerator</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%83%E3%80%81Jackson-%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3"><span class="toc-text">七、Jackson 常用注解</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E5%BA%8F%E5%88%97%E5%8C%96%E6%B3%A8%E8%A7%A3"><span class="toc-text">1、序列化注解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81-JsonGetter"><span class="toc-text">1、@JsonGetter</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81-JsonAnyGetter"><span class="toc-text">2、@JsonAnyGetter</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81-JsonPropertyOrder"><span class="toc-text">3、@JsonPropertyOrder</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81-JsonRawValue"><span class="toc-text">4、@JsonRawValue</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81-JsonValue"><span class="toc-text">5、@JsonValue</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81-JsonRootName"><span class="toc-text">6、@JsonRootName</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%E3%80%81-JsonSerialize"><span class="toc-text">7、@JsonSerialize</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%B3%A8%E8%A7%A3"><span class="toc-text">2、反序列化注解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81-JsonSetter"><span class="toc-text">1、@JsonSetter</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81-JsonAnySetter"><span class="toc-text">2、@JsonAnySetter</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81-JsonCreator"><span class="toc-text">3、@JsonCreator</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81-JacksonInject"><span class="toc-text">4、@JacksonInject</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81-JsonDeserialize"><span class="toc-text">5、@JsonDeserialize</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E5%B1%9E%E6%80%A7%E5%8C%85%E5%90%AB%E6%B3%A8%E8%A7%A3"><span class="toc-text">3、属性包含注解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81-JsonIgnore"><span class="toc-text">1、@JsonIgnore</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81-JsonIgnoreProperties"><span class="toc-text">2、@JsonIgnoreProperties</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81-JsonIgnoreType"><span class="toc-text">3、@JsonIgnoreType</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81-JsonInclude"><span class="toc-text">4、@JsonInclude</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JsonAutoDetect"><span class="toc-text">@JsonAutoDetect</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E5%A4%9A%E6%80%81%E5%A4%84%E7%90%86%E6%B3%A8%E8%A7%A3"><span class="toc-text">4、多态处理注解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81%E9%80%9A%E7%94%A8%E6%B3%A8%E8%A7%A3%EF%BC%88%E5%BA%8F%E5%88%97%E5%8C%96%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%83%BD%E7%94%9F%E6%95%88%EF%BC%89"><span class="toc-text">5、通用注解（序列化反序列化都生效）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81-JsonProperty"><span class="toc-text">1、@JsonProperty</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81-JsonFormat"><span class="toc-text">2、@JsonFormat</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81-JsonUnwrapped"><span class="toc-text">3、@JsonUnwrapped</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81-JsonView"><span class="toc-text">4、@JsonView</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81-JsonManagedReference-JsonBackReference"><span class="toc-text">5、@JsonManagedReference@JsonBackReference</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81-JsonIdentityInfo"><span class="toc-text">6、@JsonIdentityInfo</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%E3%80%81-JsonFilter"><span class="toc-text">7、@JsonFilter</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3"><span class="toc-text">6、自定义注解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3%E6%A1%88%E4%BE%8B%EF%BC%88%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E8%84%B1%E6%95%8F%EF%BC%89"><span class="toc-text">7、自定义注解案例（实现数据脱敏）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8%E3%80%81MixIn-%E6%B3%A8%E8%A7%A3"><span class="toc-text">8、MixIn 注解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E4%BD%BF%E7%AC%AC%E4%B8%89%E6%96%B9%E7%B1%BB-Jackson-%E5%8F%AF%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-text">1、使第三方类 Jackson 可序列化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E5%BF%BD%E7%95%A5%E5%B1%9E%E6%80%A7"><span class="toc-text">2、忽略属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E6%94%B9%E5%8F%98%E5%B1%9E%E6%80%A7%E5%90%8D"><span class="toc-text">3、改变属性名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E9%87%8D%E5%86%99%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BA%8F%E5%88%97%E5%8C%96%E5%99%A8%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%99%A8"><span class="toc-text">4、重写自定义序列化器和反序列化器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9%E3%80%81%E7%A6%81%E7%94%A8Jackson%E6%B3%A8%E8%A7%A3"><span class="toc-text">9、禁用Jackson注解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AB%E3%80%81Jackson-%E6%B3%A8%E8%A7%A3%E6%89%A9%E5%B1%95"><span class="toc-text">八、Jackson 注解扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#JsonIdentityReference"><span class="toc-text">@JsonIdentityReference</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JsonAppend"><span class="toc-text">@JsonAppend</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JsonNaming"><span class="toc-text">@JsonNaming</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JsonPropertyDescription"><span class="toc-text">@JsonPropertyDescription</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JsonPOJOBuilder"><span class="toc-text">@JsonPOJOBuilder</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B9%9D%E3%80%81SpringBoot-Jackson"><span class="toc-text">九、SpringBoot &amp; Jackson</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E5%BA%8F%E5%88%97%E5%8C%96-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96-%E6%97%B6%E9%97%B4%E6%A0%BC%E5%BC%8F"><span class="toc-text">1、序列化 &amp; 反序列化 时间格式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81-JsonFormat-%E6%B3%A8%E8%A7%A3%E9%85%8D%E7%BD%AE"><span class="toc-text">1、@JsonFormat 注解配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81application-yml-%E5%85%A8%E5%B1%80%E9%85%8D%E7%BD%AE"><span class="toc-text">2、application.yml 全局配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81Jackson-%E6%B3%A8%E8%A7%A3%E4%B8%8E%E5%85%A8%E5%B1%80%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%97%B6%E9%97%B4%E6%80%BB%E7%BB%93"><span class="toc-text">3、Jackson 注解与全局格式化时间总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81SpringBoot-LocalDateTime-%E6%97%B6%E9%97%B4%E6%A0%BC%E5%BC%8F%E5%A4%B1%E6%95%88%E8%A7%A3%E5%86%B3"><span class="toc-text">4、SpringBoot LocalDateTime 时间格式失效解决</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81SpringBoot-Jackson-%E9%85%8D%E7%BD%AE%E9%80%89%E9%A1%B9"><span class="toc-text">2、SpringBoot Jackson 配置选项</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81date-format-%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F%E5%8C%96"><span class="toc-text">1、date-format 日期格式化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81time-zone-%E6%97%B6%E5%8C%BA"><span class="toc-text">2、time-zone 时区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81locale-%E6%9C%AC%E5%9C%B0%E5%8C%96"><span class="toc-text">3、locale 本地化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81visibility-%E8%AE%BF%E9%97%AE%E7%BA%A7%E5%88%AB"><span class="toc-text">4、visibility 访问级别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81property-naming-strategy-%E5%B1%9E%E6%80%A7%E5%91%BD%E5%90%8D%E7%AD%96%E7%95%A5"><span class="toc-text">5、property-naming-strategy 属性命名策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81mapper-%E9%80%9A%E7%94%A8%E5%8A%9F%E8%83%BD%E5%BC%80%E5%85%B3%E9%85%8D%E7%BD%AE"><span class="toc-text">6、mapper 通用功能开关配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%E3%80%81serialization-%E5%BA%8F%E5%88%97%E5%8C%96%E7%89%B9%E6%80%A7%E5%BC%80%E5%85%B3%E9%85%8D%E7%BD%AE"><span class="toc-text">7、serialization 序列化特性开关配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8%E3%80%81deserialization-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%BC%80%E5%85%B3%E9%85%8D%E7%BD%AE"><span class="toc-text">8、deserialization 反序列化开关配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9%E3%80%81parser-%E9%85%8D%E7%BD%AE"><span class="toc-text">9、parser 配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10%E3%80%81generator-%E9%85%8D%E7%BD%AE"><span class="toc-text">10、generator 配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11%E3%80%81defaultPropertyInclusion-%E5%BA%8F%E5%88%97%E5%8C%96%E5%8C%85%E5%90%AB%E7%9A%84%E5%B1%9E%E6%80%A7%E9%85%8D%E7%BD%AE"><span class="toc-text">11、defaultPropertyInclusion 序列化包含的属性配置</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81SpringBoot-Jackson-%E9%85%8D%E7%BD%AE%E7%A4%BA%E4%BE%8B"><span class="toc-text">3、SpringBoot Jackson 配置示例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81SpringBoot-Jackson-%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D"><span class="toc-text">4、SpringBoot Jackson 自动装配</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E3%80%81SpringBoot-%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4%E5%A4%84%E7%90%86%E6%80%BB%E7%BB%93"><span class="toc-text">十、SpringBoot 日期时间处理总结</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81GET%E8%AF%B7%E6%B1%82%E5%8F%8APOST%E8%A1%A8%E5%8D%95%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A0%BC%E5%BC%8F%E8%BD%AC%E6%8D%A2"><span class="toc-text">1、GET请求及POST表单日期时间字符串格式转换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E4%BD%BF%E7%94%A8Spring%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8F%82%E6%95%B0%E8%BD%AC%E6%8D%A2%E5%99%A8%EF%BC%88Converter%EF%BC%89"><span class="toc-text">1、使用Spring自定义参数转换器（Converter）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81Converter%E4%B8%ADLambda%E4%BB%A3%E6%9B%BF%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%E5%90%AF%E5%8A%A8%E6%8A%A5%E9%94%99"><span class="toc-text">2、Converter中Lambda代替匿名内部类启动报错</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E5%9C%BA%E6%99%AF%E5%A4%8D%E7%8E%B0"><span class="toc-text">1、场景复现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E5%8E%9F%E5%9B%A0%E5%88%86%E6%9E%90"><span class="toc-text">2、原因分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95"><span class="toc-text">3、解决办法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E4%BD%BF%E7%94%A8Spring%E9%BB%98%E8%AE%A4%E8%87%AA%E5%B8%A6%E6%B3%A8%E8%A7%A3-DateTimeFormat"><span class="toc-text">3、使用Spring默认自带注解@DateTimeFormat</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E4%BD%BF%E7%94%A8-ControllerAdvice%E9%85%8D%E5%90%88-initBinder"><span class="toc-text">4、使用@ControllerAdvice配合@initBinder</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81JSON%E5%85%A5%E5%8F%82%E5%8F%8A%E8%BF%94%E5%9B%9E%E5%80%BC%E5%85%A8%E5%B1%80%E5%A4%84%E7%90%86"><span class="toc-text">2、JSON入参及返回值全局处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E4%BF%AE%E6%94%B9-application-yml-%E6%96%87%E4%BB%B6"><span class="toc-text">1、修改 application.yml 文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E5%88%A9%E7%94%A8Jackson%E7%9A%84JSON%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-text">2、利用Jackson的JSON序列化和反序列化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81JSON%E5%85%A5%E5%8F%82%E5%8F%8A%E8%BF%94%E5%9B%9E%E5%80%BC%E5%B1%80%E9%83%A8%E5%B7%AE%E5%BC%82%E5%8C%96%E5%A4%84%E7%90%86"><span class="toc-text">3、JSON入参及返回值局部差异化处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F%E5%AE%8C%E6%95%B4%E9%85%8D%E7%BD%AE"><span class="toc-text">4、日期时间格式化处理方式完整配置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81%E6%89%A9%E5%85%85%E6%BA%90%E7%A0%81%EF%BC%9A%E6%B7%B1%E5%85%A5%E7%A0%94%E7%A9%B6%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E8%BF%87%E7%A8%8B"><span class="toc-text">5、扩充源码：深入研究数据绑定过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81SpringBoot-%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4%E5%8F%82%E6%95%B0%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93"><span class="toc-text">6、SpringBoot 日期时间参数使用总结</span></a></li></ol></li></ol>
    
<style>
    .left-col .switch-btn,
    .left-col .switch-area {
        display: none;
    }
    .toc-level-3 i,
    .toc-level-3 ol {
        display: none !important;
    }
</style>
</div>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<ol>
<li>作者：三分恶；来源：Jackson用法详解：<a target="_blank" rel="noopener" href="https://fighter3.blog.csdn.net/article/details/106207324">https://fighter3.blog.csdn.net/article/details/106207324</a></li>
<li>作者：进击的阿晨；来源：Jackson注解大全：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44610216/article/details/118978414">https://blog.csdn.net/weixin_44610216/article/details/118978414</a></li>
<li>作者：萧明；来源：SpringBoot中使用Jackson总结：<a target="_blank" rel="noopener" href="https://blog.csdn.net/u010192145/article/details/115231894">https://blog.csdn.net/u010192145/article/details/115231894</a></li>
<li>来源：Spring Boot 3.0 日期时间处理总结：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_44866828/article/details/125073769">https://blog.csdn.net/qq_44866828/article/details/125073769</a></li>
</ol>
</blockquote>
<h1 id="一、Jackson-简介"><a href="#一、Jackson-简介" class="headerlink" title="一、Jackson 简介"></a>一、Jackson 简介</h1><p>Jackson 是当前用的比较广泛的，用来序列化和反序列化 json 的 Java 的开源框架。Jackson 社区相对比较活跃，更新速度也比较快， 从 Github 中的统计来看，Jackson 是最流行的 json 解析器之一 。 Spring MVC 的默认 json 解析器便是 Jackson。 Jackson 优点很多。Jackson 所依赖的 jar 包较少 ，简单易用。与其他 Java 的 json 的框架 Gson 等相比， Jackson 解析大的 json 文件速度比较快；Jackson 运行时占用内存比较低，性能比较好；Jackson 有灵活的 API，可以很容易进行扩展和定制。</p>
<p>Jackson 的 1.x 版本的包名是 org.codehaus.jackson ，当升级到 2.x 版本时，包名变为 com.fasterxml.jackson。</p>
<p>Jackson 的核心模块由三部分组成。</p>
<ul>
<li>jackson-core，核心包，提供基于”流模式”解析的相关 API，它包括 JsonPaser 和 JsonGenerator。 Jackson 内部实现正是通过高性能的流模式 API 的 JsonGenerator 和 JsonParser 来生成和解析 json。</li>
<li>jackson-annotations，注解包，提供标准注解功能；</li>
<li>jackson-databind ，数据绑定包， 提供基于”对象绑定” 解析的相关 API （ ObjectMapper ） 和”树模型” 解析的相关 API （JsonNode）；基于”对象绑定” 解析的 API 和”树模型”解析的 API 依赖基于”流模式”解析的 API。</li>
</ul>
<p>得益于 Jackson 高扩展性的设计，有很多常见的文本格式以及工具都有对 Jackson 的相应适配，如 CSV、XML、YAML 等。</p>
<p>源码地址：FasterXML&#x2F;jackson：<a target="_blank" rel="noopener" href="https://github.com/FasterXML/jackson">https://github.com/FasterXML/jackson</a></p>
<h1 id="二、Jackson-依赖"><a href="#二、Jackson-依赖" class="headerlink" title="二、Jackson 依赖"></a>二、Jackson 依赖</h1><p>Jackson 有三个核包，分别是 Streaming、Databid、Annotations，通过这些包可以方便的对 JSON 进行操作。</p>
<ul>
<li>Streaming[1] 在 jackson-core 模块。定义了一些流处理相关的 API 以及特定的 JSON 实现</li>
<li>Annotations[2] 在 jackson-annotations 模块，包含了 Jackson 中的注解</li>
<li>Databind[3] 在 jackson-databind 模块， 在 Streaming 包的基础上实现了数据绑定，依赖于 Streaming 和 Annotations 包</li>
</ul>
<p>使用Maven构建项目，需要添加依赖：</p>
<pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;
    &lt;artifactId&gt;jackson-core&lt;/artifactId&gt;
    &lt;version&gt;2.13.3&lt;/version&gt;
&lt;/dependency&gt;

&lt;dependency&gt;
    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;
    &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt;
    &lt;version&gt;2.13.3&lt;/version&gt;
&lt;/dependency&gt;

&lt;dependency&gt;
    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;
    &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;
    &lt;version&gt;2.13.3&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>当然了，jackson-databind 依赖 jackson-core 和 jackson-annotations，所以可以只显示地添加jackson-databind依赖，jackson-core 和 jackson-annotations 也随之添加到 Java 项目工程中。</p>
<pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;
    &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;
    &lt;version&gt;2.13.3&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>为了方便这篇文章后续的代码演示，我们同时引入 Junit 进行单元测试和 Lombok 以减少 Get&#x2F;Set 的代码编写。</p>
<pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;
    &lt;artifactId&gt;junit-jupiter&lt;/artifactId&gt;
    &lt;version&gt;5.8.2&lt;/version&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;

&lt;dependency&gt;
    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
    &lt;artifactId&gt;lombok&lt;/artifactId&gt;
    &lt;version&gt;1.18.24&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<h1 id="三、ObjectMapper"><a href="#三、ObjectMapper" class="headerlink" title="三、ObjectMapper"></a>三、ObjectMapper</h1><p>Jackson 最常用的 API 就是基于”对象绑定” 的 ObjectMapper：</p>
<ul>
<li><p>ObjectMapper可以从字符串，流或文件中解析JSON，并创建表示已解析的JSON的Java对象。 将JSON解析为Java对象也称为从JSON反序列化Java对象。</p>
</li>
<li><p>ObjectMapper也可以从Java对象创建JSON。 从Java对象生成JSON也称为将Java对象序列化为JSON。</p>
</li>
<li><p>Object映射器可以将JSON解析为自定义的类的对象，也可以解析置JSON树模型的对象。</p>
</li>
</ul>
<p>之所以称为ObjectMapper是因为它将JSON映射到Java对象（反序列化），或者将Java对象映射到JSON（序列化）。</p>
<h2 id="1、从JSON中获取Java对象（反序列化）"><a href="#1、从JSON中获取Java对象（反序列化）" class="headerlink" title="1、从JSON中获取Java对象（反序列化）"></a>1、从JSON中获取Java对象（反序列化）</h2><h3 id="1、Jackson-快速入门示例"><a href="#1、Jackson-快速入门示例" class="headerlink" title="1、Jackson 快速入门示例"></a>1、Jackson 快速入门示例</h3><p>将Json转换为Car类对象：</p>
<pre><code class="java">import com.fasterxml.jackson.databind.ObjectMapper;
import lombok.Data;

@Data
class Car &#123;
    private String brand = null;
    private int doors = 0;
&#125;

public class TestMain &#123;
    public static void main(String[] args) throws Exception &#123;
        String carJson = &quot;&#123; \&quot;brand\&quot; : \&quot;Mercedes\&quot;, \&quot;doors\&quot; : 5 &#125;&quot;;
        ObjectMapper objectMapper = new ObjectMapper();
        
        Car car = objectMapper.readValue(carJson, Car.class);
        System.out.println(&quot;car brand = &quot; + car.getBrand());
        System.out.println(&quot;car doors = &quot; + car.getDoors());
    &#125;
&#125;
</code></pre>
<p>打印结果如下：</p>
<pre><code>car brand = Mercedes
car doors = 5
</code></pre>
<h3 id="2、JSON字段和Java属性如何匹配"><a href="#2、JSON字段和Java属性如何匹配" class="headerlink" title="2、JSON字段和Java属性如何匹配"></a>2、JSON字段和Java属性如何匹配</h3><blockquote>
<p>ObjectMapper如何匹配JSON对象的字段和Java对象的属性：</p>
</blockquote>
<p>默认情况下，Jackson通过将JSON字段的名称与Java对象中的getter和setter方法进行匹配，将JSON对象的字段映射到Java对象中的属性。 Jackson删除了getter和setter方法名称的“ get”和“ set”部分，并将其余名称的第一个字符转换为小写。</p>
<p>例如，名为brand的JSON字段与名为getBrand()和setBrand()的Java getter和setter方法匹配。 名为engineNumber的JSON字段将与名为getEngineNumber()和setEngineNumber()的getter和setter匹配。</p>
<p>如果需要以其他方式将JSON对象字段与Java对象字段匹配，则需要使用自定义序列化器和反序列化器，或者使用一些Jackson注解。</p>
<h3 id="3、JSON-字符串-»»-Java-对象"><a href="#3、JSON-字符串-»»-Java-对象" class="headerlink" title="3、JSON 字符串 »» Java 对象"></a>3、JSON 字符串 »» Java 对象</h3><p>从JSON字符串读取Java对象非常容易。 上面已经有了一个示例：JSON字符串作为第一个参数传递给ObjectMapper的readValue()方法。 </p>
<pre><code class="java">ObjectMapper objectMapper = new ObjectMapper();
String carJson = &quot;&#123; \&quot;brand\&quot; : \&quot;Mercedes\&quot;, \&quot;doors\&quot; : 5 &#125;&quot;;
Car car = objectMapper.readValue(carJson, Car.class);
System.out.println(car);
// 输出内容: Car(brand=Mercedes, doors=5)
</code></pre>
<h3 id="4、JSON-字符输入流-»»-Java-对象"><a href="#4、JSON-字符输入流-»»-Java-对象" class="headerlink" title="4、JSON 字符输入流 »» Java 对象"></a>4、JSON 字符输入流 »» Java 对象</h3><p>还可以从通过Reader实例加载的JSON中读取对象。示例如下：</p>
<pre><code class="java">ObjectMapper objectMapper = new ObjectMapper();
String carJson = &quot;&#123; \&quot;brand\&quot; : \&quot;Mercedes\&quot;, \&quot;doors\&quot; : 4 &#125;&quot;;
Reader reader = new StringReader(carJson);

Car car = objectMapper.readValue(reader, Car.class);
System.out.println(car);
// 输出内容: Car(brand=Mercedes, doors=4)
</code></pre>
<h3 id="5、JSON-字节输入流-»»-Java-对象"><a href="#5、JSON-字节输入流-»»-Java-对象" class="headerlink" title="5、JSON 字节输入流 »» Java 对象"></a>5、JSON 字节输入流 »» Java 对象</h3><p>也可以使用ObjectMapper通过InputStream从JSON读取对象。 这是一个从InputStream读取JSON的示例：</p>
<pre><code class="java">ObjectMapper objectMapper = new ObjectMapper();
// 文件内容为: &#123; &quot;brand&quot; : &quot;Mercedes&quot;, &quot;doors&quot; : 4 &#125;
InputStream input = new FileInputStream(&quot;data/car.json&quot;);

Car car = objectMapper.readValue(input, Car.class);
System.out.println(car);
// 输出结果:  Car(brand=Mercedes, doors=4)
</code></pre>
<h3 id="6、JSON-文件-»»-Java-对象"><a href="#6、JSON-文件-»»-Java-对象" class="headerlink" title="6、JSON 文件 »» Java 对象"></a>6、JSON 文件 »» Java 对象</h3><p>从文件读取JSON当然可以通过FileReader（而不是StringReader）来完成，也可以通过File对象来完成。 这是从文件读取JSON的示例：</p>
<pre><code class="java">ObjectMapper objectMapper = new ObjectMapper();
// 文件内容为: &#123; &quot;brand&quot; : &quot;Mercedes&quot;, &quot;doors&quot; : 4 &#125;
File file = new File(&quot;D:\\car.json&quot;);

Car car = objectMapper.readValue(file, Car.class);
System.out.println(car);
// 输出结果:  Car(brand=Mercedes, doors=4)
</code></pre>
<h3 id="7、JSON-via-URL-»»-Java-对象"><a href="#7、JSON-via-URL-»»-Java-对象" class="headerlink" title="7、JSON via URL »» Java 对象"></a>7、JSON via URL »» Java 对象</h3><p>可以通过URL（java.net.URL）从JSON读取对象，如下所示：</p>
<pre><code class="java">ObjectMapper objectMapper = new ObjectMapper();
// 文件内容为: &#123; &quot;brand&quot; : &quot;Mercedes&quot;, &quot;doors&quot; : 4 &#125;
URL url = new URL(&quot;file:data/car.json&quot;);

Car car = objectMapper.readValue(url, Car.class);
System.out.println(car);
// 输出结果:  Car(brand=Mercedes, doors=4)
</code></pre>
<p>示例使用文件URL，也可以使用HTTP URL（类似于：<a target="_blank" rel="noopener" href="http://jenkov.com/some-data.json%EF%BC%89">http://jenkov.com/some-data.json）</a></p>
<h3 id="8、JSON-数组-»»-Java-对象数组"><a href="#8、JSON-数组-»»-Java-对象数组" class="headerlink" title="8、JSON 数组 »» Java 对象数组"></a>8、JSON 数组 »» Java 对象数组</h3><p>Jackson ObjectMapper也可以从JSON数组字符串读取对象数组。 这是从JSON数组字符串读取对象数组的示例：</p>
<pre><code class="java">ObjectMapper objectMapper = new ObjectMapper();
String jsonArray = &quot;[&#123;\&quot;brand\&quot;:\&quot;ford\&quot;&#125;, &#123;\&quot;brand\&quot;:\&quot;Fiat\&quot;&#125;]&quot;;

Car[] cars2 = objectMapper.readValue(jsonArray, Car[].class);
System.out.println(cars2[0] + &quot;、&quot; + cars2[1]);
// 输出结果:  Car(brand=ford, doors=0)、Car(brand=Fiat, doors=0)
</code></pre>
<p>需要将Car数组类作为第二个参数传递给readValue()方法。读取对象数组还可以与字符串以外的其他JSON源一起使用。 例如，文件，URL，InputStream，Reader等。</p>
<h3 id="9、JSON-数组-»»-List-对象"><a href="#9、JSON-数组-»»-List-对象" class="headerlink" title="9、JSON 数组 »» List 对象"></a>9、JSON 数组 »» List 对象</h3><p>Jackson ObjectMapper还可以从JSON数组字符串读取对象的Java List。 这是从JSON数组字符串读取对象列表的示例：</p>
<pre><code class="java">ObjectMapper objectMapper = new ObjectMapper();
String jsonArray = &quot;[&#123;\&quot;brand\&quot;:\&quot;ford\&quot;&#125;, &#123;\&quot;brand\&quot;:\&quot;Fiat\&quot;&#125;]&quot;;

List&lt;Car&gt; cars1 = objectMapper.readValue(jsonArray, new TypeReference&lt;List&lt;Car&gt;&gt;()&#123;&#125;);
System.out.println(cars1);
// 输出结果: [Car(brand=ford, doors=0), Car(brand=Fiat, doors=0)]
</code></pre>
<h3 id="10、JSON-字符串-»»-Map-对象"><a href="#10、JSON-字符串-»»-Map-对象" class="headerlink" title="10、JSON 字符串 »» Map 对象"></a>10、JSON 字符串 »» Map 对象</h3><p>Jackson ObjectMapper还可以从JSON字符串读取Java Map。 如果事先不知道将要解析的确切JSON结构，这种方法是很有用的。 通常，会将JSON对象读入Java Map。 JSON对象中的每个字段都将成为Java Map中的键，值对。</p>
<p>这是一个使用Jackson ObjectMapper从JSON字符串读取Java Map的示例：</p>
<pre><code class="java">ObjectMapper objectMapper = new ObjectMapper();
String jsonObject = &quot;&#123;\&quot;brand\&quot;:\&quot;ford\&quot;, \&quot;doors\&quot;:5&#125;&quot;;

Map&lt;String, Object&gt; jsonMap = objectMapper.readValue(jsonObject, new TypeReference&lt;Map&lt;String, Object&gt;&gt;()&#123;&#125;);
System.out.println(jsonMap);
// 输出结果: &#123;brand=ford, doors=5&#125;
</code></pre>
<h3 id="11、忽略未知的JSON字段"><a href="#11、忽略未知的JSON字段" class="headerlink" title="11、忽略未知的JSON字段"></a>11、忽略未知的JSON字段</h3><p>有时候，与要从JSON读取的Java对象相比，JSON中的字段更多。 默认情况下，Jackson在这种情况下会抛出异常，报不知道XYZ字段异常，因为在Java对象中找不到该字段。</p>
<p>但是，有时应该允许JSON中的字段多于相应的Java对象中的字段。 例如，要从REST服务解析JSON，而该REST服务包含的数据远远超出所需的。 在这种情况下，可以使用Jackson配置忽略这些额外的字段。 以下是配置Jackson ObjectMapper忽略未知字段的示例：</p>
<pre><code class="java">ObjectMapper objectMapper = new ObjectMapper();
objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);
</code></pre>
<p>错误示例：</p>
<pre><code class="java">@Data
class Car &#123;
    private String brand = null;
    private int doors = 0;
&#125;

public class TestMain &#123;
    public static void main(String[] args) throws Exception &#123;
        ObjectMapper objectMapper = new ObjectMapper();
        String carJson = &quot;&#123; \&quot;brand\&quot; : \&quot;Mercedes\&quot;, \&quot;doors\&quot; : 5, \&quot;name\&quot; : \&quot;Sam\&quot;&#125;&quot;;
        
        Car car = objectMapper.readValue(carJson, Car.class);
        System.out.println(car);
    &#125;
&#125;
</code></pre>
<p>打印内容如下（报错）：</p>
<pre><code>Exception in thread &quot;main&quot; com.fasterxml.jackson.databind.exc.UnrecognizedPropertyException: Unrecognized field &quot;name&quot; (class Car), not marked as ignorable (2 known properties: &quot;doors&quot;, &quot;brand&quot;])
 at [Source: (String)&quot;&#123; &quot;brand&quot; : &quot;Mercedes&quot;, &quot;doors&quot; : 5, &quot;name&quot; : &quot;Sam&quot;&#125;&quot;; line: 1, column: 48] (through reference chain: Car[&quot;name&quot;])
....
</code></pre>
<p>正确示例：</p>
<pre><code class="java">@Data
class Car &#123;
    private String brand = null;
    private int doors = 0;
&#125;

public class TestMain &#123;
    public static void main(String[] args) throws Exception &#123;
        ObjectMapper objectMapper = new ObjectMapper();
        objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);

        String carJson = &quot;&#123; \&quot;brand\&quot; : \&quot;Mercedes\&quot;, \&quot;doors\&quot; : 5, \&quot;name\&quot; : \&quot;Sam\&quot;&#125;&quot;;
        Car car = objectMapper.readValue(carJson, Car.class);
        System.out.println(car);
        // 输出结果: Car(brand=Mercedes, doors=5)
    &#125;
&#125;
</code></pre>
<h3 id="12、不允许基本类型为null"><a href="#12、不允许基本类型为null" class="headerlink" title="12、不允许基本类型为null"></a>12、不允许基本类型为null</h3><p>如果JSON字符串包含其值设置为null的字段（对于在相应的Java对象中是基本数据类型（int，long，float，double等）的字段），Jackson ObjectMapper默认会处理基本数据类型为null的情况，我们可以可以将Jackson ObjectMapper默认配置为失效，这样基本数据为null就会转换失败。 例如以下Car类：</p>
<p>现在，假设有一个与Car对象相对应的JSON字符串，如下所示：</p>
<pre><code class="json">&#123; &quot;brand&quot;:&quot;Toyota&quot;, &quot;doors&quot;:null &#125;
</code></pre>
<p>请注意，doors字段值为null。 Java中的基本数据类型不能为null值。 默认情况下，Jackson ObjectMapper会忽略原始字段的空值。 但是，可以将Jackson ObjectMapper配置设置为失败。</p>
<pre><code class="java">ObjectMapper objectMapper = new ObjectMapper();
objectMapper.configure(DeserializationFeature.FAIL_ON_NULL_FOR_PRIMITIVES, true);
</code></pre>
<p>在FAIL_ON_NULL_FOR_PRIMITIVES配置值设置为true的情况下，尝试将空JSON字段解析为基本类型Java字段时会遇到异常。 这是一个Java Jackson ObjectMapper示例，该示例将失败，因为JSON字段包含原始Java字段的空值：</p>
<pre><code class="java">@Data
class Car &#123;
    private String brand = null;
    private int doors = 0;
&#125;

public class TestMain &#123;
    public static void main(String[] args) throws Exception &#123;
        ObjectMapper objectMapper = new ObjectMapper();
        objectMapper.configure(DeserializationFeature.FAIL_ON_NULL_FOR_PRIMITIVES, true);

        String carJson = &quot;&#123; \&quot;brand\&quot;:\&quot;Toyota\&quot;, \&quot;doors\&quot;:null &#125;&quot;;
        Car car = objectMapper.readValue(carJson, Car.class);
        System.out.println(car);
    &#125;
&#125;
</code></pre>
<p>打印结果如下（报错）：</p>
<pre><code>Exception in thread &quot;main&quot; com.fasterxml.jackson.databind.exc.MismatchedInputException: Cannot map `null` into type `int` (set DeserializationConfig.DeserializationFeature.FAIL_ON_NULL_FOR_PRIMITIVES to &#39;false&#39; to allow)
 at [Source: (String)&quot;&#123; &quot;brand&quot;:&quot;Toyota&quot;, &quot;doors&quot;:null &#125;&quot;; line: 1, column: 29] (through reference chain: Car[&quot;doors&quot;])
</code></pre>
<h3 id="13、自定义反序列化"><a href="#13、自定义反序列化" class="headerlink" title="13、自定义反序列化"></a>13、自定义反序列化</h3><p>有时，可能希望以不同于Jackson ObjectMapper缺省方式的方式将JSON字符串读入Java对象。 可以将自定义反序列化器添加到ObjectMapper，可以按需要执行反序列化。</p>
<p>这是在Jackson的ObjectMapper中注册和使用自定义反序列化器的方式：</p>
<pre><code class="java">import com.fasterxml.jackson.core.JsonParser;
import com.fasterxml.jackson.core.JsonToken;
import com.fasterxml.jackson.core.Version;
import com.fasterxml.jackson.databind.DeserializationContext;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.deser.std.StdDeserializer;
import com.fasterxml.jackson.databind.module.SimpleModule;
import lombok.Data;

@Data
class Car &#123;
    private String brand = null;
    private int doors = 0;
&#125;

/**
 * 自定义反序列化器CarDeserializer类：
 */
class CarDeserializer extends StdDeserializer&lt;Car&gt; &#123;

    public CarDeserializer(Class&lt;?&gt; vc) &#123;
        super(vc);
    &#125;

    @Override
    public Car deserialize(JsonParser parser, DeserializationContext deserializer) throws Exception &#123;
        Car car = new Car();
        while (!parser.isClosed()) &#123;
            JsonToken jsonToken = parser.nextToken();

            if (JsonToken.FIELD_NAME.equals(jsonToken)) &#123;
                String fieldName = parser.getCurrentName();
                System.out.println(fieldName);

                jsonToken = parser.nextToken();

                if (&quot;brand&quot;.equals(fieldName)) &#123;
                    car.setBrand(parser.getValueAsString());
                &#125; else if (&quot;doors&quot;.equals(fieldName)) &#123;
                    car.setDoors(parser.getValueAsInt());
                &#125;
            &#125;
        &#125;
        return car;
    &#125;
&#125;

public class TestMain &#123;
    public static void main(String[] args) throws Exception &#123;
        String json = &quot;&#123; \&quot;brand\&quot; : \&quot;Ford\&quot;, \&quot;doors\&quot; : 6 &#125;&quot;;

        SimpleModule module = new SimpleModule(&quot;CarDeserializer&quot;, new Version(3, 1, 8, null, null, null));
        module.addDeserializer(Car.class, new CarDeserializer(Car.class));

        ObjectMapper mapper = new ObjectMapper();
        mapper.registerModule(module);

        Car car = mapper.readValue(json, Car.class);
        System.out.println(car);
    &#125;
&#125;
</code></pre>
<p>打印结果如下：</p>
<pre><code>brand
doors
Car(brand=Ford, doors=6)
</code></pre>
<h2 id="2、将Java对象写入JSON中（序列化）"><a href="#2、将Java对象写入JSON中（序列化）" class="headerlink" title="2、将Java对象写入JSON中（序列化）"></a>2、将Java对象写入JSON中（序列化）</h2><h3 id="1、Java对象-»»-JSON"><a href="#1、Java对象-»»-JSON" class="headerlink" title="1、Java对象 »» JSON"></a>1、Java对象 »» JSON</h3><p>Jackson ObjectMapper也可以用于从对象生成JSON。 可以使用以下方法之一进行操作：</p>
<ul>
<li>writeValue(参数, obj)：直接将传入的对象序列化为json，并且返回给客户端</li>
<li>writeValueAsString(obj)：从一个对象生成JSON，并将生成的JSON作为String返回给调用者</li>
<li>writeValueAsBytes(obj)：从一个对象生成JSON，并将生成的JSON作为字节数组返回给调用者</li>
</ul>
<p>三者的共同点：将将对象转为json字符串。</p>
<p>三者的不同点：writeValue（参数，obj）方法的参数有四种重载形式：</p>
<ul>
<li>第一种：file 将转换后的json字符串保存到指定的file文件中</li>
<li>第二种：writer 将转换后的json字符串保存到字符输出流中</li>
<li>第三重：dataOutput 将转换后的json字符串保存到数据输出流中</li>
<li>第四种：outputStream 将转换后的json字符串保存到字节输出流中</li>
<li>第五种：jsonGenerator 类</li>
</ul>
<p>这是一个从Car对象生成JSON的示例：</p>
<pre><code class="java">import com.fasterxml.jackson.core.*;
import com.fasterxml.jackson.databind.DeserializationContext;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.deser.std.StdDeserializer;
import com.fasterxml.jackson.databind.module.SimpleModule;
import lombok.Data;
import java.io.*;

@Data
class Car &#123;
    private String brand = null;
    private int doors = 0;
&#125;


public class TestMain &#123;
    public static void main(String[] args) throws Exception &#123;
        ObjectMapper objectMapper = new ObjectMapper();

        Car car = new Car();
        car.setBrand(&quot;BMW&quot;);
        car.setDoors(4);

        // 第一种：file 将转换后的json字符串保存到指定的file文件中
        objectMapper.writeValue(new File(&quot;D:\\car-1.json&quot;), car);
        // 第二种：writer 将转换后的json字符串保存到字符输出流中
        objectMapper.writeValue(new FileWriter(&quot;D:\\car-2.json&quot;), car);
        // 第三重：dataOutput 将转换后的json字符串保存到数据输出流中
        objectMapper.writeValue(new FileOutputStream(&quot;D:\\car-3.json&quot;), car);
        // 第四种：outputStream 将转换后的json字符串保存到字节输出流中
        objectMapper.writeValue((OutputStream) new DataOutputStream(new FileOutputStream(&quot;D:\\car-4.json&quot;)), car);

        // 第五种：jsonGenerator 类
        JsonFactory factory = new JsonFactory();
        JsonGenerator generator = factory.createGenerator(new File(&quot;D:\\car-5.json&quot;), JsonEncoding.UTF8);

        generator.writeStartObject();
        generator.writeStringField(&quot;brand&quot;, &quot;Mercedes&quot;);
        generator.writeNumberField(&quot;doors&quot;, 5);
        generator.writeEndObject();

        generator.close();
    &#125;
&#125;
</code></pre>
<p>此示例首先创建一个ObjectMapper，然后创建一个Car实例，最后调用ObjectMapper的writeValue()方法，该方法将Car对象转换为JSON并将其写入给定的FileOutputStream。</p>
<p>ObjectMapper的writeValueAsString()和writeValueAsBytes()都从一个对象生成JSON，并将生成的JSON作为String或字节数组返回。 示例如下：</p>
<pre><code class="java">ObjectMapper objectMapper = new ObjectMapper();

Car car = new Car();
car.setBrand(&quot;BMW&quot;);
car.setDoors(4);

String json = objectMapper.writeValueAsString(car);
System.out.println(json);
byte[] bytes = objectMapper.writeValueAsBytes(car);
System.out.println(new String(bytes));
// 输出内容: 
// &#123;&quot;brand&quot;:&quot;BMW&quot;,&quot;doors&quot;:4&#125;
// &#123;&quot;brand&quot;:&quot;BMW&quot;,&quot;doors&quot;:4&#125;
</code></pre>
<h3 id="2、自定义序列化"><a href="#2、自定义序列化" class="headerlink" title="2、自定义序列化"></a>2、自定义序列化</h3><p>有时，想要将Java对象序列化为JSON的方式与使用Jackson的默认方式不同。 例如，可能想要在JSON中使用与Java对象中不同的字段名称，或者希望完全省略某些字段。</p>
<p>Jackson可以在ObjectMapper上设置自定义序列化器。 该序列化器已为某个类注册，然后在每次要求ObjectMapper序列化Car对象时将调用该序列化器。</p>
<p>这是为Car类注册自定义序列化器的示例：</p>
<pre><code class="java">import com.fasterxml.jackson.core.JsonEncoding;
import com.fasterxml.jackson.core.JsonFactory;
import com.fasterxml.jackson.core.JsonGenerator;
import com.fasterxml.jackson.core.Version;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.SerializerProvider;
import com.fasterxml.jackson.databind.module.SimpleModule;
import com.fasterxml.jackson.databind.ser.std.StdSerializer;
import lombok.Data;
import java.io.*;

@Data
class Car &#123;
    private String brand = null;
    private int doors = 0;
&#125;

/**
 * 自定义反序列化器CarDeserializer类：
 */
class CarSerializer extends StdSerializer&lt;Car&gt; &#123;

    protected CarSerializer(Class&lt;Car&gt; t) &#123;
        super(t);
    &#125;

    public void serialize(Car car, JsonGenerator jsonGenerator, SerializerProvider serializerProvider) throws IOException &#123;
        jsonGenerator.writeStartObject();
        jsonGenerator.writeStringField(&quot;producer&quot;, car.getBrand());
        jsonGenerator.writeNumberField(&quot;doorCount&quot;, car.getDoors());
        jsonGenerator.writeEndObject();
    &#125;
&#125;

public class TestMain &#123;
    public static void main(String[] args) throws Exception &#123;
        CarSerializer carSerializer = new CarSerializer(Car.class);
        ObjectMapper objectMapper = new ObjectMapper();

        SimpleModule module = new SimpleModule(&quot;CarSerializer&quot;, new Version(2, 1, 3, null, null, null));
        module.addSerializer(Car.class, carSerializer);

        objectMapper.registerModule(module);

        Car car = new Car();
        car.setBrand(&quot;Mercedes&quot;);
        car.setDoors(5);

        String carJson = objectMapper.writeValueAsString(car);
        System.out.println(carJson);
        // 输出内容: &#123;&quot;producer&quot;:&quot;Mercedes&quot;,&quot;doorCount&quot;:5&#125;
    &#125;
&#125;
</code></pre>
<h2 id="3、Jackson-日期转化"><a href="#3、Jackson-日期转化" class="headerlink" title="3、Jackson 日期转化"></a>3、Jackson 日期转化</h2><p>默认情况下，Jackson会将java.util.Date对象序列化为其long型的值，该值是自1970年1月1日以来的毫秒数。但是，Jackson还支持将日期格式化为字符串。</p>
<h3 id="1、Date-«»-Long"><a href="#1、Date-«»-Long" class="headerlink" title="1、Date «» Long"></a>1、Date «» Long</h3><p>默认的Jackson日期格式，该格式将Date序列化为自1970年1月1日以来的毫秒数（long类型）所以反序列化也必须要是毫秒数（long）</p>
<p>这是一个包含Date字段的Java类示例（Date 转 Long 以及 Long 转 Date）：</p>
<pre><code class="java">import com.fasterxml.jackson.databind.ObjectMapper;
import java.text.SimpleDateFormat;
import java.util.Date;
import lombok.*;

@Data
@NoArgsConstructor
@AllArgsConstructor
class Transaction &#123;
    private String type = null;
    private Date date = null;
&#125;

public class TestMain &#123;
    public static void main(String[] args) throws Exception &#123;
        /**
         * Date 序列化成 Long
         */
        ObjectMapper objectMapper = new ObjectMapper();
        String output = objectMapper.writeValueAsString(new Transaction(&quot;transfer&quot;, new Date()));
        System.out.println(output);
        // 输出内容: &#123;&quot;type&quot;:&quot;transfer&quot;,&quot;date&quot;:1668744922635&#125;

        /**
         * Long 反序列化成 Date
         */
        String json = &quot;&#123; \&quot;type\&quot; : \&quot;transfer\&quot;, \&quot;date\&quot; : 1668738063531 &#125;&quot;;
        Transaction transaction = objectMapper.readValue(json, Transaction.class);
        System.out.println(transaction);
        // 输出内容: Transaction(type=transfer, date=Fri Nov 18 10:21:03 CST 2022)
    &#125;
&#125;
</code></pre>
<p>打印内容如下：</p>
<pre><code class="json">&#123;&quot;type&quot;:&quot;transfer&quot;,&quot;date&quot;:1668744922635&#125;
Transaction(type=transfer, date=Fri Nov 18 10:21:03 CST 2022)
</code></pre>
<h3 id="2、Date-«»-String"><a href="#2、Date-«»-String" class="headerlink" title="2、Date «» String"></a>2、Date «» String</h3><p>日期的long序列化格式不符合人类的时间查看格式。 因此，Jackson也支持文本日期格式。 可以通过在ObjectMapper上设置SimpleDateFormat来指定要使用的确切Jackson日期格式。 这是在Jackson的ObjectMapper上设置SimpleDateFormat的示例：</p>
<pre><code class="java">@Data
@NoArgsConstructor
@AllArgsConstructor
class Transaction &#123;
    private String type = null;
    private Date date = null;
&#125;

public class TestMain &#123;
    public static void main(String[] args) throws Exception &#123;
        /**
         * Date 序列化成 String
         */
        ObjectMapper objectMapper = new ObjectMapper();
        objectMapper.setDateFormat(new SimpleDateFormat(&quot;yyyy-MM-dd&quot;));
        String output = objectMapper.writeValueAsString(new Transaction(&quot;transfer&quot;, new Date()));
        System.out.println(output);
        // 输出内容: &#123;&quot;type&quot;:&quot;transfer&quot;,&quot;date&quot;:&quot;2022-11-18&quot;&#125;

        /**
         * String 反序列化成 Date
         * Long  反序列化成 Date
         */
        String json1 = &quot;&#123; \&quot;type\&quot; : \&quot;Dev\&quot;, \&quot;date\&quot; : \&quot;2022-11-18\&quot; &#125;&quot;;
        Transaction transaction = objectMapper.readValue(json1, Transaction.class);
        System.out.println(transaction);
        // 输出内容: Transaction(type=Dev, date=Fri Nov 18 00:00:00 CST 2022)
        String json2 = &quot;&#123; \&quot;type\&quot; : \&quot;transfer\&quot;, \&quot;date\&quot; : 1668738063531 &#125;&quot;;
        System.out.println(objectMapper.readValue(json2, Transaction.class));
        // 输出内容: Transaction(type=transfer, date=Fri Nov 18 10:21:03 CST 2022)
    &#125;
&#125;
</code></pre>
<p>打印结果如下：</p>
<pre><code class="json">&#123;&quot;type&quot;:&quot;transfer&quot;,&quot;date&quot;:&quot;2022-11-18&quot;&#125;
Transaction(type=Dev, date=Fri Nov 18 00:00:00 CST 2022)
Transaction(type=transfer, date=Fri Nov 18 10:21:03 CST 2022)
</code></pre>
<h3 id="3、LocalDateTime-类型"><a href="#3、LocalDateTime-类型" class="headerlink" title="3、LocalDateTime 类型"></a>3、LocalDateTime 类型</h3><p>为什么没有尝试设置 LocalDateTime 类型的时间呢？默认情况下进行 LocalDateTime 类的 JSON 转换会遇到报错。错误示例如下：</p>
<pre><code class="java">import com.fasterxml.jackson.databind.ObjectMapper;

import java.text.SimpleDateFormat;
import java.time.LocalDateTime;
import java.util.Date;
import lombok.*;

@Data
@NoArgsConstructor
@AllArgsConstructor
class Transaction &#123;
    private String type = null;
    private LocalDateTime localDateTime = null;
&#125;

public class TestMain &#123;
    public static void main(String[] args) throws Exception &#123;
        /**
         * LocalDateTime 序列化
         */
        try &#123;
            ObjectMapper objectMapper = new ObjectMapper();
            String output = objectMapper.writeValueAsString(new Transaction(&quot;transfer&quot;, LocalDateTime.now()));
            System.out.println(output);
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125;

        /**
         * LocalDateTime 反序列化 
         */
        try &#123;
            ObjectMapper objectMapper = new ObjectMapper();
            String json = &quot;&#123; \&quot;type\&quot; : \&quot;transfer\&quot;, \&quot;date\&quot; : 1668738063531 &#125;&quot;;
            Transaction transaction = objectMapper.readValue(json, Transaction.class);
            System.out.println(transaction);
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;
</code></pre>
<p>打印信息如下：</p>
<pre><code class="shell">## 序列化报错
com.fasterxml.jackson.databind.exc.InvalidDefinitionException: Java 8 date/time type `java.time.LocalDateTime` not supported by default: add Module &quot;com.fasterxml.jackson.datatype:jackson-datatype-jsr310&quot; to enable handling (through reference chain: Transaction[&quot;localDateTime&quot;])

## 反序列化报错
com.fasterxml.jackson.databind.exc.UnrecognizedPropertyException: Unrecognized field &quot;date&quot; (class Transaction), not marked as ignorable (2 known properties: &quot;type&quot;, &quot;localDateTime&quot;])
 at [Source: (String)&quot;&#123; &quot;type&quot; : &quot;transfer&quot;, &quot;date&quot; : 1668738063531 &#125;&quot;; line: 1, column: 46] (through reference chain: Transaction[&quot;date&quot;])## 
</code></pre>
<p>这里我们需要添加相应的数据绑定支持包。添加依赖：</p>
<pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;com.fasterxml.jackson.datatype&lt;/groupId&gt;
    &lt;artifactId&gt;jackson-datatype-jsr310&lt;/artifactId&gt;
    &lt;version&gt;2.13.3&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>然后在定义 ObjectMapper 时通过 findAndRegisterModules() 方法来注册依赖。这里需要注意：Jackson 默认序列化LocalDateTime返回是Integer数组：[2022,11,18,12,36,10,133708200]</p>
<pre><code class="java">import com.fasterxml.jackson.databind.ObjectMapper;
import java.text.SimpleDateFormat;
import java.time.LocalDateTime;
import java.util.Date;
import lombok.*;

@Data
@NoArgsConstructor
@AllArgsConstructor
class Transaction &#123;
    private String type = null;
    private LocalDateTime localDateTime = null;
&#125;

public class TestMain &#123;
    public static void main(String[] args) throws Exception &#123;
        /**
         * LocalDateTime 序列化
         */
        try &#123;
            ObjectMapper objectMapper = new ObjectMapper().findAndRegisterModules();
            String output = objectMapper.writeValueAsString(new Transaction(&quot;transfer&quot;, LocalDateTime.now()));
            System.out.println(output);
            // 输出内容: &#123;&quot;type&quot;:&quot;transfer&quot;,&quot;localDateTime&quot;:[2022,11,18,12,36,10,133708200]&#125;
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125;

        /**
         * LocalDateTime 反序列化
         */
        try &#123;
            ObjectMapper objectMapper = new ObjectMapper().findAndRegisterModules();
            String json = &quot;&#123;\&quot;type\&quot;:\&quot;transfer\&quot;,\&quot;localDateTime\&quot;:[2022,11,18,12,34,2,844805800]&#125;&quot;;
            Transaction transaction = objectMapper.readValue(json, Transaction.class);
            System.out.println(transaction);
            // 输出内容: Transaction(type=transfer, localDateTime=2022-11-18T12:34:02.844805800)
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;
</code></pre>
<p>打印内容如下，可以得到正常序列化与反序列化日志，不过序列化后的时间格式依旧奇怪。</p>
<pre><code>&#123;&quot;type&quot;:&quot;transfer&quot;,&quot;localDateTime&quot;:[2022,11,18,12,36,10,133708200]&#125;
Transaction(type=transfer, localDateTime=2022-11-18T12:34:02.844805800)
</code></pre>
<h3 id="4、时间格式化注解"><a href="#4、时间格式化注解" class="headerlink" title="4、时间格式化注解"></a>4、时间格式化注解</h3><pre><code class="java">import com.fasterxml.jackson.annotation.JsonFormat;
import com.fasterxml.jackson.databind.ObjectMapper;
import java.time.LocalDateTime;
import java.util.Date;
import lombok.*;

@Data
@NoArgsConstructor
@AllArgsConstructor
class Transaction &#123;
    private String type = null;
    @JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;, timezone = &quot;Asia/Shanghai&quot;)
    private Date date = null;
    @JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;, timezone = &quot;Asia/Shanghai&quot;)
    private LocalDateTime localDateTime = null;
&#125;

public class TestMain &#123;
    public static void main(String[] args) throws Exception &#123;
        /**
         * LocalDateTime、Date 序列化
         */
        ObjectMapper objectMapper = new ObjectMapper().findAndRegisterModules();
        String output = objectMapper.writeValueAsString(new Transaction(&quot;transfer&quot;, new Date(), LocalDateTime.now()));
        System.out.println(output);
        
        /**
         * LocalDateTime、Date 反序列化
         */
        objectMapper = new ObjectMapper().findAndRegisterModules();
        String json1 = &quot;&#123;\&quot;type\&quot;:\&quot;transfer\&quot; , \&quot;date\&quot; : 1668738063531, \&quot;localDateTime\&quot;:[2022,11,18,12,34,2]&#125;&quot;;
        System.out.println(objectMapper.readValue(json1, Transaction.class));

        String json2 = &quot;&#123;\&quot;type\&quot;:\&quot;transfer\&quot; , \&quot;date\&quot; : \&quot;2022-11-18 12:42:45\&quot;, \&quot;localDateTime\&quot;:[2022,11,18,12,34,2]&#125;&quot;;
        System.out.println(objectMapper.readValue(json2, Transaction.class));

        String json3 = &quot;&#123;\&quot;type\&quot;:\&quot;transfer\&quot; , \&quot;date\&quot; : \&quot;2022-11-18 12:42:45\&quot;, \&quot;localDateTime\&quot;:\&quot;2022-11-18 12:34:02\&quot;&#125;&quot;;
        System.out.println(objectMapper.readValue(json3, Transaction.class));
    &#125;
&#125;
</code></pre>
<p>打印结果如下</p>
<pre><code>&#123;&quot;type&quot;:&quot;transfer&quot;,&quot;date&quot;:&quot;2022-11-18 12:48:30&quot;,&quot;localDateTime&quot;:&quot;2022-11-18 12:48:30&quot;&#125;
Transaction(type=transfer, date=Fri Nov 18 10:21:03 CST 2022, localDateTime=2022-11-18T12:34:02)
Transaction(type=transfer, date=Fri Nov 18 12:42:45 CST 2022, localDateTime=2022-11-18T12:34:02)
Transaction(type=transfer, date=Fri Nov 18 12:42:45 CST 2022, localDateTime=2022-11-18T12:34:02)
</code></pre>
<h2 id="4、Jackson-JSON-树模型"><a href="#4、Jackson-JSON-树模型" class="headerlink" title="4、Jackson JSON 树模型"></a>4、Jackson JSON 树模型</h2><p>Jackson具有内置的树模型，可用于表示JSON对象。 如果不知道接收到的JSON的格式，或者由于某种原因而不能（或者只是不想）创建一个类来表示它，那么就要用到Jackson的树模型。 如果需要在使用或转化JSON之前对其进行操作，也需要被用到Jackson树模型。 所有这些情况在数据流场景中都很常见。</p>
<p>Jackson树模型由JsonNode类表示。 您可以使用Jackson ObjectMapper将JSON解析为JsonNode树模型，就像使用您自己的类一样。</p>
<p>以下将展示如何使用Jackson ObjectMapper读写JsonNode实例。</p>
<h3 id="1、Jackson-Tree-Model-示例"><a href="#1、Jackson-Tree-Model-示例" class="headerlink" title="1、Jackson Tree Model 示例"></a>1、Jackson Tree Model 示例</h3><p>下面是一个简单的例子：</p>
<pre><code class="java">import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import lombok.Data;

@Data
class Car &#123;
    private String brand = null;
    private int doors = 0;
&#125;

public class TestMain &#123;
    public static void main(String[] args) throws Exception &#123;
        String carJson = &quot;&#123; \&quot;brand\&quot; : \&quot;Mercedes\&quot;, \&quot;doors\&quot; : 5 &#125;&quot;;
        ObjectMapper objectMapper = new ObjectMapper();
        try &#123;
            JsonNode jsonNode = objectMapper.readValue(carJson, JsonNode.class);
            System.out.println(jsonNode);
            // 输出内容: &#123;&quot;brand&quot;:&quot;Mercedes&quot;,&quot;doors&quot;:5&#125;
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;
</code></pre>
<p>只需将JsonNode.class作为第二个参数传递给readValue()方法，而不是本教程前面的示例中使用的Car.class，就可以将JSON字符串解析为JsonNode对象而不是Car对象。 。</p>
<p>ObjectMapper类还具有一个特殊的readTree()方法，该方法返回JsonNode。 这是使用ObjectMapper readTree()方法将JSON解析为JsonNode的示例：</p>
<pre><code class="java">@Data
class Car &#123;
    private String brand = null;
    private int doors = 0;
&#125;

public class TestMain &#123;
    public static void main(String[] args) throws Exception &#123;
        String carJson = &quot;&#123; \&quot;brand\&quot; : \&quot;Mercedes\&quot;, \&quot;doors\&quot; : 5 &#125;&quot;;
        ObjectMapper objectMapper = new ObjectMapper();
        try &#123;
            JsonNode jsonNode = objectMapper.readTree(carJson);
            System.out.println(jsonNode);
            // 输出内容: &#123;&quot;brand&quot;:&quot;Mercedes&quot;,&quot;doors&quot;:5&#125;
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="2、Jackson-JsonNode-类"><a href="#2、Jackson-JsonNode-类" class="headerlink" title="2、Jackson JsonNode 类"></a>2、Jackson JsonNode 类</h3><p>通过JsonNode类，可以以非常灵活和动态的方式将JSON作为Java对象导航。这里了解一些如何使用它的基础知识。</p>
<p>将JSON解析为JsonNode（或JsonNode实例树）后，就可以浏览JsonNode树模型。 这是一个JsonNode示例，显示了如何访问JSON字段，数组和嵌套对象：</p>
<pre><code class="json">&#123;
    &quot;brand&quot;: &quot;Mercedes&quot;,
    &quot;doors&quot;: 5,
    &quot;owners&quot;: [&quot;John&quot;, &quot;Jack&quot;, &quot;Jill&quot;],
    &quot;nestedObject&quot;: &#123;
        &quot;field&quot;: &quot;value&quot;
    &#125;
&#125;
</code></pre>
<pre><code class="java">@Data
class Car &#123;
    private String brand = null;
    private int doors = 0;
&#125;

public class TestMain &#123;
    public static void main(String[] args) throws Exception &#123;
        String carJson = &quot;&#123; \&quot;brand\&quot; : \&quot;Mercedes\&quot;, \&quot;doors\&quot; : 5,&quot; +
                &quot;  \&quot;owners\&quot; : [\&quot;John\&quot;, \&quot;Jack\&quot;, \&quot;Jill\&quot;],&quot; +
                &quot;  \&quot;nestedObject\&quot; : &#123; \&quot;field\&quot; : \&quot;value\&quot; &#125; &#125;&quot;;

        ObjectMapper objectMapper = new ObjectMapper();
        try &#123;
            JsonNode jsonNode = objectMapper.readValue(carJson, JsonNode.class);

            JsonNode brandNode = jsonNode.get(&quot;brand&quot;);
            String brand = brandNode.asText();
            System.out.println(&quot;brand = &quot; + brand);

            JsonNode doorsNode = jsonNode.get(&quot;doors&quot;);
            int doors = doorsNode.asInt();
            System.out.println(&quot;doors = &quot; + doors);

            JsonNode array = jsonNode.get(&quot;owners&quot;);
            JsonNode jsonArray = array.get(0);
            String john = jsonArray.asText();
            System.out.println(&quot;john  = &quot; + john);

            JsonNode child = jsonNode.get(&quot;nestedObject&quot;);
            JsonNode childField = child.get(&quot;field&quot;);
            String field = childField.asText();
            System.out.println(&quot;field = &quot; + field);

        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;
</code></pre>
<p>打印内容如下</p>
<pre><code>brand = Mercedes
doors = 5
john  = John
field = value
</code></pre>
<p>请注意，JSON字符串现在包含一个称为owners的数组字段和一个称为nestedObject的嵌套对象字段。</p>
<p>无论访问的是字段，数组还是嵌套对象，都可以使用JsonNode类的get()方法。 通过将字符串作为参数提供给get()方法，可以访问JsonNode的字段。 如果JsonNode表示数组，则需要将索引传递给get()方法。 索引指定要获取的数组元素。</p>
<h3 id="3、Java-对象-»»-JsonNode"><a href="#3、Java-对象-»»-JsonNode" class="headerlink" title="3、Java 对象  »» JsonNode"></a>3、Java 对象  »» JsonNode</h3><p>可以使用Jackson ObjectMapper将Java对象转换为JsonNode，而JsonNode是转换后的Java对象的JSON表示形式。 可以通过Jackson ObjectMapper valueToTree()方法将Java对象转换为JsonNode。 这是一个使用ObjectMapper valueToTree()方法将Java对象转换为JsonNode的示例：</p>
<pre><code class="java">@Data
@NoArgsConstructor
@AllArgsConstructor
class Car &#123;
    private String brand = null;
    private int doors = 0;
&#125;

public class TestMain &#123;
    public static void main(String[] args) &#123;
        ObjectMapper objectMapper = new ObjectMapper();
        Car car = new Car(&quot;Cadillac&quot;, 18);
        JsonNode carJsonNode = objectMapper.valueToTree(car);
        System.out.println(carJsonNode);
        // 输出内容: &#123;&quot;brand&quot;:&quot;Cadillac&quot;,&quot;doors&quot;:18&#125;
    &#125;
&#125;
</code></pre>
<h3 id="4、JsonNode-»»-Java-对象"><a href="#4、JsonNode-»»-Java-对象" class="headerlink" title="4、JsonNode »» Java 对象"></a>4、JsonNode »» Java 对象</h3><p>可以使用Jackson ObjectMapper treeToValue()方法将JsonNode转换为Java对象。 这类似于使用Jackson Jackson的ObjectMapper将JSON字符串（或其他来源）解析为Java对象。 唯一的区别是，JSON源是JsonNode。 这是一个使用Jackson ObjectMapper treeToValue()方法将JsonNode转换为Java对象的示例：</p>
<pre><code class="java">@Data
@NoArgsConstructor
@AllArgsConstructor
class Car &#123;
    private String brand = null;
    private int doors = 0;
&#125;

public class TestMain &#123;
    public static void main(String[] args) throws Exception &#123;
        String carJson = &quot;&#123; \&quot;brand\&quot; : \&quot;Mercedes\&quot;, \&quot;doors\&quot; : 5 &#125;&quot;;
        ObjectMapper objectMapper = new ObjectMapper();

        // JSON字符串 转换 JsonNode对象
        JsonNode carJsonNode = objectMapper.readTree(carJson);
        System.out.println(carJsonNode);
        // 输出内容: &#123;&quot;brand&quot;:&quot;Mercedes&quot;,&quot;doors&quot;:5&#125;

        // JsonNode对象 转 Java对象
        Car car = objectMapper.treeToValue(carJsonNode, Car.class);
        System.out.println(car);
        // 输出内容: Car(brand=Mercedes, doors=5)
    &#125;
&#125;
</code></pre>
<p>上面的示例有点“人为”，因为我们首先将JSON字符串转换为JsonNode，然后将JsonNode转换为Car对象。 显然，如果我们有对原始JSON字符串的引用，则最好将其直接转换为Car对象，而无需先将其转换为JsonNode。</p>
<h1 id="四、JsonNode"><a href="#四、JsonNode" class="headerlink" title="四、JsonNode"></a>四、JsonNode</h1><p>Jackson JsonNode类com.fasterxml.jackson.databind.JsonNode是Jackson的JSON树形模型（对象图模型）。 Jackson可以将JSON读取到JsonNode实例中，然后将JsonNode写入JSON。 因此，这一节将说明如何将JSON反序列化为JsonNode以及将JsonNode序列化为JSON。 此Jackson JsonNode教程还将说明如何从头开始构建JsonNode对象图，因此以后可以将它们序列化为JSON。</p>
<h2 id="1、JsonNode-vs-ObjectNode"><a href="#1、JsonNode-vs-ObjectNode" class="headerlink" title="1、JsonNode vs ObjectNode"></a>1、JsonNode vs ObjectNode</h2><p>Jackson JsonNode类是不可变的。 这意味着，实际上不能直接构建JsonNode实例的对象图。 而是创建JsonNode子类ObjectNode的对象图。 作为JsonNode的子类，可以在可以使用JsonNode的任何地方使用ObjectNode。</p>
<h2 id="2、JSON转JsonNode"><a href="#2、JSON转JsonNode" class="headerlink" title="2、JSON转JsonNode"></a>2、JSON转JsonNode</h2><p>要使用Jackson将JSON读取到JsonNode中，首先需要创建一个Jackson ObjectMapper实例。 在ObjectMapper实例上，调用readTree()并将JSON源作为参数传递。 这是将JSON反序列化为JsonNode的示例：</p>
<pre><code class="java">import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;

public class TestMain &#123;
    public static void main(String[] args) throws Exception &#123;
        String json = &quot;&#123; \&quot;f1\&quot; : \&quot;v1\&quot; &#125; &quot;;
        ObjectMapper objectMapper = new ObjectMapper();

        JsonNode jsonNode = objectMapper.readTree(json);
        System.out.println(jsonNode.get(&quot;f1&quot;).asText());
        // 输出内容: v1
    &#125;
&#125;
</code></pre>
<h2 id="3、JsonNode转JSON"><a href="#3、JsonNode转JSON" class="headerlink" title="3、JsonNode转JSON"></a>3、JsonNode转JSON</h2><p>要将Jackson的JsonNode写入JSON，还需要一个Jackson ObjectMapper实例。 在ObjectMapper上，调用writeValueAsString()方法或任何适合需要的写入方法。 这是将JsonNode写入JSON的示例：</p>
<pre><code class="java">import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;

public class TestMain &#123;
    public static void main(String[] args) throws Exception &#123;
        JsonNode jsonNode = new ObjectMapper().readTree(&quot;&#123; \&quot;f1\&quot; : \&quot;v1\&quot; &#125;&quot;);

        ObjectMapper objectMapper = new ObjectMapper();
        String json = objectMapper.writeValueAsString(jsonNode);
        System.out.println(json);
        // 输出内容: 
    &#125;
&#125;
</code></pre>
<h2 id="4、获取JsonNode字段"><a href="#4、获取JsonNode字段" class="headerlink" title="4、获取JsonNode字段"></a>4、获取JsonNode字段</h2><p>JsonNode可以像JSON对象一样具有字段。 假设已将以下JSON解析为JsonNode：</p>
<pre><code class="java">import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;

public class TestMain &#123;
    public static void main(String[] args) throws Exception &#123;
        JsonNode jsonNode = new ObjectMapper().readTree(&quot;&#123;\&quot;field1\&quot; : \&quot;value1\&quot;, \&quot;field2\&quot; : 999&#125;&quot;);
        JsonNode field1 = jsonNode.get(&quot;field1&quot;);
        JsonNode field2 = jsonNode.get(&quot;field2&quot;);
        System.out.println(field1 + &quot;、&quot; + field2);
        // 输出内容: &quot;value1&quot;、999
    &#125;
&#125;
</code></pre>
<p>请注意，即使两个字段都是String字段，get()方法也始终返回JsonNode来表示该字段。</p>
<h2 id="5、路径中获取JsonNode字段"><a href="#5、路径中获取JsonNode字段" class="headerlink" title="5、路径中获取JsonNode字段"></a>5、路径中获取JsonNode字段</h2><p>Jackson JsonNode有一个称为at()的特殊方法。 at()方法可以从JSON图中以给定JsonNode为根的任何位置访问JSON字段。 假设JSON结构如下所示：</p>
<pre><code class="json">&#123;
    &quot;identification&quot; :  &#123;
        &quot;name&quot; : &quot;James&quot;,
        &quot;ssn&quot;: &quot;ABC123552&quot;
    &#125;
&#125;
</code></pre>
<p>如果将此JSON解析为JsonNode，则可以使用at()方法访问名称字段，如下所示：</p>
<pre><code class="java">JsonNode nameNode = jsonNode.at(&quot;/identification/name&quot;);
</code></pre>
<p>注意传递给at()方法的参数：字符串&#x2F; identification &#x2F; name。 这是一个JSON路径表达式。 此路径表达式指定从根JsonNode到您要访问其值的字段的完整路径。 这类似于从文件系统根目录到Unix文件系统中文件的路径。</p>
<p><strong>请注意</strong>：JSON路径表达式必须以斜杠字符（&#x2F;字符）开头。</p>
<p>at()方法返回一个JsonNode，它表示请求的JSON字段。 要获取该字段的实际值，需要调用下一部分介绍的方法之一。 如果没有节点与给定的路径表达式匹配，则将返回null。</p>
<pre><code class="java">import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;

public class TestMain &#123;
    public static void main(String[] args) throws Exception &#123;
        String json = &quot;&#123;\n&quot; +
                &quot;    \&quot;identification\&quot; :  &#123;\n&quot; +
                &quot;        \&quot;name\&quot; : \&quot;James\&quot;,\n&quot; +
                &quot;        \&quot;ssn\&quot;: \&quot;ABC123552\&quot;\n&quot; +
                &quot;    &#125;\n&quot; +
                &quot;&#125;&quot;;
        JsonNode jsonNode = new ObjectMapper().readTree(json);

        JsonNode identificationNode = jsonNode.at(&quot;/identification&quot;);
        System.out.println(identificationNode);
        // 输出内容: &#123;&quot;name&quot;:&quot;James&quot;,&quot;ssn&quot;:&quot;ABC123552&quot;&#125;

        JsonNode nameNode = jsonNode.at(&quot;/identification/name&quot;);
        System.out.println(nameNode);
        // 输出内容: &quot;James&quot;
    &#125;
&#125;
</code></pre>
<h2 id="6、转换JsonNode字段"><a href="#6、转换JsonNode字段" class="headerlink" title="6、转换JsonNode字段"></a>6、转换JsonNode字段</h2><p>Jackson JsonNode类包含一组可以将字段值转换为另一种数据类型的方法。 例如，将String字段值转换为long或相反。 这是将JsonNode字段转换为一些更常见的数据类型的示例：</p>
<pre><code class="java">String f2Str = jsonNode.get(&quot;f1&quot;).asText();
double f2Dbl = jsonNode.get(&quot;f2&quot;).asDouble();
int    f2Int = jsonNode.get(&quot;f3&quot;).asInt();
long   f2Lng = jsonNode.get(&quot;f4&quot;).asLong();
</code></pre>
<p><strong>使用默认值转换：</strong>如果JsonNode中的字段可以为null，则在尝试转换它时可以提供默认值。 这是使用默认值调用转换方法的示例：</p>
<pre><code class="java">import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;

public class TestMain &#123;
    public static void main(String[] args) throws Exception &#123;
        String json = &quot;&#123; \&quot;f1\&quot;:\&quot;Hello\&quot;, \&quot;f2\&quot;:null &#125;&quot;;
        ObjectMapper objectMapper = new ObjectMapper();

        JsonNode jsonNode = objectMapper.readTree(json);
        String f2Value = jsonNode.get(&quot;f2&quot;).asText(&quot;Default&quot;);
        System.out.println(f2Value);
        // 输出内容: Default
    &#125;
&#125;
</code></pre>
<p>在示例的JSON字符串中可以看到，声明了f2字段，但将其设置为null。 在这种情况下，调用jsonNode.get（“ f2”）。asText（“ Default”）将返回默认值，在此示例中为字符串Default。asDouble()，asInt()和asLong()方法还可以采用默认参数值，如果尝试从中获取值的字段为null，则将返回默认参数值。</p>
<p>请注意：如果该字段在JSON中未显式设置为null，但在JSON中丢失，则调用jsonNode.get(“fieldName”) 将返回Java null值，您无法在该Java值上调用asInt() ，asDouble()，asLong()或asText()。 如果尝试这样做，将会导致NullPointerException。 这是说明这种情况的示例：</p>
<pre><code class="java">import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;

public class TestMain &#123;
    public static void main(String[] args) throws Exception &#123;
        String json = &quot;&#123; \&quot;f1\&quot;:\&quot;Hello\&quot; &#125;&quot;;
        ObjectMapper objectMapper = new ObjectMapper();

        JsonNode jsonNode = objectMapper.readTree(json);
        JsonNode f2FieldNode = jsonNode.get(&quot;f2&quot;);
        System.out.println(f2FieldNode);
        // 输出内容: null
    &#125;
&#125;
</code></pre>
<h2 id="7、创建ObjectNode对象"><a href="#7、创建ObjectNode对象" class="headerlink" title="7、创建ObjectNode对象"></a>7、创建ObjectNode对象</h2><p>如前所述，JsonNode类是不可变的。 要创建JsonNode对象图，必须能够更改图中的JsonNode实例，例如 设置属性值和子JsonNode实例等。由于是不可变的，因此无法直接使用JsonNode来实现。</p>
<p>而是创建一个ObjectNode实例，该实例是JsonNode的子类。 这是一个通过Jackson ObjectMapper createObjectNode()方法创建ObjectNode的示例：</p>
<pre><code class="java">ObjectMapper objectMapper = new ObjectMapper();
ObjectNode objectNode = objectMapper.createObjectNode();
</code></pre>
<h2 id="8、Set-ObjectNode字段"><a href="#8、Set-ObjectNode字段" class="headerlink" title="8、Set ObjectNode字段"></a>8、Set ObjectNode字段</h2><p>要在Jackson ObjectNode上设置字段，可以调用其set()方法，并将字段名称String和JsonNode作为参数传递。 这是在Jackson的ObjectNode上设置字段的示例：</p>
<pre><code class="java">import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ObjectNode;

public class TestMain &#123;
    public static void main(String[] args) throws Exception &#123;
        JsonNode childNode = new ObjectMapper().readTree(&quot;&#123; \&quot;f1\&quot; : \&quot;v1\&quot; &#125;&quot;);

        ObjectMapper objectMapper = new ObjectMapper();
        ObjectNode parentNode = objectMapper.createObjectNode();
        parentNode.set(&quot;child1&quot;, childNode);
        System.out.println(parentNode);
        // 输出内容: &#123;&quot;child1&quot;:&#123;&quot;f1&quot;:&quot;v1&quot;&#125;&#125;
    &#125;
&#125;
</code></pre>
<h2 id="9、Put-ObjectNode字段"><a href="#9、Put-ObjectNode字段" class="headerlink" title="9、Put ObjectNode字段"></a>9、Put ObjectNode字段</h2><p>ObjectNode类还具有一组方法，可以直接为字段put(设置)值。 这比尝试将原始值转换为JsonNode并使用set()进行设置要容易得多。 以下是使用put()方法为ObjectNode上的字段设置字符串值的示例：</p>
<pre><code class="java">import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ObjectNode;

public class TestMain &#123;
    public static void main(String[] args) &#123;
        ObjectMapper objectMapper = new ObjectMapper();
        ObjectNode objectNode = objectMapper.createObjectNode();
        objectNode.put(&quot;field1&quot;, &quot;value1&quot;);
        objectNode.put(&quot;field2&quot;, 123);
        objectNode.put(&quot;field3&quot;, 999.999);
        System.out.println(objectNode);
        // 输出内容: &#123;&quot;field1&quot;:&quot;value1&quot;,&quot;field2&quot;:123,&quot;field3&quot;:999.999&#125;
    &#125;
&#125;
</code></pre>
<h2 id="10、Get-ObjectNode字段"><a href="#10、Get-ObjectNode字段" class="headerlink" title="10、Get ObjectNode字段"></a>10、Get ObjectNode字段</h2><p>ObjectNode类可以直接通过get(field)方法获取value的值，返回的是JsonNode对象，不过只能一层一层获取，多层结构无法一次性就获取到最内部的value。示例如下：</p>
<pre><code class="java">import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ObjectNode;

public class TestMain &#123;
    public static void main(String[] args) throws Exception &#123;
        JsonNode childNode = new ObjectMapper().readTree(&quot;&#123; \&quot;f1\&quot; : \&quot;v1\&quot; &#125;&quot;);
        ObjectNode parentNode = new ObjectMapper().createObjectNode();
        parentNode.set(&quot;child1&quot;, childNode);
        JsonNode child1 = parentNode.get(&quot;child1&quot;);
        System.out.println(child1);
        // 输出内容: &#123;&quot;f1&quot;:&quot;v1&quot;&#125;
        System.out.println(parentNode.get(&quot;f1&quot;));
        // 输出内容: null
    &#125;
&#125;
</code></pre>
<h2 id="11、删除ObjectNode字段"><a href="#11、删除ObjectNode字段" class="headerlink" title="11、删除ObjectNode字段"></a>11、删除ObjectNode字段</h2><p>ObjectNode类具有一个称为remove()的方法，该方法可用于从ObjectNode中删除字段。 这是一个通过其remove()方法从Jackson ObjectNode删除字段的示例：</p>
<pre><code class="java">import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ObjectNode;

public class TestMain &#123;
    public static void main(String[] args) &#123;
        ObjectMapper objectMapper = new ObjectMapper();
        ObjectNode objectNode = objectMapper.createObjectNode();
        objectNode.put(&quot;field1&quot;, &quot;value1&quot;);
        objectNode.put(&quot;field2&quot;, 123);
        objectNode.put(&quot;field3&quot;, 999.999);
        System.out.println(objectNode);
        // 输出内容: &#123;&quot;field1&quot;:&quot;value1&quot;,&quot;field2&quot;:123,&quot;field3&quot;:999.999&#125;

        // 删除字段
        objectNode.remove(&quot;field3&quot;);
        System.out.println(objectNode);
        // 输出内容: &#123;&quot;field1&quot;:&quot;value1&quot;,&quot;field2&quot;:123&#125;

    &#125;
&#125;
</code></pre>
<h2 id="12、循环ObjectNode字段"><a href="#12、循环ObjectNode字段" class="headerlink" title="12、循环ObjectNode字段"></a>12、循环ObjectNode字段</h2><p>ObjectNode类具有一个名为fieldNames()的方法，该方法返回一个Iterator，可以迭代JsonNode的所有字段名称。 我们可以使用字段名称来获取字段值。 这是一个迭代Jackson ObjectNode的所有字段名称和值的示例：</p>
<pre><code class="java">import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ObjectNode;

import java.util.Iterator;

public class TestMain &#123;
    public static void main(String[] args) throws Exception &#123;
        JsonNode childNode = new ObjectMapper().readTree(&quot;&#123;\&quot;f1\&quot; : \&quot;v1\&quot;, \&quot;f2\&quot; : \&quot;v2\&quot;&#125;&quot;);
        ObjectNode parentNode = new ObjectMapper().createObjectNode();
        parentNode.set(&quot;child1&quot;, childNode);

        // 首先获取所以key名称, 然后通过key名后去value值
        Iterator&lt;String&gt; fieldNames1 = parentNode.fieldNames();
        while(fieldNames1.hasNext()) &#123;
            String fieldName = fieldNames1.next();
            JsonNode field = parentNode.get(fieldName);
            System.out.println(field);
        &#125;
    &#125;
&#125;
</code></pre>
<p>打印结果如下</p>
<pre><code>&#123;&quot;f1&quot;:&quot;v1&quot;,&quot;f2&quot;:&quot;v2&quot;&#125;
</code></pre>
<h2 id="13、循环JsonNode字段"><a href="#13、循环JsonNode字段" class="headerlink" title="13、循环JsonNode字段"></a>13、循环JsonNode字段</h2><p>JsonNode类具有一个名为fieldNames()的方法，该方法返回一个Iterator，可以迭代JsonNode的所有字段名称。 我们可以使用字段名称来获取字段值。 这是一个迭代Jackson JsonNode的所有字段名称和值的示例：</p>
<pre><code class="java">import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;

import java.util.Iterator;

public class TestMain &#123;
    public static void main(String[] args) throws Exception &#123;
        JsonNode jsonNode = new ObjectMapper().readTree(&quot;&#123;\&quot;f1\&quot; : \&quot;v1\&quot;, \&quot;f2\&quot; : \&quot;v2\&quot;&#125;&quot;);
        // 首先获取所以key名称, 然后通过key名后去value值
        Iterator&lt;String&gt; fieldNames = jsonNode.fieldNames();
        while(fieldNames.hasNext()) &#123;
            String fieldName = fieldNames.next();
            JsonNode field = jsonNode.get(fieldName);
            System.out.println(field);
        &#125;

        System.out.println(&quot;=================================&quot;);

        String json = &quot;&#123;\n&quot; +
                &quot;    \&quot;identification\&quot; :  &#123;\n&quot; +
                &quot;        \&quot;name\&quot; : \&quot;James\&quot;,\n&quot; +
                &quot;        \&quot;ssn\&quot;: \&quot;ABC123552\&quot;\n&quot; +
                &quot;    &#125;\n&quot; +
                &quot;&#125;&quot;;
        JsonNode jsonNode2 = new ObjectMapper().readTree(json);
        // 首先获取所以key名称, 然后通过key名后去value值
        Iterator&lt;String&gt; fieldNames2 = jsonNode2.fieldNames();
        while(fieldNames2.hasNext()) &#123;
            String fieldName = fieldNames2.next();
            JsonNode field = jsonNode2.get(fieldName);
            System.out.println(field);
        &#125;
    &#125;
&#125;
</code></pre>
<h1 id="五、JsonParser"><a href="#五、JsonParser" class="headerlink" title="五、JsonParser"></a>五、JsonParser</h1><p>Jackson JsonParser类是一个底层一些的JSON解析器。 它类似于XML的Java StAX解析器，差别是JsonParser解析JSON而不解析XML。JsonParser的运行层级低于Jackson ObjectMapper。 这使得JsonParser比ObjectMapper更快，但使用起来也比较麻烦。</p>
<h2 id="1、创建一个JsonParser"><a href="#1、创建一个JsonParser" class="headerlink" title="1、创建一个JsonParser"></a>1、创建一个JsonParser</h2><p>为了创建Jackson JsonParser，首先需要创建一个JsonFactory。 JsonFactory用于创建JsonParser实例。 JsonFactory类包含几个createParser()方法，每个方法都使用不同的JSON源作为参数。</p>
<p>这是创建一个JsonParser来从字符串中解析JSON的示例：</p>
<pre><code class="java">import com.fasterxml.jackson.core.JsonFactory;
import com.fasterxml.jackson.core.JsonParser;

public class TestMain &#123;
    public static void main(String[] args) throws Exception &#123;
        String json = &quot;&#123;\&quot;f1\&quot; : \&quot;v1\&quot;, \&quot;f2\&quot; : \&quot;v2\&quot;&#125;&quot;;
        JsonFactory factory = new JsonFactory();
        JsonParser parser  = factory.createParser(json);
    &#125;
&#125;
</code></pre>
<h2 id="2、用JsonParser转化JSON"><a href="#2、用JsonParser转化JSON" class="headerlink" title="2、用JsonParser转化JSON"></a>2、用JsonParser转化JSON</h2><p>一旦创建了Jackson JsonParser，就可以使用它来解析JSON。 JsonParser的工作方式是将JSON分解为一系列令牌，可以一个一个地迭代令牌。</p>
<p>这是一个JsonParser示例，它简单地循环遍历所有标记并将它们输出到System.out。 这是一个实际上很少用示例，只是展示了将JSON分解成的令牌，以及如何遍历令牌的基础知识。</p>
<pre><code class="java">import com.fasterxml.jackson.core.JsonFactory;
import com.fasterxml.jackson.core.JsonParser;
import com.fasterxml.jackson.core.JsonToken;

public class TestMain &#123;
    public static void main(String[] args) throws Exception &#123;
        String json = &quot;&#123;\&quot;f1\&quot; : \&quot;v1\&quot;, \&quot;f2\&quot; : \&quot;v2\&quot;&#125;&quot;;
        JsonFactory factory = new JsonFactory();
        JsonParser parser = factory.createParser(json);
        while (!parser.isClosed()) &#123;
            JsonToken jsonToken = parser.nextToken();
            System.out.println(&quot;jsonToken = &quot; + jsonToken);
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code>jsonToken = START_OBJECT
jsonToken = FIELD_NAME
jsonToken = VALUE_STRING
jsonToken = FIELD_NAME
jsonToken = VALUE_STRING
jsonToken = END_OBJECT
jsonToken = null
</code></pre>
<p>只要JsonParser的isClosed()方法返回false，那么JSON源中仍然会有更多的令牌。</p>
<p>可以使用JsonParser的nextToken()获得一个JsonToken。 您可以使用此JsonToken实例检查给定的令牌。 令牌类型由JsonToken类中的一组常量表示。 这些常量是：</p>
<pre><code>START_OBJECT
END_OBJECT
START_ARRAY
END_ARRAY
FIELD_NAME
VALUE_EMBEDDED_OBJECT
VALUE_FALSE
VALUE_TRUE
VALUE_NULL
VALUE_STRING
VALUE_NUMBER_INT
VALUE_NUMBER_FLOAT
</code></pre>
<p>可以使用这些常量来找出当前JsonToken是什么类型的令牌。 可以通过这些常量的equals()方法进行操作。 这是一个例子：</p>
<pre><code class="java">import com.fasterxml.jackson.core.*;
import lombok.Data;

@Data
class Car &#123;
    public String brand = null;
    public int doors = 0;
&#125;

public class TestMain &#123;
    public static void main(String[] args) throws Exception &#123;
        String carJson = &quot;&#123; \&quot;brand\&quot; : \&quot;Mercedes\&quot;, \&quot;doors\&quot; : 5 &#125;&quot;;

        JsonFactory factory = new JsonFactory();
        JsonParser parser = factory.createParser(carJson);

        Car car = new Car();
        while (!parser.isClosed()) &#123;
            JsonToken jsonToken = parser.nextToken();

            if (JsonToken.FIELD_NAME.equals(jsonToken)) &#123;
                String fieldName = parser.getCurrentName();
                System.out.println(fieldName);

                jsonToken = parser.nextToken();

                if (&quot;brand&quot;.equals(fieldName)) &#123;
                    car.brand = parser.getValueAsString();
                &#125; else if (&quot;doors&quot;.equals(fieldName)) &#123;
                    car.doors = parser.getValueAsInt();
                &#125;
            &#125;
        &#125;

        System.out.println(&quot;car.brand = &quot; + car.brand);
        System.out.println(&quot;car.doors = &quot; + car.doors);
    &#125;
&#125;
</code></pre>
<p>打印结果如下</p>
<pre><code>brand
doors
car.brand = Mercedes
car.doors = 5
</code></pre>
<p>如果指向的标记是字段名称，则JsonParser的getCurrentName()方法将返回当前字段名称。</p>
<p>如果指向的令牌是字符串字段值，则getValueAsString()返回当前令牌值作为字符串。 如果指向的令牌是整数字段值，则getValueAsInt()返回当前令牌值作为int值。 JsonParser具有更多类似的方法来获取不同类型的curren令牌值（例如boolean，short，long，float，double等）。</p>
<h1 id="六、JsonGenerator"><a href="#六、JsonGenerator" class="headerlink" title="六、JsonGenerator"></a>六、JsonGenerator</h1><p>Jackson JsonGenerator用于从Java对象（或代码从中生成JSON的任何数据结构）生成JSON。</p>
<h2 id="1、创建一个JsonGenerator"><a href="#1、创建一个JsonGenerator" class="headerlink" title="1、创建一个JsonGenerator"></a>1、创建一个JsonGenerator</h2><p>为了创建Jackson JsonGenerator，必须首先创建JsonFactory实例。 这是创建JsonFactory的方法：<code>new JsonFactory();</code></p>
<p>一旦创建了JsonFactory，就可以使用JsonFactory的createGenerator()方法创建JsonGenerator。 这是创建JsonGenerator的示例：</p>
<pre><code class="java">JsonFactory factory = new JsonFactory();
JsonGenerator generator = factory.createGenerator(new File(&quot;D:\\output.json&quot;), JsonEncoding.UTF8);
</code></pre>
<p>createGenerator()方法的第一个参数是生成的JSON的目标。 在上面的示例中，参数是File对象。 这意味着生成的JSON将被写入给定文件。 createGenerator()方法已重载，因此还有其他版本的createGenerator()方法采用例如OutputStream等，提供了有关将生成的JSON写入何处的不同选项。</p>
<p>createGenerator()方法的第二个参数是生成JSON时使用的字符编码。 上面的示例使用UTF-8。</p>
<h2 id="2、JsonGenerator生成JSON"><a href="#2、JsonGenerator生成JSON" class="headerlink" title="2、JsonGenerator生成JSON"></a>2、JsonGenerator生成JSON</h2><p>一旦创建了JsonGenerator，就可以开始生成JSON。 JsonGenerator包含一组write …()方法，可以使用这些方法来编写JSON对象的各个部分。 这是一个使用Jackson JsonGenerator生成JSON的简单示例：</p>
<pre><code class="java">import com.fasterxml.jackson.core.*;
import lombok.Data;
import java.io.File;

public class TestMain &#123;
    public static void main(String[] args) throws Exception &#123;
        JsonFactory factory = new JsonFactory();
        JsonGenerator generator = factory.createGenerator(new File(&quot;D:\\output.json&quot;), JsonEncoding.UTF8);

        generator.writeStartObject();
        generator.writeStringField(&quot;brand&quot;, &quot;Mercedes&quot;);
        generator.writeNumberField(&quot;doors&quot;, 5);
        generator.writeEndObject();

        generator.close();
    &#125;
&#125;
</code></pre>
<p>文件内容如下：</p>
<pre><code class="json">&#123;&quot;brand&quot;:&quot;Mercedes&quot;,&quot;doors&quot;:5&#125;
</code></pre>
<p>此示例首先调用writeStartObject()，将{写入输出。 然后，该示例调用writeStringField()，将品牌字段名称+值写入输出。 之后，将调用writeNumberField()方法，此方法会将Doors字段名称+值写入输出。 最后，调用writeEndObject()，将}写入输出。</p>
<p>JsonGenerator还可以使用许多其他写入方法。 这个例子只显示了其中一些。</p>
<h2 id="3、关闭JsonGenerator"><a href="#3、关闭JsonGenerator" class="headerlink" title="3、关闭JsonGenerator"></a>3、关闭JsonGenerator</h2><p>完成生成JSON后，应关闭JsonGenerator。 您可以通过调用其close()方法来实现。 这是关闭JsonGenerator的样子：</p>
<pre><code class="java">generator.close();
</code></pre>
<h1 id="七、Jackson-常用注解"><a href="#七、Jackson-常用注解" class="headerlink" title="七、Jackson 常用注解"></a>七、Jackson 常用注解</h1><h2 id="1、序列化注解"><a href="#1、序列化注解" class="headerlink" title="1、序列化注解"></a>1、序列化注解</h2><h3 id="1、-JsonGetter"><a href="#1、-JsonGetter" class="headerlink" title="1、@JsonGetter"></a>1、@JsonGetter</h3><p><strong>简单说：就是给字段取别名。可以用来代替@JsonProperty</strong></p>
<p>@JsonGetter 注解用于告诉Jackson，应该通过调用getter方法而不是通过直接字段访问来获取某个字段值。 如果您的Java类使用jQuery样式的getter和setter名称，则@JsonGetter注解很有用。</p>
<p>例如：JSON中有一个字段叫id，准备序列化Java对象中的studentId，就可以使用此注解</p>
<pre><code class="java">import com.fasterxml.jackson.annotation.JsonGetter;
import com.fasterxml.jackson.annotation.JsonSetter;
import com.fasterxml.jackson.databind.ObjectMapper;
import lombok.*;

@Data
@AllArgsConstructor
@NoArgsConstructor
class Student &#123;
    private Integer studentId = 0;
    private String name = &quot;Sam&quot;;
    private Integer age = 18;

    // 此注解只能用在方法上
    @JsonGetter(&quot;id&quot;)
    public Integer getStudentId() &#123;
        return studentId;
    &#125;
    @JsonSetter(&quot;id&quot;)
    public void setStudentId(Integer studentId) &#123;
        this.studentId = studentId;
    &#125;
&#125;

public class TestMain &#123;
    public static void main(String[] args) throws Exception &#123;
        String json = new ObjectMapper().writeValueAsString(new Student());
        System.out.println(json);
        // 输出内容: &#123;&quot;name&quot;:&quot;Sam&quot;,&quot;age&quot;:18,&quot;id&quot;:0&#125;
    &#125;
&#125;
</code></pre>
<h3 id="2、-JsonAnyGetter"><a href="#2、-JsonAnyGetter" class="headerlink" title="2、@JsonAnyGetter"></a>2、@JsonAnyGetter</h3><p><strong>简单说：序列化普通字段到 Map 集合中</strong></p>
<p>@JsonAnyGetter 可以在对 Java 对象进行序列化时，使其中的 Map 集合作为 JSON 中属性的来源。像普通属性一样序列化Map：@JsonAnyGetter 注解使您可以将Map用作要序列化为JSON的属性的容器。下面做个示例。</p>
<pre><code class="java">import com.fasterxml.jackson.annotation.JsonAnyGetter;
import com.fasterxml.jackson.databind.ObjectMapper;
import java.util.*;
import lombok.*;

@Data
@AllArgsConstructor
@NoArgsConstructor
class Student &#123;
    private String name = &quot;Sam&quot;;
    private Integer age = 18;
    @JsonAnyGetter
    private Map&lt;String, Object&gt; diyMap = new HashMap&lt;&gt;() &#123;&#123;
        put("a", 111);
        put("b", 222);
        put("c", 333);
    &#125;&#125;;
    // 两种方式都支持(建议使用此种方式,方法名称可以随意命名)
    // @JsonAnyGetter
    // public Map&lt;String, Object&gt; getDiyMap () &#123;
    //     return diyMap;
    // &#125;
&#125;

public class TestMain &#123;
    public static void main(String[] args) throws Exception &#123;
        String json = new ObjectMapper().writeValueAsString(new Student());
        System.out.println(json);
        // 输出内容: &#123;&quot;name&quot;:&quot;Sam&quot;,&quot;age&quot;:18,&quot;diyMap&quot;:&#123;&quot;a&quot;:111,&quot;b&quot;:222,&quot;c&quot;:333&#125;,&quot;a&quot;:111,&quot;b&quot;:222,&quot;c&quot;:333&#125;
    &#125;
&#125;
</code></pre>
<h3 id="3、-JsonPropertyOrder"><a href="#3、-JsonPropertyOrder" class="headerlink" title="3、@JsonPropertyOrder"></a>3、@JsonPropertyOrder</h3><p>用在类上，在序列化的时候自定义属性输出顺序</p>
<pre><code class="java">import com.fasterxml.jackson.annotation.JsonPropertyOrder;
import com.fasterxml.jackson.databind.ObjectMapper;
import lombok.*;

@Data
@AllArgsConstructor
@NoArgsConstructor
@JsonPropertyOrder(&#123; &quot;age&quot;, &quot;name&quot;, &quot;id&quot;&#125;)
class Student &#123;
    private Integer id = 0;
    private String name = &quot;Sam&quot;;
    private Integer age = 18;
&#125;

public class TestMain &#123;
    public static void main(String[] args) throws Exception &#123;
        String json = new ObjectMapper().writeValueAsString(new Student());
        System.out.println(json);
        // 输出内容: &#123;&quot;age&quot;:18,&quot;name&quot;:&quot;Sam&quot;,&quot;id&quot;:0&#125;
    &#125;
&#125;
</code></pre>
<h3 id="4、-JsonRawValue"><a href="#4、-JsonRawValue" class="headerlink" title="4、@JsonRawValue"></a>4、@JsonRawValue</h3><p><strong>简单说：完全按照原样序列化属性的值</strong></p>
<p>@JsonRawValue 注解告诉Jackson该属性值应直接写入JSON输出。 如果该属性是字符串，Jackson通常会将值括在引号中，但是如果使用@JsonRawValue属性进行注解，Jackson将不会这样做。</p>
<pre><code class="java">import com.fasterxml.jackson.annotation.JsonRawValue;
import com.fasterxml.jackson.databind.ObjectMapper;
import lombok.*;

@Data
@AllArgsConstructor
@NoArgsConstructor
class Student &#123;
    private String name_1 = &quot;Sam&quot;;
    @JsonRawValue
    private String name_2 = &quot;Sam&quot;;
    private String json_1 = &quot;&#123;\&quot;attr\&quot;:false&#125;&quot;;
    @JsonRawValue
    private String json_2 = &quot;&#123;\&quot;attr\&quot;:false&#125;&quot;;
&#125;

public class TestMain &#123;
    public static void main(String[] args) throws Exception &#123;
        String json = new ObjectMapper().writeValueAsString(new Student());
        System.out.println(json);
        // 输出内容: &#123;&quot;name_1&quot;:&quot;Sam&quot;,&quot;name_2&quot;:Sam,&quot;json_1&quot;:&quot;&#123;\&quot;attr\&quot;:false&#125;&quot;,&quot;json_2&quot;:&#123;&quot;attr&quot;:false&#125;&#125;
    &#125;
&#125;
</code></pre>
<p>可以发现Java对象的一个字段为JSON字符串并且带转义符，如果没有加@JsonRawValue，那么序列化会把转义符带上并加上引号，如果带上有@JsonRawValue注解，就会显示正常的JSON字符串。</p>
<h3 id="5、-JsonValue"><a href="#5、-JsonValue" class="headerlink" title="5、@JsonValue"></a>5、@JsonValue</h3><p><strong>简单说：定义整个实体的序列化方法，Jackson将会使用该方法的输出作为序列化输出</strong></p>
<p>@JsonValue告诉Jackson不应该尝试序列化对象本身，而应在对象上调用将对象序列化为JSON字符串的方法。 请注意，Jackson将在自定义序列化返回的String内转义任何引号，因此不能返回例如完整的JSON对象。 为此，应该改用 @JsonRawValue。</p>
<p>@JsonValue注解已添加到Jackson调用的方法中，以将对象序列化为JSON字符串。 这是显示如何使用@JsonValue注解的示例：</p>
<pre><code class="java">import com.fasterxml.jackson.annotation.JsonValue;
import com.fasterxml.jackson.databind.ObjectMapper;
import lombok.*;

@Data
@AllArgsConstructor
@NoArgsConstructor
class Student &#123;
    private String name = &quot;Sam&quot;;
    private String type = &quot;Java&quot;;
    @JsonValue
    public String toJson() &#123;
        return this.name + this.type;
    &#125;
&#125;

@Getter
@AllArgsConstructor
enum TypeEnumWithValue &#123;
    TYPE1(1, &quot;Type A&quot;), TYPE2(2, &quot;Type B&quot;);
    private Integer id;
    private String name;
    @JsonValue
    public String getJson() &#123;
        return this.name + this.id;
    &#125;
&#125;

public class TestMain &#123;
    public static void main(String[] args) throws Exception &#123;
        String student = new ObjectMapper().writeValueAsString(new Student());
        System.out.println(student);
        // 输出内容: &quot;SamJava&quot;
        String typeEnum = new ObjectMapper().writeValueAsString(TypeEnumWithValue.TYPE1);
        System.out.println(typeEnum);
        // 输出内容: &quot;Type A1&quot;
    &#125;
&#125;
</code></pre>
<p>引号由Jackson添加。 请记住，对象返回的值字符串中的所有引号均会转义。</p>
<blockquote>
<p>@JsonValue 与 @JsonRawValue 的区别：</p>
<ol>
<li>@JsonRawValue 表示原样输出，输出时不会加引号，所以有转义符会自动转义。</li>
<li>@JsonRawValue 既可以放在字段上，也能放在方法上</li>
<li>@JsonValue 只能作用在方法上，序列化的结果就为方法返回结果，并且会带上引号，如果有转移会在引号中显示出来</li>
</ol>
</blockquote>
<h3 id="6、-JsonRootName"><a href="#6、-JsonRootName" class="headerlink" title="6、@JsonRootName"></a>6、@JsonRootName</h3><p><strong>简单说：如果需要将实体包装一层，可以使用@JsonRootName来指定根包装器的名称</strong></p>
<p>@JsonRootName 仅用于指定 JSON 根属性的名称，并不能启用装功能。只有当 <strong>SerializationFeature.WRAP_ROOT_VALUE</strong>、<strong>DeserializationFeature.UNWRAP_ROOT_VALUE</strong> 启用时才有效。若只开启了 Feature 功能但未使用 @JsonRootName 注解，默认会使用类名作为 RootName。</p>
<p>1、使用 @JsonRootName 注解 + 开启 Feature 功能</p>
<pre><code class="java">import com.fasterxml.jackson.annotation.JsonRootName;
import com.fasterxml.jackson.databind.DeserializationFeature;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.SerializationFeature;
import lombok.*;

@Data
@JsonRootName(value = &quot;data&quot;)
class Student &#123;
    private String name = &quot;Sam&quot;;
    private String type = &quot;Java&quot;;
&#125;

public class TestMain &#123;
    public static void main(String[] args) throws Exception &#123;
        ObjectMapper objectMapper = new ObjectMapper();
        Student student = new Student();

        System.out.println(&quot;-- before serialization --&quot;);
        String json = objectMapper.writeValueAsString(student);
        System.out.println(json);
        // 输出内容: &#123;&quot;name&quot;:&quot;Sam&quot;,&quot;type&quot;:&quot;Java&quot;&#125;

        // 启用 SerializationFeature.WRAP_ROOT_VALUE
        objectMapper.enable(SerializationFeature.WRAP_ROOT_VALUE);
        System.out.println(&quot;-- after serialization --&quot;);
        json = objectMapper.writeValueAsString(student);
        System.out.println(json);
        // 输出内容: &#123;&quot;data&quot;:&#123;&quot;name&quot;:&quot;Sam&quot;,&quot;type&quot;:&quot;Java&quot;&#125;&#125;

        // 启用 DeserializationFeature.UNWRAP_ROOT_VALUE
        objectMapper.enable(DeserializationFeature.UNWRAP_ROOT_VALUE);
        System.out.println(&quot;-- after deserialization --&quot;);
        Student student2 = objectMapper.readValue(json, Student.class);
        System.out.println(student2);
        // 输出内容: Student(name=Sam, type=Java)
    &#125;
&#125;
</code></pre>
<p>打印结果如下</p>
<pre><code class="java">-- before serialization --
&#123;&quot;name&quot;:&quot;Sam&quot;,&quot;type&quot;:&quot;Java&quot;&#125;
-- after serialization --
&#123;&quot;data&quot;:&#123;&quot;name&quot;:&quot;Sam&quot;,&quot;type&quot;:&quot;Java&quot;&#125;&#125;
-- after deserialization --
Student(name=Sam, type=Java)
</code></pre>
<p>2、未使用 @JsonRootName 注解 + 开启 Feature 功能</p>
<p>打印结果如下：可以看出默认 RootName 为 PersonEntity（类名）</p>
<pre><code>-- before serialization --
&#123;&quot;name&quot;:&quot;Sam&quot;,&quot;type&quot;:&quot;Java&quot;&#125;
-- after serialization --
&#123;&quot;Student&quot;:&#123;&quot;name&quot;:&quot;Sam&quot;,&quot;type&quot;:&quot;Java&quot;&#125;&#125;
-- after deserialization --
Student(name=Sam, type=Java)
</code></pre>
<h3 id="7、-JsonSerialize"><a href="#7、-JsonSerialize" class="headerlink" title="7、@JsonSerialize"></a>7、@JsonSerialize</h3><p><strong>简单说：用于指定自定义序列化器来序列化实体</strong></p>
<pre><code class="java">import com.fasterxml.jackson.databind.*;
import com.fasterxml.jackson.core.JsonGenerator;
import com.fasterxml.jackson.databind.annotation.JsonSerialize;
import lombok.*;
import java.io.IOException;

@Data
class Student &#123;
    private String name = &quot;Sam&quot;;
    private String type = &quot;Java&quot;;
    // 注意启用字段上方的@JsonSerialize注解
    @JsonSerialize(using = OptimizedBooleanSerializer.class)
    public boolean enabled = false;
&#125;

/**
 * OptimizedBooleanSerializer将序列的真值序列化为1，将假值序列化为0
 */
class OptimizedBooleanSerializer extends JsonSerializer&lt;Boolean&gt; &#123;
    @Override
    public void serialize(Boolean enable,
                          JsonGenerator jsonGenerator,
                          SerializerProvider serializerProvider) throws IOException &#123;
        if (enable) &#123;
            jsonGenerator.writeNumber(1);
        &#125; else &#123;
            jsonGenerator.writeNumber(0);
        &#125;
    &#125;
&#125;

public class TestMain &#123;
    public static void main(String[] args) throws Exception &#123;
        String json = new ObjectMapper().writeValueAsString(new Student());
        System.out.println(json);
        // 输出内容: &#123;&quot;name&quot;:&quot;Sam&quot;,&quot;type&quot;:&quot;Java&quot;,&quot;enabled&quot;:0&#125;
    &#125;
&#125;
</code></pre>
<h2 id="2、反序列化注解"><a href="#2、反序列化注解" class="headerlink" title="2、反序列化注解"></a>2、反序列化注解</h2><h3 id="1、-JsonSetter"><a href="#1、-JsonSetter" class="headerlink" title="1、@JsonSetter"></a>1、@JsonSetter</h3><p><strong>简单说：可以指定属性别名，当时只能用在方法上</strong></p>
<p>@JsonSetter告诉Jackson，当将JSON读入对象时，应将此setter方法的名称与JSON数据中的属性名称匹配。 如果Java类内部使用的属性名称与JSON文件中使用的属性名称不同，这个注解就很有用了。</p>
<p>以下Student类用studentId名称对应JSON中名为id的字段（JSON对象中，使用名称id代替studentId）：</p>
<pre><code class="java">import com.fasterxml.jackson.annotation.JsonGetter;
import com.fasterxml.jackson.annotation.JsonSetter;
import com.fasterxml.jackson.databind.ObjectMapper;
import lombok.*;

@Data
@AllArgsConstructor
@NoArgsConstructor
class Student &#123;
    private Integer studentId = 0;
    private String name = &quot;Sam&quot;;
    private Integer age = 18;

    // 此注解只能用在方法上
    @JsonGetter(&quot;id&quot;)
    public Integer getStudentId() &#123;
        return studentId;
    &#125;
    @JsonSetter(&quot;id&quot;)
    public void setStudentId(Integer studentId) &#123;
        this.studentId = studentId;
    &#125;
&#125;

public class TestMain &#123;
    public static void main(String[] args) throws Exception &#123;
        String json = &quot;&#123;\&quot;name\&quot;:\&quot;Sam\&quot;,\&quot;age\&quot;:18,\&quot;id\&quot;:0&#125;&quot;;
        Student student = new ObjectMapper().readValue(json, Student.class);
        System.out.println(student);
        // 输出内容: Student(studentId=0, name=Sam, age=18)
    &#125;
&#125;
</code></pre>
<h3 id="2、-JsonAnySetter"><a href="#2、-JsonAnySetter" class="headerlink" title="2、@JsonAnySetter"></a>2、@JsonAnySetter</h3><p><strong>简单说：就是把不存在Java对象的属性都放进加了此注解的Map集合中</strong></p>
<p>使用 @JsonAnySetter 可以在对 JSON 进行反序列化时，对所有在 Java 对象中不存在的属性进行逻辑处理，下面的代码演示把不存在的属性存放到一个 Map 集合中。</p>
<pre><code class="java">import com.fasterxml.jackson.annotation.JsonAnySetter;
import com.fasterxml.jackson.databind.ObjectMapper;
import java.util.*;
import lombok.*;

@Data
@AllArgsConstructor
@NoArgsConstructor
class Student &#123;
    private String name;
    private Integer age;
    @JsonAnySetter
    private Map&lt;String, Object&gt; diyMap = new HashMap&lt;&gt;();
    // 两种方式都支持(建议使用此种方式,方法名称可以随意命名)
    // @JsonAnySetter
    // public void otherField(String key, String value) &#123;
    //     this.diyMap.put(key, value);
    // &#125;
&#125;

public class TestMain &#123;
    public static void main(String[] args) throws Exception &#123;
        String json = &quot;&#123;\&quot;name\&quot;:\&quot;Sam\&quot;, \&quot;age\&quot;:18, \&quot;key1\&quot;:\&quot;java\&quot;, \&quot;key2\&quot;:\&quot;python\&quot;&#125;&quot;;
        System.out.println(json);
        Student student = new ObjectMapper().readValue(json, Student.class);
        System.out.println(student);
        // 输出内容: Student(name=Sam, age=18, diyMap=&#123;key1=java, key2=python&#125;)
    &#125;
&#125;
</code></pre>
<p>打印结果如下</p>
<pre><code>&#123;&quot;name&quot;:&quot;Sam&quot;, &quot;age&quot;:18, &quot;key1&quot;:&quot;java&quot;, &quot;key2&quot;:&quot;python&quot;&#125;
Student(name=Sam, age=18, diyMap=&#123;key1=java, key2=python&#125;)
</code></pre>
<h3 id="3、-JsonCreator"><a href="#3、-JsonCreator" class="headerlink" title="3、@JsonCreator"></a>3、@JsonCreator</h3><p>@JsonCreator告诉Jackson该Java对象具有一个构造函数（“创建者”），该构造函数可以将JSON对象的字段与Java对象的字段进行匹配。@JsonCreator注解在无法使用@JsonSetter注解的情况下使用。 例如，不可变对象没有任何设置方法，因此它们需要将其初始值注入到构造函数中。</p>
<p>要告诉Jackson应该调用Student的构造函数，我们必须在构造函数中添加@JsonCreator注解。 但是，仅凭这一点还不够。 我们还必须注解构造函数的参数，以告诉Jackson将JSON对象中的哪些字段传递给哪些构造函数参数。</p>
<p>添加了@JsonCreator和@JsonProperty注解的Student类的示例如下：</p>
<pre><code class="java">import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.databind.ObjectMapper;
import lombok.*;

@ToString
@NoArgsConstructor
class Student &#123;
    @Getter
    @Setter
    private Integer id = 0;
    @Getter
    private String name = &quot;Sam&quot;;
    @Getter
    private Integer age = 18;

    @JsonCreator
    public Student(@JsonProperty(&quot;name&quot;) String name,
                   @JsonProperty(&quot;age&quot;) Integer age) &#123;
        this.name = name;
        this.age = age;
    &#125;
&#125;

public class TestMain &#123;
    public static void main(String[] args) throws Exception &#123;
        String json = &quot;&#123;\&quot;name\&quot;:\&quot;Sam\&quot;,\&quot;age\&quot;:18,\&quot;id\&quot;:0&#125;&quot;;
        Student student = new ObjectMapper().readValue(json, Student.class);
        System.out.println(student);
        // 输出内容: Student(id=0, name=Sam, age=18)
    &#125;
&#125;
</code></pre>
<p>总结：使用 @JsonCreator + @JsonProperty 时，反序列化可以省略 Setter 方法。</p>
<h3 id="4、-JacksonInject"><a href="#4、-JacksonInject" class="headerlink" title="4、@JacksonInject"></a>4、@JacksonInject</h3><p><strong>简单说：指定某个字段从注入赋值，而不是从JSON</strong></p>
<p>@JacksonInject 用于将值注入到解析的对象中，而不是从JSON中读取这些值。 例如，假设正在从各种不同的源下载Student JSON对象，并且想知道给定Student对象来自哪个源。 源本身可能不包含该信息，但是可以让Jackson将其注入到根据JSON对象创建的Java对象中。要将Java类中的字段标记为需要由Jackson注入其值的字段，请在该字段上方添加@JacksonInject注解。</p>
<p>这是一个示例Student类，在属性上方添加了@JacksonInject注解：</p>
<pre><code class="java">import com.fasterxml.jackson.annotation.JacksonInject;
import com.fasterxml.jackson.databind.InjectableValues;
import com.fasterxml.jackson.databind.ObjectMapper;
import lombok.*;

@Data
class Student &#123;
    @JacksonInject
    private Integer id;
    private String name = &quot;Sam&quot;;
    private Integer age = 18;
&#125;

public class TestMain &#123;
    public static void main(String[] args) throws Exception &#123;
        String json = &quot;&#123;\&quot;name\&quot;:\&quot;Sam\&quot;,\&quot;age\&quot;:18&#125;&quot;;
        // 如下如果未设置忽略Java对象不存在的字段配置，会显示报错
        // System.out.println(new ObjectMapper().readValue(json, Student.class));

        InjectableValues inject = new InjectableValues.Std().addValue(Integer.class, 1);
        Student student = new ObjectMapper().reader(inject).forType(Student.class).readValue(json);
        System.out.println(student);
        // 输出内容: Student(id=1, name=Sam, age=18)
    &#125;
&#125;
</code></pre>
<p>请注意，如何在InjectableValues.addValue()方法中设置要注入到ID属性中的值。 还要注意，该值仅绑定到字符串类型-而不绑定到任何特定的字段名称。 @JacksonInject注解指定将值注入到哪个字段。</p>
<p>如果要从多个源下载人员JSON对象，并为每个源注入不同的源值，则必须为每个源重复以上代码。</p>
<h3 id="5、-JsonDeserialize"><a href="#5、-JsonDeserialize" class="headerlink" title="5、@JsonDeserialize"></a>5、@JsonDeserialize</h3><p><strong>简单说：用于为Java对象中给定的属性指定自定义反序列化器类</strong></p>
<p>例如，假设想优化布尔值false和true的在线格式，使其分别为0和1。首先，需要将@JsonDeserialize注解添加到要为其使用自定义反序列化器的字段。 这是将@JsonDeserialize注解添加到字段的示例：</p>
<pre><code class="java">import com.fasterxml.jackson.databind.*;
import com.fasterxml.jackson.core.JsonParser;
import com.fasterxml.jackson.core.JsonGenerator;
import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import com.fasterxml.jackson.databind.annotation.JsonSerialize;
import lombok.*;
import java.io.IOException;

@Data
class Student &#123;
    private String name = &quot;Sam&quot;;
    private String type = &quot;Java&quot;;
    // @JsonSerialize 为序列化注解，@JsonDeserialize 为反序列化注解
    @JsonSerialize(using = OptimizedBooleanSerializer.class)
    @JsonDeserialize(using = OptimizedBooleanDeserializer.class)
    public boolean enabled = false;
&#125;

/**
 * OptimizedBooleanSerializer将序列的真值序列化为1，将假值序列化为0
 */
class OptimizedBooleanSerializer extends JsonSerializer&lt;Boolean&gt; &#123;
    @Override
    public void serialize(Boolean enable,
                          JsonGenerator jsonGenerator,
                          SerializerProvider serializerProvider) throws IOException &#123;
        if (enable) &#123;
            jsonGenerator.writeNumber(1);
        &#125; else &#123;
            jsonGenerator.writeNumber(0);
        &#125;
    &#125;
&#125;

/**
 * OptimizedBooleanDeserializer将序列的1反序列化为真值，将0反序列化为假值
 */
class OptimizedBooleanDeserializer
        extends JsonDeserializer&lt;Boolean&gt; &#123;

    @Override
    public Boolean deserialize(JsonParser jsonParser,
                               DeserializationContext deserializationContext) throws IOException &#123;
        String text = jsonParser.getText();
        if (&quot;0&quot;.equals(text)) return false;
        return true;
    &#125;
&#125;

public class TestMain &#123;
    public static void main(String[] args) throws Exception &#123;
        String json = new ObjectMapper().writeValueAsString(new Student());
        System.out.println(json);
        // 输出内容: &#123;&quot;name&quot;:&quot;Sam&quot;,&quot;type&quot;:&quot;Java&quot;,&quot;enabled&quot;:0&#125;
        System.out.println(new ObjectMapper().readValue(json, Student.class));
        // 输出内容: Student(name=Sam, type=Java, enabled=false)
    &#125;
&#125;
</code></pre>
<h2 id="3、属性包含注解"><a href="#3、属性包含注解" class="headerlink" title="3、属性包含注解"></a>3、属性包含注解</h2><h3 id="1、-JsonIgnore"><a href="#1、-JsonIgnore" class="headerlink" title="1、@JsonIgnore"></a>1、@JsonIgnore</h3><p><strong>简单说：在具体属性上忽略，使其不参与序列化过程</strong></p>
<p>@JsonIgnore用于告诉Jackson忽略Java对象的某个属性（字段）。 在将JSON读取到Java对象中以及将Java对象写入JSON时，都将忽略该属性。</p>
<pre><code class="java">import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.databind.*;
import lombok.*;

@Data
class Student &#123;
    @JsonIgnore
    private String name = &quot;Sam&quot;;
    @JsonIgnore
    private String type = &quot;Java&quot;;
    public boolean enabled = false;
&#125;

public class TestMain &#123;
    public static void main(String[] args) throws Exception &#123;
        String json = new ObjectMapper().writeValueAsString(new Student());
        System.out.println(json);
        // 输出内容: &#123;&quot;enabled&quot;:false&#125;
    &#125;
&#125;
</code></pre>
<p>与**@JsonIgnoreProperties**是等效的。</p>
<h3 id="2、-JsonIgnoreProperties"><a href="#2、-JsonIgnoreProperties" class="headerlink" title="2、@JsonIgnoreProperties"></a>2、@JsonIgnoreProperties</h3><p><strong>简单说：在类上指定要忽略的属性</strong></p>
<p>@JsonIgnoreProperties 注解用于指定要忽略的类的属性列表。 @JsonIgnoreProperties注解放置在类声明上方，而不是要忽略的各个属性（字段）上方。</p>
<pre><code class="java">import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.databind.*;
import lombok.*;

@Data
@JsonIgnoreProperties(&#123;&quot;name&quot;, &quot;type&quot;&#125;)
class Student &#123;
    private String name = &quot;Sam&quot;;
    private String type = &quot;Java&quot;;
    public boolean enabled = false;
&#125;

public class TestMain &#123;
    public static void main(String[] args) throws Exception &#123;
        String json = new ObjectMapper().writeValueAsString(new Student());
        System.out.println(json);
        // 输出内容: &#123;&quot;enabled&quot;:false&#125;
    &#125;
&#125;
</code></pre>
<h3 id="3、-JsonIgnoreType"><a href="#3、-JsonIgnoreType" class="headerlink" title="3、@JsonIgnoreType"></a>3、@JsonIgnoreType</h3><p><strong>简单说：使用此注解可以忽略整个类</strong>。@JsonIgnoreType 注解用于将整个类型（类）标记为在使用该类型的任何地方都将被忽略。</p>
<p>使用@JsonIgnoreType注解，在类上将忽略该类所有属性：</p>
<pre><code class="java">import com.fasterxml.jackson.databind.*;
import lombok.*;

@Data
class Student &#123;
    private String name = &quot;Sam&quot;;
    private String type = &quot;Java&quot;;
    private Address address = new Address();
    @JsonIgnoreType
    public static class Address &#123;
        public String streetName = &quot;1&quot;;
        public String houseNumber = &quot;2&quot;;
        public String zipCode = &quot;3&quot;;
        public String city = &quot;4&quot;;
        public String country = &quot;5&quot;;
    &#125;
&#125;

public class TestMain &#123;
    public static void main(String[] args) throws Exception &#123;
        String json = new ObjectMapper().writeValueAsString(new Student());
        System.out.println(json);
        // 输出内容: &#123;&quot;name&quot;:&quot;Sam&quot;,&quot;type&quot;:&quot;Java&quot;&#125;
    &#125;
&#125;
</code></pre>
<p>如果去掉@JsonIgnoreType注解那么打印如下：</p>
<pre><code>&#123;&quot;name&quot;:&quot;Sam&quot;,&quot;type&quot;:&quot;Java&quot;,&quot;address&quot;:&#123;&quot;streetName&quot;:&quot;1&quot;,&quot;houseNumber&quot;:&quot;2&quot;,&quot;zipCode&quot;:&quot;3&quot;,&quot;city&quot;:&quot;4&quot;,&quot;country&quot;:&quot;5&quot;&#125;&#125;
</code></pre>
<h3 id="4、-JsonInclude"><a href="#4、-JsonInclude" class="headerlink" title="4、@JsonInclude"></a>4、@JsonInclude</h3><p><strong>简单说：用于排除值为<code>empty/null/default</code>的属性</strong>。@JsonInclude告诉Jackson仅在某些情况下包括属性，如果属性值为empty&#x2F;null&#x2F;default，那么将忽略该字段。例如：仅当属性为非null，非空或具有非默认值时，才应包括该属性。 </p>
<pre><code class="java">import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.databind.*;
import lombok.*;

@Data
@JsonInclude(JsonInclude.Include.NON_EMPTY)
class Student &#123;
    private Long id = 1L;
    private String name = null;
    private String type = null;
&#125;

public class TestMain &#123;
    public static void main(String[] args) throws Exception &#123;
        String json = new ObjectMapper().writeValueAsString(new Student());
        System.out.println(json);
        // 输出内容: &#123;&quot;id&quot;:1&#125;
    &#125;
&#125;
</code></pre>
<p>当前注解表示：如果有字段为null或空字符串的话，将忽略这个字段的生成。</p>
<h3 id="JsonAutoDetect"><a href="#JsonAutoDetect" class="headerlink" title="@JsonAutoDetect"></a>@JsonAutoDetect</h3><p><strong>简单说：强制序列化私有属性，不管它有没有getter方法</strong>。@JsonAutoDetect告诉Jackson在读写对象时包括非public修饰的属性。</p>
<p>这是一个示例类，展示如何使用@JsonAutoDetect注解：</p>
<pre><code class="java">import com.fasterxml.jackson.annotation.JsonAutoDetect;
import com.fasterxml.jackson.databind.*;

@JsonAutoDetect(fieldVisibility = JsonAutoDetect.Visibility.ANY)
class Student &#123;
    private Long id = 1L;
    private String name = &quot;Sam&quot;;
    private String type = &quot;Java&quot;;
&#125;

public class TestMain &#123;
    public static void main(String[] args) throws Exception &#123;
        String json = new ObjectMapper().writeValueAsString(new Student());
        System.out.println(json);
        // 输出内容: &#123;&quot;id&quot;:1,&quot;name&quot;:&quot;Sam&quot;,&quot;type&quot;:&quot;Java&quot;&#125;
    &#125;
&#125;
</code></pre>
<p>注意：JsonAutoDetect.Visibility类包含与Java中的可见性级别匹配的常量，表示ANY，DEFAULT，NON_PRIVATE，NONE，PROTECTED_AND_PRIVATE和PUBLIC_ONLY。</p>
<h2 id="4、多态处理注解"><a href="#4、多态处理注解" class="headerlink" title="4、多态处理注解"></a>4、多态处理注解</h2><p>一般都是组合起来使用，有下面三个注解：</p>
<ul>
<li>@JsonTypeInfo：指定序列化中包含的类型信息的详细信息</li>
<li>@JsonSubTypes：指定带注释类型的子类型</li>
<li>@JsonTypeName：指定用于带注释的类的逻辑类型名称</li>
</ul>
<p>下面例子中，指定属性type为判断具体子类的依据，例如：type&#x3D;dog，将被序列化为Dog类型。</p>
<pre><code class="java">public class Zoo &#123;
    public Animal animal;

    @JsonTypeInfo(use = JsonTypeInfo.Id.NAME, 
                  include = JsonTypeInfo.As.PROPERTY, 
                  property = &quot;type&quot;)
    @JsonSubTypes(&#123;@JsonSubTypes.Type(value = Dog.class, name = &quot;dog&quot;), 
                   @JsonSubTypes.Type(value = Cat.class, name = &quot;cat&quot;)&#125;)
    public static class Animal &#123;
        public String name;
    &#125;

    @JsonTypeName(&quot;dog&quot;)
    public static class Dog extends Animal &#123;
        public double barkVolume;
    &#125;

    @JsonTypeName(&quot;cat&quot;)
    public static class Cat extends Animal &#123;
        boolean likesCream;
        public int lives;
    &#125;
&#125;
</code></pre>
<h2 id="5、通用注解（序列化反序列化都生效）"><a href="#5、通用注解（序列化反序列化都生效）" class="headerlink" title="5、通用注解（序列化反序列化都生效）"></a>5、通用注解（序列化反序列化都生效）</h2><h3 id="1、-JsonProperty"><a href="#1、-JsonProperty" class="headerlink" title="1、@JsonProperty"></a>1、@JsonProperty</h3><p>指定JSON中的属性名称，又称取别名。即可以序列化又可以反序列化，可以在方法和属性上使用</p>
<pre><code class="java">import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.databind.*;
import lombok.Data;

@Data
class Student &#123;
    @JsonProperty(&quot;id&quot;)
    private Long studentId = 1L;
    private String name = &quot;Sam&quot;;
    private String type = &quot;Java&quot;;
&#125;

public class TestMain &#123;
    public static void main(String[] args) throws Exception &#123;
        String json = new ObjectMapper().writeValueAsString(new Student());
        System.out.println(json);
        // 输出内容: &#123;&quot;name&quot;:&quot;Sam&quot;,&quot;type&quot;:&quot;Java&quot;,&quot;id&quot;:1&#125;
        System.out.println(new ObjectMapper().readValue(json, Student.class));
        // 输出内容: Student(studentId=1, name=Sam, type=Java)
    &#125;
&#125;
</code></pre>
<h3 id="2、-JsonFormat"><a href="#2、-JsonFormat" class="headerlink" title="2、@JsonFormat"></a>2、@JsonFormat</h3><p>用于在序列化日期&#x2F;时间值时指定格式</p>
<pre><code class="java">@Data
public class Student &#123;
    private Long id = 1L;
    @JsonFormat(shape = JsonFormat.Shape.STRING, pattern = &quot;dd-MM-yyyy hh:mm:ss&quot;)
    public Date date;
&#125;
</code></pre>
<h3 id="3、-JsonUnwrapped"><a href="#3、-JsonUnwrapped" class="headerlink" title="3、@JsonUnwrapped"></a>3、@JsonUnwrapped</h3><p>将对象中所有的属性与当前平级，不太好描述，简单说就是拆开包装。简单说：就是扁平化</p>
<pre><code class="java">import com.fasterxml.jackson.annotation.JsonUnwrapped;
import com.fasterxml.jackson.databind.*;
import lombok.ToString;
import lombok.Data;

@Data
class Student &#123;
    private Long id = 1L;
    @JsonUnwrapped
    public Name name = new Name();
    @ToString
    public static class Name &#123;
        public String firstName = &quot;Sam&quot;;
        public String lastName = &quot;Liu&quot;;
    &#125;
&#125;

public class TestMain &#123;
    public static void main(String[] args) throws Exception &#123;
        String json = new ObjectMapper().writeValueAsString(new Student());
        System.out.println(json);
        // 输出内容: &#123;&quot;id&quot;:1,&quot;firstName&quot;:&quot;Sam&quot;,&quot;lastName&quot;:&quot;Liu&quot;&#125;
        System.out.println(new ObjectMapper().readValue(json, Student.class));
        // 输出内容: Student(id=1, name=Student.Name(firstName=Sam, lastName=Liu))
    &#125;
&#125;
</code></pre>
<p>打印结果如下</p>
<pre><code>&#123;&quot;id&quot;:1,&quot;firstName&quot;:&quot;Sam&quot;,&quot;lastName&quot;:&quot;Liu&quot;&#125;
Student(id=1, name=Student.Name(firstName=Sam, lastName=Liu))
</code></pre>
<p>对比一下加于不加注解的区别：</p>
<ol>
<li><p>如果加@JsonUnwrapped注解，将被序列化为：</p>
<pre><code class="json">&#123;
    &quot;id&quot;:1,
    &quot;firstName&quot;:&quot;John&quot;,
    &quot;lastName&quot;:&quot;Doe&quot;
&#125;
</code></pre>
</li>
<li><p>如果不加@JsonUnwrapped注解，将被序列化为：</p>
<pre><code class="json">&#123;
    &quot;id&quot;:1,
    &quot;name&quot;: &#123;
        &quot;firstName&quot;:&quot;John&quot;,
        &quot;lastName&quot;:&quot;Doe&quot;
    &#125;
&#125;
</code></pre>
</li>
</ol>
<h3 id="4、-JsonView"><a href="#4、-JsonView" class="headerlink" title="4、@JsonView"></a>4、@JsonView</h3><p>指定视图，类似分组进行序列化&#x2F;反序列化。分组指定序列化&#x2F;反序列化时是否包含属性。</p>
<pre><code class="java">import com.fasterxml.jackson.annotation.JsonView;
import com.fasterxml.jackson.databind.*;
import lombok.*;

/**
 * 定义视图
 */
class Views &#123;
    public static class Public &#123;&#125;
    public static class Internal extends Public &#123;&#125;
&#125;

/**
 * 定义实体
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
class Item &#123;
    @JsonView(Views.Public.class)
    public int id;
    @JsonView(Views.Public.class)
    public String itemName;
    @JsonView(Views.Internal.class)
    public String ownerName;
&#125;

public class TestMain &#123;
    public static void main(String[] args) throws Exception &#123;
        Item item = new Item(2, &quot;book&quot;, &quot;Sam&quot;);
        String result = new ObjectMapper().writerWithView(Views.Public.class).writeValueAsString(item);
        System.out.println(result);
        // 输出内容: &#123;&quot;id&quot;:2,&quot;itemName&quot;:&quot;book&quot;&#125;
    &#125;
&#125;
</code></pre>
<p>最终，将只会序列化 id 和 itemName 字段</p>
<h3 id="5、-JsonManagedReference-JsonBackReference"><a href="#5、-JsonManagedReference-JsonBackReference" class="headerlink" title="5、@JsonManagedReference@JsonBackReference"></a>5、@JsonManagedReference@JsonBackReference</h3><p>@JsonManagedReference 和 @JsonBackReference 注解用于处理父&#x2F;子关系并解决循环问题。</p>
<pre><code class="java">@Data
public class ItemWithRef &#123;
    public int id;
    public String itemName;
    @JsonManagedReference
    public UserWithRef owner;
&#125;
</code></pre>
<pre><code class="java">public class UserWithRef &#123;
    public int id;
    public String name;
    @JsonBackReference
    public List&lt;ItemWithRef&gt; userItems;
&#125;
</code></pre>
<p>不加注解，会循环调用，导致内存溢出，这时候可以使用@JsonManagedReference和@JsonBackReference来避免内存溢出。</p>
<h3 id="6、-JsonIdentityInfo"><a href="#6、-JsonIdentityInfo" class="headerlink" title="6、@JsonIdentityInfo"></a>6、@JsonIdentityInfo</h3><p>用于指定在序列化 或者 反序列化值时使用对象标识，例如，处理无限递归类型的问题。</p>
<pre><code class="java">@JsonIdentityInfo(generator = ObjectIdGenerators.PropertyGenerator.class, property = &quot;id&quot;)
public class ItemWithIdentity &#123;
    public int id;
    public String itemName;
    public UserWithIdentity owner;
&#125;
</code></pre>
<h3 id="7、-JsonFilter"><a href="#7、-JsonFilter" class="headerlink" title="7、@JsonFilter"></a>7、@JsonFilter</h3><p>指定序列化期间要使用的过滤器</p>
<pre><code class="java">import com.fasterxml.jackson.databind.*;
import com.fasterxml.jackson.annotation.JsonFilter;
import com.fasterxml.jackson.databind.ser.FilterProvider;
import com.fasterxml.jackson.databind.ser.impl.SimpleBeanPropertyFilter;
import com.fasterxml.jackson.databind.ser.impl.SimpleFilterProvider;
import lombok.*;

@Data
@AllArgsConstructor
@JsonFilter(&quot;myFilter&quot;)
class BeanWithFilter &#123;
    public int id;
    public String name;
&#125;

public class TestMain &#123;
    public static void main(String[] args) throws Exception &#123;
        BeanWithFilter bean = new BeanWithFilter(1, &quot;My bean&quot;);

        // 指定filter需要序列化输出那些属性,这里只序列化name
        SimpleBeanPropertyFilter filter = SimpleBeanPropertyFilter.filterOutAllExcept(&quot;name&quot;);
        FilterProvider filters = new SimpleFilterProvider().addFilter(&quot;myFilter&quot;, filter);

        String result = new ObjectMapper().writer(filters).writeValueAsString(bean);
        System.out.println(result);
        // 输出内容: &#123;&quot;name&quot;:&quot;My bean&quot;&#125;
    &#125;
&#125;
</code></pre>
<h2 id="6、自定义注解"><a href="#6、自定义注解" class="headerlink" title="6、自定义注解"></a>6、自定义注解</h2><p>可以使用**@JacksonAnnotationsInside**来开发自定义注解</p>
<pre><code class="java">import com.fasterxml.jackson.annotation.*;
import com.fasterxml.jackson.databind.ObjectMapper;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import lombok.Data;

/**
 * 一般自定义注解不会单独使用,会组合其他Jackson一起使用
 * 这里加上了忽略NULL值配置 以及 序列化属性排序注解
 */
@Retention(RetentionPolicy.RUNTIME)
@JacksonAnnotationsInside
@JsonInclude(JsonInclude.Include.NON_NULL)
@JsonPropertyOrder(&#123; &quot;name&quot;, &quot;id&quot;, &quot;age&quot; &#125;)
@interface CustomAnnotation &#123;&#125;

@Data
@CustomAnnotation
class Student &#123;
    private Integer id = 0;
    private String name;
    private Integer age;
&#125;

public class TestMain &#123;
    public static void main(String[] args) throws Exception &#123;
        String json = new ObjectMapper().writeValueAsString(new Student());
        System.out.println(json);
        // 输出内容: &#123;&quot;id&quot;:0&#125;
    &#125;
&#125;
</code></pre>
<p>作用：自定义注解可以<strong>增强代码复用</strong>，把一些通用的Jackson注解组合起来，形成一个新注解，新注解可以代替组合的注解。</p>
<hr>
<h2 id="7、自定义注解案例（实现数据脱敏）"><a href="#7、自定义注解案例（实现数据脱敏）" class="headerlink" title="7、自定义注解案例（实现数据脱敏）"></a>7、自定义注解案例（实现数据脱敏）</h2><blockquote>
<p>下面完成一个案例：<strong>Jackson 自定义注解实现数据脱敏</strong></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/RujXqk0MWhmtQKpf_zaTnQ">https://mp.weixin.qq.com/s/RujXqk0MWhmtQKpf_zaTnQ</a></li>
</ul>
</blockquote>
<p>1、自定义一个Jackson注解 + 定制脱敏策略 （这里偷懒了，把注解于枚举定义在一起了。实际上需要分开定义）</p>
<pre><code class="java">import com.fasterxml.jackson.annotation.JacksonAnnotationsInside;
import com.fasterxml.jackson.databind.annotation.JsonSerialize;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
import java.util.function.Function;

/**
 * 自定义jackson注解，标注在属性上
 * 
 * 需要自定义一个脱敏注解，一旦有属性被标注，则进行对应得脱敏，
 * 针对项目需求，定制不同字段的脱敏规则，比如手机号中间几位用*替代
 */
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.FIELD) // 针对成员属性进行脱敏
@JacksonAnnotationsInside  // 表示和其他Jackson注解联合使用，如果缺少则无法执行数据脱敏流程
@JsonSerialize(using = SensitiveJsonSerializer.class) // 表明使用的序列化的类，定义在后面
public @interface Sensitive &#123;
    /**
     * 脱敏策略
     */
    SensitiveStrategy strategy();

    /**
     * 脱敏策略，枚举类，针对不同的数据定制特定的策略
     */
    enum SensitiveStrategy &#123;
        /**
         * 用户名
         */
        USERNAME(s -&gt; s.replaceAll(&quot;(\\S)\\S(\\S*)&quot;, &quot;$1*$2&quot;)),
        /**
         * 身份证
         */
        ID_CARD(s -&gt; s.replaceAll(&quot;(\\d&#123;4&#125;)\\d&#123;10&#125;(\\w&#123;4&#125;)&quot;, &quot;$1****$2&quot;)),
        /**
         * 手机号
         */
        PHONE(s -&gt; s.replaceAll(&quot;(\\d&#123;3&#125;)\\d&#123;4&#125;(\\d&#123;4&#125;)&quot;, &quot;$1****$2&quot;)),
        /**
         * 地址
         */
        ADDRESS(s -&gt; s.replaceAll(&quot;(\\S&#123;3&#125;)\\S&#123;2&#125;(\\S*)\\S&#123;2&#125;&quot;, &quot;$1****$2****&quot;));
        
        private final Function&lt;String, String&gt; desensitize;

        SensitiveStrategy(Function&lt;String, String&gt; desensitize) &#123;
            this.desensitize = desensitize;
        &#125;

        public Function&lt;String, String&gt; desensitize() &#123;
            return desensitize;
        &#125;
    &#125;
&#125;
</code></pre>
<p>2、自定义JsonSerializer从而实现数据脱敏，对标注注解@Sensitive的字段进行脱敏，实现如下：</p>
<pre><code class="java">import com.fasterxml.jackson.core.JsonGenerator;
import com.fasterxml.jackson.databind.BeanProperty;
import com.fasterxml.jackson.databind.JsonMappingException;
import com.fasterxml.jackson.databind.JsonSerializer;
import com.fasterxml.jackson.databind.SerializerProvider;
import com.fasterxml.jackson.databind.ser.ContextualSerializer;
import java.io.IOException;
import java.util.Objects;

/**
 * 序列化注解自定义实现
 * JsonSerializer&lt;String&gt;：指定String 类型，serialize()方法用于将修改后的数据载入
 */
public class SensitiveJsonSerializer extends JsonSerializer&lt;String&gt; implements ContextualSerializer &#123;
    private Sensitive.SensitiveStrategy strategy;

    @Override
    public void serialize(String value, JsonGenerator gen, SerializerProvider serializers) throws IOException &#123;
        // 在序列化时进行数据脱敏
        gen.writeString(strategy.desensitize().apply(value));
    &#125;

    /**
     * 获取属性上的注解属性, 又叫自定义注解被拦截后的回调函数
     */
    @Override
    public JsonSerializer&lt;?&gt; createContextual(SerializerProvider prov, BeanProperty property) throws JsonMappingException &#123;

        Sensitive annotation = property.getAnnotation(Sensitive.class);
        if (Objects.nonNull(annotation) &amp;&amp; Objects.equals(String.class, property.getType().getRawClass())) &#123;
            this.strategy = annotation.strategy();
            return this;
        &#125;
        return prov.findValueSerializer(property.getType(), property);
    &#125;
&#125;
</code></pre>
<p>4、定义Person类，对其数据脱敏</p>
<pre><code class="java">import lombok.*;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class Person &#123;
    /**
     * 真实姓名
     */
    @Sensitive(strategy = Sensitive.SensitiveStrategy.USERNAME)
    private String realName;
    /**
     * 地址
     */
    @Sensitive(strategy = Sensitive.SensitiveStrategy.ADDRESS)
    private String address;
    /**
     * 电话号码
     */
    @Sensitive(strategy = Sensitive.SensitiveStrategy.PHONE)
    private String phoneNumber;
    /**
     * 身份证号码
     */
    @Sensitive(strategy = Sensitive.SensitiveStrategy.ID_CARD)
    private String idCard;
&#125;
</code></pre>
<p>5、模拟接口测试，以上4个步骤完成了数据脱敏的Jackson注解，这里模拟main方法测试，接口测试效果一样。代码如下：</p>
<pre><code class="java">import com.fasterxml.jackson.databind.ObjectMapper;

public class TestMain &#123;
    public static void main(String[] args) throws Exception &#123;
        Student student = new Student(&quot;路边烧卖&quot;, &quot;广东广州&quot;, &quot;12306&quot;, &quot;4333333333334334333&quot;);
        String json = new ObjectMapper().writeValueAsString(student);
        System.out.println(json);
        // 输出内容: &#123;&quot;realName&quot;:&quot;路*烧卖&quot;,&quot;address&quot;:&quot;广东广州&quot;,&quot;phoneNumber&quot;:&quot;12306&quot;,&quot;idCard&quot;:&quot;4333****34333&quot;&#125;
    &#125;
&#125;
</code></pre>
<h2 id="8、MixIn-注解"><a href="#8、MixIn-注解" class="headerlink" title="8、MixIn 注解"></a>8、MixIn 注解</h2><blockquote>
<p>Jackson的Mixins,真香：<a target="_blank" rel="noopener" href="https://blog.csdn.net/wjw465150/article/details/127187859">https://blog.csdn.net/wjw465150/article/details/127187859</a></p>
</blockquote>
<p>Jackson Mixins 是一种在类中添加 Jackson 注解而不修改实际类的机制。 它是为我们无法修改类的情况而创建的，例如在使用第三方类时。</p>
<p>我们可以使用任何Jackson注释，但不直接将它们添加到类中。我们在mixin类中使用它们，而mixin类既可以是抽象类，也可以是接口。它们既可以用于Jackson序列化也可以用于反序列化，并且必须将它们添加到ObjectMapper配置中。</p>
<p>在接下来的部分中，将展示一些使用 Jackson Mixin 有用的常见案例。</p>
<h3 id="1、使第三方类-Jackson-可序列化"><a href="#1、使第三方类-Jackson-可序列化" class="headerlink" title="1、使第三方类 Jackson 可序列化"></a>1、使第三方类 Jackson 可序列化</h3><p>我们展示的第一个案例是当我们需要使用无法由 Jackson 序列化或反序列化的第三方类时，因为它们不遵循 Jackson 约定。 由于我们无法修改这些类，我们必须使用 mixins 来添加 Jackson 序列化所需的所有必要部分。</p>
<p>假设我们要序列化这个第三方类：</p>
<pre><code class="java">public class Person &#123;
    private final String firstName;
    private final String lastName;

    public Person(String firstName, String lastName) &#123;
        this.firstName = firstName;
        this.lastName = lastName;
    &#125;

    @Override
    public String toString() &#123;
        return new StringJoiner(&quot;, &quot;, Person.class.getSimpleName() + &quot;[&quot;, &quot;]&quot;)
                .add(&quot;firstName=&#39;&quot; + firstName + &quot;&#39;&quot;)
                .add(&quot;lastName=&#39;&quot; + lastName + &quot;&#39;&quot;)
                .toString();
    &#125;
&#125;
</code></pre>
<p>我们不能用 Jackson 序列化这个类，因为属性是私有的并且没有 getter 和 setter。 因此，Jackson 不会识别任何属性并会抛出异常：</p>
<pre><code class="java">String jsonSting = new ObjectMapper().writeValueAsString(new Person(&quot;Sam&quot;, &quot;Liu&quot;));
System.out.println(jsonSting);
</code></pre>
<pre><code class="shell">com.fasterxml.jackson.databind.exc.InvalidDefinitionException: No serializer found for class com.grabanotherbyte.jackson.Person and no properties discovered to create BeanSerializer (to avoid exception, disable SerializationFeature.FAIL_ON_EMPTY_BEANS)
</code></pre>
<p>现在让我们创建一个 mixin 来解决这个问题！ 在我们的 mixin 中，我们将添加我们想要序列化的属性：</p>
<pre><code class="java">public abstract class PersonMixin &#123;
    @JsonProperty private String firstName;
    @JsonProperty private String lastName;
&#125;
</code></pre>
<p>在这种情况下，我们创建了一个抽象类，因为稍后我们需要添加一个构造函数。之后，我们需要告诉 Jackson 使用我们的 Mixin。 为此，我们需要在 <em>ObjectMapper</em> 中进行设置：</p>
<pre><code class="java">// 序列化
        String jsonSting = new ObjectMapper()
                .addMixIn(Person.class, PersonMixin.class)
                .writeValueAsString(new Person(&quot;Sam&quot;, &quot;Liu&quot;));
        System.out.println(jsonSting);
        // 输出内容: &#123;&quot;firstName&quot;:&quot;Sam&quot;,&quot;lastName&quot;:&quot;Liu&quot;&#125;

        // 反序列化
        Person person = new ObjectMapper()
                .addMixIn(Person.class, PersonMixin.class)
                .readValue(jsonSting, Person.class);
        System.out.println(person);
        // .readValue(jsonSting, Person.class); 这里已经报错
</code></pre>
<p>现在，Jackson将能够序列化我们的<em>Person</em>，并将序列化<em>firstName</em>和<em>lastName</em>。另一方面，如果我们还想使用<em>Person</em>类进行反序列化，我们需要在mixin类中添加一个Jackson友好的构造函数:</p>
<pre><code class="java">public abstract class PersonMixin &#123;
    @JsonProperty private String firstName;
    @JsonProperty private String lastName;
    @JsonCreator
    public PersonMixin(@JsonProperty(&quot;firstName&quot;) String firstName, @JsonProperty(&quot;lastName&quot;) String lastName) &#123;&#125;
&#125;
</code></pre>
<p>这样配置后反序列化就不会报错了，否则，Jackson将抛出异常。</p>
<h3 id="2、忽略属性"><a href="#2、忽略属性" class="headerlink" title="2、忽略属性"></a>2、忽略属性</h3><p>现在，在序列化第三方类时，我们将考虑不同的场景。让我们假设现在我们的<em>Person</em>类拥有所需的所有getter、setter和构造函数，并且它的所有字段都将被序列化：</p>
<pre><code class="java">public class Person &#123;
    private String firstName;
    private String lastName;

    public String getFirstName() &#123;
        return firstName;
    &#125;

    public void setFirstName(String firstName) &#123;
        this.firstName = firstName;
    &#125;

    public String getLastName() &#123;
        return lastName;
    &#125;

    public void setLastName(String lastName) &#123;
        this.lastName = lastName;
    &#125;
&#125;
</code></pre>
<p>但是，我们希望只序列化firstName，并且和以前一样不能修改这个类。同样，我们可以通过使用mixin类来解决这个问题：</p>
<pre><code class="java">public abstract class PersonMixin &#123;
    @JsonIgnore private String lastName;
&#125;
</code></pre>
<p>这样，Jackson将忽略这个属性，只序列化firstName。</p>
<h3 id="3、改变属性名"><a href="#3、改变属性名" class="headerlink" title="3、改变属性名"></a>3、改变属性名</h3><p>按照前面的例子，我们还希望在序列化某些属性时更改它们的名称。</p>
<p>让我们修改mixin类，重命名属性lastName:</p>
<pre><code class="java">public abstract class PersonMixin &#123;
    @JsonProperty(&quot;surname&quot;) private String lastName;
&#125;
</code></pre>
<p>现在，我们的 <em>lastName</em> 属性将被序列化为 <em>surname</em>。</p>
<h3 id="4、重写自定义序列化器和反序列化器"><a href="#4、重写自定义序列化器和反序列化器" class="headerlink" title="4、重写自定义序列化器和反序列化器"></a>4、重写自定义序列化器和反序列化器</h3><p>在其他情况下，我们会发现使用自定义序列化器和反序列化器的类，但我们希望重写它们。当然，我们不能也不想修改这些类。</p>
<p>让我们扩展我们的<em>Person</em>类来包含一个自定义序列化器和反序列化器：</p>
<pre><code class="java">@JsonSerialize(using = PersonSerializer.class)
@JsonDeserialize(using = PersonDeserializer.class)
public class Person &#123;
    private final String firstName;
    private final String lastName;

    // getters, setters, constructors...
    public static class PersonSerializer extends JsonSerializer&lt;Person&gt; &#123;
        static final String SEPARATOR = &quot; &quot;;
        @Override
        public void serialize(
            Person person, JsonGenerator jsonGenerator, SerializerProvider serializerProvider)
            throws IOException &#123;
            jsonGenerator.writeString(person.getFirstName() + SEPARATOR + person.getLastName());
        &#125;
    &#125;

    public static class PersonDeserializer extends JsonDeserializer&lt;Person&gt; &#123;
        @Override
        public Person deserialize(JsonParser jsonParser, DeserializationContext deserializationContext)
            throws IOException &#123;
            String[] fields = jsonParser.getValueAsString().split(PersonSerializer.SEPARATOR);
            return new Person(fields[0], fields[1]);
        &#125;
    &#125;
&#125;
</code></pre>
<p>正如我们所见，<em>Person</em> 类现在通过连接<em>firstName</em> 和<em>lastName</em> 进行序列化。</p>
<p>然而，在某些情况下，我们希望以不同的方式序列化这个类。 让我们为我们的类创建一个不同的序列化器和反序列化器：</p>
<pre><code class="java">public static class PersonReversedSerializer extends JsonSerializer&lt;Person&gt; &#123;
    static final String SEPARATOR = &quot;, &quot;;
    @Override
    public void serialize(
        Person person, JsonGenerator jsonGenerator, SerializerProvider serializerProvider)
        throws IOException &#123;
        jsonGenerator.writeString(person.getLastName() + SEPARATOR + person.getFirstName());
    &#125;
&#125;

public static class PersonReversedDeserializer extends JsonDeserializer&lt;Person&gt; &#123;
    @Override
    public Person deserialize(JsonParser jsonParser, DeserializationContext deserializationContext)
        throws IOException &#123;
        String[] fields = jsonParser.getValueAsString().split(PersonReversedSerializer.SEPARATOR);
        return new Person(fields[1], fields[0]);
    &#125;
&#125;
</code></pre>
<p>现在，我们的 <em>Person</em> 将被序列化为“<em>lastName</em>, <em>firstName</em>”。</p>
<p>正如我们之前所做的那样，要在不修改 <em>Person</em> 的情况下使用这个新的序列化器和反序列化器，我们需要在我们的 mixin 类中指定它：</p>
<pre><code class="java">@JsonSerialize(using = PersonReversedSerializer.class)
@JsonDeserialize(using = PersonReversedDeserializer.class)
public abstract class PersonMixin &#123;&#125;
</code></pre>
<p>现在，Jackson将使用这些序列化器，并将忽略<em>Person</em>中指定的序列化器。</p>
<p>如果我们只是想对一个特定的属性这样做也是一样的。</p>
<h2 id="9、禁用Jackson注解"><a href="#9、禁用Jackson注解" class="headerlink" title="9、禁用Jackson注解"></a>9、禁用Jackson注解</h2><p>我们可以这样来禁用该实体上的所有Jackson注解：</p>
<pre><code class="java">import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;
import com.fasterxml.jackson.databind.*;
import com.fasterxml.jackson.databind.json.JsonMapper;
import lombok.Data;

// 假设我们有一个带Jackson注解的实体
@Data
@JsonInclude(JsonInclude.Include.NON_NULL)
@JsonPropertyOrder(&#123; &quot;name&quot;, &quot;id&quot; &#125;)
class Student &#123;
    private Long id = 1L;
    private String name;
&#125;

public class TestMain &#123;
    public static void main(String[] args) throws Exception &#123;
        ObjectMapper objectMapper = new ObjectMapper();
        // 让注解失效,此方法已经被标记@Deprecated
        objectMapper.disable(MapperFeature.USE_ANNOTATIONS);
        System.out.println(objectMapper.writeValueAsString(new Student()));
        // 输出内容: &#123;&quot;id&quot;:1,&quot;name&quot;:null&#125;

        // 方式二（2.10 后新增）:
        JsonMapper mapper = JsonMapper.builder().disable(MapperFeature.USE_ANNOTATIONS).build();
        System.out.println(mapper.writeValueAsString(new Student()));
        // 输出内容: &#123;&quot;id&quot;:1,&quot;name&quot;:null&#125;
    &#125;
&#125;
</code></pre>
<h1 id="八、Jackson-注解扩展"><a href="#八、Jackson-注解扩展" class="headerlink" title="八、Jackson 注解扩展"></a>八、Jackson 注解扩展</h1><h2 id="JsonIdentityReference"><a href="#JsonIdentityReference" class="headerlink" title="@JsonIdentityReference"></a>@JsonIdentityReference</h2><p>使用指定的标识来序列化Java对象，而不是序列化整个对象</p>
<pre><code class="java">@JsonIdentityInfo(generator = ObjectIdGenerators.PropertyGenerator.class, property = &quot;id&quot;)
@JsonIdentityReference(alwaysAsId = true)
public class BeanWithoutIdentityReference &#123;
    private int id;
    private String name;
&#125;
</code></pre>
<h2 id="JsonAppend"><a href="#JsonAppend" class="headerlink" title="@JsonAppend"></a>@JsonAppend</h2><p>运行在序列化时添加额外的属性</p>
<pre><code class="java">import com.fasterxml.jackson.databind.annotation.JsonAppend;
import com.fasterxml.jackson.databind.*;
import lombok.*;

@Data
@NoArgsConstructor
@AllArgsConstructor
@JsonAppend(attrs = &#123;@JsonAppend.Attr(value = &quot;version&quot;)&#125;)
class BeanWithAppend &#123;
    private Integer id;
    private String name;
&#125;

public class TestMain &#123;
    public static void main(String[] args) throws Exception &#123;
        BeanWithAppend bean = new BeanWithAppend(2, &quot;Bean With Append Annotation&quot;);
        ObjectWriter writer = new ObjectMapper().writerFor(BeanWithAppend.class).withAttribute(&quot;version&quot;, &quot;1.0&quot;);
        String jsonString = writer.writeValueAsString(bean);
        System.out.println(jsonString);
        // 输出内容: &#123;&quot;id&quot;:2,&quot;name&quot;:&quot;Bean With Append Annotation&quot;,&quot;version&quot;:&quot;1.0&quot;&#125;
    &#125;
&#125;
</code></pre>
<h2 id="JsonNaming"><a href="#JsonNaming" class="headerlink" title="@JsonNaming"></a>@JsonNaming</h2><p>指定序列化的时候属性命名方式</p>
<p>有四种选项：</p>
<ul>
<li><p>KEBAB_CASE：由连字符分割，例如：kebab-case</p>
</li>
<li><p>LOWER_CASE：所有的字母都转换为小写，例如：lowercase</p>
</li>
<li><p>SNAKE_CASE：所有的字母都转换为小写，并且由下划线分割，例如：snake_case</p>
</li>
<li><p>UPPER_CAMEL_CASE：所有名称元素，包括第一个元素，都以大写字母开头，后跟小写字母，并且没有分隔符，例如：UpperCamelCase</p>
</li>
</ul>
<pre><code class="java">import com.fasterxml.jackson.databind.annotation.JsonNaming;
import com.fasterxml.jackson.databind.*;
import lombok.*;

@Data
@NoArgsConstructor
@AllArgsConstructor
@JsonNaming(PropertyNamingStrategies.SnakeCaseStrategy.class)
class NamingBean &#123;
    private Integer id;
    private String beanName;
&#125;

public class TestMain &#123;
    public static void main(String[] args) throws Exception &#123;
        NamingBean bean = new NamingBean(2, &quot;Naming Bean&quot;);
        String jsonString = new ObjectMapper().writeValueAsString(bean);
        System.out.println(jsonString);
        // 输出内容: &#123;&quot;id&quot;:2,&quot;bean_name&quot;:&quot;Naming Bean&quot;&#125;
    &#125;
&#125;
</code></pre>
<h2 id="JsonPropertyDescription"><a href="#JsonPropertyDescription" class="headerlink" title="@JsonPropertyDescription"></a>@JsonPropertyDescription</h2><p>用于生成字段的描述信息。Jackson的独立模块JSON Schema提供了创建Json信息表(Json schemas)来描述Java的类型信息. 信息表可用于输出我们期望的序列化Java对象, 或者在反序列化前验证JSON文档（Document）</p>
<p>首先需要导入JSON Schema依赖：</p>
<pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;com.fasterxml.jackson.module&lt;/groupId&gt;
    &lt;artifactId&gt;jackson-module-jsonSchema&lt;/artifactId&gt;
    &lt;version&gt;2.13.3&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>注解@JsonPropertyDescription允许把人类可读的描述信息, 附加在要创建的Json信息表的description属性</p>
<pre><code class="java">import com.fasterxml.jackson.annotation.JsonPropertyDescription;
import com.fasterxml.jackson.databind.*;
import com.fasterxml.jackson.module.jsonSchema.JsonSchema;
import com.fasterxml.jackson.module.jsonSchema.factories.SchemaFactoryWrapper;
import lombok.*;

@Data
@NoArgsConstructor
@AllArgsConstructor
class PropertyDescriptionBean &#123;
    private int id;
    @JsonPropertyDescription(&quot;This is a description of the name property&quot;)
    private String name;
&#125;

public class TestMain &#123;
    public static void main(String[] args) throws Exception &#123;
        ObjectMapper objectMapper = new ObjectMapper();
        SchemaFactoryWrapper wrapper = new SchemaFactoryWrapper();
        objectMapper.acceptJsonFormatVisitor(PropertyDescriptionBean.class, wrapper);
        JsonSchema jsonSchema = wrapper.finalSchema();
        String jsonString = objectMapper.writeValueAsString(jsonSchema);
        System.out.println(jsonString);
    &#125;
&#125;
</code></pre>
<p>打印结果如下（JSON经过格式化）</p>
<pre><code class="json">&#123;
    &quot;type&quot;: &quot;object&quot;,
    &quot;id&quot;: &quot;urn:jsonschema:PropertyDescriptionBean&quot;,
    &quot;properties&quot;: &#123;
        &quot;id&quot;: &#123;
            &quot;type&quot;: &quot;integer&quot;
        &#125;,
        &quot;name&quot;: &#123;
            &quot;type&quot;: &quot;string&quot;,
            &quot;description&quot;: &quot;This is a description of the name property&quot;
        &#125;
    &#125;
&#125;
</code></pre>
<h2 id="JsonPOJOBuilder"><a href="#JsonPOJOBuilder" class="headerlink" title="@JsonPOJOBuilder"></a>@JsonPOJOBuilder</h2><p>自定义生成器类，来控制JSON的反序列化行为。该注解用来配置一个builder类用于定制反序列化过程，尤其是当JSON文档中属性命名习惯和POJO类对象的属性不同</p>
<p>@JsonPOJOBuilder有两个属性</p>
<ul>
<li><p>buildMethodName：将JSON字段绑定到bean的属性后，用于实例化预期bean的无参构造的名称。默认名称为build。</p>
</li>
<li><p>withPrefix：用于自动检测json和bean属性之间匹配的名称前缀。默认前缀为with。</p>
</li>
</ul>
<p>1、假设我们要反序列化的JSON如下</p>
<pre><code class="json">&#123;
    &quot;id&quot;: 5,
    &quot;name&quot;: &quot;POJO Builder Bean&quot;
&#125;
</code></pre>
<p>2、对应的POJO（可以看到Bean属性的名称和JSON字符串中对应属性的名称不同. 这就是@JsonPOJOBuilder发挥作用的地方）：</p>
<pre><code class="java">@JsonDeserialize(builder = BeanBuilder.class)
public class POJOBuilderBean &#123;
    private int identity;
    private String beanName;
&#125;
</code></pre>
<p>3、对应的生成器：</p>
<pre><code class="java">@JsonPOJOBuilder(buildMethodName = &quot;createBean&quot;, withPrefix = &quot;construct&quot;)
public class BeanBuilder &#123;
    private int idValue;
    private String nameValue;
    public BeanBuilder constructId(int id) &#123;
        idValue = id;
        return this;
    &#125;

    public BeanBuilder constructName(String name) &#123;
        nameValue = name;
        return this;
    &#125;

    public POJOBuilderBean createBean() &#123;
        return new POJOBuilderBean(idValue, nameValue);
    &#125;
&#125;
</code></pre>
<p>4、使用ObjectMapper反序列化：</p>
<pre><code class="java">String jsonString = &quot;&#123;\&quot;id\&quot;:5,\&quot;name\&quot;:\&quot;POJO Builder Bean\&quot;&#125;&quot;;
POJOBuilderBean bean = mapper.readValue(jsonString, POJOBuilderBean.class);
</code></pre>
<p>5、完整代码：</p>
<pre><code class="java">import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import com.fasterxml.jackson.databind.annotation.JsonPOJOBuilder;
import lombok.*;

@Data
@NoArgsConstructor
@AllArgsConstructor
@JsonDeserialize(builder = BeanBuilder.class)
class POJOBuilderBean &#123;
    private int identity;
    private String beanName;
&#125;

/**
 * 我们配置了注解@JsonPOJOBuilder的参数, 用createBean方法作为build方法, 用construct前缀来匹配属性名
 */
@JsonPOJOBuilder(buildMethodName = &quot;createBean&quot;, withPrefix = &quot;construct&quot;)
class BeanBuilder &#123;
    private int idValue;
    private String nameValue;

    public BeanBuilder constructId(int id) &#123;
        idValue = id;
        return this;
    &#125;

    public BeanBuilder constructName(String name) &#123;
        nameValue = name;
        return this;
    &#125;

    public POJOBuilderBean createBean() &#123;
        return new POJOBuilderBean(idValue, nameValue);
    &#125;
&#125;

public class TestMain &#123;
    public static void main(String[] args) throws Exception &#123;
        String jsonString = &quot;&#123;\&quot;id\&quot;:5,\&quot;name\&quot;:\&quot;POJO Builder Bean\&quot;&#125;&quot;;
        POJOBuilderBean bean = new ObjectMapper().readValue(jsonString, POJOBuilderBean.class);
        System.out.println(bean);
        // 输出内容: POJOBuilderBean(identity=5, beanName=POJO Builder Bean)
    &#125;
&#125;
</code></pre>
<h1 id="九、SpringBoot-Jackson"><a href="#九、SpringBoot-Jackson" class="headerlink" title="九、SpringBoot &amp; Jackson"></a>九、SpringBoot &amp; Jackson</h1><p>通常我们在使用SpringBoot框架时，如果没有特别指定接口的序列化类型，则会使用SpringBoot框架默认集成的Jackson框架进行处理，通过Jackson框架将服务端响应的数据序列化成JSON格式的数据。</p>
<p>目前市面上针对JSON序列化的框架很多,比较出名的就是<a target="_blank" rel="noopener" href="https://github.com/FasterXML/jackson">Jackson</a>、<a target="_blank" rel="noopener" href="https://github.com/google/gson">Gson</a>、<a target="_blank" rel="noopener" href="https://github.com/alibaba/fastjson">FastJson</a>。如果开发者对序列化框架没有特别的要求的情况下，个人建议是直接使用SpringBoot框架默认集成的Jackson，<strong>没有必要</strong>进行更换。</p>
<h2 id="1、序列化-反序列化-时间格式"><a href="#1、序列化-反序列化-时间格式" class="headerlink" title="1、序列化 &amp; 反序列化 时间格式"></a>1、序列化 &amp; 反序列化 时间格式</h2><p>在我们的接口中，针对时间类型的字段序列化是最常见的需求之一，一般前后端开发人员会针对时间字段统一进行约束，这样有助于在编码开发时，统一编码规范。</p>
<p>在Spring Boot框架中，如果使用Jackson处理框架，并且没有任何配置的情况下，Jackson针对不同时间类型字段，序列化的格式也会不尽相同。</p>
<p>先来看一个简单示例，User.java实体类编码如下：</p>
<pre><code class="java">import com.fasterxml.jackson.annotation.JsonFormat;
import lombok.Data;
import java.sql.Timestamp;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.ZoneId;
import java.util.Calendar;
import java.util.Date;
import java.util.Random;

@Data
public class User &#123;
    private String name = &quot;姓名-&quot; + new Random().nextInt(5);
    private Integer age = new Random().nextInt(100);
    private LocalDateTime localDateTime;
    private LocalDate localDate;
    private Date date;
    private Timestamp timestamp;
    private Calendar calendar;

    public static User buildOne() &#123;
        User user = new User();
        LocalDateTime now = LocalDateTime.now();
        user.setLocalDateTime(now);
        user.setLocalDate(now.plusYears(15).toLocalDate());
        user.setDate(Date.from(now.plusYears(10).atZone(ZoneId.systemDefault()).toInstant()));
        user.setTimestamp(Timestamp.from(now.plusYears(5).atZone(ZoneId.systemDefault()).toInstant()));
        user.setCalendar(Calendar.getInstance());
        return user;
    &#125;
&#125;
</code></pre>
<p>接口代码层也很简单，返回一个User的实体对象即可，代码如下：</p>
<pre><code class="java">@RestController
public class TestController &#123;
    @GetMapping(&quot;/queryOne&quot;)
    public ResponseEntity&lt;User&gt; queryOne() &#123;
        return ResponseEntity.ok(User.buildOne());
    &#125;
&#125;
</code></pre>
<p>如果我们对框架代码没有任何的配置，此时我们通过调用接口&#x2F;queryOne，拿到的返回结果数据如下：</p>
<pre><code class="json">&#123;
    &quot;name&quot;: &quot;姓名-0&quot;,
    &quot;age&quot;: 1,
    &quot;localDateTime&quot;: &quot;2022-11-22T20:40:20.3144084&quot;,
    &quot;localDate&quot;: &quot;2037-11-22&quot;,
    &quot;date&quot;: &quot;2032-11-22T12:40:20.314+00:00&quot;,
    &quot;timestamp&quot;: &quot;2027-11-22T12:40:20.314+00:00&quot;,
    &quot;calendar&quot;: &quot;2022-11-22T12:40:20.318+00:00&quot;
&#125;
</code></pre>
<p>Jackson序列化框架针对四个不同的时间类型字段，序列化处理的操作是不同的，如果我们对时间字段有格式化的要求时，我们应该如何处理呢？</p>
<h3 id="1、-JsonFormat-注解配置"><a href="#1、-JsonFormat-注解配置" class="headerlink" title="1、@JsonFormat 注解配置"></a>1、@JsonFormat 注解配置</h3><p>最直接也是最简单的一种方式，是我们通过使用Jackson提供的@JsonFormat注解，对需要格式化处理的时间字段进行标注，在@JsonFormat注解中写上我们的时间格式化字符。</p>
<p>1、User.java代码如下：</p>
<pre><code class="java">import com.fasterxml.jackson.annotation.JsonFormat;
import lombok.Data;
import java.sql.Timestamp;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.ZoneId;
import java.util.Calendar;
import java.util.Date;
import java.util.Random;

@Data
public class User &#123;
    private String name = &quot;姓名-&quot; + new Random().nextInt(5);
    private Integer age = new Random().nextInt(100);
    // 需要注意的是: LocalDateTime 格式化必须带上HH mm ss, 不能只有yyyy MM dd, 不然反序列化会报错,序列化还是正常
    // 总结: 格式可以变, 年月日时分秒不可少.
    @JsonFormat(pattern = &quot;yyyy_MM_dd HH_mm_ss&quot;)
    private LocalDateTime localDateTime;
    @JsonFormat(pattern = &quot;yyyy_MM_dd&quot;)
    private LocalDate localDate;
    @JsonFormat(pattern = &quot;yyyyMMdd&quot;)
    private Date date;
    @JsonFormat(pattern = &quot;yyyyMMdd&quot;)
    private Timestamp timestamp;
    @JsonFormat(pattern = &quot;yyyyMMdd HHmmss&quot;)
    private Calendar calendar;

    public static User buildOne() &#123;
        User user = new User();
        LocalDateTime now = LocalDateTime.now();
        user.setLocalDateTime(now);
        user.setLocalDate(now.plusYears(15).toLocalDate());
        user.setDate(Date.from(now.plusYears(10).atZone(ZoneId.systemDefault()).toInstant()));
        user.setTimestamp(Timestamp.from(now.plusYears(5).atZone(ZoneId.systemDefault()).toInstant()));
        user.setCalendar(Calendar.getInstance());
        return user;
    &#125;
&#125;
</code></pre>
<p>2、调用Controller接口序列化对象</p>
<pre><code class="java">@RestController
public class TestController &#123;
    @GetMapping(&quot;/queryOne&quot;)
    public ResponseEntity&lt;User&gt; queryOne() &#123;
        return ResponseEntity.ok(User.buildOne());
    &#125;
&#125;
</code></pre>
<p>3、返回结果如下，可以发现时间格式都按照指定格式序列化输出成字符串了</p>
<pre><code class="json">&#123;
    &quot;name&quot;: &quot;姓名-4&quot;,
    &quot;age&quot;: 27,
    &quot;localDateTime&quot;: &quot;2022_11_22 20_51_35&quot;,
    &quot;localDate&quot;: &quot;2037_11_22&quot;,
    &quot;date&quot;: &quot;20321122&quot;,
    &quot;timestamp&quot;: &quot;20271122&quot;,
    &quot;calendar&quot;: &quot;20221122 125135&quot;
&#125;
</code></pre>
<p>4、现在开始尝试反序列化对象，还是使用如上的User.java。我们把&#x2F;queryOne返回的结果当成request Body。现在写一个Post接口</p>
<pre><code class="java">@RestController
public class TestController &#123;
    // ...GET接口省略了
    @PostMapping(&quot;/queryTwo&quot;)
    public ResponseEntity&lt;User&gt; queryTwo(@RequestBody User user) &#123;
        System.out.println(user);
        return ResponseEntity.ok(user);
    &#125;
&#125;
</code></pre>
<p>5、然后调用当前接口查看控制台输出：</p>
<pre><code class="java">User(name=姓名-4, 
     age=27, 
     localDateTime=2022-11-22T20:51:35, 
     localDate=2037-11-22, 
     date=Mon Nov 22 08:00:00 CST 2032, 
     timestamp=2027-11-22 08:00:00.0,
     calendar=java.util.GregorianCalendar[time=1669121495000,areFieldsSet=true,areAllFieldsSet=true,lenient=true,zone=sun.util.calendar.ZoneInfo[id=&quot;UTC&quot;,offset=0,dstSavings=0,useDaylight=false,transitions=0,lastRule=null],firstDayOfWeek=1,minimalDaysInFirstWeek=1,ERA=1,YEAR=2022,MONTH=10,WEEK_OF_YEAR=48,WEEK_OF_MONTH=4,DAY_OF_MONTH=22,DAY_OF_YEAR=326,DAY_OF_WEEK=3,DAY_OF_WEEK_IN_MONTH=4,AM_PM=1,HOUR=0,HOUR_OF_DAY=12,MINUTE=51,SECOND=35,MILLISECOND=0,ZONE_OFFSET=0,DST_OFFSET=0])
</code></pre>
<p>可以看得出来增加@JsonFormat直接后，不管是序列化或者反序列化都能正常格式化时间了。</p>
<h3 id="2、application-yml-全局配置"><a href="#2、application-yml-全局配置" class="headerlink" title="2、application.yml 全局配置"></a>2、application.yml 全局配置</h3><p>通过@JsonFormat注解的方式虽然能解决问题，但是我们在实际的开发当中，涉及到的时间字段会非常多，如果全部都用注解的方式对项目中的时间字段进行标注，那开发的工作量也会很大，并且多团队一起协同编码时，难免会存在遗漏的情况，因此，@JsonFormat注解只适用于针对特定的接口，特定的场景下，对序列化响应的时间字段进行约束，而在全局的角度来看，开发者应该考虑通过在application.yml配置文件中进行全局配置。针对SpringBoot框架中Jackson的全局配置，我们在application.yml进行配置时，IDEA等编辑器会给出相应的提示，只需要输入<code>spring.jackson.</code>IDEA就会自动弹窗提示。</p>
<p>开发者可以通过<code>org.springframework.boot.autoconfigure.jackson.JacksonProperties.java</code>查看所有配置的源码信息</p>
<table>
<thead>
<tr>
<th>配置属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>date-format</code></td>
<td>日期字段格式化，例如:<code>yyyy-MM-dd HH:mm:ss</code></td>
</tr>
</tbody></table>
<p>我们从Spring Boot的源码中可以看到对Jackson的时间处理逻辑，JacksonAutoConfiguration.java中部分代码如下：</p>
<pre><code class="java">private void configureDateFormat(Jackson2ObjectMapperBuilder builder) &#123;
    // We support a fully qualified class name extending DateFormat or a date
    // pattern string value
    String dateFormat = this.jacksonProperties.getDateFormat();
    if (dateFormat != null) &#123;
        try &#123;
            Class&lt;?&gt; dateFormatClass = ClassUtils.forName(dateFormat, null);
            builder.dateFormat((DateFormat) BeanUtils.instantiateClass(dateFormatClass));
        &#125;
        catch (ClassNotFoundException ex) &#123;
            SimpleDateFormat simpleDateFormat = new SimpleDateFormat(dateFormat);
            // Since Jackson 2.6.3 we always need to set a TimeZone (see
            // gh-4170). If none in our properties fallback to the Jackson&#39;s
            // default
            TimeZone timeZone = this.jacksonProperties.getTimeZone();
            if (timeZone == null) &#123;
                timeZone = new ObjectMapper().getSerializationConfig().getTimeZone();
            &#125;
            simpleDateFormat.setTimeZone(timeZone);
            builder.dateFormat(simpleDateFormat);
        &#125;
    &#125;
&#125;
</code></pre>
<p>从上面的代码中，我们可以看到的处理逻辑：</p>
<ul>
<li>从yml配置文件中拿到dateFormat属性字段</li>
<li>首先通过ClassUtils.forName方法来判断开发者配置的是否是格式化类，如果配置的是格式化类，则直接配置dateFormat属性</li>
<li>类找不到的情况下,捕获ClassNotFoundException异常，默认使用JDK自带的SimpleDateFormat类进行初始化</li>
</ul>
<hr>
<p>1、针对全局日期字段的格式化处理，我们只需要使用<code>date-format</code>属性进行配置即可，<code>application.yml</code>配置如下：</p>
<pre><code class="yaml">spring:
  jackson:
    date-format: yyyy_MM_dd HH_mm_ss
    # 此配置对 LocalDateTime、LocalDate、LocalTime 无效（不管配置成什么格式, yyyy_MM_dd 也是无效）
</code></pre>
<p>2、修改User.java类，删除所有@JsonFormat注解</p>
<pre><code class="java">import lombok.Data;
import java.sql.Timestamp;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.ZoneId;
import java.util.Calendar;
import java.util.Date;
import java.util.Random;

@Data
public class User &#123;
    private String name = &quot;姓名-&quot; + new Random().nextInt(5);
    private Integer age = new Random().nextInt(100);
    private LocalDateTime localDateTime;
    private LocalDate localDate;
    private Date date;
    private Timestamp timestamp;
    private Calendar calendar;

    public static User buildOne() &#123;
        User user = new User();
        LocalDateTime now = LocalDateTime.now();
        user.setLocalDateTime(now);
        user.setLocalDate(now.plusYears(15).toLocalDate());
        user.setDate(Date.from(now.plusYears(10).atZone(ZoneId.systemDefault()).toInstant()));
        user.setTimestamp(Timestamp.from(now.plusYears(5).atZone(ZoneId.systemDefault()).toInstant()));
        user.setCalendar(Calendar.getInstance());
        return user;
    &#125;
&#125;
</code></pre>
<p>3、调用Controller的queryOne和queryTwo接口（序列化于反序列化）</p>
<pre><code class="java">@RestController
public class TestController &#123;
    @GetMapping(&quot;/queryOne&quot;)
    public ResponseEntity&lt;User&gt; queryOne() &#123;
        return ResponseEntity.ok(User.buildOne());
    &#125;

    @PostMapping(&quot;/queryTwo&quot;)
    public ResponseEntity&lt;User&gt; queryTwo(@RequestBody User user) &#123;
        System.out.println(user);
        return ResponseEntity.ok(user);
    &#125;
&#125;
</code></pre>
<p>4、queryOne接口序列化输出结果如下：</p>
<pre><code class="json">&#123;
    &quot;name&quot;: &quot;姓名-1&quot;,
    &quot;age&quot;: 68,
    &quot;localDateTime&quot;: &quot;2022-11-22T22:07:47.0203599&quot;,
    &quot;localDate&quot;: &quot;2037-11-22&quot;,
    &quot;date&quot;: &quot;2032_11_22 14_07_47&quot;,
    &quot;timestamp&quot;: &quot;2027_11_22 14_07_47&quot;,
    &quot;calendar&quot;: &quot;2022_11_22 14_07_47&quot;
&#125;
</code></pre>
<p>注意：可以查看到 LocalDateTime 与 LocalDate 时间没有被格式化到。</p>
<p>5.1、接下来再来调用queryTwo接口反序列化，requestBody 如下：</p>
<pre><code class="json">&#123;
    &quot;name&quot;: &quot;姓名-1&quot;,
    &quot;age&quot;: 68,
    &quot;localDateTime&quot;: &quot;2022-11-22 22_07_47&quot;,
    &quot;localDate&quot;: &quot;2037_11_22&quot;,
    &quot;date&quot;: &quot;2032_11_22 14_07_47&quot;,
    &quot;timestamp&quot;: &quot;2027_11_22 14_07_47&quot;,
    &quot;calendar&quot;: &quot;2022_11_22 14_07_47&quot;
&#125;
</code></pre>
<p>5.2、可以看到控制台报如下错误（这是因为Jackson SpringBoot全局配置不支持 LocalDateTime、LocalDate、LocalTime）</p>
<pre><code class="shell">2022-11-22 21:32:39.830  WARN 11552 --- [nio-8080-exec-2] .w.s.m.s.DefaultHandlerExceptionResolver : Resolved [org.springframework.http.converter.HttpMessageNotReadableException: JSON parse error: Cannot deserialize value of type `java.time.LocalDateTime` from String &quot;2022_11_22&quot;: Failed to deserialize java.time.LocalDateTime: (java.time.format.DateTimeParseException) Text &#39;2022_11_22&#39; could not be parsed at index 4; nested exception is com.fasterxml.jackson.databind.exc.InvalidFormatException: Cannot deserialize value of type `java.time.LocalDateTime` from String &quot;2022_11_22&quot;: Failed to deserialize java.time.LocalDateTime: (java.time.format.DateTimeParseException) Text &#39;2022_11_22&#39; could not be parsed at index 4
 at [Source: (PushbackInputStream); line: 4, column: 20] (through reference chain: com.example.springbootjackson.model.User[&quot;localDateTime&quot;])]
</code></pre>
<p><strong>解决方法一</strong>：</p>
<p>5.3、重新修改User.java，在开启全局配置情况下，使用@JsonFormat重写LocalDateTime等失效字段，代码如下：</p>
<pre><code class="java">package com.example.springbootjackson.model;

import com.fasterxml.jackson.annotation.JsonFormat;
import lombok.Data;
import java.sql.Timestamp;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.ZoneId;
import java.util.Calendar;
import java.util.Date;
import java.util.Random;

@Data
public class User &#123;
    private String name = &quot;姓名-&quot; + new Random().nextInt(5);
    private Integer age = new Random().nextInt(100);
    // 需要注意的是: LocalDateTime 格式化必须带上HH mm ss, 不能只有yyyy MM dd, 不然反序列化会报错,序列化还是正常
    // 总结: 格式可以变, 年月日时分秒不可少.
    @JsonFormat(pattern = &quot;yyyy_MM_dd HH_mm_ss&quot;)
    private LocalDateTime localDateTime;
    @JsonFormat(pattern = &quot;yyyy_MM_dd&quot;)
    private LocalDate localDate;
    private Date date;
    private Timestamp timestamp;
    private Calendar calendar;

    public static User buildOne() &#123;
        User user = new User();
        LocalDateTime now = LocalDateTime.now();
        user.setLocalDateTime(now);
        user.setLocalDate(now.plusYears(15).toLocalDate());
        user.setDate(Date.from(now.plusYears(10).atZone(ZoneId.systemDefault()).toInstant()));
        user.setTimestamp(Timestamp.from(now.plusYears(5).atZone(ZoneId.systemDefault()).toInstant()));
        user.setCalendar(Calendar.getInstance());
        return user;
    &#125;
&#125;
</code></pre>
<p>5.4、调用queryOne接口（序列化）返回结果如下：</p>
<pre><code class="json">&#123;
    &quot;name&quot;: &quot;姓名-3&quot;,
    &quot;age&quot;: 91,
    &quot;localDateTime&quot;: &quot;2022_11_22 22_23_19&quot;,
    &quot;localDate&quot;: &quot;2037_11_22&quot;,
    &quot;date&quot;: &quot;2032_11_22 14_23_19&quot;,
    &quot;timestamp&quot;: &quot;2027_11_22 14_23_19&quot;,
    &quot;calendar&quot;: &quot;2022_11_22 14_23_19&quot;
&#125;
</code></pre>
<p>5.5、调用queryTwo接口反序列化，requestBody 为上面的json，调用接口返回结果如下：</p>
<pre><code class="java">User(name=姓名-3, 
     age=91, 
     localDateTime=2022-11-22T22:23:19, 
     localDate=2037-11-22, 
     date=Mon Nov 22 22:23:19 CST 2032, timestamp=2027-11-22 22:23:19.0, 
     calendar=java.util.GregorianCalendar[time=1669126999000,areFieldsSet=true,areAllFieldsSet=true,lenient=true,zone=sun.util.calendar.ZoneInfo[id=&quot;UTC&quot;,offset=0,dstSavings=0,useDaylight=false,transitions=0,lastRule=null],firstDayOfWeek=1,minimalDaysInFirstWeek=1,ERA=1,YEAR=2022,MONTH=10,WEEK_OF_YEAR=48,WEEK_OF_MONTH=4,DAY_OF_MONTH=22,DAY_OF_YEAR=326,DAY_OF_WEEK=3,DAY_OF_WEEK_IN_MONTH=4,AM_PM=1,HOUR=2,HOUR_OF_DAY=14,MINUTE=23,SECOND=19,MILLISECOND=0,ZONE_OFFSET=0,DST_OFFSET=0])
</code></pre>
<h3 id="3、Jackson-注解与全局格式化时间总结"><a href="#3、Jackson-注解与全局格式化时间总结" class="headerlink" title="3、Jackson 注解与全局格式化时间总结"></a>3、Jackson 注解与全局格式化时间总结</h3><ol>
<li>可以发现SpringBoot在格式化时间格式的时候可以使用两种方式，一个是注解单一字段格式化，另一种是全局配置</li>
<li>@JsonFormat 注解单一字段格式化优缺点：<ul>
<li>优点：可以格式化（序列化与反序列化）任意时间类型</li>
<li>缺点：如果项目时间格式比较统一，那么每个字段都配置相同的操作，显示很冗余。</li>
</ul>
</li>
<li>application.yml 全局时间格式化配置优缺点：<ul>
<li>优点：可以不需要每个字段都配置，配置一个全局的，如果有个别需要单独处理使用@JsonFormat重写即可</li>
<li>缺点：无法格式化（序列化与反序列化）LocalDateTime、LocalDate、LocalTime 时间类型（可以搭配@JsonFormat解决）</li>
</ul>
</li>
<li>LocalDateTime、LocalDate、LocalTime 全局配置失效，除了 使用全局配置 + @JsonFormat，还可以使用其他方案请看下篇</li>
</ol>
<h3 id="4、SpringBoot-LocalDateTime-时间格式失效解决"><a href="#4、SpringBoot-LocalDateTime-时间格式失效解决" class="headerlink" title="4、SpringBoot LocalDateTime 时间格式失效解决"></a>4、SpringBoot LocalDateTime 时间格式失效解决</h3><blockquote>
<p>方案一：Jackson序列化LocalDateTime，引包 + 配置ObjectMapper</p>
</blockquote>
<p>1、Java序列化工具用的是Jackson，实体类上加注解，可以让Date序列化生效，但是LocalDateTime属性不生效</p>
<pre><code class="yaml">spring:
  jackson:
    time-zone: GMT+8
    date-format: yyyy-MM-dd HH:mm:ss
    default-property-inclusion: always
</code></pre>
<p>2、添加使LocalDateTime生效的依赖（SpringBoot-2.5.0版本的mvc-starter已经包含该依赖，所以可以不引入）</p>
<pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;com.fasterxml.jackson.datatype&lt;/groupId&gt;
    &lt;artifactId&gt;jackson-datatype-jsr310&lt;/artifactId&gt;
    &lt;version&gt;2.12.3&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>3、SpringBoot 配置 ObjectMapper</p>
<pre><code class="java">import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.SerializationFeature;
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;
import com.fasterxml.jackson.datatype.jsr310.deser.LocalDateDeserializer;
import com.fasterxml.jackson.datatype.jsr310.deser.LocalDateTimeDeserializer;
import com.fasterxml.jackson.datatype.jsr310.ser.LocalDateSerializer;
import com.fasterxml.jackson.datatype.jsr310.ser.LocalDateTimeSerializer;
import org.springframework.context.annotation.Bean;
import org.springframework.http.converter.json.Jackson2ObjectMapperBuilder;
import org.springframework.stereotype.Component;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;

@Component
public class LocalDateTimeSerializerConfig &#123;
    DateTimeFormatter localDateTimeFormatter = DateTimeFormatter.ofPattern(&quot;yyyy_MM_dd HH_mm_ss&quot;);
    DateTimeFormatter localDateFormatter = DateTimeFormatter.ofPattern(&quot;yyyy_MM_dd&quot;);

    @Bean
    public ObjectMapper serializingObjectMapper() &#123;
        JavaTimeModule module = new JavaTimeModule();
        LocalDateTimeDeserializer dateTimeDeserializer = new LocalDateTimeDeserializer(localDateTimeFormatter);
        LocalDateTimeSerializer dateTimeSerializer = new LocalDateTimeSerializer(localDateTimeFormatter);
        // LocalDateTime类型 序列化与反序列化同时处理
        module.addDeserializer(LocalDateTime.class, dateTimeDeserializer);
        module.addSerializer(LocalDateTime.class, dateTimeSerializer);
        // LocalDate类型 序列化与反序列化同时处理
        module.addDeserializer(LocalDate.class, new LocalDateDeserializer(localDateFormatter));
        module.addSerializer(LocalDate.class, new LocalDateSerializer(localDateFormatter));
        return Jackson2ObjectMapperBuilder.json().modules(module)
                .featuresToDisable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS).build();
    &#125;
&#125;
</code></pre>
<hr>
<blockquote>
<p>方案二：Jackson序列化LocalDateTime，依赖 + 重写 WebMvcConfigurer 方法 + 配置ObjectMapper</p>
</blockquote>
<p>1、添加使LocalDateTime生效的依赖（SpringBoot-2.5.0版本的mvc-starter已经包含该依赖，所以可以不引入）</p>
<pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;com.fasterxml.jackson.datatype&lt;/groupId&gt;
    &lt;artifactId&gt;jackson-datatype-jsr310&lt;/artifactId&gt;
    &lt;version&gt;2.12.3&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>2、出参入参处理，<strong>实现</strong>WebMvcConfigurer的extendMessageConverters方法</p>
<pre><code class="java">package com.example.springbootjackson.config;

import com.fasterxml.jackson.databind.DeserializationFeature;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.SerializationFeature;
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;
import com.fasterxml.jackson.datatype.jsr310.deser.LocalDateTimeDeserializer;
import com.fasterxml.jackson.datatype.jsr310.ser.LocalDateTimeSerializer;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.converter.HttpMessageConverter;
import org.springframework.http.converter.json.Jackson2ObjectMapperBuilder;
import org.springframework.http.converter.json.MappingJackson2HttpMessageConverter;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;
import java.text.SimpleDateFormat;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.List;

@Configuration
public class DateTimeSerializerConfig implements WebMvcConfigurer &#123;

    @Value(&quot;$&#123;spring.jackson.date-format&#125;&quot;)
    private String pattern;

    /**
     * 时间处理
     * 使用此方法, 以下 spring-boot: jackson时间格式化 配置 将会失效
     * spring.jackson.date-format=yyyy-MM-dd HH:mm:ss
     * spring.jackson.time-zone=GMT+8
     * 原因: 会覆盖 @EnableAutoConfiguration 关于 WebMvcAutoConfiguration 的配置
     */
    @Override
    public void extendMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) &#123;
        MappingJackson2HttpMessageConverter converter = new MappingJackson2HttpMessageConverter();

        // LocalDateTime 格式化
        JavaTimeModule module = new JavaTimeModule();
        LocalDateTimeDeserializer dateTimeDeserializer = new LocalDateTimeDeserializer(DateTimeFormatter.ofPattern(pattern));
        LocalDateTimeSerializer dateTimeSerializer = new LocalDateTimeSerializer(DateTimeFormatter.ofPattern(pattern));
        module.addDeserializer(LocalDateTime.class, dateTimeDeserializer);
        module.addSerializer(LocalDateTime.class, dateTimeSerializer);
        ObjectMapper objectMapper = Jackson2ObjectMapperBuilder.json().modules(module)
                .featuresToDisable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS).build();
        
        // LocalDate 格式化如果有需要可以自行定义

        // Date 时间格式化
        objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);
        objectMapper.setDateFormat(new SimpleDateFormat(pattern));

        // 设置格式化内容
        converter.setObjectMapper(objectMapper);
        converters.add(0, converter);
    &#125;
&#125;
</code></pre>
<blockquote>
<p>配置方案一 或者 方案二：然后执行如下代码。</p>
</blockquote>
<pre><code class="java">@Data
public class User &#123;
    private String name = &quot;姓名-&quot; + new Random().nextInt(5);
    private Integer age = new Random().nextInt(100);
    private LocalDateTime localDateTime;
    private LocalDate localDate;
    private Date date;
    private Timestamp timestamp;
    private Calendar calendar;

    public static User buildOne() &#123;
        User user = new User();
        LocalDateTime now = LocalDateTime.now();
        user.setLocalDateTime(now);
        user.setLocalDate(now.plusYears(15).toLocalDate());
        user.setDate(Date.from(now.plusYears(10).atZone(ZoneId.systemDefault()).toInstant()));
        user.setTimestamp(Timestamp.from(now.plusYears(5).atZone(ZoneId.systemDefault()).toInstant()));
        user.setCalendar(Calendar.getInstance());
        return user;
    &#125;
&#125;
</code></pre>
<pre><code class="java">@RestController
public class TestController &#123;
    @GetMapping(&quot;/queryOne&quot;)
    public ResponseEntity&lt;User&gt; queryOne() &#123;
        return ResponseEntity.ok(User.buildOne());
    &#125;

    @PostMapping(&quot;/queryTwo&quot;)
    public ResponseEntity&lt;User&gt; queryTwo(@RequestBody User user) &#123;
        System.out.println(user);
        return ResponseEntity.ok(user);
    &#125;
&#125;
</code></pre>
<p>执行后可以发现结果都是正常</p>
<blockquote>
<p>5、SpringBoot  GET 接口入参时间格式化填(天)坑</p>
<p>GET请求及POST表单日期时间字符串格式转换的区别：这种情况要和时间作为JSON字符串时区别对待，因为前端JSON转后端POJO底层使用的是JSON序列化Jackson工具（HttpMessgeConverter）；而时间字符串作为普通请求参数传入时，转换用的是Converter，两者在处理方式上是有区别。</p>
<ul>
<li>POST 请求时：时间参数作为JSON字符串，从前端JSON转到后端POJO，底层使用的是JSON序列化Jackson工具（HttpMessgeConverter），Header中Content-Type类型为application&#x2F;json。</li>
<li>GET 请求时：而时间字符串作为普通请求参数传入时，转换用的是SpringWeb框架的Converter。</li>
</ul>
</blockquote>
<h2 id="2、SpringBoot-Jackson-配置选项"><a href="#2、SpringBoot-Jackson-配置选项" class="headerlink" title="2、SpringBoot Jackson 配置选项"></a>2、SpringBoot Jackson 配置选项</h2><p>在上面的时间字段序列化处理，我们已经知道了如何配置，那么在SpringBoot的框架中，针对Jackson的各个配置项主要包含哪些呢？我们通过IDEA的提示可以看到：会出现12个配置项，并且有一个已经过时了。这里就讲解11个正在使用的（本人使用的是SpringBoot 2.5.0 version）</p>
<pre><code class="properties">spring.jackson.locale=zh_CN
spring.jackson.time-zone=Asia/Shanghai
spring.jackson.date-format=yyyy-MM-dd HH:mm:ss
spring.jackson.property-naming-strategy=SNAKE_CASE
spring.jackson.default-property-inclusion=always
spring.jackson.serialization.write-empty-json-arrays=true
spring.jackson.deserialization.read-enums-using-to-string=true
spring.jackson.mapper.use-annotations=true
spring.jackson.parser.ignore-undefined=true
spring.jackson.generator.ignore-unknown=true
spring.jackson.visibility.field=any
</code></pre>
<h3 id="1、date-format-日期格式化"><a href="#1、date-format-日期格式化" class="headerlink" title="1、date-format 日期格式化"></a>1、date-format 日期格式化</h3><p>date-format 在前面我们已经知道了该属性的作用，主要是针对日期字段的格式化</p>
<pre><code class="yaml">spring:
  jackson:
    date-format: yyyy-MM-dd HH:mm:ss
</code></pre>
<h3 id="2、time-zone-时区"><a href="#2、time-zone-时区" class="headerlink" title="2、time-zone 时区"></a>2、time-zone 时区</h3><p>time-zone 字段也是和日期字段类型，使用不同的时区，最终日期类型字段响应的结果会不一样。</p>
<p>时区的表示方法有两种：</p>
<ul>
<li>指定时区的名称，例如：Asia&#x2F;Shanghai、Asia&#x2F;Hong_Kong、America&#x2F;Los_Angeles</li>
<li>通过格林威治平时<code>GMT</code>针对时分秒做<code>+</code>或者<code>-</code>自定义操作，例如：GMT+8</li>
</ul>
<p>时区配置与代码示例如下：</p>
<pre><code class="yaml">spring:
  jackson:
    date-format: yyyy-MM-dd HH:mm:ss
    time-zone: America/Los_Angeles
</code></pre>
<pre><code class="java">@Data
public class User &#123;
    private String name = &quot;姓名-&quot; + new Random().nextInt(5);
    private Integer age = new Random().nextInt(100);
    private LocalDateTime localDateTime;
    private LocalDate localDate;
    private Date date;
    private Timestamp timestamp;
    private Calendar calendar;

    public static User buildOne() &#123;
        User user = new User();
        LocalDateTime now = LocalDateTime.now();
        user.setLocalDateTime(now);
        user.setLocalDate(now.plusYears(15).toLocalDate());
        user.setDate(Date.from(now.plusYears(10).atZone(ZoneId.systemDefault()).toInstant()));
        user.setTimestamp(Timestamp.from(now.plusYears(5).atZone(ZoneId.systemDefault()).toInstant()));
        user.setCalendar(Calendar.getInstance());
        return user;
    &#125;
&#125;
</code></pre>
<pre><code class="java">@RestController
public class TestController &#123;
    @GetMapping(&quot;/queryOne&quot;)
    public ResponseEntity&lt;User&gt; queryOne() &#123;
        return ResponseEntity.ok(User.buildOne());
    &#125;
&#125;
</code></pre>
<pre><code class="json">&#123;
    &quot;name&quot;: &quot;姓名-3&quot;,
    &quot;age&quot;: 16,
    &quot;localDateTime&quot;: &quot;2022-11-23T18:31:12.1163728&quot;,
    &quot;localDate&quot;: &quot;2037-11-23&quot;,
    &quot;date&quot;: &quot;2032-11-23 02:31:12&quot;,
    &quot;timestamp&quot;: &quot;2027-11-23 02:31:12&quot;,
    &quot;calendar&quot;: &quot;2022-11-23 02:31:12&quot;
&#125;
</code></pre>
<p>我们在结合代码来分析，由于洛杉矶时区与上海时区相差16个小时，因此，Jackson 框架针对日期的序列化时，分别做了不同类型的处理，但我们也能看出差别</p>
<ul>
<li>LocalDateTime、LocalDate 类型的字段，Jackson的时区设置不会对该字段产生影响（因为这两个日期类型自带时区属性）</li>
<li>Date、Timestamp、Calendar 类型的字段受Jackson序列化框架的时区设置影响</li>
</ul>
<hr>
<p>另外一种方式是通过格林威治平时（GMT）做加减法，主要有两种格式支持：</p>
<ul>
<li>GMT+HHMM或者GMT-HHMM或者GMT+H：其中HH代表的是小时数，MM代表的是分钟数，取值范围是0-9。例如我们常见的GMT+8代表东八区，也就是北京时间</li>
<li>GMT+HH:MM 或 GMT-HH:MM：其中HH代表的是小时数，MM代表的是分钟数，取值范围是0-9，和上面意思差不多</li>
</ul>
<p>SpringBoot 配置文件配置如下，配置默认是GMT0时区（与北京时间相差8小时），还是继续执行上面的代码。查看打印结果：</p>
<pre><code class="yaml">spring:
  jackson:
    date-format: yyyy-MM-dd HH:mm:ss
    time-zone: GMT
</code></pre>
<pre><code class="json">&#123;
    &quot;name&quot;: &quot;姓名-1&quot;,
    &quot;age&quot;: 41,
    &quot;localDateTime&quot;: &quot;2022-11-23T21:38:51.8442623&quot;,
    &quot;localDate&quot;: &quot;2037-11-23&quot;,
    &quot;date&quot;: &quot;2032-11-23 13:38:51&quot;,
    &quot;timestamp&quot;: &quot;2027-11-23 13:38:51&quot;,
    &quot;calendar&quot;: &quot;2022-11-23 13:38:51&quot;
&#125;
</code></pre>
<p>自己写测试代码进行测试，示例如下：</p>
<pre><code class="java">public class TimeTest &#123;
    public static void main(String[] args) &#123;
        DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;);
        LocalDateTime localDateTime = LocalDateTime.now();
        System.out.println(localDateTime.format(dateTimeFormatter));
        System.out.println(LocalDateTime.now(ZoneId.of(&quot;GMT+0901&quot;)).format(dateTimeFormatter));
        System.out.println(LocalDateTime.now(ZoneId.of(&quot;GMT+09:01&quot;)).format(dateTimeFormatter));
    &#125;
&#125;
</code></pre>
<pre><code class="shell">2022-11-23 18:36:04
2022-11-23 19:37:04
2022-11-23 19:37:04
</code></pre>
<h3 id="3、locale-本地化"><a href="#3、locale-本地化" class="headerlink" title="3、locale 本地化"></a>3、locale 本地化</h3><p>JSON序列化时Locale的变量设置，简单说就是指定当地时区，例如：zh_HK、en_US</p>
<pre><code class="yaml">spring:
  jackson:
    locale: zh_HK
</code></pre>
<p>一般locale与time-zone不会同时配置，例如我们在代码或者数据库中取出带有时区的时间，想序列化本地时区，就可以使用此配置。</p>
<p>下面我们来看locale配置的使用示例，设置locale为zh_HK：</p>
<pre><code class="yaml">spring:
  jackson:
    date-format: yyyy-MM-dd HH:mm:ss
    locale: zh_HK
</code></pre>
<pre><code class="java">@Data
public class User &#123;
    private String name = &quot;姓名-&quot; + new Random().nextInt(5);
    private Integer age = new Random().nextInt(100);
    private LocalDateTime localDateTime = LocalDateTime.now();
    private Date date = Date.from(Instant.now().atZone(ZoneId.of(&quot;GMT&quot;)).toInstant());
    private Timestamp timestamp = Timestamp.from(Instant.now().atZone(ZoneId.of(&quot;GMT&quot;)).toInstant());
&#125;
</code></pre>
<pre><code class="java">@RestController
public class TestController &#123;
    @GetMapping(&quot;/queryOne&quot;)
    public ResponseEntity&lt;User&gt; queryOne() &#123;
        User user = new User();
        System.out.println(user);
        return ResponseEntity.ok(user);
    &#125;
&#125;
</code></pre>
<p>控制台及前端返回如下：</p>
<pre><code class="java">User(name=姓名-1, age=93, 
     localDateTime=2022-11-23T22:01:10.751406300, 
     date=Thu Nov 24 06:01:10 CST 2022, 
     timestamp=2022-11-24 06:01:10.7514063)
</code></pre>
<pre><code class="json">&#123;
    &quot;name&quot;: &quot;姓名-0&quot;,
    &quot;age&quot;: 71,
    &quot;localDateTime&quot;: &quot;2022-11-23T22:01:10.7614191&quot;,
    &quot;date&quot;: &quot;2022-11-23 22:01:10&quot;,
    &quot;timestamp&quot;: &quot;2022-11-23 22:01:10&quot;
&#125;
</code></pre>
<p>从结果可以看出，控制台输出的date和timestamp，与返回前端的JSON不一致。因为在返回前端时区被设置成了本机的了。</p>
<h3 id="4、visibility-访问级别"><a href="#4、visibility-访问级别" class="headerlink" title="4、visibility 访问级别"></a>4、visibility 访问级别</h3><p>Jackson支持从私有字段中读取值，但是默认情况下不这样做，如果我们的项目中存在不同的序列化反序列化需求，那么我们可以在配置文件中对visibility进行配置。修改User.java代码中的name属性的get方法修饰符从public变更为private。代码如下：</p>
<pre><code class="java">@Data
public class User &#123;
    private String name = &quot;姓名-&quot; + new Random().nextInt(5);
    private Integer age = new Random().nextInt(100);
    // getter方法修饰符从public修改为private
    private String getName() &#123;
        return name;
    &#125;
&#125;

@RestController
public class TestController &#123;
    @GetMapping(&quot;/queryOne&quot;)
    public ResponseEntity&lt;User&gt; queryOne() &#123;
        return ResponseEntity.ok(new User());
    &#125;
&#125;
</code></pre>
<pre><code class="java">&#123;
    &quot;age&quot;: 72
&#125;
</code></pre>
<p>从结果中我们可以看到，由于我们将name属性的getter方法设置为了private，因此Jackson在序列化时，没有拿到该字段。</p>
<p>此时我们修改 application.yml 的配置，我们通过将getter设置为any级别的类型，再调用&#x2F;queryOne接口，响应结果如下：</p>
<pre><code class="yaml">spring:
  jackson:
    visibility:
      getter: any
    # 开启visibility私有字段或方法访问级别, 可以让私有属性或者方法被Jackson序列化或反序列化到
    # 枚举类PropertyAccessor中的枚举属性为key, 枚举类JsonAutoDetect.Visibility中的枚举属性为value
</code></pre>
<p>开启配置后重新调用&#x2F;queryOne接口接口查看返回结果，可以发现私有方法中的name被序列化到了：</p>
<pre><code class="json">&#123;
    &quot;name&quot;: &quot;姓名-2&quot;,
    &quot;age&quot;: 88
&#125;
</code></pre>
<p>可以发现在设置了visibility属性后，private修改的方法也可以被序列化了。这代表即使name字段的属性和getter方法都是private，但是jackson还是获取到了该成员变量的值，并且进行了序列化处理。<strong>通过设置visibility属性即可达到上面的效果</strong>。开发者根据自己的需要自行进行选择。</p>
<h3 id="5、property-naming-strategy-属性命名策略"><a href="#5、property-naming-strategy-属性命名策略" class="headerlink" title="5、property-naming-strategy 属性命名策略"></a>5、property-naming-strategy 属性命名策略</h3><p>通常比较常见的我们针对Java代码中的实体类属性一般都是驼峰命名法(Camel-Case)，但是Jackson序列化框架也提供了更多的序列化策略，而property-naming-strategy就是配置该属性的。</p>
<p>先来看SpringBoot框架如何配置Jackson的命名策略：JacksonAutoConfiguration.java</p>
<pre><code class="java">private void configurePropertyNamingStrategyField(Jackson2ObjectMapperBuilder builder, String fieldName) &#123;
    // Find the field (this way we automatically support new constants
    // that may be added by Jackson in the future)
    Field field = ReflectionUtils.findField(PropertyNamingStrategy.class, fieldName,
                                            PropertyNamingStrategy.class);
    Assert.notNull(field, () -&gt; &quot;Constant named &#39;&quot; + fieldName + &quot;&#39; not found on &quot;
                   + PropertyNamingStrategy.class.getName());
    try &#123;
        builder.propertyNamingStrategy((PropertyNamingStrategy) field.get(null));
    &#125;
    catch (Exception ex) &#123;
        throw new IllegalStateException(ex);
    &#125;
&#125;
</code></pre>
<p>通过反射，直接获取PropertyNamingStrategy类中的成员变量的值。PropertyNamingStrategy定义了Jackson(2.11.4)框架中的命名策略常量成员变量。</p>
<pre><code class="java">package com.fasterxml.jackson.databind;

//other import

public class PropertyNamingStrategy // NOTE: was abstract until 2.7
    implements java.io.Serializable
&#123;
    /**
     * Naming convention used in languages like C, where words are in lower-case
     * letters, separated by underscores.
     * See &#123;@link SnakeCaseStrategy&#125; for details.
     *
     * @since 2.7 (was formerly called &#123;@link #CAMEL_CASE_TO_LOWER_CASE_WITH_UNDERSCORES&#125;)
     */
    public static final PropertyNamingStrategy SNAKE_CASE = new SnakeCaseStrategy();

    /**
     * Naming convention used in languages like Pascal, where words are capitalized
     * and no separator is used between words.
     * See &#123;@link PascalCaseStrategy&#125; for details.
     *
     * @since 2.7 (was formerly called &#123;@link #PASCAL_CASE_TO_CAMEL_CASE&#125;)
     */
    public static final PropertyNamingStrategy UPPER_CAMEL_CASE = new UpperCamelCaseStrategy();

    /**
     * Naming convention used in Java, where words other than first are capitalized
     * and no separator is used between words. Since this is the native Java naming convention,
     * naming strategy will not do any transformation between names in data (JSON) and
     * POJOS.
     *
     * @since 2.7 (was formerly called &#123;@link #PASCAL_CASE_TO_CAMEL_CASE&#125;)
     */
    public static final PropertyNamingStrategy LOWER_CAMEL_CASE = new PropertyNamingStrategy();

    /**
     * Naming convention in which all words of the logical name are in lower case, and
     * no separator is used between words.
     * See &#123;@link LowerCaseStrategy&#125; for details.
     * 
     * @since 2.4
     */
    public static final PropertyNamingStrategy LOWER_CASE = new LowerCaseStrategy();

    /**
     * Naming convention used in languages like Lisp, where words are in lower-case
     * letters, separated by hyphens.
     * See &#123;@link KebabCaseStrategy&#125; for details.
     * 
     * @since 2.7
     */
    public static final PropertyNamingStrategy KEBAB_CASE = new KebabCaseStrategy();

    /**
     * Naming convention widely used as configuration properties name, where words are in
     * lower-case letters, separated by dots.
     * See &#123;@link LowerDotCaseStrategy&#125; for details.
     *
     * @since 2.10
     */
    public static final PropertyNamingStrategy LOWER_DOT_CASE = new LowerDotCaseStrategy();

    //others...
&#125;
</code></pre>
<p>从源码中我们可以看到，有六种策略供我们进行配置，策略详解如下：</p>
<p>1、<strong>SNAKE_CASE</strong>：主要包含的规则，详见 SnakeCaseStrategy：</p>
<ul>
<li>Java属性名称中所有大写的字符都会转换为两个字符，下划线和该字符的小写形式，例如userName会转换为user_name,对于连续性的大写字符，近第一个进行下划线转换，后面的大小字符则是小写，例如theWWW会转换为the_www</li>
<li>对于首字母大写的情况，近转成小写，例如:Results会转换为results，并不会转换为_results</li>
<li>针对属性中已经包含下划线的情况，仅做小写转换处理</li>
<li>下划线出现在首位的情况下，会被去除处理，例如属性名：_user会被转换为user</li>
</ul>
<pre><code class="shell">Java 对象属性：userName
JSON 返回属性：user_name
</code></pre>
<p>2、<strong>UPPER_CAMEL_CASE</strong>：顾名思义，驼峰命名法的规则，只是首字母会转换为大写，详见 <a target="_blank" rel="noopener" href="https://www.javadoc.io/doc/com.fasterxml.jackson.core/jackson-databind/latest/com/fasterxml/jackson/databind/PropertyNamingStrategy.UpperCamelCaseStrategy.html">UpperCamelCaseStrategy</a></p>
<pre><code>Java 对象属性：userName
JSON 返回属性：UserName
</code></pre>
<p>3、<strong>LOWER_CAMEL_CASE</strong>：效果和<code>UPPER_CAMEL_CASE</code>正好相反，其首字母会变成小写，详见 <a target="_blank" rel="noopener" href="https://www.javadoc.io/doc/com.fasterxml.jackson.core/jackson-databind/latest/com/fasterxml/jackson/databind/PropertyNamingStrategies.LowerCamelCaseStrategy.html">LowerCamelCaseStrategy</a></p>
<pre><code class="java">Java 对象属性：userName
JSON 返回属性：userName
</code></pre>
<p>4、LOWER_CASE：从命名来看很明显，将属性名 全部转为小写，详见 <a target="_blank" rel="noopener" href="https://www.javadoc.io/doc/com.fasterxml.jackson.core/jackson-databind/latest/com/fasterxml/jackson/databind/PropertyNamingStrategy.LowerCaseStrategy.html">LowerCaseStrategy</a></p>
<pre><code>Java 对象属性：userName
JSON 返回属性：username
</code></pre>
<p>5、KEBAB_CASE：KEBAB_CASE策略和SNAKE_CASE规则类似，只是下划线变成了横线<code>-</code>,详见 <a target="_blank" rel="noopener" href="https://www.javadoc.io/doc/com.fasterxml.jackson.core/jackson-databind/latest/com/fasterxml/jackson/databind/PropertyNamingStrategy.KebabCaseStrategy.html">KebabCaseStrategy</a></p>
<pre><code class="java">Java 对象属性：userName
JSON 返回属性：user-name
</code></pre>
<p>6、LOWER_DOT_CASE：当前策略和KEBAB_CASE规则相似，只是由横线变成了点<code>.</code>，详见 <a target="_blank" rel="noopener" href="https://www.javadoc.io/doc/com.fasterxml.jackson.core/jackson-databind/latest/com/fasterxml/jackson/databind/PropertyNamingStrategy.LowerDotCaseStrategy.html">LowerDotCaseStrategy</a></p>
<pre><code class="java">Java 对象属性：userName
JSON 返回属性：user.name
</code></pre>
<p><strong>总结</strong>：看了上面这么多属性名称的策略，其实每一种类型只是不同的场景下才需要，如果上面Jackson给定的默认策略名称无法满足，我们从源码中也能看到，通过自定义实现类，也能满足企业的个性化需求，非常方便。</p>
<h3 id="6、mapper-通用功能开关配置"><a href="#6、mapper-通用功能开关配置" class="headerlink" title="6、mapper 通用功能开关配置"></a>6、mapper 通用功能开关配置</h3><p>mapper属性是一个Map类型，主要是针对MapperFeature定义开关属性，是否启用这些特性。</p>
<pre><code class="java">/**
 * Jackson general purpose on/off features.
 */
private final Map&lt;MapperFeature, Boolean&gt; mapper = new EnumMap&lt;&gt;(MapperFeature.class);
</code></pre>
<p>MapperFeature.java是一个枚举类型，对当前Jackson的一些特性通过枚举变量的方式来定义开关属性，也是方便使用者来使用的。</p>
<pre><code class="java">public enum MapperFeature implements ConfigFeature &#123;
    USE_ANNOTATIONS(true),
    USE_GETTERS_AS_SETTERS(true),
    PROPAGATE_TRANSIENT_MARKER(false),
    AUTO_DETECT_CREATORS(true),
    //.......
&#125;
</code></pre>
<p>主要包含以下枚举变量：</p>
<ul>
<li>USE_ANNOTATIONS</li>
<li>USE_GETTERS_AS_SETTERS</li>
<li>PROPAGATE_TRANSIENT_MARKER</li>
<li>AUTO_DETECT_CREATORS</li>
<li>AUTO_DETECT_FIELDS</li>
<li>AUTO_DETECT_GETTERS</li>
<li>AUTO_DETECT_IS_GETTERS</li>
<li>AUTO_DETECT_SETTERS</li>
<li>REQUIRE_SETTERS_FOR_GETTERS</li>
<li>ALLOW_FINAL_FIELDS_AS_MUTATORS</li>
<li>INFER_PROPERTY_MUTATORS</li>
<li>INFER_CREATOR_FROM_CONSTRUCTOR_PROPERTIES</li>
<li>CAN_OVERRIDE_ACCESS_MODIFIERS</li>
<li>OVERRIDE_PUBLIC_ACCESS_MODIFIERS</li>
<li>USE_STATIC_TYPING</li>
<li>USE_BASE_TYPE_AS_DEFAULT_IMPL</li>
<li>DEFAULT_VIEW_INCLUSION</li>
<li>SORT_PROPERTIES_ALPHABETICALLY</li>
<li>ACCEPT_CASE_INSENSITIVE_PROPERTIES</li>
<li>ACCEPT_CASE_INSENSITIVE_ENUMS</li>
<li>ACCEPT_CASE_INSENSITIVE_VALUES</li>
<li>USE_WRAPPER_NAME_AS_PROPERTY_NAME</li>
<li>USE_STD_BEAN_NAMING</li>
<li>ALLOW_EXPLICIT_PROPERTY_RENAMING</li>
<li>ALLOW_COERCION_OF_SCALARS</li>
<li>IGNORE_DUPLICATE_MODULE_REGISTRATIONS</li>
<li>IGNORE_MERGE_FOR_UNMERGEABLE</li>
<li>BLOCK_UNSAFE_POLYMORPHIC_BASE_TYPES</li>
</ul>
<h3 id="7、serialization-序列化特性开关配置"><a href="#7、serialization-序列化特性开关配置" class="headerlink" title="7、serialization 序列化特性开关配置"></a>7、serialization 序列化特性开关配置</h3><p>serialization 属性同mapper类似，也是一个Map类型的属性。主要是直接使用 Jackson 已经自定义好的 序列化规则。</p>
<pre><code class="java">/**
 * Jackson on/off features that affect the way Java objects are serialized.
 */
private final Map&lt;SerializationFeature, Boolean&gt; serialization = new EnumMap&lt;&gt;(SerializationFeature.class);
</code></pre>
<p>枚举类SerializationFeature中的枚举属性为key，值为boolean设置jackson序列化特性，具体key请看源码：</p>
<pre><code class="java">public enum SerializationFeature implements ConfigFeature &#123;
    WRAP_ROOT_VALUE(false),
    INDENT_OUTPUT(false),
    FAIL_ON_EMPTY_BEANS(true),
    FAIL_ON_SELF_REFERENCES(true),
    WRAP_EXCEPTIONS(true),
    // ...
&#125;
</code></pre>
<p>SpringBoot Jackson Serialization 序列化特性开关配置示例如下：</p>
<pre><code class="yaml">spring:
  jackson:
    serialization:
      WRITE_DATES_AS_TIMESTAMPS: true
      FAIL_ON_EMPTY_BEANS: true
    # 常规默认: 枚举类SerializationFeature中的枚举属性为key,值为boolean设置jackson序列化特性,具体key请看源码
    # WRITE_DATES_AS_TIMESTAMPS: true : 返回的java.util.date转换成timestamp
    # FAIL_ON_EMPTY_BEANS: true       : 对象为空时是否报错，默认true
</code></pre>
<h3 id="8、deserialization-反序列化开关配置"><a href="#8、deserialization-反序列化开关配置" class="headerlink" title="8、deserialization 反序列化开关配置"></a>8、deserialization 反序列化开关配置</h3><p>deserialization属性同mapper类似，也是一个Map类型的属性，配置方式与serialization一样，只需配置DeserializationFeature的key即可</p>
<pre><code class="java">/**
 * Jackson on/off features that affect the way Java objects are deserialized.
 */
private final Map&lt;DeserializationFeature, Boolean&gt; deserialization = new EnumMap&lt;&gt;(DeserializationFeature.class);
</code></pre>
<pre><code class="java">public enum DeserializationFeature implements ConfigFeature &#123;
    USE_BIG_DECIMAL_FOR_FLOATS(false),
    USE_BIG_INTEGER_FOR_INTS(false),
    USE_LONG_FOR_INTS(false),
    USE_JAVA_ARRAY_FOR_JSON_ARRAY(false),
    FAIL_ON_UNKNOWN_PROPERTIES(true),
    FAIL_ON_NULL_FOR_PRIMITIVES(false),
    FAIL_ON_NUMBERS_FOR_ENUMS(false),
&#125;
</code></pre>
<p>SpringBoot Jackson Deserialization反序列化特性开关配置示例如下：</p>
<pre><code class="yaml">spring:
  jackson:
    deserialization:
      FAIL_ON_UNKNOWN_PROPERTIES: false
    # 常用配置,json中含pojo不存在属性时是否失败报错,默认true
    # 枚举类DeserializationFeature中的枚举属性为key，值为boolean设置jackson反序列化特性,具体key请看源码
</code></pre>
<h3 id="9、parser-配置"><a href="#9、parser-配置" class="headerlink" title="9、parser 配置"></a>9、parser 配置</h3><p>JsonParser在Jackson中负责JSON内容的读取（反序列化），具体特性请看JsonParser.Feature</p>
<pre><code class="yaml">spring:
  jackson: 
    parser:
      ALLOW_SINGLE_QUOTES: true
      allow_unquoted_control_chars: true
    # 枚举类JsonParser.Feature枚举类中的枚举属性为key，值为boolean设置jackson JsonParser特性
    # JsonParser在jackson中负责json内容的读取,具体特性请看JsonParser.Feature，一般无需设置默认即可
    # ALLOW_SINGLE_QUOTES: true           :  是否允许出现单引号,默认false
    # allow_unquoted_control_chars: true  :  是否允许出现单引号,默认false
</code></pre>
<h3 id="10、generator-配置"><a href="#10、generator-配置" class="headerlink" title="10、generator 配置"></a>10、generator 配置</h3><p>JsonGenerator在Jackson中负责JSON内容编写（序列化），具体特性请看JsonGenerator.Feature。枚举类JsonGenerator.Feature枚举类中的枚举属性为key，值为boolean设置jackson JsonGenerator特性，一般无需设置默认即可。</p>
<pre><code class="yaml">spring:
  jackson:
    generator:
      write-numbers-as-strings: true
    # 枚举类JsonGenerator.Feature枚举类中的枚举属性为key，值为boolean设置JsonGenerator特性，一般无需设置默认即可
    # JsonGenerator在jackson中负责编写json内容,具体特性请看JsonGenerator.Feature
    # write-numbers-as-strings: true  :  强制将所有Java数字写为字符串的功能，默认为false
</code></pre>
<p>当前配置后序列化数字类型，接口返回接口中数字会自动被解析成字符串并带上引号。</p>
<h3 id="11、defaultPropertyInclusion-序列化包含的属性配置"><a href="#11、defaultPropertyInclusion-序列化包含的属性配置" class="headerlink" title="11、defaultPropertyInclusion 序列化包含的属性配置"></a>11、defaultPropertyInclusion 序列化包含的属性配置</h3><p>该属性是一个枚举配置，主要包含：</p>
<ul>
<li>ALWAYS：顾名思义，始终包含，和属性的值无关</li>
<li>NON_NULL：值非空的属性才会包含属性</li>
<li>NON_ABSENT：值非空的属性，或者Optional类型的属性非空</li>
<li>NON_EMPTY:：空值的属性不包含</li>
<li>NON_DEFAULT：不使用jackson的默认规则对该字段进行序列化,详见示例</li>
<li>CUSTOM：自定义规则</li>
<li>USE_DEFAULTS：配置使用该规则的属性字段，将会优先使用class上的注解规则，否则会使用全局的序列化规则，详见示例</li>
</ul>
<p>CUSTOM 是自定义规则是需要开发者在属性字段上使用@JsonInclude注解，并且指定valueFilter属性，该属性需要传递一个Class，示例如下：</p>
<pre><code class="java">// User.java
// 指定value级别是CUSTOM
@JsonInclude(value = JsonInclude.Include.CUSTOM, valueFilter = StringFilter.class)
private String name;
</code></pre>
<p>StringFilter：是判断非空的依据，该依据由开发者自己定义，返回true将会被排除，false则不会排除，示例如下：</p>
<pre><code class="java">// 自定义非空判断规则
public class StringFilter &#123;
    @Override
    public boolean equals(Object other) &#123;
        if (other == null) &#123;
            // Filter null&#39;s.
            return true;
        &#125;
        // Filter &quot;custom_string&quot;.
        return &quot;custom_string&quot;.equals(other);
    &#125;
&#125;
</code></pre>
<h2 id="3、SpringBoot-Jackson-配置示例"><a href="#3、SpringBoot-Jackson-配置示例" class="headerlink" title="3、SpringBoot Jackson 配置示例"></a>3、SpringBoot Jackson 配置示例</h2><pre><code class="yaml">spring:
  jackson:
    # 设置当地时区
    locale: zh
    # 设置全局时区
    time-zone: GMT+8
    # 全局时间格式设置 @JsonFormat的格式pattern
    date-format: yyyy-MM-dd HH:mm:ss
    # 设置属性命名策略,对应jackson下PropertyNamingStrategy中的常量值
    # SNAKE_CASE-返回的json驼峰式转下划线，json body下划线传到后端自动转驼峰式
    property-naming-strategy: SNAKE_CASE
    # 常用: 全局设置pojo或被@JsonInclude注解的属性的序列化方式
    # 不为空的属性才会序列化,具体属性可看JsonInclude.Include
    default-property-inclusion: NON_NULL
    # 常规默认,枚举类SerializationFeature中的枚举属性为key,值为boolean设置jackson序列化特性,具体key请看源码
    # WRITE_DATES_AS_TIMESTAMPS: true : 返回的java.util.date转换成timestamp
    # FAIL_ON_EMPTY_BEANS: true       : 对象为空时是否报错，默认true
    serialization:
      WRITE_DATES_AS_TIMESTAMPS: true
      FAIL_ON_EMPTY_BEANS: true
    # 枚举类DeserializationFeature中的枚举属性为key，值为boolean设置jackson反序列化特性,具体key请看源码
    # FAIL_ON_UNKNOWN_PROPERTIES: false   :  常用配置,json中含pojo不存在属性时是否失败报错,默认true
    deserialization:
      FAIL_ON_UNKNOWN_PROPERTIES: false
    # 枚举类MapperFeature中的枚举属性为key，值为boolean设置jackson ObjectMapper特性
    # ObjectMapper在jackson中负责json的读写、json与pojo的互转、json tree的互转,具体特性请看MapperFeature,常规默认即可
    mapper:
      # 使用getter取代setter探测属性，如类中含getName()但不包含name属性与setName()，传输的vo json格式模板中依旧含name属性
      USE_GETTERS_AS_SETTERS: true # 默认false
    # 枚举类JsonParser.Feature枚举类中的枚举属性为key，值为boolean设置jackson JsonParser特性
    # JsonParser在jackson中负责json内容的读取,具体特性请看JsonParser.Feature，一般无需设置默认即可
    parser:
      ALLOW_SINGLE_QUOTES: true # 是否允许出现单引号,默认false
    # 枚举类JsonGenerator.Feature枚举类中的枚举属性为key，值为boolean设置jackson JsonGenerator特性，一般无需设置默认即可
    # JsonGenerator在jackson中负责编写json内容,具体特性请看JsonGenerator.Feature
    # write-numbers-as-strings: true  :  强制将所有Java数字写为字符串的功能，默认为false
    generator:
      write-numbers-as-strings: true
    # 开启visibility私有字段或方法访问级别, 可以让私有属性或者方法被Jackson序列化或反序列化到
    # 枚举类PropertyAccessor中的枚举属性为key, 枚举类JsonAutoDetect.Visibility中的枚举属性为value
    visibility:
      field: any
</code></pre>
<h2 id="4、SpringBoot-Jackson-自动装配"><a href="#4、SpringBoot-Jackson-自动装配" class="headerlink" title="4、SpringBoot Jackson 自动装配"></a>4、SpringBoot Jackson 自动装配</h2><p>在前面的文章中，我们已经详细的了解了Jackson在Spring Boot框架中的各个配置项，那么Spring Boot针对Jackson框架在约定配置时会做哪些事情呢?</p>
<p>在Spring Boot的spring-boot-autoconfigure-x.x.jar包中，我们可以看到Spring Boot框架针对jackson的处理源码，主要包含三个类：</p>
<ul>
<li><p>JacksonProperties:Spring Boot框架提供jackson的配置属性类，即开发者在application.yml配置文件中的配置项属性</p>
</li>
<li><p>JacksonAutoConfiguration:Jackson的默认注入配置类</p>
</li>
<li><p>Jackson2ObjectMapperBuilderCustomizer:自定义用于注入jackson的配置辅助接口</p>
</li>
</ul>
<p>核心类是JacksonAutoConfiguration.java,该类是Spring Boot框架将Jackson相关实体Bean注入Spring容器的关键配置类。其主要作用：</p>
<ul>
<li>注入Jackson的ObjectMapper实体Bean到Spring容器中</li>
<li>注入ParameterNamesModule实体Bean到Spring容器中</li>
<li>注入Jackson2ObjectMapperBuilder实体Bean</li>
<li>注入JsonComponentModule实体Bean</li>
<li>注入StandardJackson2ObjectMapperBuilderCustomizer实体Bean，该类是上面Jackson2ObjectMapperBuilderCustomizer的实现类，主要用于接收JacksonProperties属性，将Jackson的外部配置属性接收，然后最终执行customize方法，构建ObjectMapper所需要的Jackson2ObjectMapperBuilder属性，最终为ObjectMapper属性赋值准备</li>
</ul>
<p>源码如下：</p>
<pre><code class="java">package com.example.springbootjackson.model;

@Configuration(proxyBeanMethods = false)
@ConditionalOnClass(ObjectMapper.class)
public class JacksonAutoConfiguration &#123;

    private static final Map&lt;?, Boolean&gt; FEATURE_DEFAULTS;

    static &#123;
        Map&lt;Object, Boolean&gt; featureDefaults = new HashMap&lt;&gt;();
        featureDefaults.put(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false);
        featureDefaults.put(SerializationFeature.WRITE_DURATIONS_AS_TIMESTAMPS, false);
        FEATURE_DEFAULTS = Collections.unmodifiableMap(featureDefaults);
    &#125;

    @Bean
    public JsonComponentModule jsonComponentModule() &#123;
        return new JsonComponentModule();
    &#125;

    @Configuration(proxyBeanMethods = false)
    @ConditionalOnClass(Jackson2ObjectMapperBuilder.class)
    static class JacksonObjectMapperConfiguration &#123;

        @Bean
        @Primary
        @ConditionalOnMissingBean
        ObjectMapper jacksonObjectMapper(Jackson2ObjectMapperBuilder builder) &#123;
            return builder.createXmlMapper(false).build();
        &#125;

    &#125;

    @Configuration(proxyBeanMethods = false)
    @ConditionalOnClass(ParameterNamesModule.class)
    static class ParameterNamesModuleConfiguration &#123;

        @Bean
        @ConditionalOnMissingBean
        ParameterNamesModule parameterNamesModule() &#123;
            return new ParameterNamesModule(JsonCreator.Mode.DEFAULT);
        &#125;

    &#125;

    @Configuration(proxyBeanMethods = false)
    @ConditionalOnClass(Jackson2ObjectMapperBuilder.class)
    static class JacksonObjectMapperBuilderConfiguration &#123;

        @Bean
        @Scope(&quot;prototype&quot;)
        @ConditionalOnMissingBean
        Jackson2ObjectMapperBuilder jacksonObjectMapperBuilder(ApplicationContext applicationContext,
                                                               List&lt;Jackson2ObjectMapperBuilderCustomizer&gt; customizers) &#123;
            Jackson2ObjectMapperBuilder builder = new Jackson2ObjectMapperBuilder();
            builder.applicationContext(applicationContext);
            customize(builder, customizers);
            return builder;
        &#125;

        private void customize(Jackson2ObjectMapperBuilder builder,
                               List&lt;Jackson2ObjectMapperBuilderCustomizer&gt; customizers) &#123;
            for (Jackson2ObjectMapperBuilderCustomizer customizer : customizers) &#123;
                customizer.customize(builder);
            &#125;
        &#125;

    &#125;

    @Configuration(proxyBeanMethods = false)
    @ConditionalOnClass(Jackson2ObjectMapperBuilder.class)
    @EnableConfigurationProperties(JacksonProperties.class)
    static class Jackson2ObjectMapperBuilderCustomizerConfiguration &#123;

        @Bean
        StandardJackson2ObjectMapperBuilderCustomizer standardJacksonObjectMapperBuilderCustomizer(
            ApplicationContext applicationContext, JacksonProperties jacksonProperties) &#123;
            return new StandardJackson2ObjectMapperBuilderCustomizer(applicationContext, jacksonProperties);
        &#125;

        static final class StandardJackson2ObjectMapperBuilderCustomizer
            implements Jackson2ObjectMapperBuilderCustomizer, Ordered &#123;

            private final ApplicationContext applicationContext;

            private final JacksonProperties jacksonProperties;

            StandardJackson2ObjectMapperBuilderCustomizer(ApplicationContext applicationContext,
                                                          JacksonProperties jacksonProperties) &#123;
                this.applicationContext = applicationContext;
                this.jacksonProperties = jacksonProperties;
            &#125;

            @Override
            public int getOrder() &#123;
                return 0;
            &#125;

            @Override
            public void customize(Jackson2ObjectMapperBuilder builder) &#123;

                if (this.jacksonProperties.getDefaultPropertyInclusion() != null) &#123;
                    builder.serializationInclusion(this.jacksonProperties.getDefaultPropertyInclusion());
                &#125;
                if (this.jacksonProperties.getTimeZone() != null) &#123;
                    builder.timeZone(this.jacksonProperties.getTimeZone());
                &#125;
                configureFeatures(builder, FEATURE_DEFAULTS);
                configureVisibility(builder, this.jacksonProperties.getVisibility());
                configureFeatures(builder, this.jacksonProperties.getDeserialization());
                configureFeatures(builder, this.jacksonProperties.getSerialization());
                configureFeatures(builder, this.jacksonProperties.getMapper());
                configureFeatures(builder, this.jacksonProperties.getParser());
                configureFeatures(builder, this.jacksonProperties.getGenerator());
                configureDateFormat(builder);
                configurePropertyNamingStrategy(builder);
                configureModules(builder);
                configureLocale(builder);
            &#125;

            // more configure methods...
        &#125;
    &#125;
&#125;
</code></pre>
<p><strong>总结</strong>：通过一系列的方法，最终构造一个生产级别可用的<code>ObjectMapper</code>对象，供在Spring Boot框架中对Java对象实现序列化与反序列化操作。</p>
<h1 id="十、SpringBoot-日期时间处理总结"><a href="#十、SpringBoot-日期时间处理总结" class="headerlink" title="十、SpringBoot 日期时间处理总结"></a>十、SpringBoot 日期时间处理总结</h1><blockquote>
<p>PS：如果你的Controller中的LocalDate类型的参数啥注解（RequestParam、PathVariable等）都没加，也是会出错的，因为默认情况下，解析这种参数是使用ModelAttributeMethodProcessor进行处理，而这个处理器要通过反射实例化一个对象出来，然后再对对象中的各个参数进行convert，但是LocalDate类没有构造函数，无法反射实例化因此会报错！！！</p>
</blockquote>
<p>项目中使用LocalDateTime系列作为DTO中时间的数据类型，但是SpringMVC收到参数后总报错，为了配置全局时间类型转换，尝试了如下处理方式。</p>
<h2 id="1、GET请求及POST表单日期时间字符串格式转换"><a href="#1、GET请求及POST表单日期时间字符串格式转换" class="headerlink" title="1、GET请求及POST表单日期时间字符串格式转换"></a>1、GET请求及POST表单日期时间字符串格式转换</h2><blockquote>
<p>这种情况要和时间作为JSON字符串时区别对待，因为前端JSON转到后端POJO底层使用的是JSON序列化Jackson工具（HttpMessgeConverter）；而时间字符串作为普通请求参数传入时，转换用的是Converter，两者在处理方式上是有区别。</p>
</blockquote>
<p>场景：请求接口，入参转换（因为不是JSON所以不能称反序列化），非content-type&#x3D;application&#x2F;json情况，</p>
<ul>
<li><p>GET 请求入参：GET请求是没有 content-type 的</p>
<pre><code class="java">@RestController
public class TestController &#123;
    /**
     * GET请求:
     * ip:port/queryOne?localDateTime=20221124 111111&amp;localDate=20221124&amp;date=20221124&amp;timestamp=20221124
     * response json:
     * &#123;
     *   &quot;localDateTime&quot;: &quot;2022-11-25T14:49:40.5289825&quot;,
     *   &quot;localDate&quot;: &quot;2022-11-25&quot;,
     *   &quot;date&quot;: &quot;2022-11-25 06:49:40&quot;,
     *   &quot;timestamp&quot;: &quot;2022-11-25 06:49:40&quot;
     * &#125;
     * 控制台打印:
     * (localDateTime=2022-11-24T11:11:11, localDate=2022-11-24, date=Thu Nov 24 00:00:00 CST 2022, timestamp=2022-11-24 00:00:00.0)
     */
    @GetMapping(&quot;/query&quot;)
    public ResponseEntity&lt;User&gt; query(User user) &#123;
        System.out.println(user);
        return ResponseEntity.ok(user);
    &#125;

    @Data
    public static class User &#123;
        private LocalDateTime localDateTime;
        private LocalDate localDate;
        private Date date;
        private Timestamp timestamp;
    &#125;
&#125;
</code></pre>
</li>
<li><p>POST 请求入参：请求类型为：content-type&#x3D;application&#x2F;x-www-form-urlencoded， 后台不能用@RequestBody接收</p>
<pre><code class="java">@RestController
public class TestController &#123;
    /**
     * POST http://localhost:8080/query
     * Content-Type: application/x-www-form-urlencoded
     *
     * localDateTime=20221124 111111&amp;localDate=20221124&amp;date=20221124&amp;timestamp=20221124
     * 
     * response json:
     * &#123;
     *   &quot;localDateTime&quot;: &quot;2022-11-24T11:11:11&quot;,
     *   &quot;localDate&quot;: &quot;2022-11-24&quot;,
     *   &quot;date&quot;: &quot;2022-11-23T16:00:00.000+00:00&quot;,
     *   &quot;timestamp&quot;: &quot;2022-11-23T16:00:00.000+00:00&quot;
     * &#125;
     * 控制台打印:
     * (localDateTime=2022-11-24T11:11:11, localDate=2022-11-24, date=Thu Nov 24 00:00:00 CST 2022, timestamp=2022-11-24 00:00:00.0)
     */
    @PostMapping(&quot;/query&quot;)
    public ResponseEntity&lt;User&gt; query(User user) &#123;
        System.out.println(user);
        return ResponseEntity.ok(user);
    &#125;

    @Data
    public static class User &#123;
        private LocalDateTime localDateTime;
        private LocalDate localDate;
        private Date date;
        private Timestamp timestamp;
    &#125;
&#125;
</code></pre>
</li>
</ul>
<h3 id="1、使用Spring自定义参数转换器（Converter）"><a href="#1、使用Spring自定义参数转换器（Converter）" class="headerlink" title="1、使用Spring自定义参数转换器（Converter）"></a>1、使用Spring自定义参数转换器（Converter）</h3><p>在Spring中定义了3中类型转换接口，分别为：</p>
<ol>
<li>Converter 接口            ：使用最简单，最不灵活；（本次使用）</li>
<li>ConverterFactory 接口：使用较复杂，比较灵活；</li>
<li>GenericConverter 接口：使用最复杂，也最灵活；</li>
</ol>
<p>实现 org.springframework.core.convert.converter.Converter，自定义参数转换器，如下：</p>
<pre><code class="java">@Configuration
public class DateConverterConfig &#123;
    @Bean
    public Converter&lt;String, LocalDate&gt; localDateConverter() &#123;
        return new Converter&lt;String, LocalDate&gt;() &#123;
            @Override
            public LocalDate convert(String source) &#123;
                return LocalDate.parse(source, DateTimeFormatter.ofPattern(&quot;yyyyMMdd&quot;));
            &#125;
        &#125;;
    &#125;

    @Bean
    public Converter&lt;String, LocalDateTime&gt; localDateTimeConverter() &#123;
        return new Converter&lt;String, LocalDateTime&gt;() &#123;
            @Override
            public LocalDateTime convert(String source) &#123;
                return LocalDateTime.parse(source, DateTimeFormatter.ofPattern(&quot;yyyyMMdd HHmmss&quot;));
            &#125;
        &#125;;
    &#125;
    
    @Bean
    public Converter&lt;String, Date&gt; dateConverter() &#123;
        return new Converter&lt;String, Date&gt;() &#123;
            @SneakyThrows
            @Override
            public Date convert(String source) &#123;
                return new SimpleDateFormat(&quot;yyyyMMdd&quot;).parse(source);
            &#125;
        &#125;;
    &#125;

    @Bean
    public Converter&lt;String, Timestamp&gt; timestampConverter() &#123;
        return new Converter&lt;String, Timestamp&gt;() &#123;
            @SneakyThrows
            @Override
            public Timestamp convert(String source) &#123;
                return new Timestamp(new SimpleDateFormat(&quot;yyyyMMdd&quot;).parse(source).getTime());
            &#125;
        &#125;;
    &#125;
&#125;
</code></pre>
<p>以上两个Bean会注入到SpringMVC的参数解析器（好像叫做ParameterConversionService），当传入的字符串要转为LocalDateTime类或者LocalDate类时，Spring会调用该Converter对这个入参进行转换。</p>
<h3 id="2、Converter中Lambda代替匿名内部类启动报错"><a href="#2、Converter中Lambda代替匿名内部类启动报错" class="headerlink" title="2、Converter中Lambda代替匿名内部类启动报错"></a>2、Converter中Lambda代替匿名内部类启动报错</h3><blockquote>
<p>注意：关于自定义的参数转换器 Converter，这里我遇到了一个坑，我再这里详细记录下，本来我的想法是为了代码精简，将上面匿名内部类的写法精简成lambda表达式，可是启动报错： does the class parameterize those types?</p>
</blockquote>
<h4 id="1、场景复现"><a href="#1、场景复现" class="headerlink" title="1、场景复现"></a>1、场景复现</h4><pre><code class="java">/*
 * 注入自定义的LocalDateTime转换器
 */
@Bean
public Converter&lt;String, LocalDateTime&gt; localDateTimeConverter() &#123;
    return source -&gt; LocalDateTime.parse(source, DateTimeFormatter.ofPattern(&quot;yyyyMMdd HHmmss&quot;));
&#125;
</code></pre>
<p>启动项目时却出现了异常：</p>
<pre><code class="shell">Caused by: java.lang.IllegalArgumentException: Unable to determine source type &lt;S&gt; and target type &lt;T&gt; for your Converter [com.example.demo126.config.MappingConverterAdapter$$Lambda$522/817994751]; does the class parameterize those types?
</code></pre>
<h4 id="2、原因分析"><a href="#2、原因分析" class="headerlink" title="2、原因分析"></a>2、原因分析</h4><ol>
<li><p>Web项目启动注册requestMappingHandlerAdapter的时候会初始化WebBindingInitializer</p>
<pre><code class="java">adapter.setWebBindingInitializer(getConfigurableWebBindingInitializer());
</code></pre>
</li>
<li><p>而ConfigurableWebBindingInitializer需要FormattingConversionService，而FormattingConversionService会将所有的Converter添加进来,添加的时候需要获取泛型信息</p>
<pre><code class="java">@Override
public void addFormatters(FormatterRegistry registry) &#123;
    for (Converter&lt;?, ?&gt; converter : getBeansOfType(Converter.class)) &#123;
        registry.addConverter(converter);
    &#125;
    for (GenericConverter converter : getBeansOfType(GenericConverter.class)) &#123;
        registry.addConverter(converter);
    &#125;
    for (Formatter&lt;?&gt; formatter : getBeansOfType(Formatter.class)) &#123;
        registry.addFormatter(formatter);
    &#125;
&#125;
</code></pre>
</li>
<li><p>添加Converter.class 一般是通过接口获取两个泛型的具体类型</p>
<pre><code class="java">public ResolvableType as(Class&lt;?&gt; type) &#123;
    if (this == NONE) &#123;
        return NONE;
    &#125;
    Class&lt;?&gt; resolved = resolve();
    if (resolved == null || resolved == type) &#123;
        return this;
    &#125;
    for (ResolvableType interfaceType : getInterfaces()) &#123;
        ResolvableType interfaceAsType = interfaceType.as(type);
        if (interfaceAsType != NONE) &#123;
            return interfaceAsType;
        &#125;
    &#125;
    return getSuperType().as(type);
&#125;
</code></pre>
</li>
<li><p>Lambda表达式的接口是<code>Converter&lt;?, ?&gt;</code>，<strong>不能的到具体的类型</strong>。</p>
</li>
</ol>
<h4 id="3、解决办法"><a href="#3、解决办法" class="headerlink" title="3、解决办法"></a>3、解决办法</h4><p>1、方案一：等待requestMappingHandlerAdapter注册结束在注册，再添加自己的Converter就不会注册到FormattingConversionService中。网上很多人推荐此方法，实际上这是种矛盾，本人查看了源码和打了断点，既然都不会注册到FormattingConversionService中，那么我们自定义的Converter也不会被注入成功，那么实际上只是解决了启动报错的问题，根本上自定义的Converter也不胡生效。（<strong>无效</strong>）</p>
<pre><code class="java">// 此方式实际无效
@Bean
@ConditionalOnBean(name = &quot;requestMappingHandlerAdapter&quot;)
public Converter&lt;String, LocalDate&gt; localDateConverter() &#123;
    return source -&gt; LocalDate.parse(source, DateTimeFormatter.ofPattern(&quot;yyyyMMdd&quot;));
&#125;
</code></pre>
<p>2、方案二：那么真的就不能使用Lambda表达式了吗？也不是，我们实际上还可以使用SpringMVC来注册Converter。从上面原因分析可以看出根本报错原因是在：<code>void addConverter(Converter&lt;?, ?&gt; converter);</code>，这个调用的Lambda表达式会让产生的转换器无法解析什么是传入类型，什么是目标类型，这就导致无法生效。（<strong>推荐</strong>）</p>
<p>所以你要用Lambda的话你需要用如下方法（其中参数的意思就是传入类型和需要转换成的类型。，还有转换器定义）：</p>
<pre><code class="java">&lt;S, T&gt; void addConverter(Class&lt;S&gt; sourceType, Class&lt;T&gt; targetType, Converter&lt;? super S, ? extends T&gt; converter);
</code></pre>
<p>使用SpringMVC的WebMvcConfigurer重写addConverter()，自动把Converter注册进去。上面的Converter是Spring容器自动注册的。</p>
<pre><code class="java">@Configuration
public class DateConverterConfig &#123;

    @Bean
    public WebMvcConfigurer webMvcConfigurer() &#123;
        DateTimeFormatter yyyyMMdd = DateTimeFormatter.ofPattern(&quot;yyyyMMdd&quot;);
        DateTimeFormatter yyyyMMdd_hHmmss = DateTimeFormatter.ofPattern(&quot;yyyyMMdd HHmmss&quot;);

        return new WebMvcConfigurer() &#123;
            @Override
            public void addFormatters(FormatterRegistry registry) &#123;
                registry.addConverter(String.class, LocalDate.class, 
                                      source -&gt; LocalDate.parse(source, yyyyMMdd));
                registry.addConverter(String.class, LocalDateTime.class, 
                                      source -&gt; LocalDateTime.parse(source, yyyyMMdd_hHmmss));
                registry.addConverter(String.class, Date.class, source -&gt; &#123;
                    try &#123;
                        return new SimpleDateFormat(&quot;yyyyMMdd&quot;).parse(source);
                    &#125; catch (ParseException e) &#123;
                        throw new RuntimeException(e);
                    &#125;
                &#125;);
                registry.addConverter(String.class, Timestamp.class, source -&gt; &#123;
                    try &#123;
                        return new Timestamp(new SimpleDateFormat(&quot;yyyyMMdd&quot;).parse(source).getTime());
                    &#125; catch (ParseException e) &#123;
                        throw new RuntimeException(e);
                    &#125;
                &#125;);
            &#125;
        &#125;;
    &#125;
&#125;
</code></pre>
<p>3、方案三：最简单的方法就是不适用Lambda表达式，还是老老实实的使用匿名内部类，这样就不会存在上述问题（<strong>推荐</strong>）</p>
<p>4、方案四：自定义接口继承Converter接口，具体类型接口，不再是泛型。这种就可以使用到Lambda表达式了（<strong>不推荐</strong>）</p>
<pre><code class="java">@Configuration
public class DateConverterConfig &#123;

    interface StringToLocalDateConverter extends Converter&lt;String, LocalDate&gt; &#123;
    &#125;

    interface StringToLocalDateTimeConverter extends Converter&lt;String, LocalDateTime&gt; &#123;
    &#125;

    interface StringToDateConverter extends Converter&lt;String, Date&gt; &#123;
    &#125;

    interface StringToTimestampConverter extends Converter&lt;String, Timestamp&gt; &#123;
    &#125;

    @Bean
    public StringToLocalDateConverter localDateConverter() &#123;
        return source -&gt; LocalDate.parse(source, DateTimeFormatter.ofPattern(&quot;yyyyMMdd&quot;));
    &#125;

    @Bean
    public StringToLocalDateTimeConverter localDateConverterLambda() &#123;
        return source -&gt; LocalDateTime.parse(source, DateTimeFormatter.ofPattern(&quot;yyyyMMdd HHmmss&quot;));
    &#125;

    @Bean
    public StringToDateConverter dateConverter() &#123;
        return source -&gt; &#123;
            try &#123;
                return new SimpleDateFormat(&quot;yyyyMMdd&quot;).parse(source);
            &#125; catch (ParseException e) &#123;
                throw new RuntimeException(e);
            &#125;
        &#125;;
    &#125;

    @Bean
    public StringToTimestampConverter timestampConverter() &#123;
        return source -&gt; &#123;
            try &#123;
                return new Timestamp(new SimpleDateFormat(&quot;yyyyMMdd&quot;).parse(source).getTime());
            &#125; catch (ParseException e) &#123;
                throw new RuntimeException(e);
            &#125;
        &#125;;
    &#125;
&#125;
</code></pre>
<p>5、方案五：自定义类实现Converter接口，重写接口方法。也是不适用Lambda表达式了。（<strong>推荐</strong>）</p>
<pre><code class="java">@Component
public class DateConverter implements Converter&lt;String, Date&gt; &#123;
    @Override
    public Date convert(String value) &#123;
        /**
         * 可对value进行正则匹配，支持日期、时间等多种类型转换
         * 如 yyyy-MM-dd HH:mm:ss、yyyy-MM-dd、 HH:mm:ss等，进行匹配。以适应多种场景
         * 这里我偷个懒，在匹配Date日期格式时直接使用了 hutool 为我们已经写好的解析工具类，这里就不重复造轮子了
         * cn.hutool.core.date.DateUtil
         * @param value
         * @return
         */
        return DateUtil.parse(value.trim());
    &#125;
&#125;
</code></pre>
<pre><code class="xml">&lt;!-- hutool 工具类 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;cn.hutool&lt;/groupId&gt;
    &lt;artifactId&gt;hutool-all&lt;/artifactId&gt;
    &lt;version&gt;5.1.3&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<h3 id="3、使用Spring默认自带注解-DateTimeFormat"><a href="#3、使用Spring默认自带注解-DateTimeFormat" class="headerlink" title="3、使用Spring默认自带注解@DateTimeFormat"></a>3、使用Spring默认自带注解@DateTimeFormat</h3><p>使用Spring自带注解@DateTimeFormat(pattern &#x3D; “yyyy-MM-dd”)，如下：</p>
<pre><code class="java">@DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;)
private Date startDate;
</code></pre>
<p><strong>需要特别注意：</strong></p>
<ul>
<li>如果使用了自定义参数转化器，Spring会优先使用该方式进行处理，即Spring的@DateTimeFormat注解不生效</li>
<li>Spring的@DateTimeFormat 注解只支持Date 类型，Java8 时间以及 Timestamp 类型都不支持</li>
</ul>
<h3 id="4、使用-ControllerAdvice配合-initBinder"><a href="#4、使用-ControllerAdvice配合-initBinder" class="headerlink" title="4、使用@ControllerAdvice配合@initBinder"></a>4、使用@ControllerAdvice配合@initBinder</h3><pre><code class="java">@ControllerAdvice
public class GlobalExceptionHandler &#123;
    /**
     * @ControllerAdvice的三种用法之一：配置@InitBinder可以请求参数预处理
     */
    @InitBinder
    protected void initBinder(WebDataBinder binder) &#123;
        binder.registerCustomEditor(LocalDate.class, new PropertyEditorSupport() &#123;
            @Override
            public void setAsText(String text) throws IllegalArgumentException &#123;
                setValue(LocalDate.parse(text, DateTimeFormatter.ofPattern(&quot;yyyyMMdd&quot;)));
            &#125;
        &#125;);
        binder.registerCustomEditor(LocalDateTime.class, new PropertyEditorSupport() &#123;
            @Override
            public void setAsText(String text) throws IllegalArgumentException &#123;
                setValue(LocalDateTime.parse(text, DateTimeFormatter.ofPattern(&quot;yyyyMMdd HHmmss&quot;)));
            &#125;
        &#125;);
        binder.registerCustomEditor(LocalTime.class, new PropertyEditorSupport() &#123;
            @Override
            public void setAsText(String text) throws IllegalArgumentException &#123;
                setValue(LocalTime.parse(text, DateTimeFormatter.ofPattern(&quot;HHmmss&quot;)));
            &#125;
        &#125;);
    &#125;
    
    @InitBinder
    public void initBinder2(WebDataBinder binder) &#123;
        binder.registerCustomEditor(LocalDate.class, new PropertyEditorSupport() &#123;
            @SneakyThrows
            @Override
            public void setAsText(String text) &#123;
                setValue(LocalDate.parse(text, DateTimeFormatter.ofPattern(&quot;yyyyMMdd&quot;)));
            &#125;
        &#125;);
        binder.registerCustomEditor(LocalDateTime.class, new PropertyEditorSupport() &#123;
            @SneakyThrows
            @Override
            public void setAsText(String text) &#123;
                LocalDateTime yyyyMMdd = LocalDate.parse(text, DateTimeFormatter.ofPattern(&quot;yyyyMMdd&quot;)).atTime(LocalTime.MIN);
                setValue(yyyyMMdd);
            &#125;
        &#125;);
    &#125;
&#125;
</code></pre>
<h2 id="2、JSON入参及返回值全局处理"><a href="#2、JSON入参及返回值全局处理" class="headerlink" title="2、JSON入参及返回值全局处理"></a>2、JSON入参及返回值全局处理</h2><p>场景：请求类型为：post,content-type&#x3D;application&#x2F;json， 后台用@RequestBody接收，默认接收及返回值格式为 yyyy-MM-dd HH:mm:ss</p>
<h3 id="1、修改-application-yml-文件"><a href="#1、修改-application-yml-文件" class="headerlink" title="1、修改 application.yml 文件"></a>1、修改 application.yml 文件</h3><p>在application.propertities文件中增加如下内容：</p>
<pre><code class="yaml">spring:
  jackson:
    date-format: yyyy-MM-dd HH:mm:ss
    time-zone: GMT+8
</code></pre>
<ul>
<li>支持：（content-type&#x3D;application&#x2F;json）请求中格式为 yyyy-MM-dd HH:mm:ss的字符串，后台用@RequestBody接收，及返回值date转为yyyy-MM-dd HH:mm:ss格式string</li>
<li>不支持：（content-type&#x3D;application&#x2F;json）请求中yyyy-MM-dd等类型的字符串转为date</li>
<li>不支持：Java8日期API</li>
</ul>
<h3 id="2、利用Jackson的JSON序列化和反序列化"><a href="#2、利用Jackson的JSON序列化和反序列化" class="headerlink" title="2、利用Jackson的JSON序列化和反序列化"></a>2、利用Jackson的JSON序列化和反序列化</h3><pre><code class="java">@Configuration
public class JacksonConfig &#123;

    /** 默认日期时间格式 */
    public static final String DEFAULT_DATE_TIME_FORMAT = &quot;yyyy-MM-dd HH:mm:ss&quot;;
    /** 默认日期格式 */
    public static final String DEFAULT_DATE_FORMAT = &quot;yyyy-MM-dd&quot;;
    /** 默认时间格式 */
    public static final String DEFAULT_TIME_FORMAT = &quot;HH:mm:ss&quot;;

    @Bean
    public MappingJackson2HttpMessageConverter mappingJackson2HttpMessageConverter() &#123;
        MappingJackson2HttpMessageConverter converter = new MappingJackson2HttpMessageConverter();
        ObjectMapper objectMapper = new ObjectMapper();

        // 忽略json字符串中不识别的属性
        objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);
        // 忽略无法转换的对象
        objectMapper.configure(SerializationFeature.FAIL_ON_EMPTY_BEANS, false);
        // PrettyPrinter 格式化输出
        objectMapper.configure(SerializationFeature.INDENT_OUTPUT, true);
        // NULL不参与序列化
        objectMapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);

        // 指定时区
        objectMapper.setTimeZone(TimeZone.getTimeZone(&quot;GMT+8:00&quot;));
        // 日期类型字符串处理
        objectMapper.setDateFormat(new SimpleDateFormat(DEFAULT_DATE_TIME_FORMAT));

        // Java8日期日期处理
        JavaTimeModule javaTimeModule = new JavaTimeModule();
        javaTimeModule.addSerializer(LocalDateTime.class, 
                new LocalDateTimeSerializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_TIME_FORMAT)));
        javaTimeModule.addSerializer(LocalDate.class, 
                new LocalDateSerializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_FORMAT)));
        javaTimeModule.addSerializer(LocalTime.class, 
                new LocalTimeSerializer(DateTimeFormatter.ofPattern(DEFAULT_TIME_FORMAT)));
        javaTimeModule.addDeserializer(LocalDateTime.class, 
                new LocalDateTimeDeserializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_TIME_FORMAT)));
        javaTimeModule.addDeserializer(LocalDate.class, 
                new LocalDateDeserializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_FORMAT)));
        javaTimeModule.addDeserializer(LocalTime.class, 
                new LocalTimeDeserializer(DateTimeFormatter.ofPattern(DEFAULT_TIME_FORMAT)));
        objectMapper.registerModule(javaTimeModule);

        converter.setObjectMapper(objectMapper);
        return converter;
    &#125;
&#125;
</code></pre>
<ul>
<li>支持：（content-type&#x3D;application&#x2F;json）请求中格式为yyyy-MM-dd HH:mm:ss的字符串，后台用@RequestBody接收，及返回值Date转为yyyy-MM-dd HH:mm:ss格式String</li>
<li>支持：Java8日期API</li>
<li>不支持：（content-type&#x3D;application&#x2F;json）请求中yyyy-MM-dd等类型的字符串转为Date</li>
</ul>
<p>总结：以上两种方式为JSON入参的全局化处理，推荐使用方式二，尤其适合大型项目在基础包中全局设置。</p>
<h2 id="3、JSON入参及返回值局部差异化处理"><a href="#3、JSON入参及返回值局部差异化处理" class="headerlink" title="3、JSON入参及返回值局部差异化处理"></a>3、JSON入参及返回值局部差异化处理</h2><p>场景：假如全局日期时间处理格式为：yyyy-MM-dd HH:mm:ss，但是某个字段要求接收或返回日期：yyyy-MM-dd（注意接收日期：请求类型为：post,content-type&#x3D;application&#x2F;json， 后台用@RequestBody接收）</p>
<p><strong>方式一</strong>：使用SpringBoot自带的注解<code>@JsonFormat(pattern = &quot;&quot;)</code>，如下所示：</p>
<pre><code class="java">@Data
public class User &#123;
    @JsonFormat(pattern = &quot;yyyyMMdd HHmmss&quot;)
    private LocalDateTime localDateTime = LocalDateTime.now();
    @JsonFormat(pattern = &quot;yyyyMMdd&quot;)
    private LocalDate localDate = LocalDate.now();
    private Date date = new Date();
    private Timestamp timestamp = new Timestamp(System.currentTimeMillis());
&#125;
</code></pre>
<p><strong>点评：</strong>SpringBoot默认提供，功能强大，满足常见场景使用，并可指定时区。</p>
<p><strong>方式二</strong>：自定义日期序列化与反序列化，如下所示：</p>
<pre><code class="java">/**
 * 日期序列化
 */
class LocalDateTimeJsonSerializer extends JsonSerializer&lt;LocalDateTime&gt; &#123;
    @SneakyThrows
    @Override
    public void serialize(LocalDateTime localDateTime, JsonGenerator jsonGenerator, SerializerProvider serializerProvider) &#123;
        jsonGenerator.writeString(DateTimeFormatter.ofPattern(&quot;yyyyMMdd HHmmss&quot;).format(localDateTime));
    &#125;
&#125;

/**
 * 日期反序列化
 */
class LocalDateTimeJsonDeserializer extends JsonDeserializer&lt;LocalDateTime&gt; &#123;
    @SneakyThrows
    @Override
    public LocalDateTime deserialize(JsonParser jsonParser, DeserializationContext deserializationContext) &#123;
        return LocalDateTime.parse(jsonParser.getText(), DateTimeFormatter.ofPattern(&quot;yyyyMMdd HHmmss&quot;));
    &#125;
&#125;

/**
 * 使用方式
 */
@Data
public class User &#123;
    @JsonSerialize(using = LocalDateTimeJsonSerializer.class)
    @JsonDeserialize(using = LocalDateTimeJsonDeserializer.class)
    private LocalDateTime localDateTime = LocalDateTime.now();
    private LocalDate localDate = LocalDate.now();
    private Date date = new Date();
    private Timestamp timestamp = new Timestamp(System.currentTimeMillis());
&#125;
</code></pre>
<h2 id="4、日期时间格式化处理方式完整配置"><a href="#4、日期时间格式化处理方式完整配置" class="headerlink" title="4、日期时间格式化处理方式完整配置"></a>4、日期时间格式化处理方式完整配置</h2><pre><code class="java">import cn.hutool.core.date.DateUtil;
import com.fasterxml.jackson.core.JsonGenerator;
import com.fasterxml.jackson.core.JsonParser;
import com.fasterxml.jackson.databind.*;
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;
import com.fasterxml.jackson.datatype.jsr310.deser.LocalDateDeserializer;
import com.fasterxml.jackson.datatype.jsr310.deser.LocalDateTimeDeserializer;
import com.fasterxml.jackson.datatype.jsr310.deser.LocalTimeDeserializer;
import com.fasterxml.jackson.datatype.jsr310.ser.LocalDateSerializer;
import com.fasterxml.jackson.datatype.jsr310.ser.LocalDateTimeSerializer;
import com.fasterxml.jackson.datatype.jsr310.ser.LocalTimeSerializer;
import lombok.SneakyThrows;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.core.convert.converter.Converter;
import org.springframework.format.FormatterRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;
import java.sql.Timestamp;
import java.text.SimpleDateFormat;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.time.format.DateTimeFormatter;
import java.util.Date;

/**
 * 注意: 这里偷个懒使用了hutool的日期时间解析工具类
 * &lt;dependency&gt;
 *     &lt;groupId&gt;cn.hutool&lt;/groupId&gt;
 *     &lt;artifactId&gt;hutool-all&lt;/artifactId&gt;
 *     &lt;version&gt;5.1.3&lt;/version&gt;
 * &lt;/dependency&gt;
 */
@Configuration
public class DateHandlerConfig &#123;

    /** 默认日期时间格式 */
    public static final String DEFAULT_DATE_TIME_FORMAT = &quot;yyyy-MM-dd HH:mm:ss&quot;;
    /** 默认日期格式 */
    public static final String DEFAULT_DATE_FORMAT = &quot;yyyy-MM-dd&quot;;
    /** 默认时间格式 */
    public static final String DEFAULT_TIME_FORMAT = &quot;HH:mm:ss&quot;;

    /**
     * LocalDate转换器，用于转换RequestParam（入参对象也算）和PathVariable参数
     */
    @Bean
    public Converter&lt;String, LocalDate&gt; localDateConverter() &#123;
        return new Converter&lt;String, LocalDate&gt;() &#123;
            @Override
            public LocalDate convert(String source) &#123;
                return LocalDate.parse(source, DateTimeFormatter.ofPattern(DEFAULT_DATE_FORMAT));
            &#125;
        &#125;;
    &#125;

    /**
     * LocalDateTime转换器，用于转换RequestParam（入参对象也算）和PathVariable参数
     */
    @Bean
    public Converter&lt;String, LocalDateTime&gt; localDateTimeConverter() &#123;
        return new Converter&lt;String, LocalDateTime&gt;() &#123;
            @Override
            public LocalDateTime convert(String source) &#123;
                return LocalDateTime.parse(source, DateTimeFormatter.ofPattern(DEFAULT_DATE_TIME_FORMAT));
            &#125;
        &#125;;
    &#125;

    /**
     * LocalTime转换器，用于转换RequestParam（入参对象也算）和PathVariable参数
     */
    @Bean
    public Converter&lt;String, LocalTime&gt; localTimeConverter() &#123;
        return new Converter&lt;String, LocalTime&gt;() &#123;
            @Override
            public LocalTime convert(String source) &#123;
                return LocalTime.parse(source, DateTimeFormatter.ofPattern(DEFAULT_TIME_FORMAT));
            &#125;
        &#125;;
    &#125;

    /**
     * Date转换器，用于转换RequestParam（入参对象也算）和PathVariable参数
     */
    @Bean
    public Converter&lt;String, Date&gt; dateConverter() &#123;
        return new Converter&lt;String, Date&gt;() &#123;
            @Override
            public Date convert(String source) &#123;
                return DateUtil.parse(source.trim());
            &#125;
        &#125;;
    &#125;

    /**
     * Date转换器，用于转换RequestParam（入参对象也算）和PathVariable参数
     */
    @Bean
    public Converter&lt;String, Timestamp&gt; timestampConverter() &#123;
        return new Converter&lt;String, Timestamp&gt;() &#123;
            @Override
            public Timestamp convert(String source) &#123;
                return new Timestamp(DateUtil.parse(source.trim()).getTime());
            &#125;
        &#125;;
    &#125;

    /**
     * LocalDate,LocalDateTime,LocalTime,Date,Timestamp 转换器: 用于转换RequestParam（入参对象也算）和PathVariable参数
     */
    @Bean
    public WebMvcConfigurer webMvcConfigurer() &#123;
        return new WebMvcConfigurer() &#123;
            @Override
            public void addFormatters(FormatterRegistry registry) &#123;
                registry.addConverter(String.class, LocalDate.class,
                        source -&gt; LocalDate.parse(source, DateTimeFormatter.ofPattern(DEFAULT_DATE_FORMAT)));
                registry.addConverter(String.class, LocalTime.class,
                        source -&gt; LocalTime.parse(source, DateTimeFormatter.ofPattern(DEFAULT_TIME_FORMAT)));
                registry.addConverter(String.class, LocalDateTime.class,
                        source -&gt; LocalDateTime.parse(source, DateTimeFormatter.ofPattern(DEFAULT_DATE_TIME_FORMAT)));
                registry.addConverter(String.class, Date.class, source -&gt; DateUtil.parse(source.trim()));
                registry.addConverter(String.class, Timestamp.class,
                        source -&gt; new Timestamp(DateUtil.parse(source.trim()).getTime()));
            &#125;
        &#125;;
    &#125;

    /**
     * Json序列化和反序列化转换器，用于转换Post请求体中的json以及将我们的对象序列化为返回响应的json
     */
    @Bean
    public ObjectMapper objectMapper() &#123;
        ObjectMapper objectMapper = new ObjectMapper();
        objectMapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);
        objectMapper.disable(DeserializationFeature.ADJUST_DATES_TO_CONTEXT_TIME_ZONE);

        // LocalDateTime系列序列化和反序列化模块，继承自jsr310，我们在这里修改了日期格式
        JavaTimeModule javaTimeModule = new JavaTimeModule();
        javaTimeModule.addSerializer(LocalDateTime.class,
                new LocalDateTimeSerializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_TIME_FORMAT)));
        javaTimeModule.addSerializer(LocalDate.class,
                new LocalDateSerializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_FORMAT)));
        javaTimeModule.addSerializer(LocalTime.class,
                new LocalTimeSerializer(DateTimeFormatter.ofPattern(DEFAULT_TIME_FORMAT)));
        javaTimeModule.addDeserializer(LocalDateTime.class,
                new LocalDateTimeDeserializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_TIME_FORMAT)));
        javaTimeModule.addDeserializer(LocalDate.class,
                new LocalDateDeserializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_FORMAT)));
        javaTimeModule.addDeserializer(LocalTime.class,
                new LocalTimeDeserializer(DateTimeFormatter.ofPattern(DEFAULT_TIME_FORMAT)));

        // Date序列化和反序列化
        javaTimeModule.addSerializer(Date.class, new JsonSerializer&lt;&gt;() &#123;
            @SneakyThrows
            @Override
            public void serialize(Date date, JsonGenerator jsonGenerator, SerializerProvider serializerProvider) &#123;
                SimpleDateFormat formatter = new SimpleDateFormat(DEFAULT_DATE_TIME_FORMAT);
                String formattedDate = formatter.format(date);
                jsonGenerator.writeString(formattedDate);
            &#125;
        &#125;);
        javaTimeModule.addDeserializer(Date.class, new JsonDeserializer&lt;&gt;() &#123;
            @SneakyThrows
            @Override
            public Date deserialize(JsonParser jsonParser, DeserializationContext deserializationContext) &#123;
                SimpleDateFormat format = new SimpleDateFormat(DEFAULT_DATE_TIME_FORMAT);
                String date = jsonParser.getText();
                return format.parse(date);
            &#125;
        &#125;);

        // Timestamp序列化和反序列化
        javaTimeModule.addSerializer(Timestamp.class, new JsonSerializer&lt;&gt;() &#123;
            @SneakyThrows
            @Override
            public void serialize(Timestamp timestamp, JsonGenerator jsonGenerator, SerializerProvider serializerProvider) &#123;
                SimpleDateFormat formatter = new SimpleDateFormat(DEFAULT_DATE_TIME_FORMAT);
                String formattedDate = formatter.format(timestamp);
                jsonGenerator.writeString(formattedDate);
            &#125;
        &#125;);
        javaTimeModule.addDeserializer(Timestamp.class, new JsonDeserializer&lt;&gt;() &#123;
            @SneakyThrows
            @Override
            public Timestamp deserialize(JsonParser jsonParser, DeserializationContext deserializationContext) &#123;
                SimpleDateFormat format = new SimpleDateFormat(DEFAULT_DATE_TIME_FORMAT);
                String date = jsonParser.getText();
                return new Timestamp(format.parse(date).getTime());
            &#125;
        &#125;);

        objectMapper.registerModule(javaTimeModule);
        return objectMapper;
    &#125;
&#125;
</code></pre>
<h2 id="5、扩充源码：深入研究数据绑定过程"><a href="#5、扩充源码：深入研究数据绑定过程" class="headerlink" title="5、扩充源码：深入研究数据绑定过程"></a>5、扩充源码：深入研究数据绑定过程</h2><blockquote>
<p>接下来进入Debug模式，看看mvc是如何将我们request中的参数绑定到我们controller层方法入参的</p>
</blockquote>
<p>1、写一个简单controller，打个断点看看方法调用栈：</p>
<pre><code class="java">@GetMapping(&quot;/getDate&quot;)
public LocalDateTime getDate(@RequestParam LocalDate date,
                             @RequestParam LocalDateTime dateTime,
                             @RequestParam Date originalDate) &#123;
    System.out.println(date);
    System.out.println(dateTime);
    System.out.println(originalDate);
    return LocalDateTime.now();
&#125;
</code></pre>
<p>2、调用接口以后，我们看下方法调用栈中一些关键方法：</p>
<pre><code class="java">// 进入DispatcherServlet
doService:942, DispatcherServlet
// 处理请求
doDispatch:1038, DispatcherServlet
// 生成调用链（前处理、实际调用方法、后处理）
handle:87, AbstractHandlerMethodAdapter
// 反射获取到实际调用方法，准备开始调用
invokeHandlerMethod:895, RequestMappingHandlerAdapter
invokeAndHandle:102, ServletInvocableHandlerMethod
// 这里是关键，参数从这里开始获取到
invokeForRequest:142, InvocableHandlerMethod
doInvoke:215, InvocableHandlerMethod
// 这个是Java reflect调用，因此一定是在这之前获取到的参数
invoke:566, Method
</code></pre>
<p>3、根据上述分析发现<code>invokeForRequest:142, InvocableHandlerMethod</code>这里的代码是用来拿到实际参数的：</p>
<pre><code class="java">@Nullable
public Object invokeForRequest(NativeWebRequest request, @Nullable ModelAndViewContainer mavContainer,
                               Object... providedArgs) throws Exception &#123;
    // 这个方法是获取参数的，在这里下个断
    Object[] args = getMethodArgumentValues(request, mavContainer, providedArgs);
    if (logger.isTraceEnabled()) &#123;
        logger.trace(&quot;Arguments: &quot; + Arrays.toString(args));
    &#125;
    // 这里开始调用方法
    return doInvoke(args);
&#125;
</code></pre>
<p>4、进入这个方法看看是什么操作：</p>
<pre><code class="java">protected Object[] getMethodArgumentValues(NativeWebRequest request, @Nullable ModelAndViewContainer mavContainer, Object... providedArgs) throws Exception &#123;
    // 获取方法参数数组，包含了入参信息，比如类型、泛型等等
    MethodParameter[] parameters = getMethodParameters();
    // 这个用来存放一会从request parameter转换的参数
    Object[] args = new Object[parameters.length];
    for (int i = 0; i &lt; parameters.length; i++) &#123;
        MethodParameter parameter = parameters[i];
        parameter.initParameterNameDiscovery(this.parameterNameDiscoverer);
        // 这里看起来没啥卵用（providedArgs为空）
        args[i] = resolveProvidedArgument(parameter, providedArgs);
        // 这里开始获取到方法实际调用的参数，步进
        if (this.argumentResolvers.supportsParameter(parameter)) &#123;
            // 从名字就看出来：参数解析器解析参数
            args[i] = this.argumentResolvers.resolveArgument(parameter, mavContainer, request, this.dataBinderFactory);
            continue;
        &#125;
    &#125;
    return args;
&#125;
</code></pre>
<p>5、进入resolveArgument看看：</p>
<pre><code class="java">public Object resolveArgument(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer,
                              NativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory) throws Exception &#123;
    // 根据方法入参，获取对应的解析器
    HandlerMethodArgumentResolver resolver = getArgumentResolver(parameter);
    // 开始解析参数（把请求中的parameter转为方法的入参）
    return resolver.resolveArgument(parameter, mavContainer, webRequest, binderFactory);
&#125;
</code></pre>
<p>6、这里根据参数获取相应的参数解析器，看看内部如何获取的：</p>
<pre><code class="java">// 遍历，调用supportParameter方法，跟进看看
for (HandlerMethodArgumentResolver methodArgumentResolver : this.argumentResolvers) &#123;
    if (methodArgumentResolver.supportsParameter(parameter)) &#123;
        result = methodArgumentResolver;
        this.argumentResolverCache.put(parameter, result);
        break;
    &#125;
&#125;
</code></pre>
<p>7、<strong>这里，遍历参数解析器，查找有没有适合的解析器！那么，有哪些参数解析器呢(我测试的时候有26个)？？？我列出几个重要的看看，是不是很眼熟！！！</strong></p>
<pre><code class="java">&#123;RequestParamMethodArgumentResolver@7686&#125;
&#123;PathVariableMethodArgumentResolver@8359&#125;
&#123;RequestResponseBodyMethodProcessor@8366&#125;
&#123;RequestPartMethodArgumentResolver@8367&#125;
</code></pre>
<p>8、我们进入最常用的一个解析器看看他的supportsParameter方法，发现就是通过参数注解来获取相应的解析器的。</p>
<pre><code class="java">public boolean supportsParameter(MethodParameter parameter) &#123;
    // 如果参数拥有注解@RequestParam，则走这个分支（知道为什么上文要对RequestParam和Json两种数据区别对待了把）
    if (parameter.hasParameterAnnotation(RequestParam.class)) &#123;
        // 这个似乎是对Optional类型的参数进行处理的
        if (Map.class.isAssignableFrom(parameter.nestedIfOptional().getNestedParameterType())) &#123;
            RequestParam requestParam = parameter.getParameterAnnotation(RequestParam.class);
            return (requestParam != null &amp;&amp; StringUtils.hasText(requestParam.name()));
        &#125;
        else &#123;
            return true;
        &#125;
    &#125;
    // ......
&#125;
</code></pre>
<p>也就是说，对于@RequestParam和@RequestBody以及@PathVariable注解的参数，SpringMVC会使用不同的参数解析器进行数据绑定！ 那么，这三种解析器分别使用什么Converter解析参数呢？我们分别进入三种解析器看一看： 首先看下RequestParamMethodArgumentResolver发现内部使用WebDataBinder进行数据绑定，底层使用的是ConversionService （也就是我们的Converter注入的地方）</p>
<pre><code class="java">WebDataBinder binder = binderFactory.createBinder(webRequest, null, namedValueInfo.name);
// 通过DataBinder进行数据绑定的
arg = binder.convertIfNecessary(arg, parameter.getParameterType(), parameter);

// 跟进convertIfNecessary()
public &lt;T&gt; T convertIfNecessary(@Nullable Object value, @Nullable Class&lt;T&gt; requiredType,
                                @Nullable MethodParameter methodParam) throws TypeMismatchException &#123;

    return getTypeConverter().convertIfNecessary(value, requiredType, methodParam);
&#125;

// 继续跟进，看到了把
ConversionService conversionService = this.propertyEditorRegistry.getConversionService();
if (editor == null &amp;&amp; conversionService != null &amp;&amp; newValue != null &amp;&amp; typeDescriptor != null) &#123;
    TypeDescriptor sourceTypeDesc = TypeDescriptor.forObject(newValue);
    if (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) &#123;
        try &#123;
            return (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor);
        &#125;
        catch (ConversionFailedException ex) &#123;
            // fallback to default conversion logic below
            conversionAttemptEx = ex;
        &#125;
    &#125;
&#125;
</code></pre>
<p><strong>然后看下RequestResponseBodyMethodProcessor发现使用的转换器是HttpMessageConverter类型的：</strong></p>
<pre><code class="java">// resolveArgument方法内部调用下面进行参数解析
Object arg = readWithMessageConverters(webRequest, parameter, parameter.getNestedGenericParameterType());

// step into readWithMessageConverters()，我们看到这里的Converter是HttpMessageConverter
for (HttpMessageConverter&lt;?&gt; converter : this.messageConverters) &#123;
    Class&lt;HttpMessageConverter&lt;?&gt;&gt; converterType = (Class&lt;HttpMessageConverter&lt;?&gt;&gt;) converter.getClass();
    GenericHttpMessageConverter&lt;?&gt; genericConverter =
        (converter instanceof GenericHttpMessageConverter ? (GenericHttpMessageConverter&lt;?&gt;) converter : null);
    if (genericConverter != null ? genericConverter.canRead(targetType, contextClass, contentType) :
        (targetClass != null &amp;&amp; converter.canRead(targetClass, contentType))) &#123;
        if (message.hasBody()) &#123;
            HttpInputMessage msgToUse =
                getAdvice().beforeBodyRead(message, parameter, targetType, converterType);
            body = (genericConverter != null ? genericConverter.read(targetType, contextClass, msgToUse) :
                    ((HttpMessageConverter&lt;T&gt;) converter).read(targetClass, msgToUse));
            body = getAdvice().afterBodyRead(body, msgToUse, parameter, targetType, converterType);
        &#125;
        else &#123;
            body = getAdvice().handleEmptyBody(null, message, parameter, targetType, converterType);
        &#125;
        break;
    &#125;
&#125;
</code></pre>
<p><strong>最后看下PathVariableMethodArgumentResolver发现 和RequestParam走的执行路径一致（二者都是继承自AbstractNamedValueMethodArgumentResolver解析器），因此代码就不贴了。</strong></p>
<h2 id="6、SpringBoot-日期时间参数使用总结"><a href="#6、SpringBoot-日期时间参数使用总结" class="headerlink" title="6、SpringBoot 日期时间参数使用总结"></a>6、SpringBoot 日期时间参数使用总结</h2><p>总结：如果要转换request传来的参数到我们指定的类型，根据入参注解要进行区分：</p>
<ul>
<li>如果是RequestBody，那么通过配置ObjectMapper（这个玩意儿会注入到Jackson的HttpMessagConverter里面，即MappingJackson2HttpMessageConverter中）来实现JSON格式数据的序列化和反序列化；</li>
<li>如果是RequestParam（对象参数也属于这种）或者PathVariable类型的参数，通过配置Converter实现参数转换（这些Converter会注入到ConversionService中）</li>
</ul>
<p>总结：通过POST请求和GET请求 以及 序列化和反序列化 分类：</p>
<ul>
<li>POST 请求序列化：<ul>
<li>全局配置除了Java8时间无效，其他都正常。</li>
<li>@JsonFormat注解配置，任何类型都生效</li>
</ul>
</li>
<li>POST 请求反序列化：<ul>
<li>类型为 content-type&#x3D;application&#x2F;x-www-form-urlencoded，后台非@RequestBody接收，全局与@JsonFormat注解配置都无效，只能使用Spring的Converter转换器，或者直接使用@DateTimeFormat进行接收参数转换</li>
<li>类型为 content-type&#x3D;application&#x2F;json，后台为@RequestBody接收，注解配置生效，全局配置Java8时间不生效。</li>
</ul>
</li>
<li>GET 请求序列化：<ul>
<li>全局配置除了Java8时间无效，其他都正常。</li>
<li>@JsonFormat注解配置，任何类型都生效</li>
</ul>
</li>
<li>GET 请求反序列化：<ul>
<li>全局与@JsonFormat注解配置都无效，只能使用Spring的Converter转换器，或者直接使用@DateTimeFormat进行接收参数转换</li>
</ul>
</li>
</ul>

      
       <hr><span style="font-style: italic;color: gray;"> 转载请注明来源，欢迎对文章中的引用来源进行考证，欢迎指出任何有错误或不够清晰的表达。可以在下面评论区评论，也可以邮件至 8629303@qq.com </span>
    </div>
</article>


<p>
    <a  class="dashang" onclick="dashangToggle()">赏</a>
</p>






    




    </div>
    <div class="copyright">
        <p class="footer-entry">
    ©2017-2024 Sam
</p>
<p class="footer-entry">Built with <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/yelog/hexo-theme-3-hexo" target="_blank">3-hexo</a> theme</p>

    </div>
    <div class="full-toc">
        <button class="full" data-title="切换全屏 快捷键 s"><span class="min "></span></button>
<a class="" id="rocket" ></a>

    </div>
</div>

<div class="hide_box" onclick="dashangToggle()"></div>
<div class="shang_box">
    <a class="shang_close"  onclick="dashangToggle()">×</a>
    <div class="shang_tit">
        <p>喜欢就点赞,疼爱就打赏</p>
    </div>
    <div class="shang_payimg">
        <div class="pay_img">
            <img src="/img/alipay.jpg" class="alipay" title="扫码支持">
            <img src="/img/weixin.jpg" class="weixin" title="扫码支持">
        </div>
    </div>
    <div class="shang_payselect">
        <span><label><input type="radio" name="pay" checked value="alipay">支付宝</label></span><span><label><input type="radio" name="pay" value="weixin">微信</label></span>
    </div>
</div>


</body>
<script src="/js/jquery.pjax.js?v=1.1.0" ></script>

<script src="/js/script.js?v=1.1.0" ></script>
<script>
    var img_resize = 'default';
    function initArticle() {
        /*渲染对应的表格样式*/
        
            $("#post .pjax table").addClass("green_title");
        

        /*渲染打赏样式*/
        
        $("input[name=pay]").on("click", function () {
            if($("input[name=pay]:checked").val()=="weixin"){
                $(".shang_box .shang_payimg .pay_img").addClass("weixin_img");
            } else {
                $(".shang_box .shang_payimg .pay_img").removeClass("weixin_img");
            }
        })
        

        /*高亮代码块行号*/
        
        $('pre code').each(function(){
            var lines = $(this).text().trim().split('\n').length, widther='';
            if (lines>99) {
                widther = 'widther'
            }
            var $numbering = $('<ul/>').addClass('pre-numbering ' + widther).attr("unselectable","on");
            $(this).addClass('has-numbering ' + widther)
                    .parent()
                    .append($numbering);
            for(var i=1;i<=lines;i++){
                $numbering.append($('<li/>').text(i));
            }
        });
        

        /*访问数量*/
        
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js");
        

        /*代码高亮，行号对齐*/
        $('.pre-numbering').css('line-height',$('.has-numbering').css('line-height'));

        
        
    }

    /*打赏页面隐藏与展示*/
    
    function dashangToggle() {
        $(".shang_box").fadeToggle();
        $(".hide_box").fadeToggle();
    }
    

</script>

<!--加入行号的高亮代码块样式-->

<style>
    pre{
        position: relative;
        margin-bottom: 24px;
        border-radius: 10px;
        border: 1px solid #e2dede;
        background: #FFF;
        overflow: hidden;
    }
    code.has-numbering{
        margin-left: 30px;
    }
    code.has-numbering.widther{
        margin-left: 35px;
    }
    .pre-numbering{
        margin: 0;
        position: absolute;
        top: 0;
        left: 0;
        width: 20px;
        padding: 18px 3px 15px 5px;
        border-right: 1px solid #C3CCD0;
        text-align: right;
        color: #AAA;
        background-color: #fafafa;
    }
    .pre-numbering.widther {
        width: 35px;
    }
</style>

<!--自定义样式设置-->
<style>
    
    
    .nav {
        width: 582px;
    }
    .nav.fullscreen {
        margin-left: -582px;
    }
    .nav-left {
        width: 160px;
    }
    
    
    @media screen and (max-width: 1468px) {
        .nav {
            width: 492px;
        }
        .nav.fullscreen {
            margin-left: -492px;
        }
        .nav-left {
            width: 100px;
        }
    }
    
    
    @media screen and (max-width: 1024px) {
        .nav {
            width: 492px;
            margin-left: -492px
        }
        .nav.fullscreen {
            margin-left: 0;
        }
    }
    
    @media screen and (max-width: 426px) {
        .nav {
            width: 100%;
        }
        .nav-left {
            width: 100%;
        }
    }
    
    
    .nav-right .title-list nav a .post-title, .nav-right .title-list #local-search-result a .post-title {
        color: #383636;
    }
    
    
    .nav-right .title-list nav a .post-date, .nav-right .title-list #local-search-result a .post-date {
        color: #5e5e5f;
    }
    
    
    .nav-right nav a.hover, #local-search-result a.hover{
        background-color: #e2e0e0;
    }
    
    

    /*列表样式*/
    

    /* 背景图样式 */
    
    


    /*引用块样式*/
    

    /*文章列表背景图*/
    

    
</style>







</html>
