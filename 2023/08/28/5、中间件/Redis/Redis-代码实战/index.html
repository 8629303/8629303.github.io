<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Redis-代码实战 | Hexo</title>
  <meta name="keywords" content="">
  <meta name="description" content="Redis-代码实战 | Hexo">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="description" content="请不要自己写，Spring Boot非常实用的内置功能：https:&#x2F;&#x2F;juejin.cn&#x2F;post&#x2F;7417630844100231206  在 SpringBoot 框架中，内置了许多实用的功能，这些功能可以帮助开发者高效地开发和维护应用程序。 一、请求数据记录器SpringBoot 提供了一个内置的日志记录解决方案，通过 AbstractRequestLoggingFilter 可以记录请">
<meta property="og:type" content="article">
<meta property="og:title" content="SpringBoot2.x 内置功能 - 内置过滤器和 AOP 工具类">
<meta property="og:url" content="http://example.com/2024/10/08/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot2.x%20%E5%86%85%E7%BD%AE%E5%8A%9F%E8%83%BD%20-%20%E5%86%85%E7%BD%AE%E8%BF%87%E6%BB%A4%E5%99%A8%E5%92%8C%20AOP%20%E5%B7%A5%E5%85%B7%E7%B1%BB/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="请不要自己写，Spring Boot非常实用的内置功能：https:&#x2F;&#x2F;juejin.cn&#x2F;post&#x2F;7417630844100231206  在 SpringBoot 框架中，内置了许多实用的功能，这些功能可以帮助开发者高效地开发和维护应用程序。 一、请求数据记录器SpringBoot 提供了一个内置的日志记录解决方案，通过 AbstractRequestLoggingFilter 可以记录请">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2024-10-08T08:44:19.743Z">
<meta property="article:modified_time" content="2024-10-18T10:28:56.825Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">


<link rel="icon" href="/img/avatar.jpg">

<link href="/css/style.css?v=1.1.0" rel="stylesheet">

<link href="/css/hl_theme/atom-light.css?v=1.1.0" rel="stylesheet">

<link href="//cdn.jsdelivr.net/npm/animate.css@4.1.0/animate.min.css" rel="stylesheet">

<script src="//cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
<script src="/js/titleTip.js?v=1.1.0" ></script>

<script src="//cdn.jsdelivr.net/npm/highlightjs@9.16.2/highlight.pack.min.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>

<script src="//cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script>



<script src="//cdn.jsdelivr.net/npm/jquery.cookie@1.4.1/jquery.cookie.min.js" ></script>

<script src="/js/iconfont.js?v=1.1.0" ></script>

<meta name="generator" content="Hexo 7.3.0"></head>
<div style="display: none">
  <input class="theme_disqus_on" value="false">
  <input class="theme_preload_comment" value="">
  <input class="theme_blog_path" value="">
  <input id="theme_shortcut" value="true" />
  <input id="theme_highlight_on" value="true" />
  <input id="theme_code_copy" value="true" />
</div>



<body>
<aside class="nav">
    <div class="nav-left">
        <a href="/"
   class="avatar_target">
    <img class="avatar"
         src="/img/avatar.jpg"/>
</a>
<div class="author">
    <span>John Doe</span>
</div>

<div class="icon">
    
        
            <a title="github"
               href="https://github.com/8629303"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-github"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="email"
               href="mailto:8629303@qq.com"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-email"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="qq"
               href="http://wpa.qq.com/msgrd?v=3&uin=8629303&site=qq&menu=yes"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-qq"></use>
                    </svg>
                
            </a>
        
    
</div>





<ul>
    <li>
        <div class="all active" data-rel="全部文章">全部文章
            
                <small>(172)</small>
            
        </div>
    </li>
    
        
            
        
    
        
            
                
    <li>
        <div data-rel="_posts">
            <i class="fold iconfont icon-right"></i>
            _posts
            <small>(14)</small>
        </div>
        
            <ul class="sub hide">
                
                    
    <li>
        <div data-rel="_posts&lt;---&gt;数据库">
            
            数据库
            <small>(5)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="_posts&lt;---&gt;开发工具">
            
            开发工具
            <small>(8)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="_posts&lt;---&gt;面试篇">
            
            面试篇
            <small>(1)</small>
        </div>
        
    </li>

                
            </ul>
        
    </li>

            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
                
    <li>
        <div data-rel="开发工具">
            <i class="fold iconfont icon-right"></i>
            开发工具
            <small>(8)</small>
        </div>
        
            <ul class="sub hide">
                
                    
    <li>
        <div data-rel="开发工具&lt;---&gt;Maven">
            
            Maven
            <small>(8)</small>
        </div>
        
    </li>

                
            </ul>
        
    </li>

            
        
    
        
            
        
    
        
            
                
    <li>
        <div data-rel="微服务开发">
            <i class="fold iconfont icon-right"></i>
            微服务开发
            <small>(61)</small>
        </div>
        
            <ul class="sub hide">
                
                    
    <li>
        <div data-rel="微服务开发&lt;---&gt;Shiro">
            
            Shiro
            <small>(2)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="微服务开发&lt;---&gt;Spring">
            
            Spring
            <small>(3)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="微服务开发&lt;---&gt;SpringBoot">
            
            SpringBoot
            <small>(44)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="微服务开发&lt;---&gt;SpringCloudAlibaba">
            
            SpringCloudAlibaba
            <small>(1)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="微服务开发&lt;---&gt;SpringDataJPA">
            
            SpringDataJPA
            <small>(4)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="微服务开发&lt;---&gt;SpringMVC">
            
            SpringMVC
            <small>(1)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="微服务开发&lt;---&gt;SpringSecurity">
            
            SpringSecurity
            <small>(1)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="微服务开发&lt;---&gt;SpringTransaction">
            
            SpringTransaction
            <small>(5)</small>
        </div>
        
    </li>

                
            </ul>
        
    </li>

            
        
    
        
            
        
    
        
            
                
    <li>
        <div data-rel="中间件">
            <i class="fold iconfont icon-right"></i>
            中间件
            <small>(8)</small>
        </div>
        
            <ul class="sub hide">
                
                    
    <li>
        <div data-rel="中间件&lt;---&gt;ElasticSearch">
            
            ElasticSearch
            <small>(1)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="中间件&lt;---&gt;MongoDB">
            
            MongoDB
            <small>(2)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="中间件&lt;---&gt;RabbitMQ">
            
            RabbitMQ
            <small>(3)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="中间件&lt;---&gt;Redis">
            
            Redis
            <small>(2)</small>
        </div>
        
    </li>

                
            </ul>
        
    </li>

            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
                
    <li>
        <div data-rel="Java基础篇">
            <i class="fold iconfont icon-right"></i>
            Java基础篇
            <small>(8)</small>
        </div>
        
            <ul class="sub hide">
                
                    
    <li>
        <div data-rel="Java基础篇&lt;---&gt;Java常用类库">
            
            Java常用类库
            <small>(1)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="Java基础篇&lt;---&gt;Java多线程">
            
            Java多线程
            <small>(2)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="Java基础篇&lt;---&gt;Java反射与注解">
            
            Java反射与注解
            <small>(1)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="Java基础篇&lt;---&gt;Java基础语法">
            
            Java基础语法
            <small>(1)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="Java基础篇&lt;---&gt;Java集合类">
            
            Java集合类
            <small>(1)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="Java基础篇&lt;---&gt;JavaIO流">
            
            JavaIO流
            <small>(1)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="Java基础篇&lt;---&gt;JavaNIO流">
            
            JavaNIO流
            <small>(1)</small>
        </div>
        
    </li>

                
            </ul>
        
    </li>

            
        
    
        
            
        
    
        
            
        
    
        
            
                
    <li>
        <div data-rel="Java进阶篇">
            <i class="fold iconfont icon-right"></i>
            Java进阶篇
            <small>(4)</small>
        </div>
        
            <ul class="sub hide">
                
                    
    <li>
        <div data-rel="Java进阶篇&lt;---&gt;Java设计模式">
            
            Java设计模式
            <small>(1)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="Java进阶篇&lt;---&gt;JVM虚拟机">
            
            JVM虚拟机
            <small>(3)</small>
        </div>
        
    </li>

                
            </ul>
        
    </li>

            
        
    
        
            
        
    
        
            
        
    
        
            
                
    <li>
        <div data-rel="Java新特性">
            <i class="fold iconfont icon-right"></i>
            Java新特性
            <small>(16)</small>
        </div>
        
            <ul class="sub hide">
                
                    
    <li>
        <div data-rel="Java新特性&lt;---&gt;Java10新特性">
            
            Java10新特性
            <small>(1)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="Java新特性&lt;---&gt;Java11新特性">
            
            Java11新特性
            <small>(1)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="Java新特性&lt;---&gt;Java12新特性">
            
            Java12新特性
            <small>(1)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="Java新特性&lt;---&gt;Java13新特性">
            
            Java13新特性
            <small>(1)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="Java新特性&lt;---&gt;Java14新特性">
            
            Java14新特性
            <small>(1)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="Java新特性&lt;---&gt;Java15新特性">
            
            Java15新特性
            <small>(1)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="Java新特性&lt;---&gt;Java16新特性">
            
            Java16新特性
            <small>(1)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="Java新特性&lt;---&gt;Java17新特性">
            
            Java17新特性
            <small>(1)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="Java新特性&lt;---&gt;Java18新特性">
            
            Java18新特性
            <small>(1)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="Java新特性&lt;---&gt;Java19新特性">
            
            Java19新特性
            <small>(1)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="Java新特性&lt;---&gt;Java20新特性">
            
            Java20新特性
            <small>(1)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="Java新特性&lt;---&gt;Java8新特性">
            
            Java8新特性
            <small>(4)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="Java新特性&lt;---&gt;Java9新特性">
            
            Java9新特性
            <small>(1)</small>
        </div>
        
    </li>

                
            </ul>
        
    </li>

            
        
    
        
            
        
    
        
            
                
    <li>
        <div data-rel="JavaEE">
            <i class="fold iconfont icon-right"></i>
            JavaEE
            <small>(6)</small>
        </div>
        
            <ul class="sub hide">
                
                    
    <li>
        <div data-rel="JavaEE&lt;---&gt;JavaWeb">
            
            JavaWeb
            <small>(2)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="JavaEE&lt;---&gt;SSM框架">
            
            SSM框架
            <small>(4)</small>
        </div>
        
    </li>

                
            </ul>
        
    </li>

            
        
    
        
            
        
    
        
            
        
    
        
            
                
    <li>
        <div data-rel="JavaSE">
            <i class="fold iconfont icon-right"></i>
            JavaSE
            <small>(34)</small>
        </div>
        
            <ul class="sub hide">
                
                    
    <li>
        <div data-rel="JavaSE&lt;---&gt;Java汇总篇">
            
            Java汇总篇
            <small>(28)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="JavaSE&lt;---&gt;Java新特性">
            
            Java新特性
            <small>(1)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="JavaSE&lt;---&gt;Java性能测试与安全">
            
            Java性能测试与安全
            <small>(5)</small>
        </div>
        
    </li>

                
            </ul>
        
    </li>

            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
                
    <li>
        <div data-rel="Linux">
            <i class="fold iconfont icon-right"></i>
            Linux
            <small>(7)</small>
        </div>
        
            <ul class="sub hide">
                
                    
    <li>
        <div data-rel="Linux&lt;---&gt;虚拟机工具">
            
            虚拟机工具
            <small>(2)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="Linux&lt;---&gt;Docker">
            
            Docker
            <small>(2)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="Linux&lt;---&gt;Kubernetes">
            
            Kubernetes
            <small>(2)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="Linux&lt;---&gt;Nginx">
            
            Nginx
            <small>(1)</small>
        </div>
        
    </li>

                
            </ul>
        
    </li>

            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
                
    <li>
        <div data-rel="Redis">
            <i class="fold iconfont icon-right"></i>
            Redis
            <small>(1)</small>
        </div>
        
            <ul class="sub hide">
                
                    
    <li>
        <div data-rel="Redis&lt;---&gt;backup">
            
            backup
            <small>(1)</small>
        </div>
        
    </li>

                
            </ul>
        
    </li>

            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
                
    <li>
        <div data-rel="SpringTransaction">
            <i class="fold iconfont icon-right"></i>
            SpringTransaction
            <small>(5)</small>
        </div>
        
            <ul class="sub hide">
                
                    
    <li>
        <div data-rel="SpringTransaction&lt;---&gt;多数据源事务处理">
            
            多数据源事务处理
            <small>(3)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="SpringTransaction&lt;---&gt;多线程下事务处理">
            
            多线程下事务处理
            <small>(2)</small>
        </div>
        
    </li>

                
            </ul>
        
    </li>

            
        
    
        
            
        
    
</ul>
<div class="left-bottom">
    <div class="menus">
        
            
            
            
    </div>
    <div>
        
            <a class="about  hasFriend  site_url"
               
               href="/about">关于</a>
        
        <a style="width: 50%"
                
                                           class="friends">友链</a>
        
    </div>
</div>
<input type="hidden" id="yelog_site_posts_number" value="172">

<div style="display: none">
    <span id="busuanzi_value_site_uv"></span>
    <span id="busuanzi_value_site_pv"></span>
</div>

    </div>
    <div class="nav-right">
        <div class="friends-area">
    <div class="friends-title">
        友情链接
        <i class="iconfont icon-left"></i>
    </div>
    <div class="friends-content">
        <ul>
            
            <li><a target="_blank" href="http://yelog.org/">叶落阁</a></li>
            
        </ul>
    </div>
</div>
        <div class="title-list">
    <div class="right-top">
        <div id="default-panel">
            <i class="iconfont icon-search" data-title="搜索 快捷键 i"></i>
            <div class="right-title">全部文章</div>
            <i class="iconfont icon-file-tree" data-title="切换到大纲视图 快捷键 w"></i>
        </div>
        <div id="search-panel">
            <i class="iconfont icon-left" data-title="返回"></i>
            <input id="local-search-input" autocomplete="off"/>
            <label class="border-line" for="input"></label>
            <i class="iconfont icon-case-sensitive" data-title="大小写敏感"></i>
            <i class="iconfont icon-tag" data-title="标签"></i>
        </div>
        <div id="outline-panel" style="display: none">
            <div class="right-title">大纲</div>
            <i class="iconfont icon-list" data-title="切换到文章列表"></i>
        </div>
    </div>

    <div class="tags-list">
    <input id="tag-search" />
    <div class="tag-wrapper">
        
    </div>

</div>

    
    <nav id="title-list-nav">
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2024/10/08/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot2.x%20%E5%86%85%E7%BD%AE%E5%8A%9F%E8%83%BD%20-%20%E5%86%85%E7%BD%AE%E8%BF%87%E6%BB%A4%E5%99%A8%E5%92%8C%20AOP%20%E5%B7%A5%E5%85%B7%E7%B1%BB/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot2.x 内置功能 - 内置过滤器和 AOP 工具类">SpringBoot2.x 内置功能 - 内置过滤器和 AOP 工具类</span>
            <span class="post-date" title="2024-10-08 16:44:19">2024/10/08</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2024/10/08/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%E7%B3%BB%E5%88%97-%E5%85%A8%E7%BD%91%E6%9C%80%E5%85%A8%E7%9A%84%E7%89%88%E6%9C%AC%E5%8F%98%E6%9B%B4%E5%8F%B2/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot系列-全网最全的版本变更史">SpringBoot系列-全网最全的版本变更史</span>
            <span class="post-date" title="2024-10-08 16:38:53">2024/10/08</span>
        </a>
        
        
        <a  class="全部文章 开发工具 Maven "
           href="/2024/10/08/6%E3%80%81%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Maven/Maven%20%E6%95%99%E7%A8%8B%E4%B9%8B%20%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE%20&%20%E9%B8%A3%E8%B0%A2/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Maven 教程之 参考文献 &amp; 鸣谢">Maven 教程之 参考文献 &amp; 鸣谢</span>
            <span class="post-date" title="2024-10-08 15:50:47">2024/10/08</span>
        </a>
        
        
        <a  class="全部文章 _posts 开发工具 "
           href="/2024/10/07/6%E3%80%81%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/GitHub%20%E5%AE%9E%E6%88%98%E6%8A%80%E5%B7%A7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="GitHub 实战技巧">GitHub 实战技巧</span>
            <span class="post-date" title="2024-10-07 15:55:34">2024/10/07</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2024/10/07/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot2.x%20%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AF%87%20-%20%E9%9B%86%E6%88%90%20HirakiCP%20%E4%B8%8E%20Druid%20%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot2.x 数据库篇 - 集成 HirakiCP 与 Druid 数据库连接池">SpringBoot2.x 数据库篇 - 集成 HirakiCP 与 Druid 数据库连接池</span>
            <span class="post-date" title="2024-10-07 14:19:43">2024/10/07</span>
        </a>
        
        
        <a  class="全部文章 _posts 开发工具 "
           href="/2024/09/30/6%E3%80%81%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/MacOS%20%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%8F%8A%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E5%8D%B8%E8%BD%BD/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="MacOS 开发环境搭建及软件安装卸载">MacOS 开发环境搭建及软件安装卸载</span>
            <span class="post-date" title="2024-09-30 23:56:52">2024/09/30</span>
        </a>
        
        
        <a  class="全部文章 开发工具 Maven "
           href="/2024/09/30/6%E3%80%81%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Maven/Maven%20%E6%95%99%E7%A8%8B%E4%B9%8B%20JDK%20%E7%89%88%E6%9C%AC%E9%BB%98%E8%AE%A4%E8%AE%BE%E7%BD%AE%20/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Maven 教程之 JDK 版本默认设置">Maven 教程之 JDK 版本默认设置</span>
            <span class="post-date" title="2024-09-30 16:37:08">2024/09/30</span>
        </a>
        
        
        <a  class="全部文章 开发工具 Maven "
           href="/2024/09/26/6%E3%80%81%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Maven/Maven%20%E6%95%99%E7%A8%8B%E4%B9%8B%20profiles%20%E5%A4%9A%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Maven 教程之 profiles 多环境配置">Maven 教程之 profiles 多环境配置</span>
            <span class="post-date" title="2024-09-26 17:40:34">2024/09/26</span>
        </a>
        
        
        <a  class="全部文章 开发工具 Maven "
           href="/2024/09/25/6%E3%80%81%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Maven/Maven%20%E6%95%99%E7%A8%8B%E4%B9%8B%20plugin%20%E8%AF%A6%E8%A7%A3/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Maven 教程之 plugin 详解">Maven 教程之 plugin 详解</span>
            <span class="post-date" title="2024-09-25 11:32:44">2024/09/25</span>
        </a>
        
        
        <a  class="全部文章 开发工具 Maven "
           href="/2024/09/21/6%E3%80%81%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Maven/Maven%20%E6%95%99%E7%A8%8B%E4%B9%8B%20pom.xml%20%E8%AF%A6%E8%A7%A3/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Maven 教程之 pom.xml 详解">Maven 教程之 pom.xml 详解</span>
            <span class="post-date" title="2024-09-21 16:14:13">2024/09/21</span>
        </a>
        
        
        <a  class="全部文章 开发工具 Maven "
           href="/2024/09/21/6%E3%80%81%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Maven/Maven%20%E6%95%99%E7%A8%8B%E4%B9%8B%20settings.xml%20%E8%AF%A6%E8%A7%A3/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Maven 教程之 settings.xml 详解">Maven 教程之 settings.xml 详解</span>
            <span class="post-date" title="2024-09-21 16:14:09">2024/09/21</span>
        </a>
        
        
        <a  class="全部文章 _posts 面试篇 "
           href="/2024/08/27/0%E3%80%81%E9%9D%A2%E8%AF%95%E7%AF%87/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8%E6%B1%87%E6%80%BB/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="面试宝典汇总">面试宝典汇总</span>
            <span class="post-date" title="2024-08-27 16:20:25">2024/08/27</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/2024/08/26/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E8%87%AA%E5%AE%9A%E4%B9%89%E9%9B%86%E5%90%88%E5%B8%B8%E9%87%8F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 自定义集合常量">Java 自定义集合常量</span>
            <span class="post-date" title="2024-08-26 12:11:54">2024/08/26</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringMVC "
           href="/2024/08/26/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20MVC/SpringMVC%E4%B9%8B@InitBinder%E6%B3%A8%E8%A7%A3%EF%BC%88%E6%97%A5%E6%9C%9F%E8%BD%AC%E6%8D%A2%EF%BC%89/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringMVC之@InitBinder注解（日期转换）">SpringMVC之@InitBinder注解（日期转换）</span>
            <span class="post-date" title="2024-08-26 11:10:28">2024/08/26</span>
        </a>
        
        
        <a  class="全部文章 SpringTransaction 多线程下事务处理 "
           href="/2024/08/21/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Transaction/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8B%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/Java%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BA%8B%E5%8A%A1%E6%8F%90%E4%BA%A4%E7%9A%84%E5%A4%84%E7%90%86/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 多线程事务提交的处理">Java 多线程事务提交的处理</span>
            <span class="post-date" title="2024-08-21 16:32:52">2024/08/21</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2024/08/20/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%20Cache%20%E6%95%B4%E5%90%88%20Redis%20%E7%BC%93%E5%AD%98%E6%A1%86%E6%9E%B6/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot Cache 整合 Redis 缓存框架">SpringBoot Cache 整合 Redis 缓存框架</span>
            <span class="post-date" title="2024-08-20 16:11:47">2024/08/20</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringTransaction "
           href="/2024/08/16/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Transaction/Spring%20%E4%BA%8B%E5%8A%A1%E5%BA%94%E7%94%A8%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Spring 事务应用及源码分析">Spring 事务应用及源码分析</span>
            <span class="post-date" title="2024-08-16 10:33:57">2024/08/16</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringTransaction "
           href="/2024/08/16/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Transaction/Spring%20JDBC%20-%20NamedParameterJdbcTemplate/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Spring JDBC - NamedParameterJdbcTemplate">Spring JDBC - NamedParameterJdbcTemplate</span>
            <span class="post-date" title="2024-08-16 00:18:18">2024/08/16</span>
        </a>
        
        
        <a  class="全部文章 _posts 开发工具 "
           href="/2024/07/18/6%E3%80%81%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Git%20&%20GitHub/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Git &amp; GitHub">Git &amp; GitHub</span>
            <span class="post-date" title="2024-07-18 10:34:58">2024/07/18</span>
        </a>
        
        
        <a  class="全部文章 开发工具 Maven "
           href="/2024/06/28/6%E3%80%81%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Maven/Maven%20%E5%AE%9E%E6%88%98/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Maven 实战">Maven 实战</span>
            <span class="post-date" title="2024-06-28 16:50:35">2024/06/28</span>
        </a>
        
        
        <a  class="全部文章 _posts 数据库 "
           href="/2024/06/26/3%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%9D%A2%E8%AF%95%E5%AE%98%EF%BC%9A%E4%B8%8D%E4%BC%9A%E7%9C%8B%20Explain%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%EF%BC%8C%E7%AE%80%E5%8E%86%E6%95%A2%E5%86%99%20SQL%20%E4%BC%98%E5%8C%96%EF%BC%9F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="面试官：不会看 Explain执行计划，简历敢写 SQL 优化？">面试官：不会看 Explain执行计划，简历敢写 SQL 优化？</span>
            <span class="post-date" title="2024-06-26 19:33:03">2024/06/26</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/2024/04/22/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%AF%87%E4%B9%8B%20IDEA%20-%20VM%20Options%E3%80%81Program%20Arguments%E3%80%81Environment%20Variable%20%E8%A7%A3%E6%9E%90/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 命令行篇之 IDEA - VM Options、Program Arguments、Environment Variable 解析">Java 命令行篇之 IDEA - VM Options、Program Arguments、Environment Variable 解析</span>
            <span class="post-date" title="2024-04-22 10:53:10">2024/04/22</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2024/04/19/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6-%E9%85%8D%E7%BD%AE%E5%A4%96%E9%83%A8%E5%8C%96/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 配置文件-配置外部化">SpringBoot 2.x 配置文件-配置外部化</span>
            <span class="post-date" title="2024-04-19 09:18:55">2024/04/19</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/2024/04/16/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E5%8E%9F%E7%90%86%E7%AF%87%E4%B9%8B%20SPI%20%E6%9C%BA%E5%88%B6/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 原理篇之 SPI 机制">Java 原理篇之 SPI 机制</span>
            <span class="post-date" title="2024-04-16 17:26:15">2024/04/16</span>
        </a>
        
        
        <a  class="全部文章 开发工具 Maven "
           href="/2024/01/14/6%E3%80%81%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Maven/Maven%20%E6%95%99%E7%A8%8B%E4%B9%8B%20mirror%20&%20repository%20%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Maven 教程之 mirror &amp; repository 配置详解">Maven 教程之 mirror &amp; repository 配置详解</span>
            <span class="post-date" title="2024-01-14 22:51:03">2024/01/14</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2023/12/07/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E4%B8%BA%E4%BB%80%E4%B9%88SpringBoot%20jar%20%E5%8F%AF%E4%BB%A5%E7%9B%B4%E6%8E%A5%E8%BF%90%E8%A1%8C/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 为什么SpringBoot jar 可以直接运行">SpringBoot 2.x 为什么SpringBoot jar 可以直接运行</span>
            <span class="post-date" title="2023-12-07 15:13:56">2023/12/07</span>
        </a>
        
        
        <a  class="全部文章 Java基础篇 Java多线程 "
           href="/2023/12/04/1%E3%80%81JavaSE/1.Java%20%E5%9F%BA%E7%A1%80%E7%AF%87/5%E3%80%81Java%20%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%BF%9B%E9%98%B6/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 多线程进阶">Java 多线程进阶</span>
            <span class="post-date" title="2023-12-04 16:37:09">2023/12/04</span>
        </a>
        
        
        <a  class="全部文章 _posts 数据库 "
           href="/2023/11/18/3%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BB%BA%E6%A8%A1%E5%B7%A5%E5%85%B7%E6%B1%87%E6%80%BB/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="数据库建模工具汇总">数据库建模工具汇总</span>
            <span class="post-date" title="2023-11-18 15:31:11">2023/11/18</span>
        </a>
        
        
        <a  class="全部文章 JavaEE SSM框架 "
           href="/2023/10/08/2%E3%80%81JavaEE/2%E3%80%81SSM%E6%A1%86%E6%9E%B6/Mybatis/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Mybatis">Mybatis</span>
            <span class="post-date" title="2023-10-08 19:45:47">2023/10/08</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java性能测试与安全 "
           href="/2023/08/28/1%E3%80%81JavaSE/5.Java%20%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E4%B8%8E%E5%AE%89%E5%85%A8/Java%20%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E7%AF%87%E4%B9%8B%20%E5%8E%8B%E6%B5%8B%E5%B7%A5%E5%85%B7%E6%B1%87%E6%80%BB/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 性能测试篇之 压测工具汇总">Java 性能测试篇之 压测工具汇总</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java性能测试与安全 "
           href="/2023/08/28/1%E3%80%81JavaSE/5.Java%20%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E4%B8%8E%E5%AE%89%E5%85%A8/Java%20%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E7%AF%87%E4%B9%8B%20%E9%AB%98%E5%B9%B6%E5%8F%91%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87%EF%BC%9AQPS%E3%80%81TPS%E3%80%81RT%E3%80%81%E5%B9%B6%E5%8F%91%E6%95%B0%E3%80%81%E5%90%9E%E5%90%90%E9%87%8F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 性能测试篇之 高并发性能指标：QPS、TPS、RT、并发数、吞吐量">Java 性能测试篇之 高并发性能指标：QPS、TPS、RT、并发数、吞吐量</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java性能测试与安全 "
           href="/2023/08/28/1%E3%80%81JavaSE/5.Java%20%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E4%B8%8E%E5%AE%89%E5%85%A8/Java%20%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E7%AF%87%E4%B9%8B%20JMH%20%E5%B7%A5%E5%85%B7%E7%B1%BB/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 性能测试篇之 JMH 工具类">Java 性能测试篇之 JMH 工具类</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java性能测试与安全 "
           href="/2023/08/28/1%E3%80%81JavaSE/5.Java%20%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E4%B8%8E%E5%AE%89%E5%85%A8/Java%20%E5%AE%89%E5%85%A8%E7%AF%87%E4%B9%8B%20API%20%E6%8E%A5%E5%8F%A3%E9%98%B2%E6%AD%A2%E5%8F%82%E6%95%B0%E7%AF%A1%E6%94%B9%E5%92%8C%E9%87%8D%E6%94%BE%E6%94%BB%E5%87%BB/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 安全篇之 API 接口防止参数篡改和重放攻击">Java 安全篇之 API 接口防止参数篡改和重放攻击</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java性能测试与安全 "
           href="/2023/08/28/1%E3%80%81JavaSE/5.Java%20%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E4%B8%8E%E5%AE%89%E5%85%A8/Java%20%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E7%AF%87%E4%B9%8B%2048%E5%BC%A0%E5%9B%BE%E5%AD%A6%E4%BC%9A%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E3%80%81%E5%8E%8B%E6%B5%8B%E5%92%8C%E8%B0%83%E4%BC%98/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 性能测试篇之 48张图学会性能监控、压测和调优">Java 性能测试篇之 48张图学会性能监控、压测和调优</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 _posts 开发工具 "
           href="/2023/08/28/6%E3%80%81%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/IDEA%20%E5%BF%AB%E6%8D%B7%E9%94%AE/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="IDEA 快捷键">IDEA 快捷键</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 _posts 开发工具 "
           href="/2023/08/28/6%E3%80%81%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/IDEA%20%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="IDEA 基本使用">IDEA 基本使用</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 _posts 开发工具 "
           href="/2023/08/28/6%E3%80%81%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/IDEA%20%E6%8F%92%E4%BB%B6%E5%AE%89%E8%A3%85/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="IDEA 插件安装">IDEA 插件安装</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 _posts 开发工具 "
           href="/2023/08/28/6%E3%80%81%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/PostMan%20%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="PostMan 工具的使用">PostMan 工具的使用</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 _posts 开发工具 "
           href="/2023/08/28/6%E3%80%81%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Git/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Git">Git</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E4%BC%98%E5%8C%96%E7%AF%87%E4%B9%8B%20%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3%20%E6%A0%A1%E9%AA%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 优化篇之 自定义注解 校验数据库表中的数据不可重复">Java 优化篇之 自定义注解 校验数据库表中的数据不可重复</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E5%B7%A5%E5%85%B7%E7%AF%87%E4%B9%8B%20API%20%E6%8E%A5%E5%8F%A3%E5%85%8D%E8%B4%B9%20JSONPlaceholder/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 工具篇之 API 接口免费 JSONPlaceholder">Java 工具篇之 API 接口免费 JSONPlaceholder</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E5%B7%A5%E5%85%B7%E7%AF%87%E4%B9%8B%20%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E7%BB%9F%E8%AE%A1%E4%BB%A3%E7%A0%81%E8%80%97%E6%97%B6/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 工具篇之 如何优雅的统计代码耗时">Java 工具篇之 如何优雅的统计代码耗时</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B9%8B%20%E4%B8%8D%E5%8F%AF%E4%B8%8D%E7%9F%A5%E7%9A%84%207%20%E4%B8%AA%20JDK%20%E5%91%BD%E4%BB%A4/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 命令行之 不可不知的 7 个 JDK 命令">Java 命令行之 不可不知的 7 个 JDK 命令</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%AF%87%E4%B9%8B%20Window%20%E5%90%8E%E5%8F%B0%E5%90%AF%E5%8A%A8%20JAR%20%E7%A8%8B%E5%BA%8F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 命令行篇之 Window 后台启动 JAR 程序">Java 命令行篇之 Window 后台启动 JAR 程序</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E5%B7%A5%E5%85%B7%E7%AF%87%E4%B9%8B%20Lombok/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 工具篇之 Lombok">Java 工具篇之 Lombok</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E5%B7%A5%E5%85%B7%E7%AF%87%E4%B9%8B%20API%20%E6%96%87%E6%A1%A3%E5%B7%A5%E5%85%B7%20Swagger3.x-2.x/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 工具篇之 API 文档工具 Swagger3.x-2.x">Java 工具篇之 API 文档工具 Swagger3.x-2.x</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E5%B7%A5%E5%85%B7%E7%AF%87%E4%B9%8B%20%E6%8E%8C%E6%8F%A114%E7%A7%8DUML%E5%9B%BE/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 工具篇之 掌握14种UML图">Java 工具篇之 掌握14种UML图</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E5%B7%A5%E5%85%B7%E7%B1%BB%E4%B9%8B%20%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B7%A5%E5%85%B7%E7%B1%BB/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 工具类之 自定义工具类">Java 工具类之 自定义工具类</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20Bean%20%E4%B9%8B%20DTO%E3%80%81VO%E3%80%81PO%E3%80%81DO%E3%80%81BO%20%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java Bean 之 DTO、VO、PO、DO、BO 类的区别">Java Bean 之 DTO、VO、PO、DO、BO 类的区别</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20JSON%20%E7%AF%87%E4%B9%8B%20Jackson/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java JSON 篇之 Jackson">Java JSON 篇之 Jackson</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20JSON%20%E7%AF%87%E4%B9%8B%20Gson/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java JSON 篇之 Gson">Java JSON 篇之 Gson</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Curl%20%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%91%BD%E4%BB%A4%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Curl 的使用及命令参数说明">Curl 的使用及命令参数说明</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20JSON%20%E7%AF%87%E4%B9%8B%20FastJson/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java JSON 篇之 FastJson">Java JSON 篇之 FastJson</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Redis backup "
           href="/2023/08/28/5%E3%80%81%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/backup/Redis6/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Redis6">Redis6</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 中间件 Redis "
           href="/2023/08/28/5%E3%80%81%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/Redis-%E6%9C%80%E5%85%A8%E5%AE%9E%E6%88%98/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Redis-最全实战">Redis-最全实战</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 中间件 Redis "
           href="/2023/08/28/5%E3%80%81%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/Redis-%E4%BB%A3%E7%A0%81%E5%AE%9E%E6%88%98/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Redis-代码实战">Redis-代码实战</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 中间件 RabbitMQ "
           href="/2023/08/28/5%E3%80%81%E4%B8%AD%E9%97%B4%E4%BB%B6/RabbitMQ/RabbitMQ-3.8.14/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="RabbitMQ-3.8.14">RabbitMQ-3.8.14</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 中间件 RabbitMQ "
           href="/2023/08/28/5%E3%80%81%E4%B8%AD%E9%97%B4%E4%BB%B6/RabbitMQ/RabbitMQ-3.7.x/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="RabbitMQ-3.7.x">RabbitMQ-3.7.x</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 中间件 RabbitMQ "
           href="/2023/08/28/5%E3%80%81%E4%B8%AD%E9%97%B4%E4%BB%B6/RabbitMQ/RabbitMQ-3.8.14-%E5%8D%9A%E5%AE%A2%E7%89%88/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="RabbitMQ-3.8.14-博客版">RabbitMQ-3.8.14-博客版</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 中间件 MongoDB "
           href="/2023/08/28/5%E3%80%81%E4%B8%AD%E9%97%B4%E4%BB%B6/MongoDB/MongDB-4.4.2/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="MongDB-4.4.2">MongDB-4.4.2</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 中间件 MongoDB "
           href="/2023/08/28/5%E3%80%81%E4%B8%AD%E9%97%B4%E4%BB%B6/MongoDB/MongDB-4.4.2-%E5%8D%9A%E5%AE%A2%E7%89%88/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="MongDB-4.4.2-博客版">MongDB-4.4.2-博客版</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 中间件 ElasticSearch "
           href="/2023/08/28/5%E3%80%81%E4%B8%AD%E9%97%B4%E4%BB%B6/ElasticSearch/ElasticSearch7.6.x%E5%AE%9E%E6%88%98/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="ElasticSearch7.6.x实战">ElasticSearch7.6.x实战</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Linux 虚拟机工具 "
           href="/2023/08/28/4%E3%80%81Linux/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%B7%A5%E5%85%B7/Virtualbox%E7%BD%91%E7%BB%9C%E8%AE%BE%E7%BD%AE%E6%88%96%E9%85%8D%E7%BD%AE/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Virtualbox网络设置或配置">Virtualbox网络设置或配置</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Linux 虚拟机工具 "
           href="/2023/08/28/4%E3%80%81Linux/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%B7%A5%E5%85%B7/Virtualbox%E5%AE%89%E8%A3%85Centos7%E5%AE%9E%E6%88%98/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Virtualbox安装Centos7实战">Virtualbox安装Centos7实战</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Linux Kubernetes "
           href="/2023/08/28/4%E3%80%81Linux/Kubernetes/Minikube-k8s/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Minikube-k8s">Minikube-k8s</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Linux Kubernetes "
           href="/2023/08/28/4%E3%80%81Linux/Kubernetes/k0s%20%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B%EF%BC%9A%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%20Kubernetes%20%E9%9B%86%E7%BE%A4/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="k0s 使用教程：如何快速搭建 Kubernetes 集群">k0s 使用教程：如何快速搭建 Kubernetes 集群</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Linux Nginx "
           href="/2023/08/28/4%E3%80%81Linux/Nginx/Nginx-1.8.0/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Nginx-1.8.0">Nginx-1.8.0</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Linux Docker "
           href="/2023/08/28/4%E3%80%81Linux/Docker/Docker%E5%88%9D%E7%BA%A7%E5%88%B0%E5%AE%9E%E6%88%98/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Docker初级到实战">Docker初级到实战</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Linux Docker "
           href="/2023/08/28/4%E3%80%81Linux/Docker/Docker&Docker-Compose%E5%AE%9E%E6%88%98-%E5%93%88%E5%96%BD%E6%B2%83%E5%BE%B7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Docker&amp;Docker-Compose实战-哈喽沃德">Docker&amp;Docker-Compose实战-哈喽沃德</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 Spring "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring/Spring%20Bean%20%E7%9A%84%E5%8A%A8%E6%80%81%E5%88%9B%E5%BB%BA%E8%8E%B7%E5%8F%96%E5%88%A0%E9%99%A4/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Spring Bean 的动态创建获取删除">Spring Bean 的动态创建获取删除</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 Spring "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring/Spring%20Bean%20%E7%9A%8412%E7%A7%8D%E5%AE%9A%E4%B9%89%E6%96%B9%E6%B3%95/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Spring Bean 的12种定义方法">Spring Bean 的12种定义方法</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 Spring "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring/Spring%20Bean%20%E6%B3%A8%E5%85%A5%E7%9A%843%E7%A7%8D%E6%96%B9%E5%BC%8F,%20%E4%B8%BA%E4%BD%95%E5%AE%98%E6%96%B9%E5%BB%BA%E8%AE%AE%E4%BD%BF%E7%94%A8%E6%9E%84%E9%80%A0%E5%99%A8%E6%B3%A8%E5%85%A5/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Spring Bean 注入的3种方式, 为何官方建议使用构造器注入">Spring Bean 注入的3种方式, 为何官方建议使用构造器注入</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 SpringTransaction 多数据源事务处理 "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Transaction/%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/Spring%20%E5%AE%9E%E7%8E%B0%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E5%AE%9E%E6%88%98/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Spring 实现多数据源实战">Spring 实现多数据源实战</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 SpringTransaction 多数据源事务处理 "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Transaction/%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/Spring%20%E8%A7%A3%E5%86%B3%E5%8D%95%E6%9C%BA%E7%8E%AF%E5%A2%83%E4%B8%8B%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E7%9A%84%E4%BA%8B%E5%8A%A1%E9%97%AE%E9%A2%98/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Spring 解决单机环境下多数据源的事务问题">Spring 解决单机环境下多数据源的事务问题</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 SpringTransaction 多数据源事务处理 "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Transaction/%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/Spring%20%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81%E6%95%B0%E6%8D%AE%E6%BA%90%E3%80%81%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E5%88%87%E6%8D%A2%E6%96%B9%E5%BC%8F%E3%80%81%E5%A4%9A%E6%95%B0%E6%8D%AE%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Spring 实现动态数据源、多数据源切换方式、多数据事务管理">Spring 实现动态数据源、多数据源切换方式、多数据事务管理</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringTransaction "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Transaction/Spring%20%E4%BA%8B%E5%8A%A1%E5%8E%9F%E7%90%86%E6%B7%B1%E5%85%A5%E4%B8%8E%E5%88%86%E6%9E%90/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Spring 事务原理深入与分析">Spring 事务原理深入与分析</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringSecurity "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Security/SpringSecurity/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringSecurity">SpringSecurity</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringTransaction "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Transaction/JDBC/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="JDBC">JDBC</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringTransaction "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Transaction/Spring%20JDBC%20-%20JdbcTemplate/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Spring JDBC - JdbcTemplate">Spring JDBC - JdbcTemplate</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 SpringTransaction 多线程下事务处理 "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Transaction/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8B%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/JDBC%E6%89%B9%E5%A4%84%E7%90%86%E5%AE%9E%E7%8E%B0%E6%89%8B%E5%8A%A8%E4%BA%8B%E5%8A%A1%E6%8F%92%E5%85%A51000%E4%B8%87%E6%95%B0%E6%8D%AE%EF%BC%88%E5%8D%95%E7%BA%BF%E7%A8%8B%20&%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%89/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="JDBC批处理实现手动事务插入1000万数据（单线程 &amp; 多线程）">JDBC批处理实现手动事务插入1000万数据（单线程 &amp; 多线程）</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringDataJPA "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Data%20JPA/SpringData%20JPA%20%E7%B1%BB%E5%9B%BE%E5%8F%8A%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringData JPA 类图及使用方法整理">SpringData JPA 类图及使用方法整理</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringDataJPA "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Data%20JPA/SpringData%20JPA/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringData JPA">SpringData JPA</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringDataJPA "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Data%20JPA/Spring%20Data%20JPA%20%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E6%88%98/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Spring Data JPA 原理与实战">Spring Data JPA 原理与实战</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringDataJPA "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Data%20JPA/Hibernata%20JPA/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Hibernata JPA">Hibernata JPA</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringCloudAlibaba "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Cloud%20Alibaba/SpringCloud%20Alibaba/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringCloud Alibaba">SpringCloud Alibaba</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot2.x%20%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AF%87%20-%20%E6%95%B4%E5%90%88H2%E6%95%B0%E6%8D%AE%E5%BA%93/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot2.x 数据库篇 - 整合H2数据库">SpringBoot2.x 数据库篇 - 整合H2数据库</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot2.x%20%E9%A1%B9%E7%9B%AE%E7%BB%9F%E4%B8%80%E6%9E%9A%E4%B8%BE%E8%BD%AC%E6%8D%A2%E5%AE%9E%E8%B7%B5/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot2.x 项目统一枚举转换实践">SpringBoot2.x 项目统一枚举转换实践</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AD%A6/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot从零开始学">SpringBoot从零开始学</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%E9%85%8D%E7%BD%AE%E5%B1%9E%E6%80%A7%E4%B9%8BDataSource/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot配置属性之DataSource">SpringBoot配置属性之DataSource</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SprinigBoot%E6%96%87%E7%AB%A0%E6%91%98%E8%A6%81%E5%8F%8A%E8%BD%AC%E8%BD%BD/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SprinigBoot文章摘要及转载">SprinigBoot文章摘要及转载</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/%E4%BB%A3%E7%A0%81%E5%AE%A1%E6%9F%A5%E7%9A%84%E5%BF%85%E8%A6%81%E6%80%A7%E5%92%8C%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="代码审查的必要性和最佳实践">代码审查的必要性和最佳实践</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6-%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%B9%8B@Value%E8%BF%9B%E9%98%B6/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 配置文件-读取配置文件之@Value进阶">SpringBoot 2.x 配置文件-读取配置文件之@Value进阶</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6-%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9A%84N%E7%A7%8D%E6%96%B9%E5%BC%8F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 配置文件-读取配置文件的N种方式">SpringBoot 2.x 配置文件-读取配置文件的N种方式</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E7%BB%9F%E4%B8%80%E6%8E%A5%E5%8F%A3%E8%BF%94%E5%9B%9E%E6%A0%BC%E5%BC%8F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 统一接口返回格式">SpringBoot 2.x 统一接口返回格式</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6-%E8%AF%BB%E5%8F%96%20Resources%20%E6%96%87%E4%BB%B6%E4%B9%8B%E6%97%A0%E6%B3%95%E8%AF%BB%E5%8F%96Jar%E5%8C%85classpath%E4%B8%8B%E7%9A%84%E6%96%87%E4%BB%B6/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 配置文件-读取 Resources 文件之无法读取Jar包classpath下的文件">SpringBoot 2.x 配置文件-读取 Resources 文件之无法读取Jar包classpath下的文件</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6-%E8%AF%BB%E5%8F%96%20Resources%20%E6%96%87%E4%BB%B6%E7%9A%84N%E7%A7%8D%E6%96%B9%E5%BC%8F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 配置文件-读取 Resources 文件的N种方式">SpringBoot 2.x 配置文件-读取 Resources 文件的N种方式</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B%E7%AF%87-%E6%8B%A6%E6%88%AA%E5%99%A8%E8%BF%87%E6%BB%A4%E5%99%A8%E4%B8%8E%E7%9B%91%E5%90%AC%E5%99%A8/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 切面编程篇-拦截器过滤器与监听器">SpringBoot 2.x 切面编程篇-拦截器过滤器与监听器</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E5%AE%89%E5%85%A8%E5%AF%86%E7%A0%81%E5%AD%A6%E4%B9%8B%E5%8A%A0%E8%A7%A3%E5%AF%86%E7%AE%97%E6%B3%95/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 安全密码学之加解密算法">SpringBoot 2.x 安全密码学之加解密算法</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3%E5%A4%A7%E5%85%A8/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 常用注解大全">SpringBoot 2.x 常用注解大全</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3%E8%AF%A6%E8%A7%A3/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 常用注解详解">SpringBoot 2.x 常用注解详解</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E5%90%AF%E5%8A%A8%E6%97%B6%E5%8A%A0%E8%BD%BD%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84N%E7%A7%8D%E6%96%B9%E5%BC%8F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 启动时加载初始化的N种方式">SpringBoot 2.x 启动时加载初始化的N种方式</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%8F%8A%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E8%BF%87%E7%A8%8B/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 启动流程及自动装配过程">SpringBoot 2.x 启动流程及自动装配过程</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E5%8A%A8%E6%80%81%E8%A3%85%E9%85%8DBean%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 动态装配Bean的三种方式">SpringBoot 2.x 动态装配Bean的三种方式</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E5%88%A9%E5%99%A8-1%20JUnit5/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 单元测试利器-1 JUnit5">SpringBoot 2.x 单元测试利器-1 JUnit5</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E5%88%A9%E5%99%A8-3%20MockMvc/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 单元测试利器-3 MockMvc">SpringBoot 2.x 单元测试利器-3 MockMvc</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E5%88%A9%E5%99%A8-2%20Mockito/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 单元测试利器-2 Mockito">SpringBoot 2.x 单元测试利器-2 Mockito</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E5%88%86%E7%89%87%E4%B8%8A%E4%BC%A0%E3%80%81%E6%96%AD%E7%82%B9%E7%BB%AD%E4%BC%A0%E3%80%81%E5%A4%A7%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E3%80%81%E7%A7%92%E4%BC%A0/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 分片上传、断点续传、大文件上传、秒传">SpringBoot 2.x 分片上传、断点续传、大文件上传、秒传</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20Validation%20%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C%EF%BC%88TODO%EF%BC%89/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x Validation 参数校验（TODO）">SpringBoot 2.x Validation 参数校验（TODO）</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20WebMvcConfigurer%20%E8%AF%A6%E8%A7%A3%E3%80%90SpringMVC%E3%80%91/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x WebMvcConfigurer 详解【SpringMVC】">SpringBoot 2.x WebMvcConfigurer 详解【SpringMVC】</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20YML%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x YML配置文件详解">SpringBoot 2.x YML配置文件详解</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E5%88%86%E5%B8%83%E5%BC%8F%E5%85%A8%E5%B1%80%E5%94%AF%E4%B8%80ID%E7%94%9F%E6%88%90%E6%96%B9%E6%A1%88/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 分布式全局唯一ID生成方案">SpringBoot 2.x 分布式全局唯一ID生成方案</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20JWT%20%E6%A6%82%E5%BF%B5%E7%AF%87/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x JWT 概念篇">SpringBoot 2.x JWT 概念篇</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20Jar%20%E5%8C%85%E5%90%AF%E5%8A%A8%E3%80%81%E5%81%9C%E6%AD%A2%E3%80%81%E9%87%8D%E5%90%AF%E8%84%9A%E6%9C%AC/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x Jar 包启动、停止、重启脚本">SpringBoot 2.x Jar 包启动、停止、重启脚本</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20Java%20%E5%AE%9E%E7%8E%B0%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E7%9A%848%E7%A7%8D%E6%96%B9%E5%BC%8F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x Java 实现异步编程的8种方式">SpringBoot 2.x Java 实现异步编程的8种方式</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20Java%20%E7%A8%8B%E5%BA%8F%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0%E6%80%BB%E7%BB%93/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x Java 程序命令行参数总结">SpringBoot 2.x Java 程序命令行参数总结</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20@ConfigurationProperties%E4%BB%A5%E5%8F%8A@NestedConfigurationProperty%E7%9A%84%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x @ConfigurationProperties以及@NestedConfigurationProperty的使用详解">SpringBoot 2.x @ConfigurationProperties以及@NestedConfigurationProperty的使用详解</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20@ControllerAdvice%E4%B8%89%E7%A7%8D%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x @ControllerAdvice三种使用场景">SpringBoot 2.x @ControllerAdvice三种使用场景</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20HTTP%20Content-Type%20%E8%AF%A6%E8%A7%A3/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x HTTP Content-Type 详解">SpringBoot 2.x HTTP Content-Type 详解</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20HTTP%20Headers%20%E5%A4%B4%E4%BF%A1%E6%81%AF%E8%AF%BB%E5%8F%96/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x HTTP Headers 头信息读取">SpringBoot 2.x HTTP Headers 头信息读取</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20JWT%20%E5%AE%9E%E6%88%98%E7%AF%87/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x JWT 实战篇">SpringBoot 2.x JWT 实战篇</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%20%E6%8E%A5%E5%8F%A3%E5%B9%82%E7%AD%89%E6%80%A7%E5%AE%9E%E7%8E%B0/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x  接口幂等性实现">SpringBoot 2.x  接口幂等性实现</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/Spring%20IO%20Platform%EF%BC%9A%E8%A7%A3%E5%86%B3%E4%BE%9D%E8%B5%96%E7%89%88%E6%9C%AC%E5%86%B2%E7%AA%81/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Spring IO Platform：解决依赖版本冲突">Spring IO Platform：解决依赖版本冲突</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B%E7%AF%87-AOP%20%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%8E%9F%E7%90%86/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 切面编程篇-AOP 的使用及原理">SpringBoot 2.x 切面编程篇-AOP 的使用及原理</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE SSM框架 "
           href="/2023/08/28/2%E3%80%81JavaEE/2%E3%80%81SSM%E6%A1%86%E6%9E%B6/SpringMVC/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringMVC">SpringMVC</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 Shiro "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Shiro/Shiro%E6%9D%83%E9%99%90%E5%AE%9E%E6%88%98%E8%AF%BE%E7%A8%8B/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Shiro权限实战课程">Shiro权限实战课程</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 Shiro "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Shiro/Shiro%E6%9D%83%E9%99%90%E5%AE%9E%E6%88%98/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Shiro权限实战">Shiro权限实战</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE SSM框架 "
           href="/2023/08/28/2%E3%80%81JavaEE/2%E3%80%81SSM%E6%A1%86%E6%9E%B6/Spring/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Spring">Spring</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE SSM框架 "
           href="/2023/08/28/2%E3%80%81JavaEE/2%E3%80%81SSM%E6%A1%86%E6%9E%B6/MybatisPlus/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="MybatisPlus">MybatisPlus</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE JavaWeb "
           href="/2023/08/28/2%E3%80%81JavaEE/1%E3%80%81JavaWeb/%E4%BD%A0%E8%BF%98%E5%9C%A8%E4%B8%BA%20HTTP%20%E7%9A%84%E8%BF%99%E4%BA%9B%E6%A6%82%E5%BF%B5%E5%A4%B4%E7%96%BC%E5%90%97/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="你还在为 HTTP 的这些概念头疼吗">你还在为 HTTP 的这些概念头疼吗</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE JavaWeb "
           href="/2023/08/28/2%E3%80%81JavaEE/1%E3%80%81JavaWeb/Cookie%E3%80%81Session%E3%80%81Token%E3%80%81JWT%E7%BB%88%E4%BA%8E%E8%AE%B2%E6%B8%85%E6%A5%9A%E4%BA%86/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Cookie、Session、Token、JWT终于讲清楚了">Cookie、Session、Token、JWT终于讲清楚了</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 _posts 数据库 "
           href="/2023/08/28/3%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL-%E9%AB%98%E7%BA%A7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="MySQL-高级">MySQL-高级</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 _posts 数据库 "
           href="/2023/08/28/3%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL-%E5%88%9D%E7%BA%A7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="MySQL-初级">MySQL-初级</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 _posts 数据库 "
           href="/2023/08/28/3%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93/H2%20Database/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="H2 Database">H2 Database</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E4%BC%98%E5%8C%96%E7%AF%87%E4%B9%8B%20%E6%B3%A8%E8%A7%A3%20+%20%E5%8F%8D%E5%B0%84%E6%B6%88%E9%99%A4%E9%87%8D%E5%A4%8D%E4%BB%A3%E7%A0%81/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 优化篇之 注解 + 反射消除重复代码">Java 优化篇之 注解 + 反射消除重复代码</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E4%BC%98%E5%8C%96%E7%AF%87%E4%B9%8B%20%E5%BB%B6%E6%97%B6%E9%98%9F%E5%88%97%20-%20%E8%AE%A2%E5%8D%95%E8%B6%85%E6%97%B6%E8%87%AA%E5%8A%A8%E5%8F%96%E6%B6%88%E7%9A%84N%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 优化篇之 延时队列 - 订单超时自动取消的N种实现方式">Java 优化篇之 延时队列 - 订单超时自动取消的N种实现方式</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E9%9B%86%E5%90%88%E7%AF%87%E4%B9%8B%20%E8%8E%B7%E5%8F%96%E4%B8%A4%E4%B8%AA%E9%9B%86%E5%90%88List%E7%9A%84%E4%BA%A4%E9%9B%86%E3%80%81%E8%A1%A5%E9%9B%86%E3%80%81%E5%B9%B6%E9%9B%86%E3%80%81%E5%B7%AE%E9%9B%86%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 集合篇之 获取两个集合List的交集、补集、并集、差集的几种方式">Java 集合篇之 获取两个集合List的交集、补集、并集、差集的几种方式</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E4%BC%98%E5%8C%96%E7%AF%87%E4%B9%8B%20if-else%20%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 优化篇之 if-else 代码优化方案">Java 优化篇之 if-else 代码优化方案</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E9%9B%86%E5%90%88%E7%AF%87%E4%B9%8B%20Lambda%20%E5%AE%9E%E7%8E%B0%E8%B6%85%E5%BC%BA%E6%8E%92%E5%BA%8F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 集合篇之 Lambda 实现超强排序">Java 集合篇之 Lambda 实现超强排序</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4%E5%90%84%E7%B1%BB%E5%9E%8B%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 日期时间各类型相互转换">Java 日期时间各类型相互转换</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 动态代理">Java 动态代理</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E5%9F%BA%E6%9C%AC%E5%8A%9F%E7%AF%87%E4%B9%8B%20for%E3%80%81for-each%E3%80%81forEach()%20%E7%9A%84%20break%E3%80%81continue%E3%80%81return/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 基本功篇之 for、for-each、forEach() 的 break、continue、return">Java 基本功篇之 for、for-each、forEach() 的 break、continue、return</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6%E8%AF%A6%E8%A7%A3/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 日志框架详解">Java 日志框架详解</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java新特性 "
           href="/2023/08/28/1%E3%80%81JavaSE/3.Java%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%20%E6%96%B0%E7%89%B9%E6%80%A7%E6%A6%82%E8%BF%B0%E5%8F%8A%E7%89%88%E6%9C%AC%E5%8F%91%E8%A1%8C%E5%8F%B2/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 新特性概述及版本发行史">Java 新特性概述及版本发行史</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20Bean%20%E4%B9%8B%20Record%20%E7%B1%BB/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java Bean 之 Record 类">Java Bean 之 Record 类</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E4%BC%98%E5%8C%96%E7%AF%87%E4%B9%8B%20GZIP%E5%8E%8B%E7%BC%A9%E5%AD%97%E7%AC%A6%E4%B8%B2/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 优化篇之 GZIP压缩字符串">Java 优化篇之 GZIP压缩字符串</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java进阶篇 JVM虚拟机 "
           href="/2023/08/28/1%E3%80%81JavaSE/2.Java%20%E8%BF%9B%E9%98%B6%E7%AF%87/JVM%20%E8%99%9A%E6%8B%9F%E6%9C%BA/Java%20GC%20%E6%80%BB%E7%BB%93/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java GC 总结">Java GC 总结</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java新特性 Java9新特性 "
           href="/2023/08/28/1%E3%80%81JavaSE/3.Java%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%209%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%209%20%E6%96%B0%E7%89%B9%E6%80%A7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 9 新特性">Java 9 新特性</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java新特性 Java8新特性 "
           href="/2023/08/28/1%E3%80%81JavaSE/3.Java%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%208%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%208%20%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8B%20Stream%20%E6%B5%81/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 8 新特性之 Stream 流">Java 8 新特性之 Stream 流</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java新特性 Java8新特性 "
           href="/2023/08/28/1%E3%80%81JavaSE/3.Java%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%208%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%208%20%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8B%20Optional%20%E7%B1%BB/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 8 新特性之 Optional 类">Java 8 新特性之 Optional 类</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java新特性 Java8新特性 "
           href="/2023/08/28/1%E3%80%81JavaSE/3.Java%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%208%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%208%20%E6%96%B0%E7%89%B9%E6%80%A7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 8 新特性">Java 8 新特性</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java新特性 Java8新特性 "
           href="/2023/08/28/1%E3%80%81JavaSE/3.Java%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%208%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%208%20%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8B%20DateTime%20API/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 8 新特性之 DateTime API">Java 8 新特性之 DateTime API</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java新特性 Java18新特性 "
           href="/2023/08/28/1%E3%80%81JavaSE/3.Java%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2018%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2018%20%E6%96%B0%E7%89%B9%E6%80%A7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 18 新特性">Java 18 新特性</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java新特性 Java20新特性 "
           href="/2023/08/28/1%E3%80%81JavaSE/3.Java%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2020%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2020%20%E6%96%B0%E7%89%B9%E6%80%A7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 20 新特性">Java 20 新特性</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java新特性 Java19新特性 "
           href="/2023/08/28/1%E3%80%81JavaSE/3.Java%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2019%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2019%20%E6%96%B0%E7%89%B9%E6%80%A7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 19 新特性">Java 19 新特性</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java新特性 Java17新特性 "
           href="/2023/08/28/1%E3%80%81JavaSE/3.Java%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2017%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2017%20%E6%96%B0%E7%89%B9%E6%80%A7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 17 新特性">Java 17 新特性</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java新特性 Java15新特性 "
           href="/2023/08/28/1%E3%80%81JavaSE/3.Java%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2015%E6%96%B0%E7%89%B9%E6%80%A7/Java%2015%20%E6%96%B0%E7%89%B9%E6%80%A7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 15 新特性">Java 15 新特性</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java新特性 Java16新特性 "
           href="/2023/08/28/1%E3%80%81JavaSE/3.Java%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2016%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2016%20%E6%96%B0%E7%89%B9%E6%80%A7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 16 新特性">Java 16 新特性</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java新特性 Java13新特性 "
           href="/2023/08/28/1%E3%80%81JavaSE/3.Java%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2013%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2013%20%E6%96%B0%E7%89%B9%E6%80%A7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 13 新特性">Java 13 新特性</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java新特性 Java14新特性 "
           href="/2023/08/28/1%E3%80%81JavaSE/3.Java%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2014%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2014%20%E6%96%B0%E7%89%B9%E6%80%A7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 14 新特性">Java 14 新特性</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java新特性 Java10新特性 "
           href="/2023/08/28/1%E3%80%81JavaSE/3.Java%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2010%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2010%20%E6%96%B0%E7%89%B9%E6%80%A7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 10 新特性">Java 10 新特性</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java新特性 Java11新特性 "
           href="/2023/08/28/1%E3%80%81JavaSE/3.Java%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2011%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2011%20%E6%96%B0%E7%89%B9%E6%80%A7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 11 新特性">Java 11 新特性</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java新特性 Java12新特性 "
           href="/2023/08/28/1%E3%80%81JavaSE/3.Java%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2012%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2012%20%E6%96%B0%E7%89%B9%E6%80%A7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 12 新特性">Java 12 新特性</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java基础篇 Java基础语法 "
           href="/2023/08/28/1%E3%80%81JavaSE/1.Java%20%E5%9F%BA%E7%A1%80%E7%AF%87/1%E3%80%81Java%20%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/Java%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 面向对象编程">Java 面向对象编程</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java基础篇 Java集合类 "
           href="/2023/08/28/1%E3%80%81JavaSE/1.Java%20%E5%9F%BA%E7%A1%80%E7%AF%87/3%E3%80%81Java%20%E9%9B%86%E5%90%88%E7%B1%BB/Java%20%E7%B1%BB%E9%9B%86%E6%A1%86%E6%9E%B6/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 类集框架">Java 类集框架</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java基础篇 Java常用类库 "
           href="/2023/08/28/1%E3%80%81JavaSE/1.Java%20%E5%9F%BA%E7%A1%80%E7%AF%87/2%E3%80%81Java%20%E5%B8%B8%E7%94%A8%E7%B1%BB%E5%BA%93/Java%20%E5%B8%B8%E7%94%A8%E7%B1%BB%E5%BA%93/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 常用类库">Java 常用类库</span>
            <span class="post-date" title="2023-08-28 09:23:44">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java基础篇 Java多线程 "
           href="/2023/08/28/1%E3%80%81JavaSE/1.Java%20%E5%9F%BA%E7%A1%80%E7%AF%87/5%E3%80%81Java%20%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 多线程基础">Java 多线程基础</span>
            <span class="post-date" title="2023-08-28 09:23:44">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java基础篇 Java反射与注解 "
           href="/2023/08/28/1%E3%80%81JavaSE/1.Java%20%E5%9F%BA%E7%A1%80%E7%AF%87/4%E3%80%81Java%20%E5%8F%8D%E5%B0%84%E4%B8%8E%E6%B3%A8%E8%A7%A3/Java%20%E5%8F%8D%E5%B0%84%E4%B8%8E%E6%B3%A8%E8%A7%A3/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 反射与注解">Java 反射与注解</span>
            <span class="post-date" title="2023-08-28 09:23:44">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java基础篇 JavaNIO流 "
           href="/2023/08/28/1%E3%80%81JavaSE/1.Java%20%E5%9F%BA%E7%A1%80%E7%AF%87/7%E3%80%81Java%20NIO%20%E6%B5%81/Java%20NIO%20%E6%B5%81/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java NIO 流">Java NIO 流</span>
            <span class="post-date" title="2023-08-28 09:23:44">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java基础篇 JavaIO流 "
           href="/2023/08/28/1%E3%80%81JavaSE/1.Java%20%E5%9F%BA%E7%A1%80%E7%AF%87/6%E3%80%81Java%20IO%20%E6%B5%81/Java%20IO%20%E6%B5%81/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java IO 流">Java IO 流</span>
            <span class="post-date" title="2023-08-28 09:23:44">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java进阶篇 Java设计模式 "
           href="/2023/08/28/1%E3%80%81JavaSE/2.Java%20%E8%BF%9B%E9%98%B6%E7%AF%87/Java%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/Java%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 设计模式">Java 设计模式</span>
            <span class="post-date" title="2023-08-28 09:23:44">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java进阶篇 JVM虚拟机 "
           href="/2023/08/28/1%E3%80%81JavaSE/2.Java%20%E8%BF%9B%E9%98%B6%E7%AF%87/JVM%20%E8%99%9A%E6%8B%9F%E6%9C%BA/7%20%E6%AE%B5%E5%B0%8F%E4%BB%A3%E7%A0%81%EF%BC%8C%E7%8E%A9%E8%BD%ACJava%E7%A8%8B%E5%BA%8F%E5%B8%B8%E8%A7%81%E7%9A%84%E5%B4%A9%E6%BA%83%E5%9C%BA%E6%99%AF/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="7 段小代码，玩转Java程序常见的崩溃场景">7 段小代码，玩转Java程序常见的崩溃场景</span>
            <span class="post-date" title="2023-08-28 09:23:44">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java进阶篇 JVM虚拟机 "
           href="/2023/08/28/1%E3%80%81JavaSE/2.Java%20%E8%BF%9B%E9%98%B6%E7%AF%87/JVM%20%E8%99%9A%E6%8B%9F%E6%9C%BA/JVM%20%E8%99%9A%E6%8B%9F%E6%9C%BA/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="JVM 虚拟机">JVM 虚拟机</span>
            <span class="post-date" title="2023-08-28 09:23:44">2023/08/28</span>
        </a>
        
        <div id="no-item-tips">

        </div>
    </nav>
    <div id="outline-list">
    </div>
</div>

    </div>
    <div class="hide-list">
        <div class="semicircle" data-title="切换全屏 快捷键 s">
            <div class="brackets first"><</div>
            <div class="brackets">&gt;</div>
        </div>
    </div>
</aside>
<div id="post">
    <div class="pjax">
        <article id="post-5、中间件/Redis/Redis-代码实战" class="article article-type-post" itemscope itemprop="blogPost">
    
        <h1 class="article-title">Redis-代码实战</h1>
    
    <div class="article-meta">
        
        
        
        <span class="book">
            <i class="iconfont icon-category"></i>
            
            
            <a  data-rel="中间件">中间件</a> > 
            
            <a  data-rel="中间件&lt;---&gt;Redis">Redis</a>
            
        </span>
        
        
    </div>
    <div class="article-meta">
        
            发布时间 : <time class="date" title='最后更新: 2024-10-18 18:28:56'>2023-08-28 09:23</time>
        
    </div>
    <div class="article-meta">
        
        
        <span id="busuanzi_container_page_pv">
            阅读 :<span id="busuanzi_value_page_pv">
                <span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </span>
        </span>
        
        
    </div>
    
    <div class="toc-ref">
    
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis-%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%AE%80%E4%BB%8B%E5%8F%8A%E5%AF%B9%E6%AF%94"><span class="toc-text">Redis 客户端简介及对比</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis-%E7%BC%96%E7%A8%8B%E5%AE%A2%E6%88%B7%E7%AB%AF-Jedis"><span class="toc-text">Redis 编程客户端 Jedis</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81Jedis-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA"><span class="toc-text">1、Jedis 环境搭建</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81Jedis-%E5%B8%B8%E7%94%A8API%E7%A4%BA%E4%BE%8B"><span class="toc-text">2、Jedis 常用API示例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E9%94%AE%E7%9A%84%E6%93%8D%E4%BD%9C%EF%BC%88Key%EF%BC%89"><span class="toc-text">1、键的操作（Key）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81String-%E6%93%8D%E4%BD%9C"><span class="toc-text">2、String 操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81Hash-%E6%93%8D%E4%BD%9C"><span class="toc-text">3、Hash 操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81List-%E6%93%8D%E4%BD%9C"><span class="toc-text">4、List 操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81Set-%E6%93%8D%E4%BD%9C"><span class="toc-text">5、Set 操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81Zset-%E6%93%8D%E4%BD%9C%EF%BC%88sorted-set%EF%BC%89"><span class="toc-text">6、Zset 操作（sorted-set）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%E3%80%81Hyperloglog-%E6%93%8D%E4%BD%9C"><span class="toc-text">7、Hyperloglog 操作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81Jedis-%E8%BF%9E%E6%8E%A5%E6%B1%A0%E4%B8%8E%E4%BA%8B%E5%8A%A1"><span class="toc-text">3、Jedis 连接池与事务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81Jedis%E8%BF%9E%E6%8E%A5%E5%8D%95%E6%9C%BA%E7%89%88Redis"><span class="toc-text">1、Jedis连接单机版Redis</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81Jedis%E8%BF%9E%E6%8E%A5%E6%B1%A0%E8%BF%9E%E6%8E%A5Redis"><span class="toc-text">2、Jedis连接池连接Redis</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81Jedis%E8%BF%9E%E6%8E%A5%E4%B8%BB%E4%BB%8E%E7%89%88Redis"><span class="toc-text">3、Jedis连接主从版Redis</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81Jedis%E8%BF%9E%E6%8E%A5%E5%93%A8%E5%85%B5%E7%89%88Redis"><span class="toc-text">4、Jedis连接哨兵版Redis</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81Jedis%E8%BF%9E%E6%8E%A5%E9%9B%86%E7%BE%A4%E7%89%88Redis"><span class="toc-text">5、Jedis连接集群版Redis</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81Redis%E5%BC%80%E5%90%AF%E4%BA%8B%E5%8A%A1%E6%8E%A7%E5%88%B6"><span class="toc-text">6、Redis开启事务控制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%E3%80%81Jedis-%E9%AB%98%E7%BA%A7%E6%93%8D%E4%BD%9C%E6%B1%87%E6%80%BB"><span class="toc-text">7、Jedis 高级操作汇总</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81Jedis-%E8%BF%9E%E6%8E%A5%E6%B1%A0%E7%9A%84%E9%85%8D%E7%BD%AE"><span class="toc-text">4、Jedis 连接池的配置</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis-%E7%BC%96%E7%A8%8B%E5%AE%A2%E6%88%B7%E7%AB%AF-Lettuce"><span class="toc-text">Redis  编程客户端 Lettuce</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81Lettuce-%E7%AE%80%E4%BB%8B"><span class="toc-text">1、Lettuce 简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81Lettuce-%E8%BF%9E%E6%8E%A5-Redis"><span class="toc-text">2、Lettuce 连接 Redis</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81RedisURI-%E6%96%B9%E5%BC%8F%E5%88%9B%E5%BB%BA"><span class="toc-text">1、RedisURI 方式创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E5%AE%9A%E5%88%B6%E7%9A%84%E8%BF%9E%E6%8E%A5URI%E8%AF%AD%E6%B3%95"><span class="toc-text">2、定制的连接URI语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E8%BF%9E%E6%8E%A5Redis%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="toc-text">3、连接Redis基本使用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81Lettuce-API-%E6%93%8D%E4%BD%9C"><span class="toc-text">3、Lettuce API 操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E5%90%8C%E6%AD%A5API"><span class="toc-text">1、同步API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E5%BC%82%E6%AD%A5API"><span class="toc-text">2、异步API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E5%8F%8D%E5%BA%94%E5%BC%8FAPI"><span class="toc-text">3、反应式API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E5%8F%91%E5%B8%83%E5%92%8C%E8%AE%A2%E9%98%85"><span class="toc-text">4、发布和订阅</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81%E4%BA%8B%E5%8A%A1%E5%92%8C%E6%89%B9%E9%87%8F%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C"><span class="toc-text">5、事务和批量命令执行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81Lua%E8%84%9A%E6%9C%AC%E6%89%A7%E8%A1%8C"><span class="toc-text">6、Lua脚本执行</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E9%AB%98%E5%8F%AF%E7%94%A8%E5%92%8C%E5%88%86%E7%89%87"><span class="toc-text">4、高可用和分片</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E4%B8%BB%E4%BB%8E%E6%A8%A1%E5%BC%8F"><span class="toc-text">1、主从模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F"><span class="toc-text">2、哨兵模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F"><span class="toc-text">3、集群模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81%E5%8A%A8%E6%80%81%E5%91%BD%E4%BB%A4%E5%92%8C%E8%87%AA%E5%AE%9A%E4%B9%89%E5%91%BD%E4%BB%A4"><span class="toc-text">5、动态命令和自定义命令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81Lettuce%E7%9A%84%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7"><span class="toc-text">6、Lettuce的高级特性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E9%85%8D%E7%BD%AE%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%B5%84%E6%BA%90"><span class="toc-text">1、配置客户端资源</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E4%BD%BF%E7%94%A8%E8%BF%9E%E6%8E%A5%E6%B1%A0%E9%85%8D%E7%BD%AE"><span class="toc-text">2、使用连接池配置</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E3%80%81%E5%B8%B8%E8%A7%81%E7%9A%84%E6%B8%90%E8%BF%9B%E5%BC%8F%E5%88%A0%E9%99%A4%E6%A1%88%E4%BE%8B"><span class="toc-text">7、常见的渐进式删除案例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8%E3%80%81SpringBoot%E6%95%B4%E5%90%88Lettuce"><span class="toc-text">8、SpringBoot整合Lettuce</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9%E3%80%81Lettuce-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E7%A4%BA%E4%BE%8B"><span class="toc-text">9、Lettuce 快速入门示例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10%E3%80%81%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE-%E9%B8%A3%E8%B0%A2-%E5%B0%8F%E7%BB%93"><span class="toc-text">10、参考文献 &amp; 鸣谢 &amp; 小结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis-%E7%BC%96%E7%A8%8B%E5%AE%A2%E6%88%B7%E7%AB%AF-Redisson"><span class="toc-text">Redis 编程客户端 Redisson</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81Java-Redisson"><span class="toc-text">1、Java + Redisson</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81SpringBoot-Redission"><span class="toc-text">2、SpringBoot + Redission</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81Redission-%E4%BE%9D%E8%B5%96"><span class="toc-text">1、Redission 依赖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81Redission-%E9%85%8D%E7%BD%AE"><span class="toc-text">2、Redission 配置</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E7%A8%8B%E5%BA%8F%E5%8C%96%E9%85%8D%E7%BD%AE"><span class="toc-text">1、程序化配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81YML-%E9%85%8D%E7%BD%AE"><span class="toc-text">2、YML 配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E7%A8%8B%E5%BA%8F%E5%8A%A0%E8%BD%BD%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-text">3、程序加载配置文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81%E9%85%8D%E7%BD%AERedisTemplate"><span class="toc-text">4、配置RedisTemplate</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%93%8D%E4%BD%9C"><span class="toc-text">3、数据类型操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A1%B6%E6%93%8D%E4%BD%9C%EF%BC%88RBucket%EF%BC%89"><span class="toc-text">1、字符串桶操作（RBucket）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81Hash-%E9%94%AE%E5%80%BC%E5%AF%B9%EF%BC%88RMap%EF%BC%89"><span class="toc-text">2、Hash 键值对（RMap）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81List-%E9%93%BE%E8%A1%A8%E6%93%8D%E4%BD%9C%EF%BC%88Rlist%EF%BC%89"><span class="toc-text">3、List 链表操作（Rlist）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81Set-%E6%97%A0%E5%BA%8F%E9%9B%86%E5%90%88%E6%93%8D%E4%BD%9C%EF%BC%88RSet%EF%BC%89"><span class="toc-text">4、Set 无序集合操作（RSet）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81ZSet-%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88%E6%93%8D%E4%BD%9C%EF%BC%88RScoredSortedSet%EF%BC%89"><span class="toc-text">5、ZSet 有序集合操作（RScoredSortedSet）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81%E5%9F%BA%E6%95%B0%E6%93%8D%E4%BD%9C%EF%BC%88RHyperLogLog%EF%BC%89"><span class="toc-text">5、基数操作（RHyperLogLog）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81%E5%8E%9F%E5%AD%90%E9%95%BF%E6%95%B4%E5%9E%8B%EF%BC%88RAtomicLong%EF%BC%89"><span class="toc-text">6、原子长整型（RAtomicLong）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%B1%BB%E9%9B%86"><span class="toc-text">4、分布式锁类集</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E6%99%AE%E9%80%9A%E9%94%81%EF%BC%88RLock%EF%BC%89"><span class="toc-text">1、普通锁（RLock）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E8%AF%BB%E5%86%99%E9%94%81%EF%BC%88RReadWriteLock%EF%BC%89"><span class="toc-text">2、读写锁（RReadWriteLock）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E4%BF%A1%E5%8F%B7%E9%87%8F%EF%BC%88RSemaphore%EF%BC%89"><span class="toc-text">3、信号量（RSemaphore）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E5%80%92%E8%AE%A1%E6%95%B0%E5%99%A8%EF%BC%88RCountDownLatch%EF%BC%89"><span class="toc-text">4、倒计数器（RCountDownLatch）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81-%E9%99%90%E6%B5%81%E5%99%A8%EF%BC%88RRateLimiter%EF%BC%89"><span class="toc-text">5、 限流器（RRateLimiter）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81%E4%BA%8B%E5%8A%A1%EF%BC%88RTransaction%EF%BC%89"><span class="toc-text">6、事务（RTransaction）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E3%80%81%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%EF%BC%88RBloomFilter%EF%BC%89"><span class="toc-text">7、布隆过滤器（RBloomFilter）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8%E3%80%81%E5%AE%9A%E6%97%B6%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%88RScheduledExecutorService%EF%BC%89"><span class="toc-text">8、定时线程池（RScheduledExecutorService）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9%E3%80%81%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE-%E9%B8%A3%E8%B0%A2"><span class="toc-text">9、参考文献 &amp; 鸣谢</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis-SpinrgBoot-2-5-%E6%95%B4%E5%90%88"><span class="toc-text">Redis SpinrgBoot 2.5 整合</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81SpringDataRedis-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="toc-text">1、SpringDataRedis 基本使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81StringRedisTemplate-%E4%BD%BF%E7%94%A8"><span class="toc-text">2、StringRedisTemplate 使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81RedisTemplate-%E5%BA%8F%E5%88%97%E5%8C%96%E9%97%AE%E9%A2%98"><span class="toc-text">3、RedisTemplate  序列化问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81RedisTemplate-%E5%BA%8F%E5%88%97%E5%8C%96%E9%85%8D%E7%BD%AE"><span class="toc-text">4、RedisTemplate 序列化配置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81Jedis-Lettuce-%E8%BF%9E%E6%8E%A5%E6%B1%A0%E9%85%8D%E7%BD%AE"><span class="toc-text">5、Jedis &amp; Lettuce 连接池配置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81Redis-Sentinel-%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F%E9%85%8D%E7%BD%AE"><span class="toc-text">6、Redis Sentinel 哨兵模式配置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E3%80%81Redis-Cluster-%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F%E9%85%8D%E7%BD%AE"><span class="toc-text">7、Redis Cluster 集群模式配置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8%E3%80%81Redis-Configuration-%E9%85%8D%E7%BD%AE"><span class="toc-text">8、Redis Configuration 配置</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis-RedisTemplate-%E8%AF%A6%E8%A7%A3"><span class="toc-text">Redis RedisTemplate 详解</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81RedisTemplate-%E7%AE%80%E4%BB%8B"><span class="toc-text">1、RedisTemplate 简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E7%B1%BB%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB"><span class="toc-text">1、类继承关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93"><span class="toc-text">2、方法总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E5%8A%9F%E8%83%BD%E4%BB%8B%E7%BB%8D"><span class="toc-text">3、功能介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81RedisTemplate-%E9%85%8D%E7%BD%AE"><span class="toc-text">4、RedisTemplate 配置</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81RedisTemplate-%E9%A1%B6%E5%B1%82%E6%96%B9%E6%B3%95"><span class="toc-text">2、RedisTemplate 顶层方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81RedisTemplate-opsForValue"><span class="toc-text">3、RedisTemplate.opsForValue()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81RedisTemplate-opsForHash"><span class="toc-text">4、RedisTemplate.opsForHash()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81RedisTemplate-opsForList"><span class="toc-text">5、RedisTemplate.opsForList()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81RedisTemplate-opsForSet"><span class="toc-text">6、RedisTemplate.opsForSet()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E3%80%81RedisTemplate-opsForZSet"><span class="toc-text">7、RedisTemplate.opsForZSet()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8%E3%80%81RedisUtil-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-text">8、RedisUtil 自定义工具类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9%E3%80%81%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE-%E9%B8%A3%E8%B0%A2-1"><span class="toc-text">9、参考文献 &amp; 鸣谢</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis-%E5%AE%9E%E9%99%85%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">Redis 实际使用场景</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis-Session-%E5%85%B1%E4%BA%AB"><span class="toc-text">Redis Session 共享</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis-%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-text">Redis 实现分布式锁</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-text">1、什么是分布式锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E6%96%B9%E6%A1%88%E4%B8%80%EF%BC%9ASETNX-EXPIRE"><span class="toc-text">2、方案一：SETNX + EXPIRE</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E6%96%B9%E6%A1%88%E4%BA%8C%EF%BC%9ASETNX-VALUE-%E5%AD%98%E6%94%BE%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4"><span class="toc-text">3、方案二：SETNX + VALUE 存放过期时间</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E6%96%B9%E6%A1%88%E4%B8%89%EF%BC%9A%E4%BD%BF%E7%94%A8-Lua-%E8%84%9A%E6%9C%AC%E5%AE%9E%E7%8E%B0%E5%8A%A0%E9%94%81"><span class="toc-text">4、方案三：使用 Lua 脚本实现加锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81%E6%96%B9%E6%A1%88%E5%9B%9B%EF%BC%9ASET-%E6%89%A9%E5%B1%95%E5%91%BD%E4%BB%A4-%E5%AE%9E%E7%8E%B0%E5%8A%A0%E9%94%81"><span class="toc-text">5、方案四：SET 扩展命令 实现加锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81%E6%96%B9%E6%A1%88%E4%BA%94%EF%BC%9ASET-%E6%89%A9%E5%B1%95%E5%91%BD%E4%BB%A4-%E6%A0%A1%E9%AA%8C%E5%94%AF%E4%B8%80%E5%80%BC"><span class="toc-text">6、方案五：SET 扩展命令  + 校验唯一值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E3%80%81%E6%96%B9%E6%A1%88%E5%85%AD%EF%BC%9ARedisson-%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-text">7、方案六：Redisson 实现分布式锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8%E3%80%81Redis-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%AE%9E%E8%B7%B5%EF%BC%88Lua%E8%84%9A%E6%9C%AC%E7%89%88%EF%BC%89"><span class="toc-text">8、Redis 分布式锁实践（Lua脚本版）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E5%8A%A0%E9%94%81%E8%A7%A3%E9%94%81LUA%E8%84%9A%E6%9C%AC"><span class="toc-text">1、加锁解锁LUA脚本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81RedisConfig-java"><span class="toc-text">2、RedisConfig.java</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81RedisLockController-java"><span class="toc-text">3、RedisLockController.java</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E6%B5%8B%E8%AF%95%E6%95%88%E6%9E%9C"><span class="toc-text">4、分布式锁测试效果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81Redis-Lua-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E6%80%BB%E7%BB%93"><span class="toc-text">5、Redis Lua 分布式锁总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9%E3%80%81%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE-%E9%B8%A3%E8%B0%A2-2"><span class="toc-text">9、参考文献 &amp; 鸣谢</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis-%E5%AE%9E%E7%8E%B0%E8%AE%BF%E9%97%AE%E9%99%90%E6%B5%81"><span class="toc-text">Redis 实现访问限流</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis-%E7%83%AD%E7%82%B9%E4%BF%A1%E6%81%AF%E6%9F%A5%E8%AF%A2"><span class="toc-text">Redis 热点信息查询</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis-%E9%81%8D%E5%8E%86%E6%89%80%E6%9C%89%E7%9A%84%E9%94%AE"><span class="toc-text">Redis 遍历所有的键</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis-%E7%9B%91%E5%90%AC%E9%94%AE%E8%BF%87%E6%9C%9F%E6%8F%90%E9%86%92"><span class="toc-text">Redis 监听键过期提醒</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81Redis-%E5%AE%9E%E7%8E%B0%E8%AE%A2%E5%8D%9530%E5%88%86%E9%92%9F%E8%87%AA%E5%8A%A8%E5%8F%96%E6%B6%88"><span class="toc-text">1、Redis  实现订单30分钟自动取消</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E4%B8%9A%E5%8A%A1%E5%9C%BA%E6%99%AF"><span class="toc-text">1、业务场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF"><span class="toc-text">2、实现思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E5%BC%80%E5%90%AF%E9%85%8D%E7%BD%AE"><span class="toc-text">3、开启配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-text">4、代码实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81Redis-%E7%9B%91%E5%90%AC%E9%94%AE%E8%BF%87%E6%9C%9F%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86"><span class="toc-text">2、Redis 监听键过期海量数据处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E6%8A%9B%E5%87%BA%E9%97%AE%E9%A2%98%EF%BC%9ARedis%E7%9B%91%E5%90%AC%E8%BF%87%E6%9C%9F%E9%94%AE%E4%B8%8D%E5%8F%8A%E6%97%B6"><span class="toc-text">1、抛出问题：Redis监听过期键不及时</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E5%88%86%E6%9E%90%E9%97%AE%E9%A2%98%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%87%BA%E7%8E%B0%E9%80%9A%E7%9F%A5%E4%B8%8D%E5%8F%8A%E6%97%B6"><span class="toc-text">2、分析问题：为什么会出现通知不及时</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%9A%E7%BC%93%E5%AD%98%E6%95%B0%E6%8D%AE%E4%B8%8E%E7%9B%91%E5%90%AC%E6%95%B0%E6%8D%AE%E5%88%86%E7%A6%BB"><span class="toc-text">3、解决方案：缓存数据与监听数据分离</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%EF%BC%9A%E7%BC%93%E5%AD%98%E6%95%B0%E6%8D%AE%E4%B8%8E%E7%9B%91%E5%90%AC%E6%95%B0%E6%8D%AE%E5%88%86%E7%A6%BB"><span class="toc-text">5、代码实现：缓存数据与监听数据分离</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81Redis-%E7%9B%91%E5%90%AC%E9%94%AE%E8%BF%87%E6%9C%9F%E6%8F%90%E9%86%92%E6%80%BB%E7%BB%93"><span class="toc-text">3、Redis 监听键过期提醒总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis-SpringBoot-Pipeline"><span class="toc-text">Redis SpringBoot Pipeline</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE-%E9%B8%A3%E8%B0%A2"><span class="toc-text">参考文献 &amp; 鸣谢</span></a></li></ol>
    
<style>
    .left-col .switch-btn,
    .left-col .switch-area {
        display: none;
    }
    .toc-level-3 i,
    .toc-level-3 ol {
        display: none !important;
    }
</style>
</div>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Redis-客户端简介及对比"><a href="#Redis-客户端简介及对比" class="headerlink" title="Redis 客户端简介及对比"></a>Redis 客户端简介及对比</h1><blockquote>
<p>参考：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/dw3306/p/9520741.html">https://www.cnblogs.com/dw3306/p/9520741.html</a></p>
</blockquote>
<p>Redis的Java客户端很多，官方推荐的有三种：Jedis、Redisson 和 Lettuce。</p>
<p>1、Jedis：是Redis的Java实现客户端，提供了比较全面的Redis命令的支持</p>
<ul>
<li>轻量，简洁，便于集成和改造</li>
<li>支持连接池</li>
<li>支持pipelining、事务、LUA Scripting、Redis Sentinel、Redis Cluster</li>
<li>不支持读写分离，需要自己实现</li>
<li>文档差（真的很差，几乎没有……）</li>
</ul>
<p>2、Lettuce：高级Redis客户端，用于线程安全同步，异步和响应使用，支持集群，Sentinel，管道和编码器</p>
<ul>
<li>基于Netty框架的事件驱动的通信层</li>
<li>支持连接池</li>
<li>其方法调用是异步的</li>
<li>Lettuce的API是线程安全的</li>
<li>所以可以操作单个Lettuce连接来完成各种操作</li>
</ul>
<p>3、Redisson：实现了分布式和可扩展的Java数据结构</p>
<ul>
<li>基于Netty实现，采用非阻塞IO，性能高</li>
<li>支持异步请求</li>
<li>支持连接池</li>
<li>支持pipelining、LUA Scripting、Redis Sentinel、Redis Cluster</li>
<li>不支持事务，官方建议以LUA Scripting代替事务</li>
<li>支持在Redis Cluster架构下使用pipelining</li>
<li>支持读写分离，支持读负载均衡，在主从复制和Redis Cluster架构下都可以使用</li>
<li>内建Tomcat Session Manager，为Tomcat 6&#x2F;7&#x2F;8 提供了会话共享功能</li>
<li>可以与Spring Session集成，实现基于Redis的会话共享</li>
<li>文档较丰富，有中文文档</li>
</ul>
<p>4、使用建议：Lettuce + Redisson</p>
<ul>
<li>Jedis和Lettuce是比较纯粹的Redis客户端，几乎没提供什么高级功能。Jedis的性能比较差，所以如果你不需要使用Redis的高级功能的话，优先推荐使用 Lettuce</li>
<li>Redisson的优势是提供了很多开箱即用的Redis高级功能，如果你的应用中需要使用到Redis的高级功能，建议使用Redisson。具体 Redisson的高级功能可以参考：<a target="_blank" rel="noopener" href="https://redisson.org/">https://redisson.org</a></li>
</ul>
<h1 id="Redis-编程客户端-Jedis"><a href="#Redis-编程客户端-Jedis" class="headerlink" title="Redis 编程客户端 Jedis"></a>Redis 编程客户端 Jedis</h1><h2 id="1、Jedis-环境搭建"><a href="#1、Jedis-环境搭建" class="headerlink" title="1、Jedis 环境搭建"></a>1、Jedis 环境搭建</h2><p>Jedis是Redis官方推荐的Java链接开发工具，是Java操作Redis的中间件。GitHub地址：<a target="_blank" rel="noopener" href="https://github.com/xetorthio/jedis">https://github.com/xetorthio/jedis</a></p>
<p>1、想要使用Jedis只需要引入单个依赖即可，如果需要连接池也可以增加依赖</p>
<pre><code class="xml">&lt;properties&gt;
    &lt;!--锁定 jdk 版本为 1.8--&gt;
    &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;
    &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;
&lt;/properties&gt;

&lt;dependencies&gt;
    &lt;!-- jeids --&gt;
    &lt;!-- https://mvnrepository.com/artifact/redis.clients/jedis --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;redis.clients&lt;/groupId&gt;
        &lt;artifactId&gt;jedis&lt;/artifactId&gt;
        &lt;version&gt;3.3.0&lt;/version&gt;
    &lt;/dependency&gt;

    &lt;!-- jeids连接池 --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;
        &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt;
        &lt;version&gt;2.8.0&lt;/version&gt;
    &lt;/dependency&gt;

    &lt;!-- junit4 --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;junit&lt;/groupId&gt;
        &lt;artifactId&gt;junit&lt;/artifactId&gt;
        &lt;version&gt;4.13&lt;/version&gt;
        &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;

    &lt;!-- fastjson --&gt;
    &lt;!-- https://mvnrepository.com/artifact/com.alibaba/fastjson --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
        &lt;artifactId&gt;fastjson&lt;/artifactId&gt;
        &lt;version&gt;1.2.68&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<p>2、启动本地的Redis，使用Jedis连接测试</p>
<pre><code class="java">public class TestPing &#123;
    public static void main(String[] args) &#123;
        Jedis jedis = new Jedis(&quot;localhost&quot;, 6379, 10);
        System.out.println(jedis.ping()); // PONG
    &#125;
&#125;
</code></pre>
<p>3、常见错误：</p>
<ol>
<li>redis.clients.jedis.exceptions.JedisConnectionException: java.net.SocketTimeoutException: connect timed out<ul>
<li>可能原因一：Redis的配置文件中没有注释掉bind 127.0.0.1</li>
<li>可能原因二：Linux的防火墙没有关闭（可能性较大，通过firewall-cmd –reload命令重启防火强）</li>
<li>可能原因三：代码中的IP地址和端口写错了，请仔细检查一下</li>
</ul>
</li>
<li>redis.clients.jedis.exceptions.JedisDataException: NOAUTH Authentication required<ul>
<li>可能原因：出现这个说明Redis登录需要密码，而你的代码文件中并没有指明密码是多少，Redis登录是否启用密码请在配置文件中配置requirepass</li>
</ul>
</li>
<li>redis.clients.jedis.exceptions.JedisDataException: DENIED Redis is running in protected mode<ul>
<li>在客户端执行config set protected-mode no命令</li>
</ul>
</li>
</ol>
<h2 id="2、Jedis-常用API示例"><a href="#2、Jedis-常用API示例" class="headerlink" title="2、Jedis 常用API示例"></a>2、Jedis 常用API示例</h2><h3 id="1、键的操作（Key）"><a href="#1、键的操作（Key）" class="headerlink" title="1、键的操作（Key）"></a>1、键的操作（Key）</h3><pre><code class="java">import org.junit.Before;
import org.junit.After;
import org.junit.Test;
import redis.clients.jedis.Jedis;
import java.util.Set;

public class JedisKeyTest &#123;
    private Jedis jedis;
    @Before
    public void createJedis() &#123;
        jedis = new Jedis(&quot;127.0.0.1&quot;);
        //jedis.auth(&quot;123456&quot;);
    &#125;
    @After
    public void after() &#123;
        jedis.close();
    &#125;

    /**
     * 正则匹配key,keys patten
     * 返回值：
     * 返回不重复的key value
     */
    @Test
    public void keys() &#123;
        Set&lt;String&gt; keys = jedis.keys(&quot;*&quot;);
        System.out.println(keys);
    &#125;

    /**
     * 重命名key
     * 返回值：
     * 成功返回OK
     * 失败抛异常（oldkey不存在的时候）
     */
    @Test
    public void rename() &#123;
        String status = jedis.rename(&quot;name&quot;, &quot;username&quot;);
        System.out.println(status);
    &#125;

    /**
     * 重命名key,仅当新key不存在时才执行
     * 返回值：
     * 1：oldKey被重新命名
     * 0：newKey已存在
     */
    @Test
    public void renamenx() &#123;
        long status = jedis.renamenx(&quot;name&quot;, &quot;name3&quot;);
        System.out.println(status);
    &#125;

    /**
     * 设置key的过期时间，以秒为单位
     * 返回值：
     * 1：成功设置了过期时间
     * 0：key不存在
     */
    @Test
    public void expire() &#123;
        long status = jedis.expire(&quot;name&quot;, 20000);
        System.out.println(status);
    &#125;

    /**
     * 设置key的过期时间,它是距历元(即格林威治标准时间1970年1月1日00:00:00)的秒数。
     * 返回值：
     * 1：成功设置了过期时间
     * 0：key不存在
     */
    @Test
    public void expireAt() &#123;
        long status = jedis.expireAt(&quot;name&quot;, System.currentTimeMillis()/1000 + 100);
        System.out.println(status);
    &#125;

    /**
     * 查询key的过期时间，单位秒
     * 返回值：
     *  -1: 表示没有过期时间
     *  -2：表示key不存在
     *  其他：key的过期时间
     */
    @Test
    public void ttl() &#123;
        long time = jedis.ttl(&quot;name&quot;);
        System.out.println(time);
    &#125;

    /**
     * 持久化key
     * 返回值：
     *  1：成功持久化了
     *  0：key不存在
     */
    @Test
    public void persist() &#123;
        long state = jedis.persist(&quot;name&quot;);
        System.out.println(state);
    &#125;

    /**
     * 删除key
     * 返回值：
     * 成功删除的key的个数
     * 0表示key都不存在
     */
    @Test
    public void del() &#123;
        long state = jedis.del(&quot;name&quot;, &quot;username&quot;);
        System.out.println(state);
    &#125;

    /**
     * 清空所有key
     */
    @Test
    public void flushAll() &#123;
        String status = jedis.flushAll();
        System.out.println(status);
    &#125;

&#125;
</code></pre>
<h3 id="2、String-操作"><a href="#2、String-操作" class="headerlink" title="2、String 操作"></a>2、String 操作</h3><pre><code class="java">import java.util.List;
import org.junit.Before;
import org.junit.After;
import org.junit.Test;
import redis.clients.jedis.Jedis;

public class JedisStringDemo &#123;
    private Jedis jedis;
    @Before
    public void createJedis() &#123;
        jedis = new Jedis(&quot;127.0.0.1&quot;);
        //jedis.auth(&quot;123456&quot;);
    &#125;
    @After
    public void after() &#123;
        jedis.close();
    &#125;

    /**
     * 给指定key设置value
     * 返回值
     * 成功返回OK
     */
    @Test
    public void set() &#123;
        String status = jedis.set(&quot;name&quot;, &quot;sam&quot;);
        System.out.println(status);
    &#125;

    /**
     * 获取指定key的value
     */
    @Test
    public void get() &#123;
        String value = jedis.get(&quot;name&quot;);
        System.out.println(value);
    &#125;

    /**
     * 同时给多个key设置value
     */
    @Test
    public void mset() &#123;
        String status = jedis.mset(&quot;name&quot;, &quot;sam&quot;, &quot;age&quot;, &quot;50&quot;);
        System.out.println(status);
    &#125;

    /**
     * 获取多个key的value
     */
    @Test
    public void mget() &#123;
        List&lt;String&gt; value = jedis.mget(&quot;name&quot;, &quot;age&quot;);
        System.out.println(value);
    &#125;

    /**
     * 添加带有过期时间的记录，默认单位是秒
     * 成功返回OK
     */
    @Test
    public void setex() &#123;
        String status = jedis.setex(&quot;name&quot;, 10, &quot;sam&quot;);
        System.out.println(status);
    &#125;

    /**
     * 添加一条记录，仅当给定的key不存在时才插入
     * 返回值：
     * 1：成功设置了key
     * 0：可以不存在
     */
    @Test
    public void setnx() &#123;
        long code = jedis.setnx(&quot;name&quot;, &quot;sam&quot;);
        System.out.println(code);
    &#125;

    /**
     * 设置key的value值并返回老的value值
     */
    @Test
    public void getSet() &#123;
        String value = jedis.getSet(&quot;name&quot;, &quot;马化腾&quot;);
        System.out.println(value);
    &#125;

    /**
     * 将key对应的value加上指定的值，只有value可以转为数字时该方法才可用
     * 返回相加后的值
     *
     * &lt;b&gt;可以作为获取唯一ID的方法&lt;/b&gt;
     */
    @Test
    public void incrBy() &#123;
        long value = jedis.incrBy(&quot;salary&quot;, 10);
        System.out.println(value);
    &#125;

    /**
     * 将key对应的value减去指定的值，只有value可以转为数字时该方法才可用
     * 返回相减后的值
     */
    @Test
    public void decrBy() &#123;
        long value = jedis.decrBy(&quot;salary&quot;, 10);
        System.out.println(value);
    &#125;

    /**
     * append：
     * 若 key 存在并是字符串，APPEND 命令会将 value 追加 旧 value 后面
     * 若 key 不存在，等价于 set 命令
     * setrange：
     * 用 value 参数覆写给定 key 所储存的字符串值，从偏移量 offset 开始
     * getrange：
     * 返回 key 中字符串值的子字符
     */
    @Test
    public void test() &#123;
        jedis.append(&quot;username&quot;, &quot; is boy &quot;);
        System.out.println(jedis.get(&quot;username&quot;)); //  is boy
        jedis.setrange(&quot;username&quot;, 7, &quot;girl&quot;);
        System.out.println(jedis.get(&quot;username&quot;)); //  is boygirl
        System.out.println(jedis.getrange(&quot;username&quot;, 7, -1)); // girl
    &#125;
&#125;
</code></pre>
<h3 id="3、Hash-操作"><a href="#3、Hash-操作" class="headerlink" title="3、Hash 操作"></a>3、Hash 操作</h3><pre><code class="java">import org.junit.Before;
import org.junit.After;
import org.junit.Test;
import redis.clients.jedis.Jedis;
import java.util.*;

public class JedisHashTest &#123;
    private Jedis jedis;
    @Before
    public void createJedis() &#123;
        jedis = new Jedis(&quot;127.0.0.1&quot;);
        //jedis.auth(&quot;123456&quot;);
    &#125;
    @After
    public void after() &#123;
        jedis.close();
    &#125;
    
    /**
     * 返回值新增加的field的个数，如果field都已存在则更新并返回0
     */
    @Test
    public void hset() &#123;
        HashMap&lt;String, String&gt; values = new HashMap&lt;&gt;();
        values.put(&quot;age&quot;, &quot;50&quot;);
        values.put(&quot;sex&quot;, &quot;male&quot;);
        long code = jedis.hset(&quot;sam&quot;, values);
        System.out.println(code); // 2
        code = jedis.hset(&quot;sam&quot;, &quot;address&quot;, &quot;广州&quot;);
        System.out.println(code); // 1
    &#125;

    /**
     * 演示 hget
     */
    @Test
    public void hget() &#123;
        jedis.hset(&quot;user&quot;, &quot;username&quot;, &quot;tom&quot;);
        String value = jedis.hget(&quot;user&quot;, &quot;username&quot;);
        System.out.println(value); // tom
    &#125;

    /**
     * 演示 hmset hmget
     */
    @Test
    public void hmset() &#123;
        Map&lt;String, String&gt; hash = new HashMap&lt;String, String&gt;();
        hash.put(&quot;password&quot;, &quot;123&quot;);
        hash.put(&quot;sex&quot;, &quot;male&quot;);
        jedis.hmset(&quot;user&quot;, hash);

        List&lt;String&gt; values = jedis.hmget(&quot;user&quot;, &quot;username&quot;, &quot;password&quot;, &quot;sex&quot;);
        System.out.println(values);
    &#125;

    /**
     * 将field对应的value加上指定的值，只有value可以转为数字时该方法才可用
     * 返回增加后的值
     */
    @Test
    public void hincrBy() &#123;
        long value = jedis.hincrBy(&quot;mayun&quot;, &quot;age&quot;, 1);
        System.out.println(value);
    &#125;

    /**
     * 演示 hgetAll hkeys kvals
     */
    @Test
    public void hgetAll() &#123;
        Map&lt;String, String&gt; map = jedis.hgetAll(&quot;sam&quot;);
        System.out.println(map); // &#123;age=50, sex=male, address=广州&#125;

        Set&lt;String&gt; keys = jedis.hkeys(&quot;sam&quot;);
        System.out.println(keys); // [age, sex, address]

        List&lt;String&gt; values = jedis.hvals(&quot;sam&quot;);
        System.out.println(values); // [male, 50, 广州]
    &#125;

    /**
     * 演示 hdel
     */
    @Test
    public void hdel() &#123;
        jedis.hdel(&quot;user&quot;, &quot;username&quot;, &quot;password&quot;);
        Map&lt;String, String&gt; map = jedis.hgetAll(&quot;user&quot;);
        for (String key : map.keySet()) &#123;
            System.out.println(key + &quot;  &quot; + map.get(key));
        &#125;
    &#125;

&#125;
</code></pre>
<h3 id="4、List-操作"><a href="#4、List-操作" class="headerlink" title="4、List 操作"></a>4、List 操作</h3><pre><code class="java">import org.junit.Before;
import org.junit.After;
import org.junit.Test;
import redis.clients.jedis.Jedis;
import redis.clients.jedis.ListPosition;
import java.util.List;

public class JedisListTest &#123;
    private Jedis jedis;
    @Before
    public void createJedis() &#123;
        jedis = new Jedis(&quot;127.0.0.1&quot;);
        //jedis.auth(&quot;123456&quot;);
    &#125;
    @After
    public void after() &#123;
        jedis.close();
    &#125;
    
    /**
     * 将一个或多个值插入到列表头部
     * 返回插入队列的数据的个数
     */
    @Test
    public void lpush() &#123;
        Long num = jedis.lpush(&quot;list&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;);
        System.out.println(num); // 3
    &#125;

    /**
     * 将一个或多个值插入到列表尾部
     * 返回插入队列的数据的个数
     */
    @Test
    public void rpush() &#123;
        Long num = jedis.rpush(&quot;list&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;);
        System.out.println(num); // 3
    &#125;

    /**
     * 将一个或多个值插入到已存在的列表头部
     * 返回插入队列的数据的个数
     */
    @Test
    public void lpushx() &#123;
        Long num = jedis.lpushx(&quot;list&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;);
        System.out.println(num); // 3
    &#125;

    /**
     * 将一个或多个值插入到已存在的列表尾部
     * 返回插入队列的数据的个数
     */
    @Test
    public void rpushx() &#123;
        Long num = jedis.rpushx(&quot;list&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;);
        System.out.println(num); // 3
    &#125;

    /**
     * 返回列表指定范围内的数据
     * 一般 lpush lrange 成对使用
     */
    @Test
    public void lrange() &#123;
        List&lt;String&gt; list = jedis.lrange(&quot;list&quot;, 0, 5);
        System.out.println(list);

        jedis.lpush(&quot;names&quot;, &quot;tom&quot;, &quot;james&quot;, &quot;张三&quot;, &quot;李四&quot;);
        List&lt;String&gt; names = jedis.lrange(&quot;names&quot;, 0, -1);
        System.out.println(names);
    &#125;
    
    /**
     * 演示 lset lindex
     */
    @Test
    public void test2() &#123;
        jedis.lset(&quot;names&quot;, 1, &quot;王五&quot;);
        List&lt;String&gt; names = jedis.lrange(&quot;names&quot;, 0, -1);
        System.out.println(names);

        String value = jedis.lindex(&quot;names&quot;, 1);
        System.out.println(value);
    &#125;

    /**
     * 演示 linsert
     */
    @Test
    public void test3() &#123;
        jedis.linsert(&quot;names&quot;, ListPosition.BEFORE, &quot;james&quot;, &quot;fox&quot;);
        List&lt;String&gt; names = jedis.lrange(&quot;names&quot;, 0, -1);
        System.out.println(names);
    &#125;

    /**
     * 演示 lrem
     */
    @Test
    public void test4() &#123;
        jedis.lrem(&quot;names&quot;, 1, &quot;tom&quot;);
        List&lt;String&gt; names = jedis.lrange(&quot;names&quot;, 0, -1);
        System.out.println(names);
    &#125;
    
&#125;
</code></pre>
<h3 id="5、Set-操作"><a href="#5、Set-操作" class="headerlink" title="5、Set 操作"></a>5、Set 操作</h3><pre><code class="java">import org.junit.Before;
import org.junit.After;
import org.junit.Test;
import redis.clients.jedis.Jedis;
import java.util.Set;

public class JedisSetTest &#123;
    private Jedis jedis;
    @Before
    public void createJedis() &#123;
        jedis = new Jedis(&quot;127.0.0.1&quot;);
        //jedis.auth(&quot;123456&quot;);
    &#125;
    @After
    public void after() &#123;
        jedis.close();
    &#125;

    /**
     * 往set里增加元素
     * 成功增加元素的个数，如果都已存在返回0
     */
    @Test
    public void sadd() &#123;
        long value = jedis.sadd(&quot;set&quot;, &quot;a&quot;, &quot;b&quot;);
        System.out.println(value); // 2
    &#125;

    /**
     * 移除set中的元素
     * 1：成功移除
     * 0：元素不存在
     */
    @Test
    public void srem() &#123;
        long value = jedis.srem(&quot;set&quot;, &quot;a&quot;);
        System.out.println(value); // 1
    &#125;

    /**
     * 获取set里的所有元素
     */
    @Test
    public void smembers() &#123;
        Set&lt;String&gt; value = jedis.smembers(&quot;set&quot;);
        System.out.println(value); // [b]
    &#125;

    /**
     * 交集 sinter
     */
    @Test
    public void sinter() &#123;
        jedis.flushDB();
        jedis.sadd(&quot;language1&quot;, &quot;java&quot;, &quot;c++&quot;, &quot;ruby&quot;, &quot;python&quot;);
        jedis.sadd(&quot;language2&quot;, &quot;ios&quot;, &quot;c++&quot;, &quot;c#&quot;, &quot;android&quot;);
        Set&lt;String&gt; sinter = jedis.sinter(&quot;language1&quot;, &quot;language2&quot;);
        System.out.println(sinter); // [c++]
    &#125;

    /**
     * 差集 sdiff
     */
    @Test
    public void sdiff() &#123;
        jedis.flushDB();
        jedis.sadd(&quot;language1&quot;, &quot;java&quot;, &quot;c++&quot;, &quot;ruby&quot;, &quot;python&quot;);
        jedis.sadd(&quot;language2&quot;, &quot;ios&quot;, &quot;c++&quot;, &quot;c#&quot;, &quot;android&quot;);
        Set&lt;String&gt; sdiff = jedis.sdiff(&quot;language1&quot;, &quot;language2&quot;);
        System.out.println(sdiff); // [python, java, ruby]
    &#125;

    /**
     * 并集 sunion
     */
    @Test
    public void sunion() &#123;
        jedis.flushDB();
        jedis.sadd(&quot;language1&quot;, &quot;java&quot;, &quot;c++&quot;, &quot;ruby&quot;, &quot;python&quot;);
        jedis.sadd(&quot;language2&quot;, &quot;ios&quot;, &quot;c++&quot;, &quot;c#&quot;, &quot;android&quot;);
        Set&lt;String&gt; sunion = jedis.sunion(&quot;language1&quot;, &quot;language2&quot;);
        System.out.println(sunion); // [c#, android, ios, c++, python, ruby, java]
    &#125;

&#125;
</code></pre>
<h3 id="6、Zset-操作（sorted-set）"><a href="#6、Zset-操作（sorted-set）" class="headerlink" title="6、Zset 操作（sorted-set）"></a>6、Zset 操作（sorted-set）</h3><pre><code class="java">import org.junit.Before;
import org.junit.After;
import org.junit.Test;
import redis.clients.jedis.Jedis;
import redis.clients.jedis.Tuple;
import java.util.*;

public class JedisZSetTest &#123;
    private Jedis jedis;
    @Before
    public void createJedis() &#123;
        jedis = new Jedis(&quot;127.0.0.1&quot;);
        //jedis.auth(&quot;123456&quot;);
    &#125;
    @After
    public void after() &#123;
        jedis.close();
    &#125;
    
    /**
     * 往sorted set里增加元素
     * 1: 成功增加
     * 0: 元素已存在
     */
    @Test
    public void zadd() &#123;
        long value = jedis.zadd(&quot;sortedset&quot;, 1, &quot;a&quot;);
        System.out.println(value); // 1
        value = jedis.zadd(&quot;sortedset&quot;, 2, &quot;b&quot;);
        System.out.println(value); // 1
    &#125;

    /**
     * 移除sorted set中的元素
     * 1：成功移除
     * 0：元素不存在
     */
    @Test
    public void zrem() &#123;
        long value = jedis.zrem(&quot;sortedset&quot;, &quot;a&quot;);
        System.out.println(value); // 1
    &#125;

    /**
     * 获取set里的所有元素
     */
    @Test
    public void zrange() &#123;
        Set&lt;String&gt; value = jedis.zrange(&quot;sortedset&quot;, 0, 5);
        System.out.println(value); // [b]
    &#125;

    /**
     * 演示 zadd zrange zrangeByScore
     * zadd：往sorted set里增加元素
     * zrange：通过索引返回有序集合指定区间内的成员（分数从低到高）
     * zrangeByScore：返回有序集合指定分数区间内的成员，分数从低到高排序
     */
    @Test
    public void test() &#123;
        jedis.flushDB();
        Map&lt;String, Double&gt; sm = new HashMap&lt;String, Double&gt;();
        sm.put(&quot;张三&quot;, 70.0);
        sm.put(&quot;李四&quot;, 80.0);
        sm.put(&quot;王五&quot;, 90.0);
        sm.put(&quot;赵六&quot;, 60.0);
        jedis.zadd(&quot;zkey&quot;, sm);
        Set&lt;String&gt; set = jedis.zrange(&quot;zkey&quot;, 0, -1);
        System.out.println(set); // [赵六, 张三, 李四, 王五]

        Set&lt;String&gt; set1 = jedis.zrangeByScore(&quot;zkey&quot;, 70.0, 90.0);
        System.out.println(set1); // [张三, 李四, 王五]
    &#125;

    /**
     * 演示 zrangeWithScores：通过索引区间返回有序集合指定区间内的成员（分数从低到高）
     */
    @Test
    public void zrangeWithScores() &#123;
        jedis.flushDB();
        Map&lt;String, Double&gt; sm = new HashMap&lt;String, Double&gt;();
        sm.put(&quot;张三&quot;, 70.0);
        sm.put(&quot;李四&quot;, 80.0);
        sm.put(&quot;王五&quot;, 90.0);
        sm.put(&quot;赵六&quot;, 60.0);
        jedis.zadd(&quot;zkey&quot;, sm);
        Set&lt;Tuple&gt; zws = jedis.zrangeWithScores(&quot;zkey&quot;, 0, -1);
        for (Tuple t : zws) &#123;
            System.out.println(t.getScore() + &quot;  &quot; + t.getElement());
        &#125;
    &#125;

    /**
     * 演示 zrank：返回有序集合中指定成员的排名索引（分数从低到高）
     */
    @Test
    public void zrank() &#123;
        jedis.flushDB();
        Map&lt;String, Double&gt; sm = new HashMap&lt;String, Double&gt;();
        sm.put(&quot;张三&quot;, 70.0);
        sm.put(&quot;李四&quot;, 80.0);
        sm.put(&quot;王五&quot;, 90.0);
        sm.put(&quot;赵六&quot;, 60.0);
        jedis.zadd(&quot;zkey&quot;, sm);
        Long num = jedis.zrank(&quot;zkey&quot;, &quot;赵六&quot;);
        System.out.println(num); // 0
    &#125;

    /**
     * 演示 zscore：返回集合中指定成员的分数值
     */
    @Test
    public void zscore() &#123;
        jedis.flushDB();
        Map&lt;String, Double&gt; sm = new HashMap&lt;String, Double&gt;();
        sm.put(&quot;张三&quot;, 70.0);
        sm.put(&quot;李四&quot;, 80.0);
        sm.put(&quot;王五&quot;, 90.0);
        sm.put(&quot;赵六&quot;, 60.0);
        jedis.zadd(&quot;zkey&quot;, sm);
        Double zscore = jedis.zscore(&quot;zkey&quot;, &quot;张三&quot;);
        System.out.println(zscore); // 70.0
    &#125;
&#125;
</code></pre>
<h3 id="7、Hyperloglog-操作"><a href="#7、Hyperloglog-操作" class="headerlink" title="7、Hyperloglog 操作"></a>7、Hyperloglog 操作</h3><pre><code class="java">import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import redis.clients.jedis.Jedis;

public class JedisHyperloglogTest &#123;
    private Jedis jedis;
    @Before
    public void createJedis() &#123;
        jedis = new Jedis(&quot;127.0.0.1&quot;);
        //jedis.auth(&quot;123456&quot;);
    &#125;
    @After
    public void after() &#123;
        jedis.close();
    &#125;

    /**
     * 添加指定元素到HyperLogLog中
     * 返回成功天的个数，如果元素都已存在则返回0
     */
    @Test
    public void pfadd() &#123;
        long code = jedis.pfadd(&quot;hyper&quot;, &quot;a&quot;, &quot;b&quot;, &quot;d&quot;);
        System.out.println(code); // 1
    &#125;

    /**
     * 返回给定HyperLogLog的基数估算值
     */
    @Test
    public void pfcount() &#123;
        long value = jedis.pfcount(&quot;hyper&quot;);
        System.out.println(value); // 3
    &#125;
&#125;
</code></pre>
<h2 id="3、Jedis-连接池与事务"><a href="#3、Jedis-连接池与事务" class="headerlink" title="3、Jedis 连接池与事务"></a>3、Jedis 连接池与事务</h2><h3 id="1、Jedis连接单机版Redis"><a href="#1、Jedis连接单机版Redis" class="headerlink" title="1、Jedis连接单机版Redis"></a>1、Jedis连接单机版Redis</h3><pre><code class="java">@Test
public void testLink() &#123;
    // 创建连接
    Jedis jedis = new Jedis(&quot;127.0.0.1&quot;, 6379);
    // 设置密码，如果配置了密码需要设置
    jedis.auth(&quot;123456&quot;);
    // 测试是否连接成功
    System.out.println(jedis.ping()); // PONG
    // 释放资源
    jedis.close();
&#125;
</code></pre>
<h3 id="2、Jedis连接池连接Redis"><a href="#2、Jedis连接池连接Redis" class="headerlink" title="2、Jedis连接池连接Redis"></a>2、Jedis连接池连接Redis</h3><pre><code class="java">public class RedisTest &#123;
    @Test
    public void test() &#123;
        // 1. 创建一个配置对象
        JedisPoolConfig config = new JedisPoolConfig();
        config.setMaxTotal(20);
        config.setMaxIdle(10);
        // 2. 创建 Jedis 连接池对象
        JedisPool jedisPool = new JedisPool(config, &quot;localhost&quot;, 6379);
        // 3. 获取连接
        Jedis jedis = jedisPool.getResource();
        // 4. 使用
        jedis.set(&quot;name&quot;,&quot;Jack&quot;);
        // 5. 关闭归还到连接池
        jedis.close();
    &#125;
&#125;
</code></pre>
<h3 id="3、Jedis连接主从版Redis"><a href="#3、Jedis连接主从版Redis" class="headerlink" title="3、Jedis连接主从版Redis"></a>3、Jedis连接主从版Redis</h3><pre><code class="java">@Test
public void testLink() &#123;
    // 创建对应连接，并设置密码
    Jedis jedis_M = new Jedis(&quot;127.0.0.1&quot;, 8001);
    jedis_M.auth(&quot;123456&quot;);
    Jedis jedis_S1 = new Jedis(&quot;127.0.0.1&quot;, 8002);
    jedis_S1.auth(&quot;123456&quot;);
    Jedis jedis_S2 = new Jedis(&quot;127.0.0.1&quot;, 8003);
    jedis_S2.auth(&quot;123456&quot;);

    // 从机连接主机
    jedis_S1.slaveof(&quot;127.0.0.1&quot;, 8001);
    jedis_S2.slaveof(&quot;127.0.0.1&quot;, 8001);

    // 主机写入数据
    jedis_M.set(&quot;username&quot;, &quot;zhangsan&quot;);

    // 从机读取数据
    System.out.println(jedis_S1.get(&quot;username&quot;));
    System.out.println(jedis_S2.get(&quot;username&quot;));

    // 释放所有资源
    jedis_S2.close();
    jedis_S1.close();
    jedis_M.close();
&#125;
</code></pre>
<h3 id="4、Jedis连接哨兵版Redis"><a href="#4、Jedis连接哨兵版Redis" class="headerlink" title="4、Jedis连接哨兵版Redis"></a>4、Jedis连接哨兵版Redis</h3><pre><code class="java">@Test
public void testLink() &#123;
    // 账户密码
    String masterName = &quot;mymaster&quot;;
    String password = &quot;123456&quot;;

    // 设置参数
    JedisPoolConfig jedisPoolConfig = new JedisPoolConfig();
    jedisPoolConfig.setMaxTotal(10);
    jedisPoolConfig.setMaxIdle(5);
    jedisPoolConfig.setMinIdle(5);

    // 哨兵信息
    Set&lt;String&gt; sentinels = new HashSet&lt;String&gt;();
    sentinels.add(&quot;127.0.0.1:26379&quot;);
    sentinels.add(&quot;127.0.0.1:26380&quot;);
    sentinels.add(&quot;127.0.0.1:26381&quot;);

    // 创建连接池
    JedisSentinelPool pool = new JedisSentinelPool(masterName, sentinels, jedisPoolConfig, password);

    // 获取客户端
    Jedis jedis = pool.getResource();

    // 执行写操作
    jedis.set(&quot;username&quot;, &quot;lisi&quot;);

    // 执行读操作
    System.out.println(jedis.get(&quot;username&quot;));

    // 释放资源
    pool.close();
&#125;
</code></pre>
<blockquote>
<p>注意：Java连接Redis Sentinel，哨兵模式下不要直连master，要连哨兵，master挂了才会自动故障转移，又因为连接哨兵需要连接池，所以我们需要在引入两个jar包，分别是：commons-pool2-2.4.2.jar、commons-lang3-3.3.2.jar，为了可以演示自动故障转移，您可以正常的启动一主两从和三个哨兵，然后执行以下代码，看一下效果，然后使用kill命令杀掉master，重新把set一个别的值，你再执行一次代码，你会发现set和get操作还是正常的，不会因为之前主节点宕机就不能工作，这就是哨兵模式的好处。</p>
</blockquote>
<h3 id="5、Jedis连接集群版Redis"><a href="#5、Jedis连接集群版Redis" class="headerlink" title="5、Jedis连接集群版Redis"></a>5、Jedis连接集群版Redis</h3><pre><code class="java">private static JedisCluster jedis = null;
private static JedisCluster getJedis() &#123;
    return jedis;
&#125;
static &#123;
    try &#123;
        JedisPoolConfig jedisPoolConfig = new JedisPoolConfig();
        jedisPoolConfig.setMaxTotal(1024);
        jedisPoolConfig.setMaxIdle(200);
        jedisPoolConfig.setMaxWaitMillis(1000);
        jedisPoolConfig.setTestOnBorrow(true);
        jedisPoolConfig.setTestWhileIdle(true);
        jedisPoolConfig.setTestOnReturn(true);

        Set&lt;HostAndPort&gt; jedisClusterNodes = new HashSet&lt;HostAndPort&gt;();
        jedisClusterNodes.add(new HostAndPort(&quot;127.0.0.1&quot;, 6001));
        jedisClusterNodes.add(new HostAndPort(&quot;127.0.0.1&quot;, 6002));
        jedisClusterNodes.add(new HostAndPort(&quot;127.0.0.1&quot;, 6003));
        jedisClusterNodes.add(new HostAndPort(&quot;127.0.0.1&quot;, 6004));
        jedisClusterNodes.add(new HostAndPort(&quot;127.0.0.1&quot;, 6005));
        jedisClusterNodes.add(new HostAndPort(&quot;127.0.0.1&quot;, 6006));
        jedisClusterNodes.add(new HostAndPort(&quot;127.0.0.1&quot;, 6007));
        jedisClusterNodes.add(new HostAndPort(&quot;127.0.0.1&quot;, 6008));
        jedisClusterNodes.add(new HostAndPort(&quot;127.0.0.1&quot;, 6009));

        jedis = new JedisCluster(jedisClusterNodes, 1000, 1000, 5, &quot;123456&quot;, jedisPoolConfig);
    &#125; catch (Exception e) &#123;
        e.printStackTrace();
    &#125;
&#125;

@Test
public void testLink() &#123;
    try &#123;
        // 获取链接
        JedisCluster jedisCluster = getJedis();

        // 执行写操作
        jedisCluster.set(&quot;username&quot;, &quot;wangwu&quot;);

        // 执行读操作
        System.out.println(jedisCluster.get(&quot;username&quot;));

        // 释放资源
        jedisCluster.close();
    &#125; catch (IOException e) &#123;
        e.printStackTrace();
    &#125;
&#125;
</code></pre>
<h3 id="6、Redis开启事务控制"><a href="#6、Redis开启事务控制" class="headerlink" title="6、Redis开启事务控制"></a>6、Redis开启事务控制</h3><pre><code class="java">/**
 * 测试事务
 */
public class TestTX &#123;
    public static void main(String[] args) &#123;
        Jedis jedis = new Jedis(&quot;localhost&quot;, 6379);
        jedis.flushDB();
        JSONObject jsonObject = new JSONObject();
        jsonObject.put(&quot;hello&quot;, &quot;world&quot;);
        jsonObject.put(&quot;name&quot;, &quot;xxx&quot;);

        // 开启事务
        Transaction multi = jedis.multi();
        String result = jsonObject.toJSONString();

        try &#123;
            multi.set(&quot;user1&quot;, result);
            multi.set(&quot;user2&quot;, result);
            int i = 1 / 0; // 模拟异常
            multi.exec(); // 执行事务
        &#125; catch (Exception e) &#123;
            multi.discard(); // 放弃事务
            e.printStackTrace();
        &#125; finally &#123;
            // 正常执行时&#123;&quot;name&quot;:&quot;xxx&quot;,&quot;hello&quot;:&quot;world&quot;&#125;   
            System.out.println(jedis.get(&quot;user1&quot;)); // null
            System.out.println(jedis.get(&quot;user1&quot;));
            jedis.close(); // 关闭链接
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="7、Jedis-高级操作汇总"><a href="#7、Jedis-高级操作汇总" class="headerlink" title="7、Jedis 高级操作汇总"></a>7、Jedis 高级操作汇总</h3><pre><code class="java">package com.xyz.redis;

import org.junit.Before;
import org.junit.Test;
import redis.clients.jedis.*;

import java.util.HashMap;
import java.util.HashSet;
import java.util.Set;

/**
 * 高级操作
 */
public class JedisAdvancedCase &#123;
    private JedisPoolConfig config;

    @Before
    public void before() &#123;
        config = new JedisPoolConfig();
        config.setMaxWaitMillis(1000 * 30); // 当连接池内的连接耗尽时，最大的等待时间
        config.setMaxTotal(20); // 资源池的最大连接数
        config.setMaxIdle(10); // 资源池的最大空闲连接数
        config.setMinIdle(5); // 资源池的最小空闲连接数
        config.setTestOnBorrow(true); // 获取连接实例时，是否进行测试，默认false
        config.setTestWhileIdle(true); // 是否开启空闲资源检测, 默认false
        config.setTimeBetweenEvictionRunsMillis(1000 * 10); // 空闲资源的检测周期
    &#125;

    /**
     * 管道操作,可以挺高性能
     */
    @Test
    public void pipelined() &#123;
        Jedis jedis = new Jedis(&quot;10.49.196.10&quot;);
        jedis.auth(&quot;123456&quot;);
        Pipeline pipeline = jedis.pipelined();
        for (int i = 0; i &lt; 100; i++) &#123;
            pipeline.set(&quot;key&quot; + i, i + &quot;&quot;);
        &#125;
        pipeline.sync();
        pipeline.close();
        jedis.close();
    &#125;

    /**
     * 连接池操作
     */
    @Test
    public void jedisPool() &#123;
        JedisPool pool = new JedisPool(config, &quot;10.49.196.10&quot;, 6379, 1000 * 10, &quot;123456&quot;);
        //获取Jedis实列
        Jedis jedis = pool.getResource();
        System.out.println(jedis.get(&quot;name&quot;));
        jedis.close();
        pool.close();
    &#125;

    /**
     * 哨兵模式
     */
    @Test
    public void jedisSentinelPool() &#123;
        Set&lt;String&gt; sentinels = new HashSet&lt;&gt;();
        sentinels.add(&quot;10.49.196.20:26379&quot;);
        sentinels.add(&quot;10.49.196.21:26379&quot;);
        sentinels.add(&quot;10.49.196.22:26379&quot;);
        JedisSentinelPool pool = new JedisSentinelPool(&quot;mymaster&quot;, sentinels, config, 1000 * 5, &quot;123456&quot;);
        //获取Jedis实列
        Jedis jedis = pool.getResource();
        System.out.println(jedis.get(&quot;name&quot;));
        jedis.close();
        pool.close();
    &#125;

    /**
     * 集群模式
     */
    @Test
    public void jedisCluster() &#123;
        Set&lt;HostAndPort&gt; set = new HashSet&lt;HostAndPort&gt;();
        set.add(new HostAndPort(&quot;10.49.196.20&quot;, 7000));
        set.add(new HostAndPort(&quot;10.49.196.20&quot;, 7001));
        set.add(new HostAndPort(&quot;10.49.196.21&quot;, 7000));
        set.add(new HostAndPort(&quot;10.49.196.21&quot;, 7001));
        set.add(new HostAndPort(&quot;10.49.196.22&quot;, 7000));
        set.add(new HostAndPort(&quot;10.49.196.22&quot;, 7001));
        JedisCluster cluster = new JedisCluster(set, 1000 * 5, 1000 * 5, 5, &quot;123456&quot;, config);
        //JedisCluster的基础操作和Jedis很类似

        //key
        System.out.println(&quot;判断key是否存在：&quot; + cluster.exists(&quot;name&quot;));
        System.out.println(&quot;查询key的过期时间：&quot; + cluster.ttl(&quot;name&quot;));

        //String
        System.out.println(&quot;设置键值对：&quot; + cluster.set(&quot;name&quot;, &quot;mahuateng&quot;));
        System.out.println(&quot;获取key对应的值：&quot; + cluster.get(&quot;name&quot;));

        //List
        System.out.println(&quot;将一个或多个值插入到列表头部：&quot; + cluster.lpush(&quot;list&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;));
        System.out.println(&quot;返回列表指定范围内的数据：&quot; + cluster.lrange(&quot;list&quot;, 0, 5));

        //Hash
        HashMap&lt;String, String&gt; values = new HashMap&lt;&gt;();
        values.put(&quot;age&quot;, &quot;50&quot;);
        values.put(&quot;sex&quot;, &quot;male&quot;);
        System.out.println(&quot;在hash中设置field及value：&quot; + cluster.hset(&quot;mayun&quot;, values));
        System.out.println(&quot;在hash中所有属性及值：&quot; + cluster.hgetAll(&quot;mayun&quot;));

        //set
        System.out.println(&quot;往set里增加元素：&quot; + cluster.sadd(&quot;set&quot;, &quot;a&quot;, &quot;b&quot;));
        System.out.println(&quot;取set里的所有元素：&quot; + cluster.smembers(&quot;set&quot;));

        //sorted set
        System.out.println(&quot;往sorted set里增加元素1：&quot; + cluster.zadd(&quot;sortedset&quot;, 1, &quot;a&quot;));
        System.out.println(&quot;往sorted set里增加元素2：&quot; + cluster.zadd(&quot;sortedset&quot;, 2, &quot;b&quot;));
        System.out.println(&quot;获取sorted set里的所有元素：&quot; + cluster.zrange(&quot;sortedset&quot;,0, 5));

        //集群信息
        System.out.println(&quot;集群节点信息：&quot; + cluster.getClusterNodes());
        cluster.close();
    &#125;
&#125;
</code></pre>
<h2 id="4、Jedis-连接池的配置"><a href="#4、Jedis-连接池的配置" class="headerlink" title="4、Jedis 连接池的配置"></a>4、Jedis 连接池的配置</h2><p>1、下面给出Jedis详细配置的一些选项，并且使用流的形式加载配置文件<code>jedis.properties</code></p>
<pre><code class="properties"># 最大活动对象数     
redis.pool.maxTotal=1000    
# 最大能够保持idel状态的对象数      
redis.pool.maxIdle=100  
# 最小能够保持idel状态的对象数   
redis.pool.minIdle=50    
# 当池内没有返回对象时，最大等待时间    
redis.pool.maxWaitMillis=10000    
# 当调用borrow Object方法时，是否进行有效性检查    
redis.pool.testOnBorrow=true    
# 当调用return Object方法时，是否进行有效性检查    
redis.pool.testOnReturn=true  
# “空闲链接”检测线程，检测的周期，毫秒数。如果为负值，表示不运行“检测线程”。默认为-1.  
redis.pool.timeBetweenEvictionRunsMillis=30000  
# 向调用者输出“链接”对象时，是否检测它的空闲超时；  
redis.pool.testWhileIdle=true  
# 对于“空闲链接”检测线程而言，每次检测的链接资源的个数。默认为3.  
redis.pool.numTestsPerEvictionRun=50  
# redis服务器的IP    
redis.ip=xxxxxx  
# redis服务器的Port    
redis.port=6379   
</code></pre>
<pre><code class="java">package com.xyz.util;

import java.io.IOException;
import java.io.InputStream;
import java.util.Properties;

import redis.clients.jedis.Jedis;
import redis.clients.jedis.JedisPool;
import redis.clients.jedis.JedisPoolConfig;

/**
 * 加载配置文件，配置连接池参数，提供链接的方法
 */
public class JedisPoolUtil &#123;

    private static JedisPool jedisPool;

    // 当类加载就读取配置文件
    static &#123;
        // 类加载加载配置文件
        InputStream is=JedisPoolUtil.class.getClassLoader().getResourceAsStream(&quot;jedis.properties&quot;);
        // 创建Properties对象
        Properties pr=new Properties();
        try &#123;
            // 关联文件
            pr.load(is);
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;

        JedisPoolConfig config = new JedisPoolConfig(); // 获取数据，设置数据
        config.setMaxTotal(Integer.parseInt(pr.getProperty(&quot;maxTotal&quot;))); // 最大连接数
        config.setMaxIdle(Integer.parseInt(pr.getProperty(&quot;maxIdle&quot;))); // 设置最大的空闲连接
        // 初始化JedisPool
        jedisPool = new JedisPool(pr.getProperty(&quot;host&quot;),Integer.parseInt(pr.getProperty(&quot;port&quot;)));
    &#125;

    // 获取Jedis
    public static Jedis getJedis() &#123;
        return jedisPool.getResource();
    &#125;

    // 释放资源
    public static void closeJedis(Jedis jedis) &#123;
        if(jedis!=null) &#123;
            jedis.close();
        &#125;
    &#125;
&#125;
</code></pre>
<p>2、JedisPoolConfig 参数说明。JedisPoolConfig用来设置连接池的相关属性，具体参数如下：</p>
<table>
<thead>
<tr>
<th>参数名称</th>
<th>说明</th>
<th>默认值</th>
<th>建议</th>
</tr>
</thead>
<tbody><tr>
<td>maxTotal</td>
<td>资源池中的最大连接数</td>
<td>8</td>
<td></td>
</tr>
<tr>
<td>maxIdle</td>
<td>资源池中的最大空闲连接数</td>
<td>8</td>
<td></td>
</tr>
<tr>
<td>minIdle</td>
<td>资源池中的最少空闲连接数</td>
<td>0</td>
<td></td>
</tr>
<tr>
<td>blockWhenExhausted</td>
<td>当资源池用尽后，调用者是否要等待。只有当值为true时，下面的maxWaitMillis才会生效。</td>
<td>true</td>
<td>建议使用默认值</td>
</tr>
<tr>
<td>maxWaitMillis</td>
<td>当资源池连接用尽后，调用者的最大等待时间（单位为毫秒）。</td>
<td>-1（表示永不超时）</td>
<td>不建议使用默认值</td>
</tr>
<tr>
<td>testOnBorrow</td>
<td>向资源池借用连接时是否做连接有效性检测（ping）。检测到的无效连接将会被移除。</td>
<td>false</td>
<td>业务量很大时候建议设置为false，减少一次ping的开销。</td>
</tr>
<tr>
<td>testOnReturn</td>
<td>向资源池归还连接时是否做连接有效性检测（ping）。检测到无效连接将会被移除。</td>
<td>false</td>
<td>业务量很大时候建议设置为false，减少一次ping的开销。</td>
</tr>
<tr>
<td>jmxEnabled</td>
<td>是否开启JMX监控</td>
<td>true</td>
<td>建议开启，注意应用本身也需要开启。</td>
</tr>
<tr>
<td>testWhileIdle</td>
<td>是否开启空闲资源检测</td>
<td>false</td>
<td>建议开启</td>
</tr>
<tr>
<td>timeBetweenEvictionRunsMillis</td>
<td>空闲资源的检测周期（单位为毫秒）</td>
<td>-1（不检测）</td>
<td>建议设置</td>
</tr>
<tr>
<td>minEvictableIdleTimeMillis</td>
<td>资源池中资源的最小空闲时间（单位为毫秒），达到此值后空闲资源将被移除。</td>
<td>1800000（即30分钟）</td>
<td>可根据自身业务决定，一般默认值即可</td>
</tr>
<tr>
<td>numTestsPerEvictionRun</td>
<td>做空闲资源检测时，每次检测资源的个数。</td>
<td>3</td>
<td>可根据自身应用连接数进行微调，如果设置为 -1，就是对所有连接做空闲监测。</td>
</tr>
</tbody></table>
<h1 id="Redis-编程客户端-Lettuce"><a href="#Redis-编程客户端-Lettuce" class="headerlink" title="Redis  编程客户端 Lettuce"></a>Redis  编程客户端 Lettuce</h1><blockquote>
<p>Lettuce 官网地址：<a target="_blank" rel="noopener" href="https://lettuce.io.github/">https://lettuce.io。GitHub</a> 项目地址：<a target="_blank" rel="noopener" href="https://github.com/lettuce-io/lettuce-core">https://github.com/lettuce-io/lettuce-core</a></p>
<p>本章节Lettuce主要转载作者Throwable，文章链接在底部参考文献中。</p>
</blockquote>
<h2 id="1、Lettuce-简介"><a href="#1、Lettuce-简介" class="headerlink" title="1、Lettuce 简介"></a>1、Lettuce 简介</h2><p>Lettuce是一个高性能基于Java编写的Redis驱动框架，底层集成了Project Reactor提供自然的反应式编程，通讯框架集成了Netty使用了非阻塞IO，5.x版本以后融合了JDK1.8的异步编程特性，在保证高性能的同时提供了十分丰富易用的API，5.1版本的新特性以下：node</p>
<ul>
<li>支持Redis的新增命令ZPOPMIN、ZPOPMAX、BZPOPMIN、BZPOPMAX</li>
<li>支持经过Brave模块跟踪Redis命令执行</li>
<li>支持Redis Streams</li>
<li>支持异步的主从链接</li>
<li>支持异步链接池</li>
<li>新增命令最多执行一次模式（禁止自动重连）</li>
<li>全局命令超时设置（对异步和反应式命令也有效）</li>
<li>等等…</li>
</ul>
<p><strong>注意点</strong>：Redis的版本至少须要2.6，固然越高越好，API的兼容性比较强大。</p>
<p>想要使用Lettuce只需要引入单个依赖即可，如果需要连接池也可以增加依赖</p>
<pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;io.lettuce&lt;/groupId&gt;
    &lt;artifactId&gt;lettuce-core&lt;/artifactId&gt;
    &lt;version&gt;6.0.6.RELEASE&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<h2 id="2、Lettuce-连接-Redis"><a href="#2、Lettuce-连接-Redis" class="headerlink" title="2、Lettuce 连接 Redis"></a>2、Lettuce 连接 Redis</h2><h3 id="1、RedisURI-方式创建"><a href="#1、RedisURI-方式创建" class="headerlink" title="1、RedisURI 方式创建"></a>1、RedisURI 方式创建</h3><p>单机、哨兵、集群模式下连接<code>Redis</code>需要一个统一的标准去表示连接的细节信息，在Lettuce中这个统一的标准是RedisURI。可以通过三种方式构造一个RedisURI实例：</p>
<ol>
<li><p>使用create静态构造方式：</p>
<pre><code class="java">// 定制的字符串URI语法：
RedisURI uri = RedisURI.create(&quot;redis://localhost/&quot;);
// 直接使用静态方法构造
RedisURI uri = RedisURI.create(&quot;localhost&quot;,6379);
</code></pre>
</li>
<li><p>使用建造器（<code>RedisURI.Builder</code>）：</p>
<pre><code class="java">RedisURI uri = RedisURI.builder().withHost(&quot;localhost&quot;).withPort(6379).build();
</code></pre>
</li>
<li><p>直接经过构造函数实例化（<code>new RedisURI</code>）：</p>
<pre><code class="java">RedisURI uri = new RedisURI(&quot;localhost&quot;, 6379, 60, TimeUnit.SECONDS);
</code></pre>
</li>
</ol>
<hr>
<ol>
<li>使用create静态构造方式：<ul>
<li>定制的字符串<code>URI</code>语法：RedisURI uri &#x3D; RedisURI.create(“redis:&#x2F;&#x2F;localhost&#x2F;“);</li>
<li>直接使用静态方法构造：RedisURI redisURI &#x3D; RedisURI.create(“localhost”,6379);</li>
</ul>
</li>
<li>直接通过构造函数实例化：RedisURI redisURI &#x3D; new RedisURI(“localhost”, 6379, Duration.ofSeconds(60))</li>
<li>通过建造器RedisURI.builder（推荐）：RedisURI uri &#x3D; RedisURI.builder().withHost(“localhost”).withPort(6379).build();</li>
</ol>
<h3 id="2、定制的连接URI语法"><a href="#2、定制的连接URI语法" class="headerlink" title="2、定制的连接URI语法"></a>2、定制的连接URI语法</h3><ul>
<li>单机（前缀为<code>redis://</code>）</li>
</ul>
<pre><code class="shell">格式：redis://[password@]host[:port][/databaseNumber][?[timeout=timeout[d|h|m|s|ms|us|ns]]
完整：redis://mypassword@127.0.0.1:6379/0?timeout=10s
简单：redis://localhost
</code></pre>
<ul>
<li>单机并且使用<code>SSL</code>（前缀为<code>rediss://</code>）««« 注意后面多了个<code>s</code></li>
</ul>
<pre><code class="shell">格式：rediss://[password@]host[:port][/databaseNumber][?[timeout=timeout[d|h|m|s|ms|us|ns]]
完整：rediss://mypassword@127.0.0.1:6379/0?timeout=10s
简单：rediss://localhost
</code></pre>
<ul>
<li>单机<code>Unix Domain Sockets</code>模式（前缀为<code>redis-socket://</code>）</li>
</ul>
<pre><code class="shell">格式：redis-socket://path[?[timeout=timeout[d|h|m|s|ms|us|ns]][&amp;_database=database_]]
完整：redis-socket:///tmp/redis?timeout=10s&amp;_database=0
</code></pre>
<ul>
<li>哨兵（前缀为<code>redis-sentinel://</code>）</li>
</ul>
<pre><code class="shell">格式：redis-sentinel://[password@]host[:port][,host2[:port2]][/databaseNumber][?[timeout=timeout[d|h|m|s|ms|us|ns]]#sentinelMasterId
完整：redis-sentinel://mypassword@127.0.0.1:6379,127.0.0.1:6380/0?timeout=10s#mymaster
</code></pre>
<p>超时时间单位：d 天、h 小时、m 分钟、s 秒钟、ms 毫秒、us 微秒、ns 纳秒</p>
<p>个人建议使用RedisURI提供的建造器，毕竟定制的URI虽然简洁，但是比较容易出现人为错误。鉴于笔者没有SSL和Unix Domain Socket的使用场景，下面不对这两种连接方式进行列举。</p>
<h3 id="3、连接Redis基本使用"><a href="#3、连接Redis基本使用" class="headerlink" title="3、连接Redis基本使用"></a>3、连接Redis基本使用</h3><p>Lettuce 使用的时候依赖于四个主要组件：</p>
<ul>
<li>RedisURI：连接信息</li>
<li>RedisClient：Redis客户端。特殊的情况：集群连接有一个定制的 RedisClusterClient</li>
<li>Connection：Redis连接，主要是StatefulConnection 或者 StatefulRedisConnection 的子类，连接的类型主要由连接的具体方式（单机、哨兵、集群、订阅发布等等）选定，比较重要</li>
<li>RedisCommands：Redis命令API接口，<strong>基本上覆盖了<code>Redis</code>发行版本的所有命令</strong>，提供了同步（sync）、异步（async）、反应式（reative）的调用方式，对于使用者而言，会经常跟 RedisCommands 系列接口打交道。</li>
</ul>
<p>简单操作示例：</p>
<pre><code class="java">package com.xyz.redis;

import io.lettuce.core.RedisClient;
import io.lettuce.core.RedisURI;
import io.lettuce.core.SetArgs;
import io.lettuce.core.api.StatefulRedisConnection;
import io.lettuce.core.api.sync.RedisCommands;
import org.assertj.core.api.Assertions;
import java.time.Duration;
import java.time.temporal.ChronoUnit;

public class RedisServerConnectionDemo &#123;
    public static void main(String[] args) &#123;
        /**
         * 本案例使用的是方式一建造起创建的
         * 方式一：使用建造器（RedisURI.Builder）
         *   RedisURI uri = RedisURI.builder().withHost(&quot;localhost&quot;).withPort(6379).build();
         * 方式二：直接用静态方式构造
         *   RedisURI redisUri = new RedisURI(&quot;localhost&quot;, 6379, Duration.ofSeconds(60));
         * 方式三：定制的字符串URI语法
         *   RedisURI redisUri = RedisURI.create(&quot;redis://123456@127.0.0.1:6379/0?timeout=10s&quot;);
         * 方式三：使用create静态构造方式（URL）
         *   RedisURI redisUri = RedisURI.create(&quot;localhost&quot;,6379);
         * 认证信息配置
         *   redisUri.setPassword((CharSequence) &quot;123456&quot;);
         */
        // 步骤1：创建单机连接的连接信息
        RedisURI redisUri = RedisURI.builder()
                .withHost(&quot;localhost&quot;)
                .withPort(6379)
                .withTimeout(Duration.of(10, ChronoUnit.SECONDS))
                .withPassword((CharSequence) &quot;123456&quot;)
                .build();
        // 步骤2：创建客户端（构建RedisClient实例）
        RedisClient redisClient = RedisClient.create(redisUri);
        // 步骤3：创建连接（线程安全）
        StatefulRedisConnection&lt;String, String&gt; connection = redisClient.connect();
        System.out.println(&quot;【连接实例】&quot; + connection);

        // 步骤4：创建同步或异步命令，然后开始...其他操作
        RedisCommands&lt;String, String&gt; redisCommands = connection.sync();                // &lt;4&gt; 创建同步命令
        SetArgs setArgs = SetArgs.Builder.nx().ex(5);
        String result = redisCommands.set(&quot;name&quot;, &quot;xyz&quot;, setArgs);
        Assertions.assertThat(result).isEqualToIgnoringCase(&quot;OK&quot;);
        result = redisCommands.get(&quot;name&quot;);
        Assertions.assertThat(result).isEqualTo(&quot;xyz&quot;);

        // 步骤5：关闭数据库连接
        connection.close();
        // 步骤6：关闭Redis客户端
        redisClient.shutdown();
    &#125;
&#125;
</code></pre>
<p>注意：</p>
<ul>
<li>步骤5：关闭连接一般在应用程序停止之前操作，一个应用程序中的一个<code>Redis</code>驱动实例不需要太多的连接（一般情况下只需要一个连接实例就可以，如果有多个连接的需要可以考虑使用连接池，其实<code>Redis</code>目前处理命令的模块是单线程，在客户端多个连接多线程调用理论上没有效果）</li>
<li>步骤6：关闭客户端一般应用程序停止之前操作，如果条件允许的话，基于<strong>后开先闭</strong>原则，客户端关闭应该在连接关闭之后操作</li>
</ul>
<h2 id="3、Lettuce-API-操作"><a href="#3、Lettuce-API-操作" class="headerlink" title="3、Lettuce API 操作"></a>3、Lettuce API 操作</h2><p>Lettuce 主要提供三种 API：</p>
<ul>
<li>同步（sync）RedisCommands</li>
<li>异步（async）RedisAsyncCommands</li>
<li>反应式（reactive）RedisReactiveCommands</li>
</ul>
<p>Redis 命令 API 的具体实现可以直接从 StatefulRedisConnection 实例获取，见其接口定义</p>
<pre><code class="java">public interface StatefulRedisConnection&lt;K, V&gt; extends StatefulConnection&lt;K, V&gt; &#123;
    boolean isMulti();
    RedisCommands&lt;K, V&gt; sync();
    RedisAsyncCommands&lt;K, V&gt; async();
    RedisReactiveCommands&lt;K, V&gt; reactive();
&#125;
</code></pre>
<p>值得注意的是：在不指定编码解码器RedisCodec的前提下，RedisClient建立的StatefulRedisConnection实例通常是泛型实例<code>StatefulRedisConnection&lt;String,String&gt;</code>，也就是全部命令API的KEY和VALUE都是String类型，这种使用方式能知足大部分的使用场景。固然，必要的时候能够定制编码解码器<code>RedisCodec&lt;K,V&gt;</code>。</p>
<hr>
<p>先准备好一个单机Redis连接备用：</p>
<pre><code class="java">private static RedisClient CLIENT;
private static StatefulRedisConnection&lt;String, String&gt; CONNECTION;

@BeforeClass
public static void beforeClass() &#123;
    RedisURI redisUri = RedisURI.builder()
            .withHost(&quot;localhost&quot;)
            .withPort(6379)
            .withTimeout(Duration.of(10, ChronoUnit.SECONDS))
            .build();
    CLIENT = RedisClient.create(redisUri);
    CONNECTION = CLIENT.connect();
&#125;

@AfterClass
public static void afterClass() throws Exception &#123;
    CONNECTION.close();
    CLIENT.shutdown();
&#125;
</code></pre>
<h3 id="1、同步API"><a href="#1、同步API" class="headerlink" title="1、同步API"></a>1、同步API</h3><p>同步（sync）RedisCommands</p>
<pre><code class="java">@Test
public void testSyncPing() throws Exception &#123;
    RedisCommands&lt;String, String&gt; commands = connection.sync();
    String pong = commands.ping();
    Assertions.assertThat(pong).isEqualToIgnoringCase(&quot;PONG&quot;);
&#125;


@Test
public void testSyncSetAndGet() throws Exception &#123;
    RedisCommands&lt;String, String&gt; commands = connection.sync();
    SetArgs setArgs = SetArgs.Builder.nx().ex(5);
    commands.set(&quot;name&quot;, &quot;Sam&quot;, setArgs);
    String value = commands.get(&quot;name&quot;);
    log.info(&quot;Get value: &#123;&#125;&quot;, value);
&#125;
// Get value: Sam
</code></pre>
<p>同步API在所有命令调用之后会立即返回结果。如果熟悉Jedis的话，RedisCommands的用法其实和它相差不大。</p>
<h3 id="2、异步API"><a href="#2、异步API" class="headerlink" title="2、异步API"></a>2、异步API</h3><p>异步（async）RedisAsyncCommands</p>
<pre><code class="java">@Test
public void testAsyncPing() throws Exception &#123;
    RedisAsyncCommands&lt;String, String&gt; commands = connection.async();
    RedisFuture&lt;String&gt; redisFuture = commands.ping();
    log.info(&quot;Ping result:&#123;&#125;&quot;, redisFuture.get());
&#125;
// Ping result:PONG
</code></pre>
<p>RedisAsyncCommands所有方法执行返回结果都是RedisFuture实例，而RedisFuture接口的定义如下：</p>
<pre><code class="java">public interface RedisFuture&lt;V&gt; extends CompletionStage&lt;V&gt;, Future&lt;V&gt; &#123;
    String getError();
    boolean await(long timeout, TimeUnit unit) throws InterruptedException;
&#125;
</code></pre>
<p>也就是，RedisFuture可以无缝使用Future或者JDK1.8中引入的CompletableFuture提供的方法。举个例子：</p>
<pre><code class="java">@Test
public void testAsyncSetAndGet1() throws Exception &#123;
    RedisAsyncCommands&lt;String, String&gt; commands = connection.async();
    SetArgs setArgs = SetArgs.Builder.nx().ex(5);
    RedisFuture&lt;String&gt; future = commands.set(&quot;name&quot;, &quot;throwable&quot;, setArgs);
    // CompletableFuture#thenAccept()
    future.thenAccept(value -&gt; log.info(&quot;Set命令返回:&#123;&#125;&quot;, value));
    // Future#get()
    future.get();
&#125;
// Set命令返回:OK

@Test
public void testAsyncSetAndGet2() throws Exception &#123;
    RedisAsyncCommands&lt;String, String&gt; commands = connection.async();
    SetArgs setArgs = SetArgs.Builder.nx().ex(5);
    CompletableFuture&lt;Void&gt; result =
        (CompletableFuture&lt;Void&gt;) commands.set(&quot;name&quot;, &quot;throwable&quot;, setArgs)
        .thenAcceptBoth(commands.get(&quot;name&quot;),
                        (s, g) -&gt; &#123;
                            log.info(&quot;Set命令返回:&#123;&#125;&quot;, s);
                            log.info(&quot;Get命令返回:&#123;&#125;&quot;, g);
                        &#125;);
    result.get();
&#125;
// Set命令返回:OK
// Get命令返回:throwable
</code></pre>
<p>如果能熟练使用CompletableFuture和函数式编程技巧，可以组合多个RedisFuture完成一些列复杂的操作。</p>
<h3 id="3、反应式API"><a href="#3、反应式API" class="headerlink" title="3、反应式API"></a>3、反应式API</h3><p>反应式（reactive）RedisReactiveCommands。</p>
<p>Lettuce引入的反应式编程框架是<a target="_blank" rel="noopener" href="https://projectreactor.io/">Project Reactor</a>，如果没有反应式编程经验可以先自行了解一下Project Reactor</p>
<p>根据Project Reactor，RedisReactiveCommands的方法如果返回的结果只包含0或1个元素，那么返回值类型是Mono，如果返回的结果包含0到N（N大于0）个元素，那么返回值是Flux。举个例子：</p>
<pre><code class="java">@Test
public void testReactivePing() throws Exception &#123;
    RedisReactiveCommands&lt;String, String&gt; commands = connection.reactive();
    Mono&lt;String&gt; ping = commands.ping();
    ping.subscribe(v -&gt; log.info(&quot;Ping result:&#123;&#125;&quot;, v));
    Thread.sleep(1000);
&#125;
// Ping result:PONG

@Test
public void testReactiveSetAndGet() throws Exception &#123;
    RedisReactiveCommands&lt;String, String&gt; commands = connection.reactive();
    SetArgs setArgs = SetArgs.Builder.nx().ex(5);
    commands.set(&quot;name&quot;, &quot;Sam&quot;, setArgs).block();
    commands.get(&quot;name&quot;).subscribe(value -&gt; log.info(&quot;Get命令返回:&#123;&#125;&quot;, value));
    Thread.sleep(1000);
&#125;
// Get命令返回:Sam

@Test
public void testReactiveSet() throws Exception &#123;
    RedisReactiveCommands&lt;String, String&gt; commands = connection.reactive();
    commands.sadd(&quot;food&quot;, &quot;bread&quot;, &quot;meat&quot;, &quot;fish&quot;).block();
    Flux&lt;String&gt; flux = commands.smembers(&quot;food&quot;);
    flux.subscribe(log::info);
    commands.srem(&quot;food&quot;, &quot;bread&quot;, &quot;meat&quot;, &quot;fish&quot;).block();
    Thread.sleep(1000);
&#125;
// meat
// bread
// fish
</code></pre>
<p>举个更加复杂的例子，包含了事务、函数转换等：</p>
<pre><code class="java">@Test
public void testReactiveFunctional() throws Exception &#123;
    RedisReactiveCommands&lt;String, String&gt; commands = connection.reactive();
    commands.multi().doOnSuccess(r -&gt; &#123;
        commands.set(&quot;counter&quot;, &quot;1&quot;).doOnNext(log::info).subscribe();
        commands.incr(&quot;counter&quot;).doOnNext(c -&gt; log.info(String.valueOf(c))).subscribe();
    &#125;).flatMap(s -&gt; commands.exec())
        .doOnNext(transactionResult -&gt; log.info(&quot;Discarded:&#123;&#125;&quot;, transactionResult.wasDiscarded()))
        .subscribe();
    Thread.sleep(1000);
&#125;
// OK
// 2
// Discarded:false
</code></pre>
<p>这个方法开启一个事务，先把counter设置为1，再将counter自增1。</p>
<h3 id="4、发布和订阅"><a href="#4、发布和订阅" class="headerlink" title="4、发布和订阅"></a>4、发布和订阅</h3><p>非集群模式下的发布订阅依赖于定制的连接StatefulRedisPubSubConnection，集群模式下的发布订阅依赖于定制的连接StatefulRedisClusterPubSubConnection，两者分别来源于RedisClient#connectPubSub()系列方法和RedisClusterClient#connectPubSub()：</p>
<ul>
<li><p>非集群模式：</p>
<pre><code class="java">// 可能是单机、普通主从、哨兵等非集群模式的客户端
RedisClient client = ...;
StatefulRedisPubSubConnection&lt;String, String&gt; connection = client.connectPubSub();
// 监听订阅消息
connection.addListener(new RedisPubSubListener&lt;String, String&gt;() &#123; ... &#125;);

// 同步命令
RedisPubSubCommands&lt;String, String&gt; sync = connection.sync();
sync.subscribe(&quot;channel&quot;);

// 异步命令
RedisPubSubAsyncCommands&lt;String, String&gt; async = connection.async();
RedisFuture&lt;Void&gt; future = async.subscribe(&quot;channel&quot;);

// 反应式命令
RedisPubSubReactiveCommands&lt;String, String&gt; reactive = connection.reactive();
reactive.subscribe(&quot;channel&quot;).subscribe();

reactive.observeChannels().doOnNext(patternMessage -&gt; &#123;...&#125;).subscribe()
</code></pre>
</li>
<li><p>集群模式：</p>
<pre><code class="java">// 使用方式其实和非集群模式基本一致
RedisClusterClient clusterClient = ...;
StatefulRedisClusterPubSubConnection&lt;String, String&gt; connection = clusterClient.connectPubSub();
connection.addListener(new RedisPubSubListener&lt;String, String&gt;() &#123; ... &#125;);
RedisPubSubCommands&lt;String, String&gt; sync = connection.sync();
sync.subscribe(&quot;channel&quot;);
// ...
</code></pre>
</li>
<li><p>这里用单机同步命令的模式举一个<code>Redis</code>键空间通知（<a target="_blank" rel="noopener" href="https://redis.io/topics/notifications">Redis Keyspace Notifications</a>）的例子：</p>
<pre><code class="java">@Test
public void testSyncKeyspaceNotification() throws Exception &#123;
    RedisURI redisUri = RedisURI.builder()
            .withHost(&quot;localhost&quot;)
            .withPort(6379)
            .withDatabase(0) // 注意这里只能是0号库
            .withTimeout(Duration.of(10, ChronoUnit.SECONDS))
            .build();
    RedisClient redisClient = RedisClient.create(redisUri);
    StatefulRedisConnection&lt;String, String&gt; redisConnection = redisClient.connect();
    RedisCommands&lt;String, String&gt; redisCommands = redisConnection.sync();
    // 只接收键过期的事件
    redisCommands.configSet(&quot;notify-keyspace-events&quot;, &quot;Ex&quot;);
    StatefulRedisPubSubConnection&lt;String, String&gt; connection = redisClient.connectPubSub();
    connection.addListener(new RedisPubSubAdapter&lt;&gt;() &#123;

        @Override
        public void psubscribed(String pattern, long count) &#123;
            log.info(&quot;pattern:&#123;&#125;,count:&#123;&#125;&quot;, pattern, count);
        &#125;

        @Override
        public void message(String pattern, String channel, String message) &#123;
            log.info(&quot;pattern:&#123;&#125;,channel:&#123;&#125;,message:&#123;&#125;&quot;, pattern, channel, message);
        &#125;
    &#125;);
    RedisPubSubCommands&lt;String, String&gt; commands = connection.sync();
    commands.psubscribe(&quot;__keyevent@0__:expired&quot;);
    redisCommands.setex(&quot;name&quot;, 2, &quot;throwable&quot;);
    Thread.sleep(10000);
    redisConnection.close();
    connection.close();
    redisClient.shutdown();
&#125;
// pattern:__keyevent@0__:expired,count:1
// pattern:__keyevent@0__:expired,channel:__keyevent@0__:expired,message:name
</code></pre>
</li>
</ul>
<p>实际上，在实现RedisPubSubListener的时候可以单独抽离，尽量不要设计成匿名内部类的形式。</p>
<h3 id="5、事务和批量命令执行"><a href="#5、事务和批量命令执行" class="headerlink" title="5、事务和批量命令执行"></a>5、事务和批量命令执行</h3><p>事务相关的命令就是WATCH、UNWATCH、EXEC、MULTI和DISCARD，在RedisCommands系列接口中有对应的方法。举个例子：</p>
<pre><code class="java">// 同步模式
@Test
public void testSyncMulti() throws Exception &#123;
    RedisCommands&lt;String, String&gt; commands = connection.sync();
    commands.multi();
    commands.setex(&quot;name-1&quot;, 2, &quot;throwable&quot;);
    commands.setex(&quot;name-2&quot;, 2, &quot;doge&quot;);
    TransactionResult result = commands.exec();
    int index = 0;
    for (Object r : result) &#123;
        log.info(&quot;Result-&#123;&#125;:&#123;&#125;&quot;, index, r);
        index++;
    &#125;
&#125;
// Result-0:OK
// Result-1:OK
</code></pre>
<p>Redis的Pipeline也就是管道机制可以理解为把多个命令打包在一次请求发送到Redis服务端，然后Redis服务端把所有的响应结果打包好一次性返回，从而节省不必要的网络资源（最主要是减少网络请求次数）。Redis对于Pipeline机制如何实现并没有明确的规定，也没有提供特殊的命令支持Pipeline机制。Jedis中底层采用BIO（阻塞IO）通讯，所以它的做法是客户端缓存将要发送的命令，最后需要触发然后同步发送一个巨大的命令列表包，再接收和解析一个巨大的响应列表包。Pipeline在Lettuce中对使用者是透明的，由于底层的通讯框架是Netty，所以网络通讯层面的优化Lettuce不需要过多干预，换言之可以这样理解：Netty帮Lettuce从底层实现了Redis的Pipeline机制。但是，Lettuce的异步API也提供了手动Flush的方法：</p>
<pre><code class="java">@Test
public void testAsyncManualFlush() &#123;
    RedisAsyncCommands&lt;String, String&gt; async_commands = connection.async();
    // 取消自动flush
    async_commands.setAutoFlushCommands(false);
    List&lt;RedisFuture&lt;?&gt;&gt; redisFutures = Lists.newArrayList();
    int count = 5000;
    for (int i = 0; i &lt; count; i++) &#123;
        String key = &quot;key-&quot; + (i + 1);
        String value = &quot;value-&quot; + (i + 1);
        redisFutures.add(async_commands.set(key, value));
        redisFutures.add(async_commands.expire(key, 2));
    &#125;
    long start = System.currentTimeMillis();
    async_commands.flushCommands();
    boolean result = LettuceFutures.awaitAll(10, TimeUnit.SECONDS, redisFutures.toArray(new RedisFuture[0]));
    Assertions.assertThat(result).isTrue();
    log.info(&quot;Lettuce cost:&#123;&#125; ms&quot;, System.currentTimeMillis() - start);
&#125;
// Lettuce cost:1302 ms
</code></pre>
<p>上面只是从文档看到的一些理论术语，但是现实是骨感的，对比了下Jedis的Pipeline提供的方法，发现了Jedis的Pipeline执行耗时比较低：</p>
<pre><code class="java">@Test
public void testJedisPipeline() throws Exception &#123;
    Jedis jedis = new Jedis();
    Pipeline pipeline = jedis.pipelined();
    int count = 5000;
    for (int i = 0; i &lt; count; i++) &#123;
        String key = &quot;key-&quot; + (i + 1);
        String value = &quot;value-&quot; + (i + 1);
        pipeline.set(key, value);
        pipeline.expire(key, 2);
    &#125;
    long start = System.currentTimeMillis();
    pipeline.syncAndReturnAll();
    log.info(&quot;Jedis cost:&#123;&#125; ms&quot;, System.currentTimeMillis()  - start);
&#125;
// Jedis cost:9 ms
</code></pre>
<p>个人猜测Lettuce可能底层并非合并所有命令一次发送（甚至可能是单条发送），具体可能需要抓包才能定位。依此来看，如果真的有大量执行Redis命令的场景，不妨可以使用Jedis的Pipeline。</p>
<p><strong>注意</strong>：由上面的测试推断RedisTemplate的executePipelined()方法是<strong>假的</strong>Pipeline执行方法，使用RedisTemplate的时候请务必注意这一点。</p>
<h3 id="6、Lua脚本执行"><a href="#6、Lua脚本执行" class="headerlink" title="6、Lua脚本执行"></a>6、Lua脚本执行</h3><p>Lettuce中执行Redis的Lua命令的同步接口如下：</p>
<pre><code class="java">public interface RedisScriptingCommands&lt;K, V&gt; &#123;
    &lt;T&gt; T eval(String var1, ScriptOutputType var2, K... var3);

    &lt;T&gt; T eval(String var1, ScriptOutputType var2, K[] var3, V... var4);

    &lt;T&gt; T evalsha(String var1, ScriptOutputType var2, K... var3);

    &lt;T&gt; T evalsha(String var1, ScriptOutputType var2, K[] var3, V... var4);

    List&lt;Boolean&gt; scriptExists(String... var1);

    String scriptFlush();

    String scriptKill();

    String scriptLoad(V var1);

    String digest(V var1);
&#125;
</code></pre>
<p>异步和反应式的接口方法定义差不多，不同的地方就是返回值类型，一般我们常用的是eval()、evalsha()和scriptLoad()方法。举个例子：</p>
<pre><code class="java">private static String RAW_LUA = &quot;local key = KEYS[1]\n&quot; +
        &quot;local value = ARGV[1]\n&quot; +
        &quot;local timeout = ARGV[2]\n&quot; +
        &quot;redis.call(&#39;SETEX&#39;, key, tonumber(timeout), value)\n&quot; +
        &quot;local result = redis.call(&#39;GET&#39;, key)\n&quot; +
        &quot;return result;&quot;;
private static AtomicReference&lt;String&gt; LUA_SHA = new AtomicReference&lt;&gt;();

@Test
public void testLua() throws Exception &#123;
    RedisCommands&lt;String, String&gt; commands = connection.sync();
    LUA_SHA.compareAndSet(null, commands.scriptLoad(RAW_LUA));
    String[] keys = new String[]&#123;&quot;name&quot;&#125;;
    String[] args = new String[]&#123;&quot;Sam&quot;, &quot;5000&quot;&#125;;
    String result = commands.evalsha(LUA_SHA.get(), ScriptOutputType.VALUE, keys, args);
    log.info(&quot;Get value:&#123;&#125;&quot;, result);
&#125;
// Get value:Sam
</code></pre>
<h2 id="4、高可用和分片"><a href="#4、高可用和分片" class="headerlink" title="4、高可用和分片"></a>4、高可用和分片</h2><p>为了Redis的高可用，一般会采用普通主从（Master&#x2F;Replica，这里笔者称为普通主从模式，也就是仅仅做了主从复制，故障需要手动切换）、哨兵和集群。普通主从模式可以独立运行，也可以配合哨兵运行，只是哨兵提供自动故障转移和主节点提升功能。普通主从和哨兵都可以使用MasterSlave，通过入参包括RedisClient、编码解码器以及一个或者多个RedisURI获取对应的Connection实例。</p>
<p>这里<strong>注意一点</strong>，MasterSlave中提供的方法如果只要求传入一个RedisURI实例，那么Lettuce会进行<strong>拓扑发现机制</strong>，自动获取Redis主从节点信息；如果要求传入一个RedisURI集合，那么对于普通主从模式来说所有节点信息是静态的，不会进行发现和更新。</p>
<p><strong>拓扑发现的规则如下：</strong></p>
<ul>
<li>对于普通主从（Master&#x2F;Replica）模式，不需要感知RedisURI指向从节点还是主节点，只会进行一次性的拓扑查找所有节点信息，此后节点信息会保存在静态缓存中，不会更新。</li>
<li>对于哨兵模式，会订阅所有哨兵实例并侦听订阅&#x2F;发布消息以触发拓扑刷新机制，更新缓存的节点信息，也就是哨兵天然就是动态发现节点信息，不支持静态配置。</li>
</ul>
<p>拓扑发现机制的提供API为TopologyProvider，需要了解其原理的可以参考具体的实现。</p>
<p>对于集群（Cluster）模式，Lettuce提供了一套独立的API。</p>
<p>另外，如果Lettuce连接面向的是非单个Redis节点，连接实例提供了<strong>数据读取节点偏好</strong>（ReadFrom）设置，可选值有：</p>
<ul>
<li>MASTER：只从Master节点中读取</li>
<li>MASTER_PREFERRED：优先从Master节点中读取</li>
<li>SLAVE_PREFERRED：优先从Slavor节点中读取</li>
<li>SLAVE：只从Slavor节点中读取</li>
<li>NEAREST：使用最近一次连接的Redis实例读取</li>
</ul>
<h3 id="1、主从模式"><a href="#1、主从模式" class="headerlink" title="1、主从模式"></a>1、主从模式</h3><p>假设现在有三个<code>Redis</code>服务形成树状主从关系如下：</p>
<ul>
<li>节点一：localhost:6379，角色为Master</li>
<li>节点二：localhost:6380，角色为Slavor，节点一的从节点</li>
<li>节点三：localhost:6381，角色为Slavor，节点二的从节点</li>
</ul>
<p>首次动态节点发现主从模式的节点信息需要如下构建连接：</p>
<pre><code class="java">@Test
public void testDynamicReplica() throws Exception &#123;
    // 这里只需要配置一个节点的连接信息，不一定需要是主节点的信息，从节点也可以
    RedisURI uri = RedisURI.builder().withHost(&quot;localhost&quot;).withPort(6379).build();
    RedisClient redisClient = RedisClient.create(uri);
    StatefulRedisMasterSlaveConnection&lt;String, String&gt; connection = MasterSlave.connect(redisClient, new Utf8StringCodec(), uri);
    // 只从从节点读取数据
    connection.setReadFrom(ReadFrom.SLAVE);
    // 执行其他Redis命令
    connection.close();
    redisClient.shutdown();
&#125;
</code></pre>
<p>如果需要指定静态的Redis主从节点连接属性，那么可以这样构建连接：</p>
<pre><code class="java">@Test
public void testStaticReplica() throws Exception &#123;
    List&lt;RedisURI&gt; uris = new ArrayList&lt;&gt;();
    RedisURI uri1 = RedisURI.builder().withHost(&quot;localhost&quot;).withPort(6379).build();
    RedisURI uri2 = RedisURI.builder().withHost(&quot;localhost&quot;).withPort(6380).build();
    RedisURI uri3 = RedisURI.builder().withHost(&quot;localhost&quot;).withPort(6381).build();
    uris.add(uri1);
    uris.add(uri2);
    uris.add(uri3);
    RedisClient redisClient = RedisClient.create();
    StatefulRedisMasterSlaveConnection&lt;String, String&gt; connection = MasterSlave.connect(redisClient,
            new Utf8StringCodec(), uris);
    // 只从主节点读取数据
    connection.setReadFrom(ReadFrom.MASTER);
    // 执行其他Redis命令
    connection.close();
    redisClient.shutdown();
&#125;
</code></pre>
<h3 id="2、哨兵模式"><a href="#2、哨兵模式" class="headerlink" title="2、哨兵模式"></a>2、哨兵模式</h3><p>由于Lettuce自身提供了哨兵的拓扑发现机制，所以只需要随便配置一个哨兵节点的RedisURI实例即可：</p>
<pre><code class="java">@Test
public void testDynamicSentinel() throws Exception &#123;
    RedisURI redisUri = RedisURI.builder()
            .withPassword(&quot;yourPassword&quot;)
            .withSentinel(&quot;localhost&quot;, 26379)
            .withSentinelMasterId(&quot;哨兵Master的ID&quot;)
            .build();
    RedisClient redisClient = RedisClient.create();
    StatefulRedisMasterSlaveConnection&lt;String, String&gt; connection = MasterSlave.connect(redisClient, new Utf8StringCodec(), redisUri);
    // 只允许从从节点读取数据
    connection.setReadFrom(ReadFrom.SLAVE);
    RedisCommands&lt;String, String&gt; command = connection.sync();
    SetArgs setArgs = SetArgs.Builder.nx().ex(5);
    command.set(&quot;name&quot;, &quot;throwable&quot;, setArgs);
    String value = command.get(&quot;name&quot;);
    log.info(&quot;Get value:&#123;&#125;&quot;, value);
&#125;
// Get value:throwable
</code></pre>
<h3 id="3、集群模式"><a href="#3、集群模式" class="headerlink" title="3、集群模式"></a>3、集群模式</h3><p>Redis Cluster模式下的API使用本身就有比较多的限制，这里只简单介绍一下怎么用。先说几个特性：</p>
<p><strong>下面的API提供跨槽位（<code>Slot</code>）调用的功能</strong>：</p>
<ul>
<li>RedisAdvancedClusterCommands</li>
<li>RedisAdvancedClusterAsyncCommands</li>
<li>RedisAdvancedClusterReactiveCommands</li>
</ul>
<p><strong>静态节点选择功能：</strong></p>
<ul>
<li>masters：选择所有主节点执行命令</li>
<li>slaves：选择所有从节点执行命令，其实就是只读模式</li>
<li>all nodes：命令可以在所有节点执行</li>
</ul>
<p><strong>集群拓扑视图动态更新功能：</strong></p>
<ul>
<li>手动更新，主动调用RedisClusterClient#reloadPartitions()</li>
<li>后台定时更新</li>
<li>自适应更新，基于连接断开和<code>MOVED/ASK</code>命令重定向自动更新</li>
</ul>
<p>Redis集群搭建详细过程可以参考官方文档，假设已经搭建好集群如下（192.168.56.200是笔者的虚拟机Host）：</p>
<ul>
<li>192.168.56.200:7001 »» 主节点，槽位0-5460</li>
<li>192.168.56.200:7002 »» 主节点，槽位5461-10922</li>
<li>192.168.56.200:7003 »» 主节点，槽位10923-16383</li>
<li>192.168.56.200:7004 »» 7001的从节点</li>
<li>192.168.56.200:7005 »» 7002的从节点</li>
<li>192.168.56.200:7006 »» 7003的从节点</li>
</ul>
<p>简单的集群连接和使用方式如下：</p>
<pre><code class="java">@Test
public void testSyncCluster()&#123;
    RedisURI uri = RedisURI.builder().withHost(&quot;192.168.56.200&quot;).build();
    RedisClusterClient redisClusterClient = RedisClusterClient.create(uri);
    StatefulRedisClusterConnection&lt;String, String&gt; connection = redisClusterClient.connect();
    RedisAdvancedClusterCommands&lt;String, String&gt; commands = connection.sync();
    commands.setex(&quot;name&quot;,10, &quot;throwable&quot;);
    String value = commands.get(&quot;name&quot;);
    log.info(&quot;Get value:&#123;&#125;&quot;, value);
&#125;
// Get value:throwable
</code></pre>
<p>节点选择：</p>
<pre><code class="java">@Test
public void testSyncNodeSelection() &#123;
    RedisURI uri = RedisURI.builder().withHost(&quot;192.168.56.200&quot;).withPort(7001).build();
    RedisClusterClient redisClusterClient = RedisClusterClient.create(uri);
    StatefulRedisClusterConnection&lt;String, String&gt; connection = redisClusterClient.connect();
    RedisAdvancedClusterCommands&lt;String, String&gt; commands = connection.sync();
    //  commands.all();  // 所有节点
    //  commands.masters();  // 主节点
    // 从节点只读
    NodeSelection&lt;String, String&gt; replicas = commands.slaves();
    NodeSelectionCommands&lt;String, String&gt; nodeSelectionCommands = replicas.commands();
    // 这里只是演示,一般应该禁用keys *命令
    Executions&lt;List&lt;String&gt;&gt; keys = nodeSelectionCommands.keys(&quot;*&quot;);
    keys.forEach(key -&gt; log.info(&quot;key: &#123;&#125;&quot;, key));
    connection.close();
    redisClusterClient.shutdown();
&#125;
</code></pre>
<p>定时更新集群拓扑视图（每隔十分钟更新一次，这个时间自行考量，不能太频繁）：</p>
<pre><code class="java">@Test
public void testPeriodicClusterTopology() throws Exception &#123;
    RedisURI uri = RedisURI.builder().withHost(&quot;192.168.56.200&quot;).withPort(7001).build();
    RedisClusterClient redisClusterClient = RedisClusterClient.create(uri);
    ClusterTopologyRefreshOptions options = ClusterTopologyRefreshOptions
            .builder()
            .enablePeriodicRefresh(Duration.of(10, ChronoUnit.MINUTES))
            .build();
    redisClusterClient.setOptions(ClusterClientOptions.builder().topologyRefreshOptions(options).build());
    StatefulRedisClusterConnection&lt;String, String&gt; connection = redisClusterClient.connect();
    RedisAdvancedClusterCommands&lt;String, String&gt; commands = connection.sync();
    commands.setex(&quot;name&quot;, 10, &quot;throwable&quot;);
    String value = commands.get(&quot;name&quot;);
    log.info(&quot;Get value:&#123;&#125;&quot;, value);
    Thread.sleep(Integer.MAX_VALUE);
    connection.close();
    redisClusterClient.shutdown();
&#125;
</code></pre>
<p>自适应更新集群拓扑视图：</p>
<pre><code class="java">@Test
public void testAdaptiveClusterTopology() throws Exception &#123;
    RedisURI uri = RedisURI.builder().withHost(&quot;192.168.56.200&quot;).withPort(7001).build();
    RedisClusterClient redisClusterClient = RedisClusterClient.create(uri);
    ClusterTopologyRefreshOptions options = ClusterTopologyRefreshOptions.builder()
            .enableAdaptiveRefreshTrigger(
                    ClusterTopologyRefreshOptions.RefreshTrigger.MOVED_REDIRECT,
                    ClusterTopologyRefreshOptions.RefreshTrigger.PERSISTENT_RECONNECTS
            )
            .adaptiveRefreshTriggersTimeout(Duration.of(30, ChronoUnit.SECONDS))
            .build();
    redisClusterClient.setOptions(ClusterClientOptions.builder().topologyRefreshOptions(options).build());
    StatefulRedisClusterConnection&lt;String, String&gt; connection = redisClusterClient.connect();
    RedisAdvancedClusterCommands&lt;String, String&gt; commands = connection.sync();
    commands.setex(&quot;name&quot;, 10, &quot;throwable&quot;);
    String value = commands.get(&quot;name&quot;);
    log.info(&quot;Get value:&#123;&#125;&quot;, value);
    Thread.sleep(Integer.MAX_VALUE);
    connection.close();
    redisClusterClient.shutdown();
&#125;
</code></pre>
<h2 id="5、动态命令和自定义命令"><a href="#5、动态命令和自定义命令" class="headerlink" title="5、动态命令和自定义命令"></a>5、动态命令和自定义命令</h2><p>自定义命令是<code>Redis</code>命令有限集，不过可以更细粒度指定<code>KEY</code>、<code>ARGV</code>、命令类型、编码解码器和返回值类型，依赖于<code>dispatch()</code>方法：</p>
<pre><code class="java">// 自定义实现PING方法
@Test
public void testCustomPing() throws Exception &#123;
    RedisURI redisUri = RedisURI.builder()
            .withHost(&quot;localhost&quot;)
            .withPort(6379)
            .withTimeout(Duration.of(10, ChronoUnit.SECONDS))
            .build();
    RedisClient redisClient = RedisClient.create(redisUri);
    StatefulRedisConnection&lt;String, String&gt; connect = redisClient.connect();
    RedisCommands&lt;String, String&gt; sync = connect.sync();
    RedisCodec&lt;String, String&gt; codec = StringCodec.UTF8;
    String result = sync.dispatch(CommandType.PING, new StatusOutput&lt;&gt;(codec));
    log.info(&quot;PING:&#123;&#125;&quot;, result);
    connect.close();
    redisClient.shutdown();
&#125;
// PING:PONG

// 自定义实现Set方法
@Test
public void testCustomSet() throws Exception &#123;
    RedisURI redisUri = RedisURI.builder()
            .withHost(&quot;localhost&quot;)
            .withPort(6379)
            .withTimeout(Duration.of(10, ChronoUnit.SECONDS))
            .build();
    RedisClient redisClient = RedisClient.create(redisUri);
    StatefulRedisConnection&lt;String, String&gt; connect = redisClient.connect();
    RedisCommands&lt;String, String&gt; sync = connect.sync();
    RedisCodec&lt;String, String&gt; codec = StringCodec.UTF8;
    sync.dispatch(CommandType.SETEX, new StatusOutput&lt;&gt;(codec),
            new CommandArgs&lt;&gt;(codec).addKey(&quot;name&quot;).add(5).addValue(&quot;throwable&quot;));
    String result = sync.get(&quot;name&quot;);
    log.info(&quot;Get value:&#123;&#125;&quot;, result);
    connect.close();
    redisClient.shutdown();
&#125;
// Get value:throwable
</code></pre>
<p>动态命令是基于Redis命令有限集，并且通过注解和动态代理完成一些复杂命令组合的实现。主要注解在<code>io.lettuce.core.dynamic.annotation</code>包路径下。举个例子：</p>
<pre><code class="java">public interface CustomCommand extends Commands &#123;

    // SET [key] [value]
    @Command(&quot;SET ?0 ?1&quot;)
    String setKey(String key, String value);

    // SET [key] [value]
    @Command(&quot;SET :key :value&quot;)
    String setKeyNamed(@Param(&quot;key&quot;) String key, @Param(&quot;value&quot;) String value);

    // MGET [key1] [key2]
    @Command(&quot;MGET ?0 ?1&quot;)
    List&lt;String&gt; mGet(String key1, String key2);
    /**
     * 方法名作为命令
     */
    @CommandNaming(strategy = CommandNaming.Strategy.METHOD_NAME)
    String mSet(String key1, String value1, String key2, String value2);
&#125;


@Test
public void testCustomDynamicSet() throws Exception &#123;
    RedisURI redisUri = RedisURI.builder()
            .withHost(&quot;localhost&quot;)
            .withPort(6379)
            .withTimeout(Duration.of(10, ChronoUnit.SECONDS))
            .build();
    RedisClient redisClient = RedisClient.create(redisUri);
    StatefulRedisConnection&lt;String, String&gt; connect = redisClient.connect();
    RedisCommandFactory commandFactory = new RedisCommandFactory(connect);
    CustomCommand commands = commandFactory.getCommands(CustomCommand.class);
    commands.setKey(&quot;name&quot;, &quot;throwable&quot;);
    commands.setKeyNamed(&quot;throwable&quot;, &quot;doge&quot;);
    log.info(&quot;MGET ===&gt; &quot; + commands.mGet(&quot;name&quot;, &quot;throwable&quot;));
    commands.mSet(&quot;key1&quot;, &quot;value1&quot;,&quot;key2&quot;, &quot;value2&quot;);
    log.info(&quot;MGET ===&gt; &quot; + commands.mGet(&quot;key1&quot;, &quot;key2&quot;));
    connect.close();
    redisClient.shutdown();
&#125;
// MGET ===&gt; [throwable, doge]
// MGET ===&gt; [value1, value2]
</code></pre>
<h2 id="6、Lettuce的高级特性"><a href="#6、Lettuce的高级特性" class="headerlink" title="6、Lettuce的高级特性"></a>6、Lettuce的高级特性</h2><p>Lettuce有很多高阶使用特性，这里只列举个人认为常用的两点：</p>
<ul>
<li>配置客户端资源</li>
<li>使用连接池</li>
</ul>
<p>更多其他特性可以自行参看官方文档</p>
<h3 id="1、配置客户端资源"><a href="#1、配置客户端资源" class="headerlink" title="1、配置客户端资源"></a>1、配置客户端资源</h3><p>客户端资源的设置与Lettuce的性能、并发和事件处理相关。线程池或者线程组相关配置占据客户端资源配置的大部分（EventLoopGroups和EventExecutorGroup），这些线程池或者线程组是连接程序的基础组件。一般情况下，客户端资源应该在多个Redis客户端之间共享，并且在不再使用的时候需要自行关闭。笔者认为，客户端资源是面向Netty的。<strong>注意</strong>：除非特别熟悉或者花长时间去测试调整下面提到的参数，否则在没有经验的前提下凭直觉修改默认值，有可能会踩坑。</p>
<p>客户端资源接口是ClientResources，实现类是DefaultClientResources。构建DefaultClientResources实例：</p>
<pre><code class="java">// 默认
ClientResources resources = DefaultClientResources.create();
// 建造器
ClientResources resources = DefaultClientResources.builder()
                        .ioThreadPoolSize(4)
                        .computationThreadPoolSize(4)
                        .build();
</code></pre>
<p>使用：</p>
<pre><code class="java">ClientResources resources = DefaultClientResources.create();
// 非集群
RedisClient client = RedisClient.create(resources, uri);
// 集群
RedisClusterClient clusterClient = RedisClusterClient.create(resources, uris);
// ......
client.shutdown();
clusterClient.shutdown();
// 关闭资源
resources.shutdown();
</code></pre>
<p>客户端资源基本配置：</p>
<table>
<thead>
<tr>
<th align="center">属性</th>
<th align="center">描述</th>
<th align="center">默认值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ioThreadPoolSize</td>
<td align="center"><code>I/O</code>线程数</td>
<td align="center">Runtime.getRuntime().availableProcessors()</td>
</tr>
<tr>
<td align="center">computationThreadPoolSize</td>
<td align="center">任务线程数</td>
<td align="center">Runtime.getRuntime().availableProcessors()</td>
</tr>
</tbody></table>
<p>客户端资源高级配置：</p>
<table>
<thead>
<tr>
<th align="center">属性</th>
<th align="center">描述</th>
<th align="center">默认值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">eventLoopGroupProvider</td>
<td align="center">EventLoopGroup提供商</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center">eventExecutorGroupProvider</td>
<td align="center">EventExecutorGroup提供商</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center">eventBus</td>
<td align="center">事件总线</td>
<td align="center">DefaultEventBus</td>
</tr>
<tr>
<td align="center">commandLatencyCollectorOptions</td>
<td align="center">命令延时收集器配置</td>
<td align="center">DefaultCommandLatencyCollectorOptions</td>
</tr>
<tr>
<td align="center">commandLatencyCollector</td>
<td align="center">命令延时收集器</td>
<td align="center">DefaultCommandLatencyCollector</td>
</tr>
<tr>
<td align="center">commandLatencyPublisherOptions</td>
<td align="center">命令延时发布器配置</td>
<td align="center">DefaultEventPublisherOptions</td>
</tr>
<tr>
<td align="center">dnsResolver</td>
<td align="center"><code>DNS</code>处理器</td>
<td align="center">JDK或者Netty提供</td>
</tr>
<tr>
<td align="center">reconnectDelay</td>
<td align="center">重连延时配置</td>
<td align="center">Delay.exponential()</td>
</tr>
<tr>
<td align="center">nettyCustomizer</td>
<td align="center"><code>Netty</code>自定义配置器</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center">tracing</td>
<td align="center">轨迹记录器</td>
<td align="center">-</td>
</tr>
</tbody></table>
<p>非集群客户端<code>RedisClient</code>的属性配置：</p>
<p>Redis非集群客户端RedisClient本身提供了配置属性方法：</p>
<pre><code class="java">RedisClient client = RedisClient.create(uri);
client.setOptions(ClientOptions.builder()
                       .autoReconnect(false)
                       .pingBeforeActivateConnection(true)
                       .build());
</code></pre>
<p>非集群客户端的配置属性列表：</p>
<table>
<thead>
<tr>
<th align="center">属性</th>
<th align="center">描述</th>
<th align="center">默认值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">pingBeforeActivateConnection</td>
<td align="center">连接激活之前是否执行<code>PING</code>命令</td>
<td align="center">false</td>
</tr>
<tr>
<td align="center">autoReconnect</td>
<td align="center">是否自动重连</td>
<td align="center">true</td>
</tr>
<tr>
<td align="center">cancelCommandsOnReconnectFailure</td>
<td align="center">重连失败是否拒绝命令执行</td>
<td align="center">false</td>
</tr>
<tr>
<td align="center">suspendReconnectOnProtocolFailure</td>
<td align="center">底层协议失败是否挂起重连操作</td>
<td align="center">false</td>
</tr>
<tr>
<td align="center">requestQueueSize</td>
<td align="center">请求队列容量</td>
<td align="center">2147483647(Integer#MAX_VALUE)</td>
</tr>
<tr>
<td align="center">disconnectedBehavior</td>
<td align="center">失去连接时候的行为</td>
<td align="center">DEFAULT</td>
</tr>
<tr>
<td align="center">sslOptions</td>
<td align="center">SSL配置</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center">socketOptions</td>
<td align="center">Socket配置</td>
<td align="center">10 seconds Connection-Timeout, no keep-alive, no TCP noDelay</td>
</tr>
<tr>
<td align="center">timeoutOptions</td>
<td align="center">超时配置</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center">publishOnScheduler</td>
<td align="center">发布反应式信号数据的调度器</td>
<td align="center">使用<code>I/O</code>线程</td>
</tr>
</tbody></table>
<p><strong>集群客户端属性配置：</strong></p>
<p>Redis集群客户端RedisClusterClient本身提供了配置属性方法：</p>
<pre><code class="java">RedisClusterClient client = RedisClusterClient.create(uri);
ClusterTopologyRefreshOptions topologyRefreshOptions = ClusterTopologyRefreshOptions.builder()
                .enablePeriodicRefresh(refreshPeriod(10, TimeUnit.MINUTES))
                .enableAllAdaptiveRefreshTriggers()
                .build();

client.setOptions(ClusterClientOptions.builder()
                       .topologyRefreshOptions(topologyRefreshOptions)
                       .build());
</code></pre>
<p>集群客户端的配置属性列表：</p>
<table>
<thead>
<tr>
<th align="center">属性</th>
<th align="center">描述</th>
<th align="center">默认值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">enablePeriodicRefresh</td>
<td align="center">是否允许周期性更新集群拓扑视图</td>
<td align="center">false</td>
</tr>
<tr>
<td align="center">refreshPeriod</td>
<td align="center">更新集群拓扑视图周期</td>
<td align="center">60秒</td>
</tr>
<tr>
<td align="center">enableAdaptiveRefreshTrigger</td>
<td align="center">设置自适应更新集群拓扑视图触发器<code>RefreshTrigger</code></td>
<td align="center">-</td>
</tr>
<tr>
<td align="center">adaptiveRefreshTriggersTimeout</td>
<td align="center">自适应更新集群拓扑视图触发器超时设置</td>
<td align="center">30秒</td>
</tr>
<tr>
<td align="center">refreshTriggersReconnectAttempts</td>
<td align="center">自适应更新集群拓扑视图触发重连次数</td>
<td align="center">5</td>
</tr>
<tr>
<td align="center">dynamicRefreshSources</td>
<td align="center">是否允许动态刷新拓扑资源</td>
<td align="center">true</td>
</tr>
<tr>
<td align="center">closeStaleConnections</td>
<td align="center">是否允许关闭陈旧的连接</td>
<td align="center">true</td>
</tr>
<tr>
<td align="center">maxRedirects</td>
<td align="center">集群重定向次数上限</td>
<td align="center">5</td>
</tr>
<tr>
<td align="center">validateClusterNodeMembership</td>
<td align="center">是否校验集群节点的成员关系</td>
<td align="center">true</td>
</tr>
</tbody></table>
<h3 id="2、使用连接池配置"><a href="#2、使用连接池配置" class="headerlink" title="2、使用连接池配置"></a>2、使用连接池配置</h3><p>引入连接池依赖commons-pool2：</p>
<pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;
    &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt;
    &lt;version&gt;2.8.0&lt;/version&gt;
&lt;/dependency
</code></pre>
<p>基本使用如下：</p>
<pre><code class="java">@Test
public void testUseConnectionPool() throws Exception &#123;
    RedisURI redisUri = RedisURI.builder()
            .withHost(&quot;localhost&quot;)
            .withPort(6379)
            .withTimeout(Duration.of(10, ChronoUnit.SECONDS))
            .build();
    RedisClient redisClient = RedisClient.create(redisUri);
    GenericObjectPoolConfig poolConfig = new GenericObjectPoolConfig();
    GenericObjectPool&lt;StatefulRedisConnection&lt;String, String&gt;&gt; pool
            = ConnectionPoolSupport.createGenericObjectPool(redisClient::connect, poolConfig);
    try (StatefulRedisConnection&lt;String, String&gt; connection = pool.borrowObject()) &#123;
        RedisCommands&lt;String, String&gt; command = connection.sync();
        SetArgs setArgs = SetArgs.Builder.nx().ex(5);
        command.set(&quot;name&quot;, &quot;Sam&quot;, setArgs);
        String n = command.get(&quot;name&quot;);
        log.info(&quot;Get value:&#123;&#125;&quot;, n);
    &#125;
    pool.close();
    redisClient.shutdown();
&#125;
</code></pre>
<p>其中，同步连接的池化支持需要用ConnectionPoolSupport，异步连接的池化支持需要用AsyncConnectionPoolSupport（Lettuce5.1之后才支持）</p>
<h2 id="7、常见的渐进式删除案例"><a href="#7、常见的渐进式删除案例" class="headerlink" title="7、常见的渐进式删除案例"></a>7、常见的渐进式删除案例</h2><p>1、渐进式删除Hash中的域-属性：</p>
<pre><code class="java">@Test
public void testDelBigHashKey() throws Exception &#123;
    // SCAN参数
    ScanArgs scanArgs = ScanArgs.Builder.limit(2);
    // TEMP游标
    ScanCursor cursor = ScanCursor.INITIAL;
    // 目标KEY
    String key = &quot;BIG_HASH_KEY&quot;;
    prepareHashTestData(key);
    log.info(&quot;开始渐进式删除Hash的元素...&quot;);
    int counter = 0;
    do &#123;
        MapScanCursor&lt;String, String&gt; result = COMMAND.hscan(key, cursor, scanArgs);
        // 重置TEMP游标
        cursor = ScanCursor.of(result.getCursor());
        cursor.setFinished(result.isFinished());
        Collection&lt;String&gt; fields = result.getMap().values();
        if (!fields.isEmpty()) &#123;
            COMMAND.hdel(key, fields.toArray(new String[0]));
        &#125;
        counter++;
    &#125; while (!(ScanCursor.FINISHED.getCursor().equals(cursor.getCursor()) &amp;&amp; ScanCursor.FINISHED.isFinished() == cursor.isFinished()));
    log.info(&quot;渐进式删除Hash的元素完毕,迭代次数:&#123;&#125; ...&quot;, counter);
&#125;

private void prepareHashTestData(String key) throws Exception &#123;
    COMMAND.hset(key, &quot;1&quot;, &quot;1&quot;);
    COMMAND.hset(key, &quot;2&quot;, &quot;2&quot;);
    COMMAND.hset(key, &quot;3&quot;, &quot;3&quot;);
    COMMAND.hset(key, &quot;4&quot;, &quot;4&quot;);
    COMMAND.hset(key, &quot;5&quot;, &quot;5&quot;);
&#125;
</code></pre>
<p>2、渐进式删除集合中的元素：</p>
<pre><code class="java">@Test
public void testDelBigSetKey() throws Exception &#123;
    String key = &quot;BIG_SET_KEY&quot;;
    prepareSetTestData(key);
    // SCAN参数
    ScanArgs scanArgs = ScanArgs.Builder.limit(2);
    // TEMP游标
    ScanCursor cursor = ScanCursor.INITIAL;
    log.info(&quot;开始渐进式删除Set的元素...&quot;);
    int counter = 0;
    do &#123;
        ValueScanCursor&lt;String&gt; result = COMMAND.sscan(key, cursor, scanArgs);
        // 重置TEMP游标
        cursor = ScanCursor.of(result.getCursor());
        cursor.setFinished(result.isFinished());
        List&lt;String&gt; values = result.getValues();
        if (!values.isEmpty()) &#123;
            COMMAND.srem(key, values.toArray(new String[0]));
        &#125;
        counter++;
    &#125; while (!(ScanCursor.FINISHED.getCursor().equals(cursor.getCursor()) &amp;&amp; ScanCursor.FINISHED.isFinished() == cursor.isFinished()));
    log.info(&quot;渐进式删除Set的元素完毕,迭代次数:&#123;&#125; ...&quot;, counter);
&#125;

private void prepareSetTestData(String key) throws Exception &#123;
    COMMAND.sadd(key, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;);
&#125;
</code></pre>
<p>3、渐进式删除有序集合中的元素：</p>
<pre><code class="java">@Test
public void testDelBigZSetKey() throws Exception &#123;
    // SCAN参数
    ScanArgs scanArgs = ScanArgs.Builder.limit(2);
    // TEMP游标
    ScanCursor cursor = ScanCursor.INITIAL;
    // 目标KEY
    String key = &quot;BIG_ZSET_KEY&quot;;
    prepareZSetTestData(key);
    log.info(&quot;开始渐进式删除ZSet的元素...&quot;);
    int counter = 0;
    do &#123;
        ScoredValueScanCursor&lt;String&gt; result = COMMAND.zscan(key, cursor, scanArgs);
        // 重置TEMP游标
        cursor = ScanCursor.of(result.getCursor());
        cursor.setFinished(result.isFinished());
        List&lt;ScoredValue&lt;String&gt;&gt; scoredValues = result.getValues();
        if (!scoredValues.isEmpty()) &#123;
            COMMAND.zrem(key, scoredValues.stream().map(ScoredValue&lt;String&gt;::getValue).toArray(String[]::new));
        &#125;
        counter++;
    &#125; while (!(ScanCursor.FINISHED.getCursor().equals(cursor.getCursor()) &amp;&amp; ScanCursor.FINISHED.isFinished() == cursor.isFinished()));
    log.info(&quot;渐进式删除ZSet的元素完毕,迭代次数:&#123;&#125; ...&quot;, counter);
&#125;

private void prepareZSetTestData(String key) throws Exception &#123;
    COMMAND.zadd(key, 0, &quot;1&quot;);
    COMMAND.zadd(key, 0, &quot;2&quot;);
    COMMAND.zadd(key, 0, &quot;3&quot;);
    COMMAND.zadd(key, 0, &quot;4&quot;);
    COMMAND.zadd(key, 0, &quot;5&quot;);
&#125;
</code></pre>
<h2 id="8、SpringBoot整合Lettuce"><a href="#8、SpringBoot整合Lettuce" class="headerlink" title="8、SpringBoot整合Lettuce"></a>8、SpringBoot整合Lettuce</h2><p>个人认为，spring-data-redis中的API封装并不是很优秀，用起来比较重，不够灵活，这里结合前面的例子和代码，在SpringBoot脚手架项目中配置和整合Lettuce。先引入依赖：</p>
<pre><code class="xml">&lt;dependencyManagement&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt;
            &lt;version&gt;2.5.0.RELEASE&lt;/version&gt;
            &lt;type&gt;pom&lt;/type&gt;
            &lt;scope&gt;import&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/dependencyManagement&gt;
&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;io.lettuce&lt;/groupId&gt;
        &lt;artifactId&gt;lettuce-core&lt;/artifactId&gt;
        &lt;version&gt;5.1.8.RELEASE&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
        &lt;artifactId&gt;lombok&lt;/artifactId&gt;
        &lt;version&gt;1.18.10&lt;/version&gt;
        &lt;scope&gt;provided&lt;/scope&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;        
</code></pre>
<p>一般情况下，每个应用应该使用单个Redis客户端实例和单个连接实例，这里设计一个脚手架，适配单机、普通主从、哨兵和集群四种使用场景。对于客户端资源，采用默认的实现即可。对于Redis的连接属性，比较主要的有Host、Port和Password，其他可以暂时忽略。基于约定大于配置的原则，先定制一系列属性配置类（其实有些配置是可以完全共用，但是考虑到要清晰描述类之间的关系，这里拆分多个配置属性类和多个配置方法）：</p>
<pre><code class="java">@Data
@ConfigurationProperties(prefix = &quot;lettuce&quot;)
public class LettuceProperties &#123;
    private LettuceSingleProperties single;
    private LettuceReplicaProperties replica;
    private LettuceSentinelProperties sentinel;
    private LettuceClusterProperties cluster;
&#125;

@Data
public class LettuceSingleProperties &#123;
    private String host;
    private Integer port;
    private String password;
&#125;

@EqualsAndHashCode(callSuper = true)
@Data
public class LettuceReplicaProperties extends LettuceSingleProperties &#123;

&#125;

@EqualsAndHashCode(callSuper = true)
@Data
public class LettuceSentinelProperties extends LettuceSingleProperties &#123;
    private String masterId;
&#125;

@EqualsAndHashCode(callSuper = true)
@Data
public class LettuceClusterProperties extends LettuceSingleProperties &#123;

&#125;
</code></pre>
<p>配置类如下，主要使用@ConditionalOnProperty做隔离，一般情况下，很少有人会在一个应用使用一种以上的Redis连接场景：</p>
<pre><code class="java">@RequiredArgsConstructor
@Configuration
@ConditionalOnClass(name = &quot;io.lettuce.core.RedisURI&quot;)
@EnableConfigurationProperties(value = LettuceProperties.class)
public class LettuceAutoConfiguration &#123;

    private final LettuceProperties lettuceProperties;

    @Bean(destroyMethod = &quot;shutdown&quot;)
    public ClientResources clientResources() &#123;
        return DefaultClientResources.create();
    &#125;

    @Bean
    @ConditionalOnProperty(name = &quot;lettuce.single.host&quot;)
    public RedisURI singleRedisUri() &#123;
        LettuceSingleProperties singleProperties = lettuceProperties.getSingle();
        return RedisURI.builder()
                .withHost(singleProperties.getHost())
                .withPort(singleProperties.getPort())
                .withPassword(singleProperties.getPassword())
                .build();
    &#125;

    @Bean(destroyMethod = &quot;shutdown&quot;)
    @ConditionalOnProperty(name = &quot;lettuce.single.host&quot;)
    public RedisClient singleRedisClient(ClientResources clientResources, @Qualifier(&quot;singleRedisUri&quot;) RedisURI redisUri) &#123;
        return RedisClient.create(clientResources, redisUri);
    &#125;

    @Bean(destroyMethod = &quot;close&quot;)
    @ConditionalOnProperty(name = &quot;lettuce.single.host&quot;)
    public StatefulRedisConnection&lt;String, String&gt; singleRedisConnection(@Qualifier(&quot;singleRedisClient&quot;) RedisClient singleRedisClient) &#123;
        return singleRedisClient.connect();
    &#125;

    @Bean
    @ConditionalOnProperty(name = &quot;lettuce.replica.host&quot;)
    public RedisURI replicaRedisUri() &#123;
        LettuceReplicaProperties replicaProperties = lettuceProperties.getReplica();
        return RedisURI.builder()
                .withHost(replicaProperties.getHost())
                .withPort(replicaProperties.getPort())
                .withPassword(replicaProperties.getPassword())
                .build();
    &#125;

    @Bean(destroyMethod = &quot;shutdown&quot;)
    @ConditionalOnProperty(name = &quot;lettuce.replica.host&quot;)
    public RedisClient replicaRedisClient(ClientResources clientResources, @Qualifier(&quot;replicaRedisUri&quot;) RedisURI redisUri) &#123;
        return RedisClient.create(clientResources, redisUri);
    &#125;

    @Bean(destroyMethod = &quot;close&quot;)
    @ConditionalOnProperty(name = &quot;lettuce.replica.host&quot;)
    public StatefulRedisMasterSlaveConnection&lt;String, String&gt; replicaRedisConnection(@Qualifier(&quot;replicaRedisClient&quot;) RedisClient replicaRedisClient,
                                                                                     @Qualifier(&quot;replicaRedisUri&quot;) RedisURI redisUri) &#123;
        return MasterSlave.connect(replicaRedisClient, new Utf8StringCodec(), redisUri);
    &#125;

    @Bean
    @ConditionalOnProperty(name = &quot;lettuce.sentinel.host&quot;)
    public RedisURI sentinelRedisUri() &#123;
        LettuceSentinelProperties sentinelProperties = lettuceProperties.getSentinel();
        return RedisURI.builder()
                .withPassword(sentinelProperties.getPassword())
                .withSentinel(sentinelProperties.getHost(), sentinelProperties.getPort())
                .withSentinelMasterId(sentinelProperties.getMasterId())
                .build();
    &#125;

    @Bean(destroyMethod = &quot;shutdown&quot;)
    @ConditionalOnProperty(name = &quot;lettuce.sentinel.host&quot;)
    public RedisClient sentinelRedisClient(ClientResources clientResources, @Qualifier(&quot;sentinelRedisUri&quot;) RedisURI redisUri) &#123;
        return RedisClient.create(clientResources, redisUri);
    &#125;

    @Bean(destroyMethod = &quot;close&quot;)
    @ConditionalOnProperty(name = &quot;lettuce.sentinel.host&quot;)
    public StatefulRedisMasterSlaveConnection&lt;String, String&gt; sentinelRedisConnection(@Qualifier(&quot;sentinelRedisClient&quot;) RedisClient sentinelRedisClient,
                                                                                      @Qualifier(&quot;sentinelRedisUri&quot;) RedisURI redisUri) &#123;
        return MasterSlave.connect(sentinelRedisClient, new Utf8StringCodec(), redisUri);
    &#125;

    @Bean
    @ConditionalOnProperty(name = &quot;lettuce.cluster.host&quot;)
    public RedisURI clusterRedisUri() &#123;
        LettuceClusterProperties clusterProperties = lettuceProperties.getCluster();
        return RedisURI.builder()
                .withHost(clusterProperties.getHost())
                .withPort(clusterProperties.getPort())
                .withPassword(clusterProperties.getPassword())
                .build();
    &#125;

    @Bean(destroyMethod = &quot;shutdown&quot;)
    @ConditionalOnProperty(name = &quot;lettuce.cluster.host&quot;)
    public RedisClusterClient redisClusterClient(ClientResources clientResources, @Qualifier(&quot;clusterRedisUri&quot;) RedisURI redisUri) &#123;
        return RedisClusterClient.create(clientResources, redisUri);
    &#125;

    @Bean(destroyMethod = &quot;close&quot;)
    @ConditionalOnProperty(name = &quot;lettuce.cluster&quot;)
    public StatefulRedisClusterConnection&lt;String, String&gt; clusterConnection(RedisClusterClient clusterClient) &#123;
        return clusterClient.connect();
    &#125;
&#125;
</code></pre>
<p>最后为了让IDE识别我们的配置，可以添加IDE亲缘性，<code>/META-INF</code>文件夹下新增一个文件spring-configuration-metadata.json，内容如下：</p>
<pre><code class="json">&#123;
    &quot;properties&quot;: [
        &#123;
            &quot;name&quot;: &quot;lettuce.single&quot;,
            &quot;type&quot;: &quot;club.throwable.spring.lettuce.LettuceSingleProperties&quot;,
            &quot;description&quot;: &quot;单机配置&quot;,
            &quot;sourceType&quot;: &quot;club.throwable.spring.lettuce.LettuceProperties&quot;
        &#125;,
        &#123;
            &quot;name&quot;: &quot;lettuce.replica&quot;,
            &quot;type&quot;: &quot;club.throwable.spring.lettuce.LettuceReplicaProperties&quot;,
            &quot;description&quot;: &quot;主从配置&quot;,
            &quot;sourceType&quot;: &quot;club.throwable.spring.lettuce.LettuceProperties&quot;
        &#125;,
        &#123;
            &quot;name&quot;: &quot;lettuce.sentinel&quot;,
            &quot;type&quot;: &quot;club.throwable.spring.lettuce.LettuceSentinelProperties&quot;,
            &quot;description&quot;: &quot;哨兵配置&quot;,
            &quot;sourceType&quot;: &quot;club.throwable.spring.lettuce.LettuceProperties&quot;
        &#125;,
        &#123;
            &quot;name&quot;: &quot;lettuce.single&quot;,
            &quot;type&quot;: &quot;club.throwable.spring.lettuce.LettuceClusterProperties&quot;,
            &quot;description&quot;: &quot;集群配置&quot;,
            &quot;sourceType&quot;: &quot;club.throwable.spring.lettuce.LettuceProperties&quot;
        &#125;
    ]
&#125;
</code></pre>
<p>如果想IDE亲缘性做得更好，可以添加<code>/META-INF/additional-spring-configuration-metadata.json</code>进行更多细节定义。简单使用如下：</p>
<pre><code class="java">@Slf4j
@Component
public class RedisCommandLineRunner implements CommandLineRunner &#123;

    @Autowired
    @Qualifier(&quot;singleRedisConnection&quot;)
    private StatefulRedisConnection&lt;String, String&gt; connection;

    @Override
    public void run(String... args) throws Exception &#123;
        RedisCommands&lt;String, String&gt; redisCommands = connection.sync();
        redisCommands.setex(&quot;name&quot;, 5, &quot;throwable&quot;);
        log.info(&quot;Get value:&#123;&#125;&quot;, redisCommands.get(&quot;name&quot;));
    &#125;
&#125;
// Get value:throwable
</code></pre>
<h2 id="9、Lettuce-快速入门示例"><a href="#9、Lettuce-快速入门示例" class="headerlink" title="9、Lettuce 快速入门示例"></a>9、Lettuce 快速入门示例</h2><p>1、导入依赖</p>
<pre><code class="xml">&lt;dependencies&gt;
    &lt;!-- https://mvnrepository.com/artifact/io.lettuce/lettuce-core --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;io.lettuce&lt;/groupId&gt;
        &lt;artifactId&gt;lettuce-core&lt;/artifactId&gt;
        &lt;version&gt;5.3.7.RELEASE&lt;/version&gt;
    &lt;/dependency&gt;

    &lt;!-- jeids连接池 --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;
        &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt;
        &lt;version&gt;2.8.0&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;!-- junit4 --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;junit&lt;/groupId&gt;
        &lt;artifactId&gt;junit&lt;/artifactId&gt;
        &lt;version&gt;4.13&lt;/version&gt;
        &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;

    &lt;!-- fastjson --&gt;
    &lt;!-- https://mvnrepository.com/artifact/com.alibaba/fastjson --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
        &lt;artifactId&gt;fastjson&lt;/artifactId&gt;
        &lt;version&gt;1.2.68&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<p>2、同步（sync：RedisCommands）异步（async：RedisAsyncCommands）反应式（reactive：RedisReactiveCommands）操作</p>
<pre><code class="java">import io.lettuce.core.RedisClient;
import io.lettuce.core.RedisFuture;
import io.lettuce.core.RedisURI;
import io.lettuce.core.SetArgs;
import io.lettuce.core.api.StatefulRedisConnection;
import io.lettuce.core.api.async.RedisAsyncCommands;
import io.lettuce.core.api.reactive.RedisReactiveCommands;
import io.lettuce.core.api.sync.RedisCommands;
import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;
import java.time.Duration;
import java.time.temporal.ChronoUnit;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;

public class LettuceBaseCase &#123;
    private static RedisClient client;
    private StatefulRedisConnection&lt;String, String&gt; connection;

    @Before
    public void before() &#123;
        RedisURI redisUri = RedisURI.builder()
                .withHost(&quot;127.0.0.1&quot;)
                .withPort(6379)
                //.withPassword(&quot;123456&quot;)
                .withTimeout(Duration.of(10, ChronoUnit.SECONDS))
                .build();
        client = RedisClient.create(redisUri);
        connection = client.connect();
    &#125;
    @After
    public void after() &#123;
        connection.close();
        client.shutdown();
    &#125;

    /**
     * 同步操作
     */
    @Test
    public void testSync() throws Exception &#123;
        RedisCommands&lt;String, String&gt; commands = connection.sync();
        System.out.println(commands.ping());
        commands.flushdb(); // 先清理DB数据

        String result = commands.set(&quot;name&quot;, &quot;sam&quot;);
        System.out.println(result); // OK
        System.out.println(commands.get(&quot;name&quot;)); //sam

        // 设置参数需要使用SetArgs类
        SetArgs args = SetArgs.Builder.nx().ex(10);
        result = commands.set(&quot;age&quot;, &quot;30&quot;, args);
        System.out.println(result);// OK（如果存在nx则返回null）
        System.out.println(commands.get(&quot;age&quot;));//30
    &#125;

    /**
     * 异步操作
     */
    @Test
    public void testAsync() throws Exception &#123;
        RedisAsyncCommands&lt;String, String&gt; commands = connection.async();
        commands.flushdb(); // 先清理DB数据

        Future&lt;String&gt; setFuture = commands.setex(&quot;k1&quot;, 3,&quot;async&quot;);
        System.out.println(setFuture.get());
        RedisFuture&lt;String&gt; getFuture = commands.get(&quot;k1&quot;);
        System.out.println(getFuture.get());
        TimeUnit.SECONDS.sleep(5); // 延迟5秒
        System.out.println(getFuture.get()); // 可以发现数据没有消失
        // OK
        // async
        // async
    &#125;

    /**
     * 响应式API
     */
    @Test
    public void testReactivePing() throws Exception &#123;
        RedisReactiveCommands&lt;String, String&gt; commands = connection.reactive();
        Mono&lt;String&gt; ping = commands.ping();
        ping.subscribe(v -&gt; System.out.println(&quot;Ping result:&quot; + v));
        Thread.sleep(1000);
        // Ping result:PONG
    &#125;

    /**
     * 响应式API
     */
    @Test
    public void testReactiveSetAndGet() throws Exception &#123;
        RedisReactiveCommands&lt;String, String&gt; commands = connection.reactive();
        commands.flushdb();// 先清理DB数据
        SetArgs setArgs = SetArgs.Builder.nx().ex(5);
        commands.set(&quot;name&quot;, &quot;throwable&quot;, setArgs).block();
        commands.get(&quot;name&quot;).subscribe(value -&gt; System.out.println(&quot;Get命令返回:&quot; + value));
        Thread.sleep(1000);
        // Get命令返回:throwable
    &#125;

    /**
     * 响应式API
     */
    @Test
    public void testReactiveSet() throws Exception &#123;
        RedisReactiveCommands&lt;String, String&gt; commands = connection.reactive();
        commands.flushdb();// 先清理DB数据
        commands.sadd(&quot;food&quot;, &quot;bread&quot;, &quot;meat&quot;, &quot;fish&quot;).block();
        Flux&lt;String&gt; flux = commands.smembers(&quot;food&quot;);
        flux.subscribe(System.out::println);
        commands.srem(&quot;food&quot;, &quot;bread&quot;, &quot;meat&quot;, &quot;fish&quot;).block();
        Thread.sleep(1000);
        // fish
        // bread
        // meat
    &#125;

    /**
     * 响应式API
     */
    @Test
    public void reactive() throws Exception &#123;
        RedisReactiveCommands&lt;String, String&gt; commands = connection.reactive();
        commands.flushdb();// 先清理DB数据

        Mono&lt;String&gt; result = commands.set(&quot;name&quot;, &quot;reactive&quot;);
        System.out.println(result.block());

        SetArgs args = SetArgs.Builder.nx().ex(10);
        result = commands.set(&quot;age&quot;, &quot;30&quot;, args);
        result.subscribe(value -&gt; System.out.println(value));

        // 开启一个事务，先把counter设置为1，再将counter自增1
        commands.multi().doOnSuccess(r -&gt; &#123;
            commands.set(&quot;count&quot;, &quot;1&quot;).doOnNext(System.out::println).subscribe();
            commands.incr(&quot;count&quot;).doOnNext(c -&gt; System.out.println(c)).subscribe();
        &#125;).flatMap(s -&gt; commands.exec())
                .doOnNext(transactionResult -&gt; System.out.println(transactionResult.wasDiscarded())).subscribe();

        Thread.sleep(1000 * 5);
        // OK
        // OK
        // OK
        // 2
        // false
    &#125;
&#125;
</code></pre>
<p>3、Lettuce 集群与连接池</p>
<pre><code class="java">import io.lettuce.core.ClientOptions;
import io.lettuce.core.ReadFrom;
import io.lettuce.core.RedisClient;
import io.lettuce.core.RedisURI;
import io.lettuce.core.api.StatefulRedisConnection;
import io.lettuce.core.api.sync.RedisCommands;
import io.lettuce.core.cluster.ClusterClientOptions;
import io.lettuce.core.cluster.RedisClusterClient;
import io.lettuce.core.cluster.api.StatefulRedisClusterConnection;
import io.lettuce.core.cluster.api.sync.Executions;
import io.lettuce.core.cluster.api.sync.NodeSelection;
import io.lettuce.core.cluster.api.sync.NodeSelectionCommands;
import io.lettuce.core.cluster.api.sync.RedisAdvancedClusterCommands;
import io.lettuce.core.codec.StringCodec;
import io.lettuce.core.masterreplica.MasterReplica;
import io.lettuce.core.masterreplica.StatefulRedisMasterReplicaConnection;
import io.lettuce.core.resource.ClientResources;
import io.lettuce.core.resource.DefaultClientResources;
import io.lettuce.core.support.ConnectionPoolSupport;
import org.apache.commons.pool2.impl.GenericObjectPool;
import org.apache.commons.pool2.impl.GenericObjectPoolConfig;
import org.junit.Test;
import java.time.Duration;
import java.time.temporal.ChronoUnit;
import java.util.*;

/**
 * 高级操作
 */
public class LettuceAdvanceCase &#123;
    /**
     * 主从模式操作1
     */
    @Test
    public void masterSlave() &#123;
        // 这里只需要配置一个节点的连接信息，不一定需要是主节点的信息，从节点也可以;可以自动发现主从节点
        RedisURI uri = RedisURI.builder().withHost(&quot;10.49.196.20&quot;).withPort(6379).withPassword(&quot;123456&quot;).build();
        RedisClient client = RedisClient.create(uri);
        StatefulRedisMasterReplicaConnection&lt;String, String&gt; connection = MasterReplica.connect(client, StringCodec.UTF8, uri);
        // 从节点读书数据
        connection.setReadFrom(ReadFrom.REPLICA);

        RedisCommands&lt;String, String&gt; commands = connection.sync();
        commands.set(&quot;name&quot;, &quot;刘备&quot;);
        System.out.println(commands.get(&quot;name&quot;));

        connection.close();
        client.shutdown();
    &#125;

    /**
     * 主从模式操作2
     */
    @Test
    public void masterSlave2() &#123;
        List&lt;RedisURI&gt; uris = new ArrayList();
        uris.add(RedisURI.builder().withHost(&quot;10.49.196.20&quot;).withPort(6379).withPassword(&quot;123456&quot;).build());
        uris.add(RedisURI.builder().withHost(&quot;10.49.196.21&quot;).withPort(6379).withPassword(&quot;123456&quot;).build());
        uris.add(RedisURI.builder().withHost(&quot;10.49.196.22&quot;).withPort(6379).withPassword(&quot;123456&quot;).build());
        RedisClient client = RedisClient.create();
        StatefulRedisMasterReplicaConnection&lt;String, String&gt; connection = MasterReplica.connect(client, StringCodec.UTF8, uris);
        // 从节点读书数据
        connection.setReadFrom(ReadFrom.REPLICA);

        RedisCommands&lt;String, String&gt; commands = connection.sync();
        commands.set(&quot;name&quot;, &quot;张飞&quot;);
        System.out.println(commands.get(&quot;name&quot;));

        connection.close();
        client.shutdown();
    &#125;

    /**
     * 哨兵模式操作
     */
    @Test
    public void sentinel() &#123;
        List&lt;RedisURI&gt; uris = new ArrayList();
        uris.add(RedisURI.builder().withSentinel(&quot;10.49.196.20&quot;, 26379).withSentinelMasterId(&quot;mymaster&quot;).withPassword(&quot;123456&quot;).build());
        uris.add(RedisURI.builder().withSentinel(&quot;10.49.196.21&quot;, 26379).withSentinelMasterId(&quot;mymaster&quot;).withPassword(&quot;123456&quot;).build());
        uris.add(RedisURI.builder().withSentinel(&quot;10.49.196.22&quot;, 26379).withSentinelMasterId(&quot;mymaster&quot;).withPassword(&quot;123456&quot;).build());

        RedisClient client = RedisClient.create();
        StatefulRedisMasterReplicaConnection&lt;String, String&gt; connection = MasterReplica.connect(client, StringCodec.UTF8, uris);
        // 从节点读取数据
        connection.setReadFrom(ReadFrom.REPLICA);

        RedisCommands&lt;String, String&gt; commands = connection.sync();
        commands.set(&quot;name&quot;, &quot;赵云&quot;);
        System.out.println(commands.get(&quot;name&quot;));

        connection.close();
        client.shutdown();
    &#125;

    /**
     * 集群操作
     */
    @Test
    public void cluster() &#123;
        Set&lt;RedisURI&gt; uris = new HashSet&lt;&gt;();
        uris.add(RedisURI.builder().withHost(&quot;10.49.196.20&quot;).withPort(7000).withPassword(&quot;123456&quot;).build());
        uris.add(RedisURI.builder().withHost(&quot;10.49.196.20&quot;).withPort(7001).withPassword(&quot;123456&quot;).build());
        uris.add(RedisURI.builder().withHost(&quot;10.49.196.21&quot;).withPort(7000).withPassword(&quot;123456&quot;).build());
        uris.add(RedisURI.builder().withHost(&quot;10.49.196.21&quot;).withPort(7001).withPassword(&quot;123456&quot;).build());
        uris.add(RedisURI.builder().withHost(&quot;10.49.196.22&quot;).withPort(7000).withPassword(&quot;123456&quot;).build());
        uris.add(RedisURI.builder().withHost(&quot;10.49.196.22&quot;).withPort(7001).withPassword(&quot;123456&quot;).build());
        RedisClusterClient client = RedisClusterClient.create(uris);
        StatefulRedisClusterConnection&lt;String, String&gt; connection = client.connect();
        RedisAdvancedClusterCommands&lt;String, String&gt; commands = connection.sync();
        commands.set(&quot;name&quot;, &quot;关羽&quot;);
        System.out.println(commands.get(&quot;name&quot;));

        // 选择从节点,只读
        NodeSelection&lt;String, String&gt; replicas = commands.replicas();
        NodeSelectionCommands&lt;String, String&gt; nodeSelectionCommands = replicas.commands();
        Executions&lt;List&lt;String&gt;&gt; keys = nodeSelectionCommands.keys(&quot;*&quot;);
        keys.forEach(key -&gt; System.out.println(key));

        connection.close();
        client.shutdown();
    &#125;

    /**
     * 配置客户端资源(ClientResources)及客户端参数(ClientOptions)
     */
    @Test
    public void resourceAndOption() &#123;
        ClientResources resources = DefaultClientResources.builder()
                .ioThreadPoolSize(4) //I/O线程数
                .computationThreadPoolSize(4) //任务线程数
                .build();
        RedisURI redisUri = RedisURI.builder()
                .withHost(&quot;10.49.196.10&quot;).withPort(6379).withPassword(&quot;123456&quot;)
                .withTimeout(Duration.of(10, ChronoUnit.SECONDS))
                .build();
        ClientOptions options = ClientOptions.builder()
                .autoReconnect(true)//是否自动重连
                .pingBeforeActivateConnection(true)//连接激活之前是否执行PING命令
                .build();

        RedisClient client = RedisClient.create(resources, redisUri);
        client.setOptions(options);
        StatefulRedisConnection&lt;String, String&gt; connection = client.connect();
        RedisCommands&lt;String, String&gt; commands = connection.sync();
        System.out.println(commands.get(&quot;name&quot;));

        connection.close();
        client.shutdown();
        resources.shutdown();
    &#125;

    /**
     * 配置客户端资源(ClientResources)及客户端参数(ClientOptions)
     * 集群
     */
    @Test
    public void resourceAndOption2() &#123;
        ClientResources resources = DefaultClientResources.builder()
                .ioThreadPoolSize(4) //I/O线程数
                .computationThreadPoolSize(4) //任务线程数
                .build();
        // 集群地址，配置其中一个即可，不需要配置全
        RedisURI redisUri = RedisURI.builder()
                .withHost(&quot;10.49.196.20&quot;).withPort(7000).withPassword(&quot;123456&quot;)
                .withTimeout(Duration.of(10, ChronoUnit.SECONDS))
                .build();
        ClusterClientOptions options = ClusterClientOptions.builder()
                .autoReconnect(true)//是否自动重连
                .pingBeforeActivateConnection(true)// 连接激活之前是否执行PING命令
                .validateClusterNodeMembership(true)// 是否校验集群节点的成员关系
                .build();

        RedisClusterClient client = RedisClusterClient.create(resources, redisUri);
        client.setOptions(options);
        StatefulRedisClusterConnection&lt;String, String&gt; connection = client.connect();
        RedisAdvancedClusterCommands&lt;String, String&gt; commands = connection.sync();
        System.out.println(commands.get(&quot;name&quot;));

        connection.close();
        client.shutdown();
        resources.shutdown();
    &#125;

    /**
     * 连接池
     */
    @Test
    public void pool() throws Exception &#123;
        RedisURI redisUri = RedisURI.builder()
                .withHost(&quot;10.49.196.10&quot;).withPort(6379).withPassword(&quot;123456&quot;)
                .withTimeout(Duration.of(10, ChronoUnit.SECONDS))
                .build();
        RedisClient client = RedisClient.create(redisUri);
        GenericObjectPoolConfig poolConfig = new GenericObjectPoolConfig();
        GenericObjectPool&lt;StatefulRedisConnection&lt;String, String&gt;&gt; pool = ConnectionPoolSupport.createGenericObjectPool(client::connect, poolConfig);
        StatefulRedisConnection&lt;String, String&gt; connection = pool.borrowObject();
        RedisCommands&lt;String, String&gt; commands = connection.sync();
        System.out.println(commands.get(&quot;name&quot;));

        connection.close();
        pool.close();
        client.shutdown();
    &#125;

&#125;
</code></pre>
<h2 id="10、参考文献-鸣谢-小结"><a href="#10、参考文献-鸣谢-小结" class="headerlink" title="10、参考文献 &amp; 鸣谢 &amp; 小结"></a>10、参考文献 &amp; 鸣谢 &amp; 小结</h2><p>本文算是基于Lettuce的官方文档，对它的使用进行全方位的分析，包括主要功能、配置都做了一些示例，限于篇幅部分特性和配置细节没有分析。Lettuce已经被spring-data-redis接纳作为官方的Redis客户端驱动，所以值得信赖，它的一些API设计确实比较合理，扩展性高的同时灵活性也高。个人建议，基于Lettuce包自行添加配置到SpringBoot应用用起来会得心应手，毕竟RedisTemplate实在太笨重，而且还屏蔽了Lettuce一些高级特性和灵活的API。</p>
<p>参考资料：</p>
<ul>
<li>Lettuce Reference Guide：<a target="_blank" rel="noopener" href="https://lettuce.io/core/release/reference/index.html">https://lettuce.io/core/release/reference/index.html</a></li>
<li>Cnblogs Page（Throwable）Redis高级客户端Lettuce详解：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/throwable/p/11601538.html">https://www.cnblogs.com/throwable/p/11601538.html</a></li>
<li>CSDN Page：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_18671415/article/details/110875621">https://blog.csdn.net/qq_18671415/article/details/110875621</a></li>
</ul>
<h1 id="Redis-编程客户端-Redisson"><a href="#Redis-编程客户端-Redisson" class="headerlink" title="Redis 编程客户端 Redisson"></a>Redis 编程客户端 Redisson</h1><p>Redisson官网地址：<a target="_blank" rel="noopener" href="https://redisson.org/%E3%80%81GitHub%E9%A1%B9%E7%9B%AE%E5%9C%B0%E5%9D%80%EF%BC%9Ahttps://github.com/redisson/redisson/wiki">https://redisson.org/、GitHub项目地址：https://github.com/redisson/redisson/wiki</a></p>
<p>Redisson Client是2014年1月发布的开源项目，底层也是采用netty进行通信，该客户端目的是，让开发人员减少对Redis的关注，从而让开发人员将精力更集中地放在处理业务逻辑上，它提供很多分布式相关操作服务，例如，分布式锁，分布式集合、分布式队列等。</p>
<p>Redisson是一个在Redis的基础上实现的Java常驻内存数据网格(In-Memory Data Grid)。它不仅提供了一系列的分布式的Java常用对象，还提供了许多分布式服务。Redisson提供了使用Redis的简单、便捷的方法。</p>
<h2 id="1、Java-Redisson"><a href="#1、Java-Redisson" class="headerlink" title="1、Java + Redisson"></a>1、Java + Redisson</h2><p>1、引入依赖（注意：使用到的软件版本：Java 1.8.0、Redis 5.0.8、Redisson 3.13.2）</p>
<pre><code class="xml">&lt;properties&gt;
    &lt;!--锁定 jdk 版本为 1.8--&gt;
    &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;
    &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;
&lt;/properties&gt;

&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.redisson&lt;/groupId&gt;
        &lt;artifactId&gt;redisson&lt;/artifactId&gt;
        &lt;version&gt;3.13.2&lt;/version&gt;
    &lt;/dependency&gt;

    &lt;!-- junit4 --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;junit&lt;/groupId&gt;
        &lt;artifactId&gt;junit&lt;/artifactId&gt;
        &lt;version&gt;4.13&lt;/version&gt;
        &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<p>2、Redisson 操作 Redis</p>
<pre><code class="java">import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.redisson.Redisson;
import org.redisson.api.*;
import org.redisson.config.Config;
import java.io.*;
import java.util.concurrent.TimeUnit;

/**
 * Redisson 操作 redis
 * Redisson 除了提供同步接口外，还提供了异步（Async）、反射式（Reactive）和RxJava2标准的接口。
 * Redisson 会序列化 java 对象然后保存到reids，所以通过redis命令行设置的值，Redisson 来获取值会报错；
 *          通redis命令行获取Redisson设置的值前面会多出序列化相关的信息
 */
public class RedissonCase &#123;
    private RedissonClient client;
    private RedissonReactiveClient reactiveClient;
    private RedissonRxClient rxClient;

    @Before
    public void before() &#123;
        Config config = new Config();
        //config.setCodec(new org.redisson.client.codec.StringCodec());
        config.useSingleServer().setAddress(&quot;redis://127.0.0.1:6379&quot;)/*.setPassword(&quot;123456&quot;)*/;
        client = Redisson.create(config);
        reactiveClient = Redisson.createReactive(config);
        rxClient = Redisson.createRx(config);
    &#125;

    @After
    public void after() &#123;
        client.shutdown();
        reactiveClient.shutdown();
        rxClient.shutdown();
    &#125;

    /**
     * 通用对象桶，可以用来存放任类型的对象
     */
    @Test
    public void bucket() throws Exception &#123;
        // 同步
        RBucket&lt;String&gt; bucket1 = client.getBucket(&quot;name&quot;);
        bucket1.set(&quot;zhaoyun&quot;);
        System.out.println(bucket1.get());

        // 异步
        RBucket&lt;String&gt; bucket2 = client.getBucket(&quot;name2&quot;);
        bucket2.setAsync(&quot;赵云2&quot;).get();
        bucket2.getAsync().thenAccept(System.out::println);

        // Reactive
        RBucketReactive&lt;String&gt; bucket3 = reactiveClient.getBucket(&quot;name3&quot;);
        bucket3.set(&quot;赵云3&quot;).block();
        bucket3.get().subscribe(System.out::println);

        // RxJava2
        RBucketRx&lt;String&gt; bucket4 = rxClient.getBucket(&quot;name4&quot;);
        bucket4.set(&quot;赵云4&quot;).blockingGet();
        bucket4.get().subscribe(System.out::println);

        Thread.sleep(1000 * 5);
    &#125;

    /**
     * 二进制流
     * 提供了InputStream接口和OutputStream接口的实现
     */
    @Test
    public void stream() throws Exception &#123;
        RBinaryStream stream = client.getBinaryStream(&quot;stream&quot;);
        stream.set(&quot;赵云&quot;.getBytes());
        OutputStream outputStream = stream.getOutputStream();
        outputStream.write(&quot;张飞&quot;.getBytes());

        InputStream inputStream = stream.getInputStream();
        ByteArrayOutputStream result = new ByteArrayOutputStream();
        byte[] b = new byte[1024];
        int len;
        while ((len = inputStream.read(b)) != -1) &#123;
            result.write(b, 0, len);
        &#125;
        System.out.println(result.toString());
    &#125;

    /**
     * 分布式ID
     */
    @Test
    public void atomicLong() &#123;
        RAtomicLong atomicLong = client.getAtomicLong(&quot;atomicLong&quot;);
        atomicLong.set(10);
        atomicLong.incrementAndGet();
        System.out.println(atomicLong);
    &#125;

    /**
     * 限流器
     */
    @Test
    public void rateLimiter() throws InterruptedException &#123;
        // 获取限流实例
        RRateLimiter rateLimiter = client.getRateLimiter(&quot;rateLimiter&quot;);
        // 设置令牌桶规则 初始化 最大流速:每1秒钟产生5个令牌
        rateLimiter.trySetRate(RateType.OVERALL, 5, 1, RateIntervalUnit.SECONDS);
        for (int i = 0; i &lt; 10; i++) &#123;
            new Thread(new Runnable() &#123;
                int i = 0;
                @Override
                public void run() &#123;
                    while(true) &#123;
                        // 获取1个令牌
                        rateLimiter.acquire(1);
                        System.out.println(Thread.currentThread() + &quot;-&quot; + System.currentTimeMillis() + &quot;-&quot; + i++);
                    &#125;
                &#125;
            &#125;).start();
        &#125;

        Thread.sleep(1000 * 5);
    &#125;

    /**
     * RList实现了java.util.List接口
     */
    @Test
    public void list() &#123;
        RList&lt;String&gt; list = client.getList(&quot;list&quot;);
        list.add(&quot;a&quot;);
        list.add(&quot;赵云&quot;);
        list.add(&quot;张飞&quot;);
        list.remove(1);
        System.out.println(list);
    &#125;

    /**
     * RMap实现了java.util.concurrent.ConcurrentMap接口和java.util.Map接口
     */
    @Test
    public void map() &#123;
        RMap&lt;String, String&gt; map = client.getMap(&quot;map&quot;);
        map.put(&quot;name&quot;, &quot;赵云&quot;);
        map.put(&quot;location&quot;, &quot;常山&quot;);
        map.put(&quot;camp&quot;, &quot;蜀&quot;);
        map.remove(&quot;location&quot;);
        map.forEach((key, value) -&gt; &#123;System.out.println(&quot;key=&quot; + key + &quot;,value=&quot; + value);&#125;);
    &#125;

    /**
     * RSet实现了java.util.Set接口
     * @throws Exception
     */
    @Test
    public void set() &#123;
        RSet&lt;String&gt; set = client.getSet(&quot;set&quot;);
        set.add(&quot;赵云&quot;);
        set.add(&quot;张飞&quot;);
        set.forEach(System.out::println);
    &#125;

    /**
     * RQueue实现了java.util.Queue接口
     */
    @Test
    public void queue() &#123;
        RQueue&lt;String&gt; queue = client.getQueue(&quot;queue&quot;);
        queue.add(&quot;赵云&quot;);
        queue.add(&quot;张飞&quot;);
        System.out.println(queue.poll());
        System.out.println(queue.poll());
    &#125;

    /**
     * 可重入锁 RLock实现了java.util.concurrent.locks.Lock接口
     */
    @Test
    public void lock() throws InterruptedException &#123;
        RLock lock = client.getLock(&quot;lock&quot;);
        for (int i = 0; i &lt; 5; i++) &#123;
            new Thread(() -&gt; &#123;
                lock.lock();
                try &#123;
                    System.out.println(Thread.currentThread() + &quot;-&quot; + 
                                       System.currentTimeMillis() + &quot;-&quot; + &quot;获取了锁&quot;);
                    Thread.sleep(500);
                &#125; catch (InterruptedException e) &#123;
                    e.printStackTrace();
                &#125; finally &#123;
                    lock.unlock();
                &#125;
            &#125;).start();
        &#125;
        Thread.sleep(1000 * 5);
    &#125;

    /**
     * Redisson的分布式RBitSetJava对象采用了与java.util.BiteSet类似结构的设计风格
     */
    @Test
    public void bitSet() &#123;
        RBitSet bitSet = client.getBitSet(&quot;bs&quot;);
        bitSet.expire(5, TimeUnit.DAYS);
        bitSet.set(0, true);
        bitSet.set(20, true);
        bitSet.set(96, true);
        System.out.println(bitSet.get(10));
        System.out.println(bitSet.get(20));
    &#125;

    /**
     * Redisson利用Redis实现了Java分布式布隆过滤器（Bloom Filter）
     */
    @Test
    public void bf() &#123;
        RBloomFilter&lt;String&gt; bf = client.getBloomFilter(&quot;qq&quot;);
        if (!bf.isExists()) &#123;
            bf.tryInit(150000000L, 0.05);
            bf.add(&quot;test&quot;);
            bf.expire(200, TimeUnit.SECONDS);
        &#125;
        bf.add(&quot;https://www.baidu.com/&quot;);
        bf.add(&quot;https://www.tmall.com/&quot;);
        bf.add(&quot;https://www.jd.com/&quot;);
        System.out.println(bf.contains(&quot;https://www.tmall.com/&quot;));
        System.out.println(bf.count());
    &#125;
&#125;
</code></pre>
<p>3、Redisson 高级配置</p>
<pre><code class="java">import org.junit.Test;
import org.redisson.Redisson;
import org.redisson.api.RBucket;
import org.redisson.api.RedissonClient;
import org.redisson.config.Config;

/**
 * Redisson配置
 */
public class RedissonConfigCase &#123;
    /**
     * 单Redis节点模式
     */
    @Test
    public void singl() &#123;
        Config config = new Config();
        config.useSingleServer()
                .setAddress(&quot;redis://10.49.196.10:6379&quot;)
                .setPassword(&quot;123456&quot;)
                .setConnectionPoolSize(5) // 连接池大小
                .setConnectionMinimumIdleSize(2) // 最小空闲连接数
                .setDatabase(0);
        RedissonClient client = Redisson.create(config);
        RBucket&lt;String&gt; name = client.getBucket(&quot;name&quot;);
        System.out.println(name.get());
    &#125;

    /**
     * 主从模式
     */
    @Test
    public void masterSlave() &#123;
        Config config = new Config();
        config.useMasterSlaveServers()
                .setMasterAddress(&quot;redis://10.49.196.20:6379&quot;)
                .addSlaveAddress(&quot;redis://10.49.196.21:6379&quot;)
                .addSlaveAddress(&quot;redis://10.49.196.22:6379&quot;)
                .setPassword(&quot;123456&quot;)
                .setMasterConnectionPoolSize(5) // 主节点连接池大小
                .setMasterConnectionMinimumIdleSize(2) // 主节点最小空闲连接数
                .setSlaveConnectionPoolSize(5) // 从节点连接池大小
                .setSlaveConnectionMinimumIdleSize(2) // 从节点最小空闲连接数
                .setDatabase(0);
        RedissonClient client = Redisson.create(config);
        RBucket&lt;String&gt; name = client.getBucket(&quot;name&quot;);
        System.out.println(name.get());
    &#125;

    /**
     * 哨兵模式
     */
    @Test
    public void sentinel() &#123;
        Config config = new Config();
        config.useSentinelServers()
                .setMasterName(&quot;mymaster&quot;)
                .addSentinelAddress(&quot;redis://10.49.196.20:26379&quot;)
                .addSentinelAddress(&quot;redis://10.49.196.21:26379&quot;)
                .addSentinelAddress(&quot;redis://10.49.196.22:26379&quot;)
                .setPassword(&quot;123456&quot;)
                .setMasterConnectionPoolSize(5) // 主节点连接池大小
                .setMasterConnectionMinimumIdleSize(3) // 主节点最小空闲连接数
                .setSlaveConnectionPoolSize(5) // 从节点连接池大小
                .setSlaveConnectionMinimumIdleSize(3) // 从节点最小空闲连接数
                .setCheckSentinelsList(false)
                .setDatabase(0);
        System.out.println(config.useSentinelServers().getSentinelAddresses());

        RedissonClient client = Redisson.create(config);
        RBucket&lt;String&gt; name = client.getBucket(&quot;name&quot;);
        name.set(&quot;赵云&quot;);
        System.out.println(name.get());
    &#125;

    /**
     * 集群
     */
    @Test
    public void cluster() &#123;
        Config config = new Config();
        config.useClusterServers()
                .setScanInterval(1000 * 2)
                .addNodeAddress(&quot;redis://10.49.196.20:7000&quot;, &quot;redis://10.49.196.20:7001&quot;)
                .addNodeAddress(&quot;redis://10.49.196.21:7000&quot;, &quot;redis://10.49.196.21:7001&quot;)
                .addNodeAddress(&quot;redis://10.49.196.22:7000&quot;, &quot;redis://10.49.196.22:7001&quot;)
                .setPassword(&quot;123456&quot;)
                .setMasterConnectionPoolSize(5)
                .setMasterConnectionMinimumIdleSize(2)
                .setSlaveConnectionPoolSize(5)
                .setSlaveConnectionMinimumIdleSize(2);
        RedissonClient client = Redisson.create(config);
        RBucket&lt;String&gt; name = client.getBucket(&quot;name&quot;);
        name.set(&quot;赵云&quot;);
        System.out.println(name.get());
    &#125;
&#125;
</code></pre>
<h2 id="2、SpringBoot-Redission"><a href="#2、SpringBoot-Redission" class="headerlink" title="2、SpringBoot + Redission"></a>2、SpringBoot + Redission</h2><h3 id="1、Redission-依赖"><a href="#1、Redission-依赖" class="headerlink" title="1、Redission 依赖"></a>1、Redission 依赖</h3><pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.redisson&lt;/groupId&gt;
    &lt;artifactId&gt;redisson-spring-boot-starter&lt;/artifactId&gt;
    &lt;version&gt;3.13.6&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>注意：引入次依赖后，无需再引入spring-boot-starter-data-redis，内部已经进行了引入，且排除了Redis的Luttuce以及Jedis客户端</p>
<p>可以点击 redisson-spring-boot-starter，进入pom中查看内部依赖：</p>
<pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;
    &lt;exclusions&gt;
        &lt;exclusion&gt;
            &lt;groupId&gt;redis.clients&lt;/groupId&gt;
            &lt;artifactId&gt;jedis&lt;/artifactId&gt;
        &lt;/exclusion&gt;
        &lt;exclusion&gt;
            &lt;groupId&gt;io.lettuce&lt;/groupId&gt;
            &lt;artifactId&gt;lettuce-core&lt;/artifactId&gt;
        &lt;/exclusion&gt;
    &lt;/exclusions&gt; 
&lt;/dependency&gt;
</code></pre>
<h3 id="2、Redission-配置"><a href="#2、Redission-配置" class="headerlink" title="2、Redission 配置"></a>2、Redission 配置</h3><p>官方文档：<a target="_blank" rel="noopener" href="https://github.com/redisson/redisson/wiki/2.-%E9%85%8D%E7%BD%AE%E6%96%B9%E6%B3%95">https://github.com/redisson/redisson/wiki/2.-%E9%85%8D%E7%BD%AE%E6%96%B9%E6%B3%95</a></p>
<p>引入配置可使用程序化配置以及YML配置两种方式。</p>
<h4 id="1、程序化配置"><a href="#1、程序化配置" class="headerlink" title="1、程序化配置"></a>1、程序化配置</h4><pre><code class="java">package com.xyz.redis.config;

import org.redisson.Redisson;
import org.redisson.api.RedissonClient;
import org.redisson.config.Config;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class RedissonConfig &#123;
    @Bean
    public RedissonClient redissonClient() &#123;
        // 单Redis节点模式
        Config config = new Config();
        config.useSingleServer().setAddress(&quot;redis://127.0.0.1:6379&quot;);
        return Redisson.create(config);
    &#125;

    @Bean
    public RedissonClient masterSlaveRedissonClient() &#123;
        // 主从模式
        Config config = new Config();
        config.useMasterSlaveServers()
                .setMasterAddress(&quot;redis://127.0.0.1:6379&quot;)
                .addSlaveAddress(&quot;redis://127.0.0.1:6380&quot;)
                .addSlaveAddress(&quot;redis://127.0.0.1:6381&quot;)
                .setPassword(&quot;123456&quot;)
                .setMasterConnectionPoolSize(5) // 主节点连接池大小
                .setMasterConnectionMinimumIdleSize(2) // 主节点最小空闲连接数
                .setSlaveConnectionPoolSize(5) // 从节点连接池大小
                .setSlaveConnectionMinimumIdleSize(2) // 从节点最小空闲连接数
                .setDatabase(0);
        return Redisson.create(config);
    &#125;

    @Bean
    public RedissonClient sentinelRedissonClient() &#123;
        // Sentinel哨兵模式
        Config config = new Config();
        config.useSentinelServers()
                .setMasterName(&quot;mymaster&quot;)
                .addSentinelAddress(&quot;redis://192.168.3.10:26379&quot;)
                .addSentinelAddress(&quot;redis://192.168.3.11:26379&quot;)
                .addSentinelAddress(&quot;redis://192.168.3.12:26379&quot;)
                .setPassword(&quot;123456&quot;)
                .setMasterConnectionPoolSize(5) // 主节点连接池大小
                .setMasterConnectionMinimumIdleSize(3) // 主节点最小空闲连接数
                .setSlaveConnectionPoolSize(5) // 从节点连接池大小
                .setSlaveConnectionMinimumIdleSize(3) // 从节点最小空闲连接数
                .setCheckSentinelsList(false)
                .setDatabase(0);
        return Redisson.create(config);
    &#125;

    @Bean
    public RedissonClient clusterRedissonClient() &#123;
        // Cluster集群分片模式
        Config config = new Config();
        config.useClusterServers()
                .setScanInterval(1000 * 2)
                .addNodeAddress(&quot;redis://10.49.196.20:7000&quot;, &quot;redis://10.49.196.20:7001&quot;)
                .addNodeAddress(&quot;redis://10.49.196.21:7000&quot;, &quot;redis://10.49.196.21:7001&quot;)
                .addNodeAddress(&quot;redis://10.49.196.22:7000&quot;, &quot;redis://10.49.196.22:7001&quot;)
                .setPassword(&quot;123456&quot;)
                .setMasterConnectionPoolSize(5)
                .setMasterConnectionMinimumIdleSize(2)
                .setSlaveConnectionPoolSize(5)
                .setSlaveConnectionMinimumIdleSize(2);
        return Redisson.create(config);
    &#125;
&#125;
</code></pre>
<h4 id="2、YML-配置"><a href="#2、YML-配置" class="headerlink" title="2、YML 配置"></a>2、YML 配置</h4><pre><code class="yaml"># redis单节点配置方式
singleServerConfig:
  # 连接空闲超时，单位：毫秒
  idleConnectionTimeout: 10000
  # 连接超时，单位：毫秒
  connectTimeout: 10000
  # 命令等待超时，单位：毫秒 默认3000
  timeout: 3000
  # 命令失败重试次数
  retryAttempts: 3
  # 命令重试发送时间间隔，单位：毫秒
  retryInterval: 1500
  # 无密码则设置 null
  password: &quot;123456a&quot;
  # 单个连接最大订阅数量
  subscriptionsPerConnection: 5
  # 客户端名称
  clientName: null
  # redis 节点地址
  address: &quot;redis://127.0.0.1:6379&quot;
  # 从节点发布和订阅连接的最小空闲连接数
  subscriptionConnectionMinimumIdleSize: 1
  # 发布和订阅连接池大小
  subscriptionConnectionPoolSize: 50
  # 发布和订阅连接的最小空闲连接数
  connectionMinimumIdleSize: 32
  # 发布和订阅连接池大小
  connectionPoolSize: 64
  # 数据库编号
  database: 10
  # DNS监测时间间隔，单位：毫秒  在启用该功能以后，Redisson将会监测DNS的变化情况
  dnsMonitoringInterval: 5000
threads: 0
nettyThreads: 0
codec: !&lt;org.redisson.codec.JsonJacksonCodec&gt; &#123;&#125;
transportMode: &quot;NIO&quot;

# redis主从模式配置方式
---
masterSlaveServersConfig:
  idleConnectionTimeout: 10000
  connectTimeout: 10000
  timeout: 3000
  retryAttempts: 3
  retryInterval: 1500
  failedAttempts: 3
  password: null
  subscriptionsPerConnection: 5
  clientName: null
  loadBalancer: !&lt;org.redisson.connection.balancer.RoundRobinLoadBalancer&gt; &#123;&#125;
  slaveSubscriptionConnectionMinimumIdleSize: 1
  slaveSubscriptionConnectionPoolSize: 50
  slaveConnectionMinimumIdleSize: 32
  slaveConnectionPoolSize: 64
  masterConnectionMinimumIdleSize: 32
  masterConnectionPoolSize: 64
  readMode: &quot;SLAVE&quot;
  slaveAddresses:
  - &quot;redis://127.0.0.1:6381&quot;
  - &quot;redis://127.0.0.1:6380&quot;
  masterAddress: &quot;redis://127.0.0.1:6379&quot;
  database: 0
threads: 0
nettyThreads: 0
codec: !&lt;org.redisson.codec.JsonJacksonCodec&gt; &#123;&#125;
&quot;transportMode&quot;:&quot;NIO&quot;

# redis哨兵模式配置方式
---
sentinelServersConfig:
  idleConnectionTimeout: 10000
  connectTimeout: 10000
  timeout: 3000
  retryAttempts: 3
  retryInterval: 1500
  password: null
  subscriptionsPerConnection: 5
  clientName: null
  loadBalancer: !&lt;org.redisson.connection.balancer.RoundRobinLoadBalancer&gt; &#123;&#125;
  slaveSubscriptionConnectionMinimumIdleSize: 1
  slaveSubscriptionConnectionPoolSize: 50
  slaveConnectionMinimumIdleSize: 32
  slaveConnectionPoolSize: 64
  masterConnectionMinimumIdleSize: 32
  masterConnectionPoolSize: 64
  readMode: &quot;SLAVE&quot;
  sentinelAddresses:
  - &quot;redis://127.0.0.1:26379&quot;
  - &quot;redis://127.0.0.1:26389&quot;
  masterName: &quot;mymaster&quot;
  database: 0
threads: 0
nettyThreads: 0
codec: !&lt;org.redisson.codec.JsonJacksonCodec&gt; &#123;&#125;
&quot;transportMode&quot;:&quot;NIO&quot;

# redis集群模式配置方式
---
clusterServersConfig:
  idleConnectionTimeout: 10000
  connectTimeout: 10000
  timeout: 3000
  retryAttempts: 3
  retryInterval: 1500
  password: null
  subscriptionsPerConnection: 5
  clientName: null
  loadBalancer: !&lt;org.redisson.connection.balancer.RoundRobinLoadBalancer&gt; &#123;&#125;
  slaveSubscriptionConnectionMinimumIdleSize: 1
  slaveSubscriptionConnectionPoolSize: 50
  slaveConnectionMinimumIdleSize: 32
  slaveConnectionPoolSize: 64
  masterConnectionMinimumIdleSize: 32
  masterConnectionPoolSize: 64
  readMode: &quot;SLAVE&quot;
  nodeAddresses:
  - &quot;redis://127.0.0.1:7004&quot;
  - &quot;redis://127.0.0.1:7001&quot;
  - &quot;redis://127.0.0.1:7000&quot;
  scanInterval: 1000
threads: 0
nettyThreads: 0
codec: !&lt;org.redisson.codec.JsonJacksonCodec&gt; &#123;&#125;
&quot;transportMode&quot;:&quot;NIO&quot;
</code></pre>
<h4 id="3、程序加载配置文件"><a href="#3、程序加载配置文件" class="headerlink" title="3、程序加载配置文件"></a>3、程序加载配置文件</h4><pre><code class="java">@Configuration
public class RedissonConfig &#123;
    @Bean
    public RedissonClient redissonClient() throws IOException &#123;
        Config config = Config.fromYAML(RedissonConfig.class.getClassLoader().getResource(&quot;redission-config.yml&quot;));
        return Redisson.create(config);
    &#125;
&#125;
</code></pre>
<h4 id="4、配置RedisTemplate"><a href="#4、配置RedisTemplate" class="headerlink" title="4、配置RedisTemplate"></a>4、配置RedisTemplate</h4><p>在项目使用 Redission 时，我们一般会使用 RedissonClient 进行数据操作,但有朋友或许觉得 RedissonClient 操作不方便，或者更喜欢使用 RedisTemplate 进行操作，其实这两者也是可以共存的，我们只需要再定义 RedisTemplate 的配置类即可。</p>
<p>我们只需要定义一个配置类，且创建RedisTemplate自定义配置Bean即可</p>
<pre><code class="java">package com.xyz.config;

import org.springframework.boot.autoconfigure.AutoConfigureAfter;
import org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.redis.connection.RedisConnectionFactory;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.serializer.GenericJackson2JsonRedisSerializer;
import org.springframework.data.redis.serializer.StringRedisSerializer;

@Configuration
@AutoConfigureAfter(RedisAutoConfiguration.class)
public class RedisConfig &#123;
    @Bean
    public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory connectionFactory) &#123;
        // DEBUG 会发现其 connectionFactory 实例为 redission
        RedisTemplate&lt;String, Object&gt; redisTemplate = new RedisTemplate&lt;&gt;();
        redisTemplate.setConnectionFactory(connectionFactory);
        redisTemplate.setDefaultSerializer(new GenericJackson2JsonRedisSerializer());
        StringRedisSerializer stringRedisSerializer = new StringRedisSerializer();
        redisTemplate.setKeySerializer(stringRedisSerializer);
        redisTemplate.setHashKeySerializer(stringRedisSerializer);
        return redisTemplate;
    &#125;
&#125;
</code></pre>
<blockquote>
<p>发现项目引入Redission后，RedisTemplate底层所用的连接工厂也是Redission</p>
</blockquote>
<h2 id="3、数据类型操作"><a href="#3、数据类型操作" class="headerlink" title="3、数据类型操作"></a>3、数据类型操作</h2><p>Redis常用的数据结构一共有五种，分别是字符串String、散列表Hashmap、列表List、集合Set、有序集合Sortedset</p>
<h3 id="1、字符串桶操作（RBucket）"><a href="#1、字符串桶操作（RBucket）" class="headerlink" title="1、字符串桶操作（RBucket）"></a>1、字符串桶操作（RBucket）</h3><p>作用：桶存储单个对象，提供了原子替换功能，可在高并发场景下进行更新操作</p>
<p>1、相关接口：RBucket</p>
<pre><code class="java">public interface RBucket&lt;V&gt; extends RExpirable, RBucketAsync&lt;V&gt; &#123;

    void set(V var1);                                  // 设置桶存储的对象
    void set(V var1, long var2, TimeUnit var4);        // 设置桶存储的对象，设置操作的超时时间var2
 
    boolean trySet(V var1);                            // 尝试设置桶的新值
    boolean trySet(V var1, long var2, TimeUnit var4);  // 尝试设置桶的新值，设置超时时间var2
 
    boolean compareAndSet(V var1, V var2);             // 原子替换桶的新值为var2
 
    long size();                                       // 桶存储对象的大小
 
    V get();                                           // 返回桶存储的对象
    V getAndDelete();                                  // 返回并删除桶存储的对象
 
    V getAndSet(V var1);                               // 返回桶的旧值，设置新值
    V getAndSet(V var1, long var2, TimeUnit var4);     // 返回桶的旧值，设置新值，设置操作的超时时间var2
&#125;
</code></pre>
<p>2、操作示例</p>
<pre><code class="java">import org.redisson.Redisson;
import org.redisson.api.RedissonClient;
import org.redisson.config.Config;
import java.util.*;
import java.util.concurrent.TimeUnit;

public class StringRedissonTest &#123;

    private static RedissonClient redissonClient;
    static &#123;
        // 1、创建一个Config对象 , Redisson客户端使用fluent流式风格的编程，开发的时候比较方便
        Config config = new Config();
        //指定使用单节点部署方式
        config.useSingleServer().setAddress(&quot;redis://127.0.0.1:6379&quot;);

        //2、创建一个Redisson对象
        redissonClient = Redisson.create(config);
    &#125;

    public static void main(String[] args) &#123;
        // 清空当前数据库中的所有key
        redissonClient.getKeys().flushdb();
        // 清空整个Redis服务器的数据(删除所有数据库的所有key)
        redissonClient.getKeys().flushall();

        // string类型的操作
        redissonClient.getBucket(&quot;k1&quot;).set(&quot;v1&quot;);
        Object object = redissonClient.getBucket(&quot;k1&quot;).get();
        System.out.println(object); // v1

        // 删除节点
        redissonClient.getBucket(&quot;k1&quot;).delete();

        // 设置k1五秒后过期
        redissonClient.getBucket(&quot;k1&quot;).set(&quot;v1&quot;);
        redissonClient.getBucket(&quot;k1&quot;).expire(5, TimeUnit.SECONDS);

        // 关闭客户端
        redissonClient.shutdown();
    &#125;
&#125;
</code></pre>
<pre><code class="java">import org.redisson.Redisson;
import org.redisson.api.RBucket;
import org.redisson.api.RCountDownLatch;
import org.redisson.api.RedissonClient;
import org.redisson.config.Config;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class RBucketTest &#123;
    public static void main(String[] args) &#123;
        Config config = new Config();
        config.useSingleServer().setAddress(&quot;redis://127.0.0.1:6379&quot;);
        RedissonClient client = Redisson.create(config);

        RCountDownLatch countDownLatch = client.getCountDownLatch(&quot;countDownLatch&quot;);
        countDownLatch.trySetCount(20);

        RBucket&lt;String&gt; bucket = client.getBucket(&quot;bucket8&quot;);
        bucket.set(&quot;瓜田李下 &quot; + 1);

        String oldValue = bucket.get();
        ExecutorService executorService = Executors.newFixedThreadPool(10);
        for (int i = 0; i &lt; 20; i++) &#123;
            executorService.submit(() -&gt; &#123;
                if (bucket.compareAndSet(oldValue, &quot;瓜田李下 &quot; + 2)) &#123;
                    // 线程49更新了bucket的值
                    System.out.println(&quot;线程&quot; + Thread.currentThread().getId() + &quot;更新了bucket的值&quot;);
                &#125;
                countDownLatch.countDown();
            &#125;);
        &#125;

        try &#123;
            countDownLatch.await();
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125;
        // 更新后的桶对象为：瓜田李下 2
        System.out.println(&quot;更新后的桶对象为：&quot; + bucket.get());
    &#125;
&#125;
</code></pre>
<h3 id="2、Hash-键值对（RMap）"><a href="#2、Hash-键值对（RMap）" class="headerlink" title="2、Hash 键值对（RMap）"></a>2、Hash 键值对（RMap）</h3><p>1、相关接口：RMap</p>
<pre><code class="java">public interface RMap&lt;K, V&gt; extends ConcurrentMap&lt;K, V&gt;, RExpirable, RMapAsync&lt;K, V&gt; &#123;

    void loadAll(boolean var1, int var2);
    void loadAll(Set&lt;? extends K&gt; var1, boolean var2, int var3);

    V get(Object var1);                       // 获取var1的值
    V put(K var1, V var2);                    // 添加对象
    V putIfAbsent(K var1, V var2);            // 对象不存在则设置

    V replace(K var1, V var2);                // 替换对象
    boolean replace(K var1, V var2, V var3);  // 替换对象

    V remove(Object var1);                    // 移除对象
    boolean remove(Object var1, Object var2); // 移除对象

    // 添加对象
    void putAll(Map&lt;? extends K, ? extends V&gt; var1);
    void putAll(Map&lt;? extends K, ? extends V&gt; var1, int var2);

    Map&lt;K, V&gt; getAll(Set&lt;K&gt; var1);           // 获取key在集合var1中的键值对

    int valueSize(K var1);                   // key为var1的value大小

    V addAndGet(K var1, Number var2);        // key为var1的value加var2

    long fastRemove(K... var1);              // 移除对象
    boolean fastPut(K var1, V var2);         // 添加对象
    boolean fastReplace(K var1, V var2);     // 替换key为var1的值为var2
    boolean fastPutIfAbsent(K var1, V var2); // 如果不存在则设置

    Set&lt;K&gt; readAllKeySet();                  // 获取所有key，以set形式返回
    Collection&lt;V&gt; readAllValues();           // 获取所有value，以collection返回
    Set&lt;Entry&lt;K, V&gt;&gt; readAllEntrySet();      // 遍历键值对
    Map&lt;K, V&gt; readAllMap();                  // 集合形式转换为map类型

    // 获取key集合
    Set&lt;K&gt; keySet();
    Set&lt;K&gt; keySet(int var1);
    Set&lt;K&gt; keySet(String var1, int var2);
    Set&lt;K&gt; keySet(String var1);

    // 获取所有value
    Collection&lt;V&gt; values();
    Collection&lt;V&gt; values(String var1);
    Collection&lt;V&gt; values(String var1, int var2);
    Collection&lt;V&gt; values(int var1);

    // 遍历键值对
    Set&lt;Entry&lt;K, V&gt;&gt; entrySet();
    Set&lt;Entry&lt;K, V&gt;&gt; entrySet(String var1);
    Set&lt;Entry&lt;K, V&gt;&gt; entrySet(String var1, int var2);
    Set&lt;Entry&lt;K, V&gt;&gt; entrySet(int var1);

    &lt;KOut, VOut&gt; RMapReduce&lt;K, V, KOut, VOut&gt; mapReduce();
    
    // 信号量操作
    RSemaphore getSemaphore(K var1);
    RCountDownLatch getCountDownLatch(K var1);
    RPermitExpirableSemaphore getPermitExpirableSemaphore(K var1);

    // 锁操作
    RLock getLock(K var1);
    RLock getFairLock(K var1);
    RReadWriteLock getReadWriteLock(K var1);
&#125;
</code></pre>
<p>2、操作示例</p>
<pre><code class="java">import org.redisson.Redisson;
import org.redisson.api.RMap;
import org.redisson.api.RedissonClient;
import org.redisson.config.Config;
import java.util.Map;

public class MyTest &#123;

    public static void main(String[] args) &#123;
        Config config = new Config();
        config.useSingleServer().setAddress(&quot;redis://127.0.0.1:6379&quot;).setPassword(&quot;123456&quot;);
        RedissonClient client = Redisson.create(config);

        RMap&lt;Integer, String&gt; map = client.getMap(&quot;map&quot;);
        for (int i = 0; i &lt; 10; i++) &#123;
            map.put(i, &quot;瓜田李下 &quot; + i);
        &#125;

        for (Map.Entry&lt;Integer, String&gt; entry : map.entrySet()) &#123;
            System.out.println(entry.getKey() + &quot; ==&gt; &quot; + entry.getValue());
        &#125;
        System.out.println(&quot;map的大小为：&quot; + map.size());
    &#125;
&#125;
</code></pre>
<pre><code>0 ==&gt; 瓜田李下 0
1 ==&gt; 瓜田李下 1
2 ==&gt; 瓜田李下 2
3 ==&gt; 瓜田李下 3
4 ==&gt; 瓜田李下 4
5 ==&gt; 瓜田李下 5
6 ==&gt; 瓜田李下 6
7 ==&gt; 瓜田李下 7
8 ==&gt; 瓜田李下 8
9 ==&gt; 瓜田李下 9
map的大小为：10
</code></pre>
<h3 id="3、List-链表操作（Rlist）"><a href="#3、List-链表操作（Rlist）" class="headerlink" title="3、List 链表操作（Rlist）"></a>3、List 链表操作（Rlist）</h3><p>1、相关接口</p>
<pre><code class="java">public interface RList&lt;V&gt; extends List&lt;V&gt;, RExpirable, RListAsync&lt;V&gt;, RSortable&lt;List&lt;V&gt;&gt;, RandomAccess &#123;

    List&lt;V&gt; get(int... var1);              // 获取指定的节点值

    int addAfter(V var1, V var2);          // 在var1前添加var2
    int addBefore(V var1, V var2);         // 在var1后添加var2
    void fastSet(int var1, V var2);        // 修改var1处的只为var2

    List&lt;V&gt; readAll();                     // 获取链表的所有值
    RList&lt;V&gt; subList(int var1, int var2);  // 获取var1到var2的子链表
    List&lt;V&gt; range(int var1);               // 返回var1往后的链表
    List&lt;V&gt; range(int var1, int var2);     // 返回var1到var2的链表

    void trim(int var1, int var2);         // 保留var1到var2处的链表，其余删除

    void fastRemove(int var1);             // 删除var1处的值
    boolean remove(Object var1, int var2); // 判断元素是否删除

    &lt;KOut, VOut&gt; RCollectionMapReduce&lt;V, KOut, VOut&gt; mapReduce();  // mapreduce操作
&#125;
</code></pre>
<p>2、操作示例</p>
<pre><code class="java">import org.redisson.Redisson;
import org.redisson.api.RList;
import org.redisson.api.RedissonClient;
import org.redisson.config.Config;

public class RlistTest &#123;

    public static void main(String[] args) &#123;
        Config config = new Config();
        config.useSingleServer().setAddress(&quot;redis://127.0.0.1:6379&quot;).setPassword(&quot;123456&quot;);
        RedissonClient client = Redisson.create(config);

        RList&lt;String&gt; list = client.getList(&quot;list&quot;);
        for (int i = 0; i &lt; 10; i++) &#123;
            list.add(&quot;瓜田李下 &quot; + i);
        &#125;

        list.readAll().forEach(System.out::println);
        System.out.println(&quot;list的数量为：&quot; + list.size() + &quot;\n&quot;);
    &#125;
&#125;
</code></pre>
<pre><code>瓜田李下 0
瓜田李下 1
瓜田李下 2
瓜田李下 3
瓜田李下 4
瓜田李下 5
瓜田李下 6
瓜田李下 7
瓜田李下 8
瓜田李下 9
list的数量为：10
</code></pre>
<h3 id="4、Set-无序集合操作（RSet）"><a href="#4、Set-无序集合操作（RSet）" class="headerlink" title="4、Set 无序集合操作（RSet）"></a>4、Set 无序集合操作（RSet）</h3><p>1、相关接口：RSet</p>
<pre><code class="java">public interface RSet&lt;V&gt; extends Set&lt;V&gt;, RExpirable, RSetAsync&lt;V&gt;, RSortable&lt;Set&lt;V&gt;&gt; &#123;

    V removeRandom();
    Set&lt;V&gt; removeRandom(int var1);     // 删除对象

    V random();
    Set&lt;V&gt; random(int var1);           // 随机返回对象

    boolean move(String var1, V var2); // 判断集合var1中是否存在var2，类似contains()方法

    Set&lt;V&gt; readAll();                  // 获取所有对象

    int union(String... var1);         // 集合并集对象个数
    Set&lt;V&gt; readUnion(String... var1);  // 集合并集

    int diff(String... var1);          // 集合差集对象个数
    Set&lt;V&gt; readDiff(String... var1);   // 集合差集

    int intersection(String... var1);         // 集合交集的对象个数
    Set&lt;V&gt; readIntersection(String... var1);  // 集合交集

    // 遍历集合
    Iterator&lt;V&gt; iterator(int var1);
    Iterator&lt;V&gt; iterator(String var1, int var2);
    Iterator&lt;V&gt; iterator(String var1);

    &lt;KOut, VOut&gt; RCollectionMapReduce&lt;V, KOut, VOut&gt; mapReduce();

    // 信号量
    RSemaphore getSemaphore(V var1);
    RCountDownLatch getCountDownLatch(V var1);
    RPermitExpirableSemaphore getPermitExpirableSemaphore(V var1);

    // 锁操作
    RLock getLock(V var1);
    RLock getFairLock(V var1);
    RReadWriteLock getReadWriteLock(V var1);

    // 流操作
    Stream&lt;V&gt; stream(int var1);
    Stream&lt;V&gt; stream(String var1, int var2);
    Stream&lt;V&gt; stream(String var1);
&#125;
</code></pre>
<p>2、操作示例</p>
<pre><code class="java">package com.xyz.redis;

import org.redisson.Redisson;
import org.redisson.api.RSet;
import org.redisson.api.RedissonClient;
import org.redisson.config.Config;

public class RSetTest &#123;

    public static void main(String[] args) &#123;
        Config config = new Config();
        config.useSingleServer().setAddress(&quot;redis://127.0.0.1:6379&quot;).setPassword(&quot;123456&quot;);
        RedissonClient client = Redisson.create(config);
        
        RSet&lt;String&gt; set = client.getSet(&quot;set&quot;);
        for (int i = 0; i &lt; 10; i++) &#123;
            set.add(&quot;瓜田李下 &quot; + i);
        &#125;

        for (String s : set) &#123;
            System.out.println(s);
        &#125;
        System.out.println(&quot;set的大小为：&quot; + set.size() + &quot;\n&quot;);
    &#125;
&#125;
</code></pre>
<pre><code>瓜田李下 0
瓜田李下 1
瓜田李下 7
瓜田李下 3
瓜田李下 5
瓜田李下 4
瓜田李下 9
瓜田李下 8
瓜田李下 6
瓜田李下 2
set的大小为：10
</code></pre>
<h3 id="5、ZSet-有序集合操作（RScoredSortedSet）"><a href="#5、ZSet-有序集合操作（RScoredSortedSet）" class="headerlink" title="5、ZSet 有序集合操作（RScoredSortedSet）"></a>5、ZSet 有序集合操作（RScoredSortedSet）</h3><p>1、相关接口：RScoredSortedSet。由于方法太多就不展示，自行查看源码</p>
<p>2、操作示例</p>
<pre><code class="java">import org.redisson.Redisson;
import org.redisson.api.RedissonClient;
import org.redisson.config.Config;

public class RScoredSortedSetTest &#123;

    public static void main(String[] args) &#123;
        Config config = new Config();
        config.useSingleServer().setAddress(&quot;redis://127.0.0.1:6379&quot;);
        RedissonClient client = Redisson.create(config);

        client.getScoredSortedSet(&quot;myZSet&quot;).add(1, &quot;666&quot;);
        client.getScoredSortedSet(&quot;myZSet&quot;).add(2, &quot;999&quot;);
        client.getScoredSortedSet(&quot;myZSet&quot;).add(3, &quot;888&quot;);
        client.getScoredSortedSet(&quot;myZSet&quot;).forEach(System.out::println);
        System.out.println(client.getScoredSortedSet(&quot;myZSet&quot;).getScore(&quot;666&quot;));
    &#125;
&#125;
</code></pre>
<pre><code>666
999
888
1.0
</code></pre>
<h3 id="5、基数操作（RHyperLogLog）"><a href="#5、基数操作（RHyperLogLog）" class="headerlink" title="5、基数操作（RHyperLogLog）"></a>5、基数操作（RHyperLogLog）</h3><p>作用：用于大数据计数，适用于对数据准确度不高的大数据计数场景</p>
<p>1、相关接口：RHyperLogLog。说明：重复对象不会添加</p>
<pre><code class="java">public interface RHyperLogLog&lt;V&gt; extends RExpirable, RHyperLogLogAsync&lt;V&gt; &#123;

    boolean add(V var1);                  // 添加对象
    boolean addAll(Collection&lt;V&gt; var1);   // 添加集合对象

    long count();                         // 计算当前基数个数
    long countWith(String... var1);       // 合并计算指定key的基数个数
    void mergeWith(String... var1);       // 当前基数合并计算指定基数并保存
&#125;
</code></pre>
<p>2、操作示例</p>
<pre><code class="java">import org.redisson.Redisson;
import org.redisson.api.RHyperLogLog;
import org.redisson.api.RedissonClient;
import org.redisson.config.Config;

public class RHyperLogLogTest &#123;

    public static void main(String[] args) &#123;
        Config config = new Config();
        config.useSingleServer().setAddress(&quot;redis://127.0.0.1:6379&quot;);
        RedissonClient client = Redisson.create(config);

        RHyperLogLog&lt;String&gt; hyperLogLog = client.getHyperLogLog(&quot;hyperLogLog&quot;);
        for (int i = 0; i &lt; 10000; i++) &#123;
            hyperLogLog.add(&quot;瓜田李下 &quot; + i);
        &#125;

        RHyperLogLog&lt;String&gt; hyperLogLog2 = client.getHyperLogLog(&quot;hyperLogLog2&quot;);
        for (int i = 0; i &lt; 10000; i++) &#123;
            hyperLogLog2.add(&quot;海贼王 &quot; + i);
        &#125;

        System.out.println(&quot;hyperLogLog的数据量为：&quot; + hyperLogLog.count());
        System.out.println(&quot;hyperLogLog2的数据量为：&quot; + hyperLogLog2.count());
        System.out.println(&quot;hyperLogLog合并计算hyperLogLog2的数据量为：&quot; + hyperLogLog.countWith(&quot;hyperLogLog2&quot;));

        hyperLogLog.mergeWith(&quot;hyperLogLog2&quot;);
        System.out.println(&quot;合并hyperLogLog2后的总数据量为：&quot; + hyperLogLog.count());
    &#125;
&#125;
</code></pre>
<pre><code>hyperLogLog的数据量为：10035
hyperLogLog2的数据量为：10079
hyperLogLog合并计算hyperLogLog2的数据量为：20192
合并hyperLogLog2后的总数据量为：20192
</code></pre>
<blockquote>
<p>说明：可以看出，数据统计值是个估算值，与实际数据量有差异</p>
</blockquote>
<h3 id="6、原子长整型（RAtomicLong）"><a href="#6、原子长整型（RAtomicLong）" class="headerlink" title="6、原子长整型（RAtomicLong）"></a>6、原子长整型（RAtomicLong）</h3><p>作用：原子长整形可以用作计数器，或者分布式ID</p>
<p>1、相关接口：RAtomicLong</p>
<pre><code class="java">public interface RAtomicLong extends RExpirable, RAtomicLongAsync &#123;

    long get();                  // 获取数值

    long getAndIncrement();      // 数值加1，返回原值
    long incrementAndGet();      // 加一后返回数最新值
    long getAndAdd(long var1);   // 加var1，返回原值
    long addAndGet(long var1);   // 加var1后返回最新值

    long getAndDelete();         // 获取数值后删除数据

    long getAndDecrement();      // 数值减一，返回原值
    long decrementAndGet();      // 数值减一，返回最新值

    void set(long var1);                         // 设置值为var1
    long getAndSet(long var1);                   // 设置值为var1，返回原值
    boolean compareAndSet(long var1, long var3); // 原子替换值为var3
&#125;
</code></pre>
<p>2、操作示例</p>
<pre><code class="java">import org.redisson.Redisson;
import org.redisson.api.RHyperLogLog;
import org.redisson.api.RedissonClient;
import org.redisson.config.Config;

public class RAtomicLongTest &#123;

    public static void main(String[] args) &#123;
        Config config = new Config();
        config.useSingleServer().setAddress(&quot;redis://127.0.0.1:6379&quot;);
        RedissonClient client = Redisson.create(config);

        RHyperLogLog&lt;String&gt; hyperLogLog = client.getHyperLogLog(&quot;hyperLogLog&quot;);
        for (int i = 0; i &lt; 10000; i++) &#123;
            hyperLogLog.add(&quot;瓜田李下 &quot; + i);
        &#125;

        RHyperLogLog&lt;String&gt; hyperLogLog2 = client.getHyperLogLog(&quot;hyperLogLog2&quot;);
        for (int i = 0; i &lt; 10000; i++) &#123;
            hyperLogLog2.add(&quot;海贼王 &quot; + i);
        &#125;

        System.out.println(&quot;hyperLogLog的数据量为：&quot; + hyperLogLog.count());
        System.out.println(&quot;hyperLogLog2的数据量为：&quot; + hyperLogLog2.count());
        System.out.println(&quot;hyperLogLog合并计算hyperLogLog2的数据量为：&quot; + hyperLogLog.countWith(&quot;hyperLogLog2&quot;));

        hyperLogLog.mergeWith(&quot;hyperLogLog2&quot;);
        System.out.println(&quot;合并hyperLogLog2后的总数据量为：&quot; + hyperLogLog.count());
    &#125;
&#125;
</code></pre>
<h2 id="4、分布式锁类集"><a href="#4、分布式锁类集" class="headerlink" title="4、分布式锁类集"></a>4、分布式锁类集</h2><h3 id="1、普通锁（RLock）"><a href="#1、普通锁（RLock）" class="headerlink" title="1、普通锁（RLock）"></a>1、普通锁（RLock）</h3><p>1、相关类及接口</p>
<p>RLock：Redisson的普通锁（又叫可重入锁）</p>
<pre><code class="java">public interface RLock extends Lock, RLockAsync &#123;
 
    // 获取加锁的key
    String getName();
 
    void lockInterruptibly(long var1, TimeUnit var3) throws InterruptedException;
    boolean tryLock(long var1, long var3, TimeUnit var5) throws InterruptedException;
    // 获取锁对象，设置过期时间到期自动释放，采用此种加锁方式，可能发生任务没有完成锁就释放
    void lock(long var1, TimeUnit var3);  
 
    boolean forceUnlock();                // 解锁
    boolean isLocked();                   // 锁是否被占用
 
    boolean isHeldByThread(long var1);    // 锁是否被指定线程占用
    boolean isHeldByCurrentThread();      // 锁是否被当前线程占用
 
    int getHoldCount();                   // 等待获取所的线程数
    long remainTimeToLive();              // 所得剩余时间
&#125;
</code></pre>
<p>Lock：JUC中的锁对象。说明：加锁使用此接口的lock()方法，可保证正常情况下业务没有完成锁不会释放</p>
<pre><code class="java">public interface Lock &#123;

    // 加锁
    void lock();
    void lockInterruptibly() throws InterruptedException; 

    // 如果不能获得锁，立刻返回
    boolean tryLock();
    // 如果在指定的时间内不能获得锁，则立刻返回
    boolean tryLock(long time, TimeUnit unit) throws InterruptedException;
    
    void unlock();             // 释放锁对象
    Condition newCondition();  // 获得与锁相关的condition对象
&#125;
</code></pre>
<p>RLockAsync：异步锁接口</p>
<pre><code class="java">public interface RLockAsync &#123;

    RFuture&lt;Void&gt; lockAsync();
    RFuture&lt;Void&gt; lockAsync(long var1); // var1为线程id
    RFuture&lt;Void&gt; lockAsync(long var1, TimeUnit var3);   // 锁超时时间
    // 异步加锁，超时时间var1，时间单位var3，var4为线程id
    RFuture&lt;Void&gt; lockAsync(long var1, TimeUnit var3, long var4);

    RFuture&lt;Boolean&gt; tryLockAsync();
    RFuture&lt;Boolean&gt; tryLockAsync(long var1);   // var1为线程id
    RFuture&lt;Boolean&gt; tryLockAsync(long var1, TimeUnit var3);  // 锁超时时间
    RFuture&lt;Boolean&gt; tryLockAsync(long var1, long var3, TimeUnit var5);  // 锁等待时间，超时时间
    // 异步尝试加锁，等待时间var1，锁超时时间var3，时间单位var5，var6为线程id
    RFuture&lt;Boolean&gt; tryLockAsync(long var1, long var3, TimeUnit var5, long var6);

    RFuture&lt;Void&gt; unlockAsync();
    RFuture&lt;Void&gt; unlockAsync(long var1);   // 释放锁

    RFuture&lt;Boolean&gt; forceUnlockAsync();    // 强制释放锁

    RFuture&lt;Integer&gt; getHoldCountAsync();   // 持有锁的线程数
    RFuture&lt;Boolean&gt; isLockedAsync();       // 锁是否被占有
    RFuture&lt;Long&gt; remainTimeToLiveAsync();  // 所得剩余时间
&#125;
</code></pre>
<p>2、普通锁操作示例</p>
<pre><code class="java">import org.redisson.Redisson;
import org.redisson.api.RLock;
import org.redisson.api.RedissonClient;
import org.redisson.config.Config;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;

public class RLockTest &#123;

    public static void main(String[] args) &#123;
        Config config = new Config();
        config.useSingleServer().setAddress(&quot;redis://***:6379&quot;).setPassword(&quot;123456&quot;);
        RedissonClient client = Redisson.create(config);
        // 获取一把锁，只要锁的名字一样，就是同一把锁
        RLock lock = client.getLock(&quot;lock&quot;);

        ExecutorService executorService = Executors.newFixedThreadPool(5);
        for (int i = 0; i &lt; 10; i++) &#123;
            executorService.submit(() -&gt; &#123;
                try &#123;
                    lock.lock(1, TimeUnit.SECONDS);
                    System.out.println(&quot;线程 &quot; + Thread.currentThread().getId() + &quot; 获得锁：&quot; + System.currentTimeMillis());
                    Thread.sleep(4000);
                &#125; catch (Exception e) &#123;
                    e.printStackTrace();
                &#125; finally &#123;
                    System.out.println(&quot;线程&quot; + Thread.currentThread().getId() + &quot;释放锁：&quot; + System.currentTimeMillis());
                    lock.forceUnlock();
                &#125;
            &#125;);
        &#125;
        System.out.println(lock.getName());
        System.out.println(lock.getHoldCount());
    &#125;
&#125;
</code></pre>
<p>输出内容</p>
<pre><code>线程 49 获得锁：1574600045851
线程 49 释放锁：1574600049854
 
线程 49 获得锁：1574600049872
线程 49 释放锁：1574600053876
 
线程 49 获得锁：1574600053897
线程 49 释放锁：1574600057897
 
线程 49 获得锁：1574600057903
线程 49 释放锁：1574600061904
 
线程 49 获得锁：1574600061925
线程 49 释放锁：1574600065928
 
线程 49 获得锁：1574600065933
线程 49 释放锁：1574600069936
 
线程 50 获得锁：1574600069945
线程 50 释放锁：1574600073947
 
线程 48 获得锁：1574600073955
线程 48 释放锁：1574600077958
 
线程 51 获得锁：1574600077970
线程 51 释放锁：1574600081972
 
线程 52 获得锁：1574600081993
线程 52 释放锁：1574600085995
</code></pre>
<h3 id="2、读写锁（RReadWriteLock）"><a href="#2、读写锁（RReadWriteLock）" class="headerlink" title="2、读写锁（RReadWriteLock）"></a>2、读写锁（RReadWriteLock）</h3><p>1、相关类及接口：RReadWriteLock：读写锁。说明：读读不互斥，读写、写写互斥</p>
<pre><code class="java">public interface RReadWriteLock extends ReadWriteLock &#123;
    RLock readLock();
    RLock writeLock();
&#125;
</code></pre>
<p>2、写锁操作示例</p>
<pre><code class="java">import org.redisson.Redisson;
import org.redisson.api.RLock;
import org.redisson.api.RReadWriteLock;
import org.redisson.api.RedissonClient;
import org.redisson.config.Config;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class RReadWriteLockTest &#123;

    public static void main(String[] args) &#123;
        Config config = new Config();
        config.useSingleServer().setAddress(&quot;redis://***:6379&quot;).setPassword(&quot;123456&quot;);
        RedissonClient client = Redisson.create(config);

        RReadWriteLock readWriteLock = client.getReadWriteLock(&quot;read_write_lock&quot;);
        RLock readLock = readWriteLock.readLock();
        RLock writeLock = readWriteLock.writeLock();

        System.out.println(&quot;读锁测试：&quot;);
        ExecutorService executorService = Executors.newFixedThreadPool(5);
        for (int i = 0; i &lt; 10; i++) &#123;
            executorService.submit(() -&gt; &#123;
                try &#123;
                    readLock.lock();
                    System.out.println(&quot;线程 &quot; + Thread.currentThread().getId() + &quot; 获得锁：&quot; + System.currentTimeMillis());
                    Thread.sleep(1000);
                &#125; catch (Exception e) &#123;
                    e.printStackTrace();
                &#125; finally &#123;
                    System.out.println(&quot;线程 &quot; + Thread.currentThread().getId() + &quot; 释放锁：&quot; + System.currentTimeMillis());
                    readLock.unlock();
                &#125;
            &#125;);
        &#125;

        try &#123;
            Thread.sleep(10000);
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125;

        System.out.println(&quot;写锁测试：&quot;);
        ExecutorService executorService2 = Executors.newFixedThreadPool(5);
        for (int i = 0; i &lt; 10; i++) &#123;
            executorService2.submit(() -&gt; &#123;
                try &#123;
                    writeLock.lock();
                    System.out.println(&quot;线程 &quot; + Thread.currentThread().getId() + &quot; 获得锁：&quot; + System.currentTimeMillis());
                    Thread.sleep(1000);
                &#125; catch (Exception e) &#123;
                    e.printStackTrace();
                &#125; finally &#123;
                    System.out.println(&quot;线程 &quot; + Thread.currentThread().getId() + &quot; 释放锁：&quot; + System.currentTimeMillis());
                    writeLock.unlock();
                &#125;
            &#125;);
        &#125;
    &#125;
&#125;
</code></pre>
<p>输出内容</p>
<pre><code>读锁测试：
线程 48 获得锁：1574601417219
线程 49 获得锁：1574601417220
线程 51 获得锁：1574601417220
线程 50 获得锁：1574601417220
线程 52 获得锁：1574601417220
线程 52 释放锁：1574601418223
线程 50 释放锁：1574601418223
线程 49 释放锁：1574601418223
线程 48 释放锁：1574601418223
线程 51 释放锁：1574601418223
线程 50 获得锁：1574601418260
线程 49 获得锁：1574601418260
线程 52 获得锁：1574601418260
线程 48 获得锁：1574601418261
线程 51 获得锁：1574601418261
线程 49 释放锁：1574601419261
线程 50 释放锁：1574601419261
线程 48 释放锁：1574601419264
线程 51 释放锁：1574601419264
线程 52 释放锁：1574601419265
 
写锁测试：
线程 55 获得锁：1574601427218
线程 55 释放锁：1574601428218
线程 55 获得锁：1574601428225
线程 55 释放锁：1574601429228
线程 55 获得锁：1574601429235
线程 55 释放锁：1574601430238
线程 55 获得锁：1574601430256
线程 55 释放锁：1574601431259
线程 55 获得锁：1574601431274
线程 55 释放锁：1574601432276
线程 53 获得锁：1574601432282
线程 53 释放锁：1574601433283
线程 56 获得锁：1574601433302
线程 56 释放锁：1574601434303
线程 55 获得锁：1574601434310
线程 55 释放锁：1574601435313
线程 57 获得锁：1574601435317
线程 57 释放锁：1574601436319
线程 54 获得锁：1574601436339
线程 54 释放锁：1574601437343
</code></pre>
<blockquote>
<p>说明：多个线程同时获得读锁，写锁同时只能被一个线程获取</p>
</blockquote>
<h3 id="3、信号量（RSemaphore）"><a href="#3、信号量（RSemaphore）" class="headerlink" title="3、信号量（RSemaphore）"></a>3、信号量（RSemaphore）</h3><p>作用：限制同时访问共享区域的线程数量</p>
<p>1、相关接口：RSemaphore</p>
<pre><code class="java">public interface RSemaphore extends RExpirable, RSemaphoreAsync &#123;

    boolean trySetPermits(int var1);                     // 设置permits数
    void reducePermits(int var1);                        // 减少permit数

    void acquire() throws InterruptedException;          // 获得一个permit
    void acquire(int var1) throws InterruptedException;  // 获得var1个permits

    boolean tryAcquire();                                // 尝试获得permit
    boolean tryAcquire(int var1);                        // 尝试获得var1个permit
    // 尝试获得permit，等待时间var1
    boolean tryAcquire(long var1, TimeUnit var3) throws InterruptedException;
    // 尝试获得var1个permit，等待时间var2
    boolean tryAcquire(int var1, long var2, TimeUnit var4) throws InterruptedException;

    void release();                                      // 释放permit
    void release(int var1);                              // 释放var1个permits

    int availablePermits();                              // 信号量的permits数
    int drainPermits();                                  // 清空permits
&#125;
</code></pre>
<p>2、操作示例</p>
<pre><code class="java">import org.redisson.Redisson;
import org.redisson.api.RSemaphore;
import org.redisson.api.RedissonClient;
import org.redisson.config.Config;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class RSemaphoreTest &#123;

    public static void main(String[] args) &#123;
        Config config = new Config();
        config.useSingleServer().setAddress(&quot;redis://***:6379&quot;).setPassword(&quot;123456&quot;);
        RedissonClient client = Redisson.create(config);

        RSemaphore semaphore = client.getSemaphore(&quot;semaphore&quot;);
        semaphore.trySetPermits(5);

        ExecutorService executorService = Executors.newFixedThreadPool(5);
        for (int i = 0; i &lt; 10; i++) &#123;
            executorService.submit(() -&gt; &#123;
                try &#123;
                    semaphore.acquire();
                    System.out.println(&quot;线程&quot; + Thread.currentThread().getId() + &quot; 获得permit：&quot; + System.currentTimeMillis());
                    Thread.sleep(1000);
                &#125; catch (Exception e) &#123;
                    e.printStackTrace();
                &#125; finally &#123;
                    System.out.println(&quot;线程&quot; + Thread.currentThread().getId() + &quot; 释放permit：&quot; + System.currentTimeMillis());
                    semaphore.release();
                &#125;
            &#125;);
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code>线程49 获得permit：1574646338160
线程50 获得permit：1574646338161
线程48 获得permit：1574646338161
线程51 获得permit：1574646338164
线程52 获得permit：1574646338164
线程49 释放permit：1574646339162
线程48 释放permit：1574646339162
线程50 释放permit：1574646339162
线程51 释放permit：1574646339165
线程52 释放permit：1574646339165
线程50 获得permit：1574646339189
线程49 获得permit：1574646339189
线程48 获得permit：1574646339189
线程52 获得permit：1574646339191
线程51 获得permit：1574646339191
线程48 释放permit：1574646340190
线程50 释放permit：1574646340190
线程49 释放permit：1574646340190
线程51 释放permit：1574646340191
线程52 释放permit：1574646340191
</code></pre>
<h3 id="4、倒计数器（RCountDownLatch）"><a href="#4、倒计数器（RCountDownLatch）" class="headerlink" title="4、倒计数器（RCountDownLatch）"></a>4、倒计数器（RCountDownLatch）</h3><p>作用：等待足够线程执行后，执行后续操作</p>
<p>相关接口：RCountDownLatch</p>
<pre><code class="java">public interface RCountDownLatch extends RObject, RCountDownLatchAsync &#123;
    boolean trySetCount(long var1);            // 设置等待线程的数量

    void await() throws InterruptedException;  // 等待
    boolean await(long var1, TimeUnit var3) throws InterruptedException; // 最多等待var时间后，继续运行

    void countDown();                          // 计数器减一
    long getCount();                           // 获得计数器的个数
&#125;
</code></pre>
<p>2、操作示例</p>
<pre><code class="java">import org.redisson.Redisson;
import org.redisson.api.RCountDownLatch;
import org.redisson.api.RedissonClient;
import org.redisson.config.Config;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class RCountDownLatchTest &#123;

    public static void main(String[] args) &#123;
        Config config = new Config();
        config.useSingleServer().setAddress(&quot;redis://***:6379&quot;).setPassword(&quot;123456&quot;);
        RedissonClient client = Redisson.create(config);

        RCountDownLatch countDownLatch = client.getCountDownLatch(&quot;cuntDownLatch&quot;);
        countDownLatch.trySetCount(5);

        
        ExecutorService executorService = Executors.newFixedThreadPool(5);
        for (int i = 0; i &lt; 5; i++) &#123;
            int finalI = i;
            executorService.submit(() -&gt; &#123;
                try &#123;
                    System.out.println(&quot;瓜田李下 &quot; + finalI + &quot;开始执行：&quot; + System.currentTimeMillis());
                    Thread.sleep(1000);
                    System.out.println(&quot;瓜田李下 &quot; + finalI + &quot;执行结束：&quot; + System.currentTimeMillis());
                &#125; catch (Exception e) &#123;
                    e.printStackTrace();
                &#125; finally &#123;
                    countDownLatch.countDown();
                &#125;
            &#125;);
        &#125;

        try &#123;
            System.out.println(&quot;主线程开始等待：&quot; + System.currentTimeMillis());
            countDownLatch.await();
            System.out.println(&quot;主线程等待结束：&quot; + System.currentTimeMillis());
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125;

        System.out.println(&quot;主线程运行结束&quot;);
    &#125;
&#125;
</code></pre>
<pre><code>瓜田李下 0开始执行：1574648441622
瓜田李下 3开始执行：1574648441622
瓜田李下 4开始执行：1574648441622
主线程开始等待：1574648441622
瓜田李下 2开始执行：1574648441622
瓜田李下 1开始执行：1574648441622
瓜田李下 3执行结束：1574648442625
瓜田李下 4执行结束：1574648442625
瓜田李下 1执行结束：1574648442625
瓜田李下 0执行结束：1574648442625
瓜田李下 2执行结束：1574648442625
主线程等待结束：1574648442637
主线程运行结束
</code></pre>
<h2 id="5、-限流器（RRateLimiter）"><a href="#5、-限流器（RRateLimiter）" class="headerlink" title="5、 限流器（RRateLimiter）"></a>5、 限流器（RRateLimiter）</h2><p>作用：限制一段时间内对数据的访问数量</p>
<p>1、相关接口与类</p>
<p>RRateLimiter：限流器</p>
<pre><code class="java">public interface RRateLimiter extends RRateLimiterAsync, RObject &#123;

    // 设置访问速率，var2为访问数，var4为单位时间，var6为时间单位
    boolean trySetRate(RateType var1, long var2, long var4, RateIntervalUnit var6);

    void acquire();           // 访问数据
    void acquire(long var1);  // 占var1的速度计算值
 
    boolean tryAcquire();                                    // 尝试访问数据
    boolean tryAcquire(long var1);                           // 尝试访问数据，占var1的速度计算值
    boolean tryAcquire(long var1, TimeUnit var3);            // 尝试访问数据，设置等待时间var3
    boolean tryAcquire(long var1, long var3, TimeUnit var5); // 尝试访问数据，占数据计算值var1，设置等待时间var3
 
    RateLimiterConfig getConfig();
&#125;
</code></pre>
<p>RateType：限流类型</p>
<pre><code class="java">public enum RateType &#123;
    OVERALL,             // 所有客户端加总限流
    PER_CLIENT;          // 每个客户端单独计算流量
    private RateType() &#123;
    &#125;
&#125;
</code></pre>
<p>RateInternalUnit：限流单位</p>
<pre><code class="java">public enum RateIntervalUnit &#123;
    MILLISECONDS &#123;
        public long toMillis(long value) &#123;
            return value;
        &#125;
    &#125;,
    SECONDS &#123;
        public long toMillis(long value) &#123;
            return TimeUnit.SECONDS.toMillis(value);
        &#125;
    &#125;,
    MINUTES &#123;
        public long toMillis(long value) &#123;
            return TimeUnit.MINUTES.toMillis(value);
        &#125;
    &#125;,
    HOURS &#123;
        public long toMillis(long value) &#123;
            return TimeUnit.HOURS.toMillis(value);
        &#125;
    &#125;,
    DAYS &#123;
        public long toMillis(long value) &#123;
            return TimeUnit.DAYS.toMillis(value);
        &#125;
    &#125;;

    private RateIntervalUnit() &#123;
    &#125;

    public abstract long toMillis(long var1);
&#125;
</code></pre>
<p>2、操作示例</p>
<pre><code class="java">import org.redisson.Redisson;
import org.redisson.api.RRateLimiter;
import org.redisson.api.RateIntervalUnit;
import org.redisson.api.RateType;
import org.redisson.api.RedissonClient;
import org.redisson.config.Config;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class RRateLimiterTest &#123;

    public static void main(String[] args) &#123;
        Config config = new Config();
        config.useSingleServer().setAddress(&quot;redis://192.168.57.120:6379&quot;).setPassword(&quot;123456&quot;);
        RedissonClient client = Redisson.create(config);

        RRateLimiter rateLimiter = client.getRateLimiter(&quot;rate_limiter&quot;);
        rateLimiter.trySetRate(RateType.PER_CLIENT, 5, 2, RateIntervalUnit.MINUTES);

        ExecutorService executorService = Executors.newFixedThreadPool(10);
        for (int i = 0; i &lt; 10; i++) &#123;
            executorService.submit(() -&gt; &#123;
                try &#123;
                    rateLimiter.acquire();
                    System.out.println(&quot;线程&quot; + Thread.currentThread().getId() + &quot;进入数据区：&quot; + System.currentTimeMillis());
                &#125; catch (Exception e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;);
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code>线程49进入数据区：1574672546522
线程55进入数据区：1574672546522
线程56进入数据区：1574672546526
线程50进入数据区：1574672546523
线程48进入数据区：1574672546523
 
线程51进入数据区：1574672666627
线程53进入数据区：1574672666627
线程54进入数据区：1574672666627
线程57进入数据区：1574672666628
线程52进入数据区：1574672666628
</code></pre>
<blockquote>
<p>说明：两分钟之内最多只有5个线程在执行</p>
</blockquote>
<h2 id="6、事务（RTransaction）"><a href="#6、事务（RTransaction）" class="headerlink" title="6、事务（RTransaction）"></a>6、事务（RTransaction）</h2><p>Redisson可对一些对象进行事务操作，这些对象包括RBucket、Rbuckets，RSet、RSetCache，RMap、RMapCache、RLocalCachedMap</p>
<p>1、相关接口</p>
<p>RTransaction</p>
<pre><code class="java">public interface RTransaction &#123;
    // RBucket、RBuckets
    &lt;V&gt; RBucket&lt;V&gt; getBucket(String var1);
    &lt;V&gt; RBucket&lt;V&gt; getBucket(String var1, Codec var2);
    RBuckets getBuckets();
    RBuckets getBuckets(Codec var1);

    // RSet、RSetCache
    &lt;V&gt; RSet&lt;V&gt; getSet(String var1);
    &lt;V&gt; RSet&lt;V&gt; getSet(String var1, Codec var2);
    &lt;V&gt; RSetCache&lt;V&gt; getSetCache(String var1);
    &lt;V&gt; RSetCache&lt;V&gt; getSetCache(String var1, Codec var2);

    // RMap、RMapCache、RLocalCachedMap
    &lt;K, V&gt; RMap&lt;K, V&gt; getMap(String var1);
    &lt;K, V&gt; RMap&lt;K, V&gt; getMap(String var1, Codec var2);
    &lt;K, V&gt; RMapCache&lt;K, V&gt; getMapCache(String var1);
    &lt;K, V&gt; RMapCache&lt;K, V&gt; getMapCache(String var1, Codec var2);
 
    &lt;K, V&gt; RLocalCachedMap&lt;K, V&gt; getLocalCachedMap(RLocalCachedMap&lt;K, V&gt; var1);

    // 其他方法
    void commit();
    RFuture&lt;Void&gt; commitAsync();  //提交事务
 
    void rollback();
    RFuture&lt;Void&gt; rollbackAsync();//回滚事务
&#125;
</code></pre>
<blockquote>
<p>说明：每次创建的transaction只能进行一次提交或者回滚，不能重复使用；如果需要多个事务操作，需创建多个事务</p>
</blockquote>
<p>TransactionOptions</p>
<pre><code class="java">public final class TransactionOptions &#123;
    private long responseTimeout = 3000L;  // 返回超时时间
    private int retryAttempts = 3;         // 重试次数
    private long retryInterval = 1500L;    // 重试间隔
    private long syncTimeout = 5000L;      // 从节点同步超时时间
    private long timeout = 5000L;          // 超时时间

    // 构造方法
    private TransactionOptions() &#123;
    &#125;

    // 普通方法
    public static TransactionOptions defaults() &#123;
        // 返回TransactionOtiopns对象实例
        return new TransactionOptions();
    &#125;

    // 返回超时时间
    public long getResponseTimeout() &#123;
        return responseTimeout;
    &#125;
    // 设置超时时间
    public TransactionOptions responseTimeout(long timeout, TimeUnit unit) &#123;
        this.responseTimeout = unit.toMillis(timeout);
        return this;
    &#125;

    // 返回重试次数
    public int getRetryAttempts() &#123;
        return retryAttempts;
    &#125;
    // 设置重试次数 
    public TransactionOptions retryAttempts(int retryAttempts) &#123;
        this.retryAttempts = retryAttempts;
        return this;
    &#125;

    // 返回重试间隔
    public long getRetryInterval() &#123;
        return retryAttempts;
    &#125;
    // 设置重试间隔
    public TransactionOptions retryInterval(long retryInterval, TimeUnit retryIntervalUnit) &#123;
        this.retryAttempts = retryAttempts;
        return this;
    &#125;

    // 返回从节点同步超时时间  
    public long getSyncTimeout() &#123;
        return syncTimeout;
    &#125;
    // 设置从节点同步超时时间
    public TransactionOptions syncSlavesTimeout(long syncTimeout, TimeUnit syncUnit) &#123;
        this.syncTimeout = syncUnit.toMillis(syncTimeout);
        return this;
    &#125;

    // 返回超时时间
    public long getTimeout() &#123;
        return timeout;
    &#125;
    // 设置超时时间
    public TransactionOptions timeout(long timeout, TimeUnit timeoutUnit) &#123;
        if (timeout == -1) &#123;
            this.timeout = timeout;
            return this;
        &#125;
        this.timeout = timeoutUnit.toMillis(timeout);
        return this;
    &#125;                               
&#125;
</code></pre>
<p>2、操作示例</p>
<pre><code class="java">import org.redisson.Redisson;
import org.redisson.api.*;
import org.redisson.config.Config;

public class RTransactionTest &#123;

    public static void main(String[] args) &#123;
        Config config = new Config();
        config.useSingleServer().setAddress(&quot;redis://192.168.57.120:6379&quot;).setPassword(&quot;123456&quot;);
        RedissonClient client = Redisson.create(config);

        RTransaction transaction = client.createTransaction(TransactionOptions.defaults());
        RSet&lt;String&gt; set = transaction.getSet(&quot;transaction_set&quot;);
        try &#123;
            for (int i = 0; i &lt; 10; i++) &#123;
                set.add(&quot;瓜田李下 &quot; + i);
            &#125;

            transaction.commit();
        &#125; catch (Exception e) &#123;
            transaction.rollback();
            e.printStackTrace();
        &#125;
        System.out.println(&quot;set的大小为：&quot; + set.size()); // set的大小为：10

        RTransaction transaction2 = client.createTransaction(TransactionOptions.defaults());
        RMap&lt;Integer, String&gt; map = transaction2.getMap(&quot;transaction_map&quot;);
        try &#123;
            for (int i = 0; i &lt; 10; i++) &#123;
                map.put(i, &quot;瓜田李下 &quot; + i);

                if (i == 2) &#123;
                    throw new RuntimeException(&quot;出错了&quot;);
                &#125;
            &#125;

            transaction.commit();
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125;
        System.out.println(&quot;map的大小为：&quot; + map.size()); // map的大小为：0
    &#125;
&#125;
</code></pre>
<blockquote>
<p>说明：set的大小为10表明事务transaction提交，map的大小为0表明事务回滚</p>
</blockquote>
<h2 id="7、布隆过滤器（RBloomFilter）"><a href="#7、布隆过滤器（RBloomFilter）" class="headerlink" title="7、布隆过滤器（RBloomFilter）"></a>7、布隆过滤器（RBloomFilter）</h2><p>作用：在缓存层前添加布隆过滤器，常用于高并发场景下应对缓存穿透问题</p>
<p>1、相关接口：RBloomFilter。说明：开源版本不支持集群布隆过滤器</p>
<pre><code class="java">public interface RBloomFilter&lt;T&gt; extends RExpirable &#123;

    boolean tryInit(long var1, double var3);  // 初始化布隆过滤器，var1表示大小，var3表示容错率

    boolean add(T var1);                      // 添加对象
    boolean contains(T var1);                 // 判断对象是否存在

    long getExpectedInsertions();             // 返回预计插入数量
    double getFalseProbability();             // 返回容错率
    int getHashIterations();                  // 返回hash函数个数

    long count();                             // 对象插入后，估计插入数量
    long getSize();                           // 布隆过滤器位数组的大小
&#125;
</code></pre>
<p>2、操作示例</p>
<pre><code class="java">import org.redisson.Redisson;
import org.redisson.api.RBloomFilter;
import org.redisson.api.RedissonClient;
import org.redisson.config.Config;

public class RBloomFilterTest &#123;

    public static void main(String[] args) &#123;
        Config config = new Config();
        config.useSingleServer().setAddress(&quot;redis:/***:6379&quot;).setPassword(&quot;123456&quot;);
        RedissonClient client = Redisson.create(config);

        RBloomFilter&lt;String&gt; bloomFilter = client.getBloomFilter(&quot;bloom-filter&quot;);
        bloomFilter.tryInit(1000, 0.03);

        for (int i = 0; i &lt; 1000; i++) &#123;
            bloomFilter.add(&quot;瓜田李下 &quot; + i);
        &#125;

        System.out.println(&quot;&#39;瓜田李下 1&#39;是否存在：&quot; + bloomFilter.contains(&quot;瓜田李下 &quot; + 1));
        System.out.println(&quot;&#39;海贼王&#39;是否存在：&quot; + bloomFilter.contains(&quot;海贼王&quot;));
        System.out.println(&quot;预计插入数量：&quot; + bloomFilter.getExpectedInsertions());
        System.out.println(&quot;容错率：&quot; + bloomFilter.getFalseProbability());
        System.out.println(&quot;hash函数的个数：&quot; + bloomFilter.getHashIterations());
        System.out.println(&quot;插入对象的个数：&quot; + bloomFilter.count());
    &#125;
&#125;
</code></pre>
<pre><code>&#39;瓜田李下 1&#39;是否存在：true
&#39;海贼王&#39;是否存在：false
预计插入数量：1000
容错率：0.03
hash函数的个数：5
插入对象的个数：1007
</code></pre>
<blockquote>
<p>说明：count()计算的插入对象的个数是个估算值</p>
</blockquote>
<h2 id="8、定时线程池（RScheduledExecutorService）"><a href="#8、定时线程池（RScheduledExecutorService）" class="headerlink" title="8、定时线程池（RScheduledExecutorService）"></a>8、定时线程池（RScheduledExecutorService）</h2><p>作用：redisson提供的定时线程池可在分布式环境下执行定时任务</p>
<p>1、相关类及接口</p>
<p>RScheduledExecutorService：定时任务线程池</p>
<pre><code class="java">public interface RScheduledExecutorService extends RExecutorService, ScheduledExecutorService, RScheduledExecutorServiceAsync &#123;
    RScheduledFuture&lt;?&gt; schedule(Runnable var1, long var2, TimeUnit var4);
    
    // var2时间后执行任务
    &lt;V&gt; RScheduledFuture&lt;V&gt; schedule(Callable&lt;V&gt; var1, long var2, TimeUnit var4);

    // 周期性地执行任务，初始时间间隔var1后，每隔时间段var2后
    RScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable var1, long var2, long var4, TimeUnit var6);
    
    // 周期性地执行任务，初始时间间隔var1后，任务执行后下一个任务在var2后执行
    RScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable var1, long var2, long var4, TimeUnit var6);

    // 定时执行任务
    RScheduledFuture&lt;?&gt; schedule(Runnable var1, CronSchedule var2);
&#125;
</code></pre>
<p>CronSchedule：创建定时时间</p>
<pre><code class="java">public final class CronSchedule &#123;
    private CronExpression expression;
    // 使用字符串构造cron表达式
    CronSchedule(CronExpression expression) &#123;
        this.expression = expression;
    &#125;

    public static CronSchedule of(String expression) &#123;
        return new CronSchedule(new CronExpression(expression));
    &#125;

    // 每天hour时minute分执行任务
    public static CronSchedule dailyAtHourAndMinute(int hour, int minute) &#123;
        String expression = String.format(&quot;0 %d %d ? * *&quot;, minute, hour);
        return of(expression);
    &#125;

    // 每周daysOfWeek的hour时minute分执行任务
    public static CronSchedule weeklyOnDayAndHourAndMinute(int hour, int minute, Integer... daysOfWeek) &#123;
        if (daysOfWeek != null &amp;&amp; daysOfWeek.length != 0) &#123;
            String expression = String.format(&quot;0 %d %d ? * %d&quot;, minute, hour, daysOfWeek[0]);

            for(int i = 1; i &lt; daysOfWeek.length; ++i) &#123;
                expression = expression + &quot;,&quot; + daysOfWeek[i];
            &#125;

            return of(expression);
        &#125; else &#123;
            throw new IllegalArgumentException(&quot;You must specify at least one day of week.&quot;);
        &#125;
    &#125;

    public static CronSchedule monthlyOnDayAndHourAndMinute(int dayOfMonth, int hour, int minute) &#123;
        String expression = String.format(&quot;0 %d %d %d * ?&quot;, minute, hour, dayOfMonth);
        return of(expression);
    &#125;

    // 每月dayOfMonth的hour时minute分执行任务
    public CronExpression getExpression() &#123;
        return this.expression;
    &#125;
&#125;
</code></pre>
<p>2、操作示例</p>
<pre><code class="java">import org.redisson.Redisson;
import org.redisson.api.RScheduledExecutorService;
import org.redisson.api.RedissonClient;
import org.redisson.config.Config;
import java.io.Serializable;
import java.util.concurrent.TimeUnit;

public class RScheduledExecutorServiceTest &#123;
    public static void main(String[] args) &#123;
        Config config = new Config();
        config.useSingleServer().setAddress(&quot;redis://127.0.0.1:6379&quot;);
        RedissonClient client = Redisson.create(config);

        RScheduledExecutorService executorService = client.getExecutorService(&quot;es&quot;);
        executorService.schedule((Runnable &amp; Serializable) () -&gt; &#123;
            System.out.println(&quot;hello world&quot;);
        &#125;, 1, TimeUnit.SECONDS);

        System.out.println(executorService.getName());
        System.out.println(&quot;主线程运行结束&quot;);
    &#125;
&#125;
</code></pre>
<h2 id="9、参考文献-鸣谢"><a href="#9、参考文献-鸣谢" class="headerlink" title="9、参考文献 &amp; 鸣谢"></a>9、参考文献 &amp; 鸣谢</h2><ol>
<li>从头开始学Redisson【CSDN 小大宇】<a target="_blank" rel="noopener" href="https://blog.csdn.net/yanluandai1985/category_9795024.html">https://blog.csdn.net/yanluandai1985/category_9795024.html</a></li>
<li>Redisson 源码初探【CSDN 妖四灵.Shuen】<a target="_blank" rel="noopener" href="https://blog.csdn.net/wangxuelei036/category_7529628.html">https://blog.csdn.net/wangxuelei036/category_7529628.html</a></li>
<li>Redis &amp; Redisson 实战示例【CSDN 瓜田李下】<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43931625/category_9397188.html">https://blog.csdn.net/weixin_43931625/category_9397188.html</a></li>
<li>Springboot2.x整合Redission【CSDN 保护我方胖虎】<a target="_blank" rel="noopener" href="https://blog.csdn.net/leilei1366615/article/details/123885990">https://blog.csdn.net/leilei1366615/article/details/123885990</a></li>
</ol>
<h1 id="Redis-SpinrgBoot-2-5-整合"><a href="#Redis-SpinrgBoot-2-5-整合" class="headerlink" title="Redis SpinrgBoot 2.5 整合"></a>Redis SpinrgBoot 2.5 整合</h1><h2 id="1、SpringDataRedis-基本使用"><a href="#1、SpringDataRedis-基本使用" class="headerlink" title="1、SpringDataRedis 基本使用"></a>1、SpringDataRedis 基本使用</h2><p><strong>注意说明：</strong></p>
<ol>
<li>在 Spring Boot 2.x 之后，原来默认的 Jedis 被替换为了 Lttuce</li>
<li>旧版 Lettuce 存在堆外内存溢出的 bug， 5.3版本修复了这个 bug，我们是用 6.1（也就是SpringBoot 2.4.x 及以上）</li>
<li>很多人没产生原因：1.并发量不高，2.内存足够大，没发生问题就又发布更新了</li>
<li>解决方式：1.升级版本，2.换成 Jedis 客户端</li>
<li>Jedis：采用的直连，多线程操作的话是不安全的，如果想要避免不安全的话，使用 Jedis Pool ，更像 BIO 模式</li>
<li>Lettuce ：采用 netty ，实例可以在多个线程中共享，不存在线程不安全的情况，可以减少线程链接，更像 NIO 模式</li>
</ol>
<p>1、导入依赖：</p>
<pre><code class="xml">&lt;parent&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
    &lt;version&gt;2.5.0&lt;/version&gt;
    &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;
&lt;/parent&gt;
&lt;dependency&gt;&lt;!--spring-data-redis也是2.5.0版本--&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<p>2、配置连接</p>
<pre><code class="properties"># 配置Redis，如果是本地启动Redis的也可以不配置，因为RedisProperties内这3个参数是默认的
spring.redis.host=127.0.0.1
spring.redis.port=6379
spring.redis.database=0
</code></pre>
<p>3、测试代码</p>
<pre><code class="java">import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.test.context.junit4.SpringRunner;

@RunWith(SpringRunner.class)
@SpringBootTest
public class Redis02SpringbootApplicationTests &#123;
    @Autowired
    private RedisTemplate redisTemplate;

    @Test
    public void contextLoads() &#123;
        // 除了基本的操作，我们常用的方法都可以直接通过 redisTemplate 操作，比如事务和 CRUD
        redisTemplate.opsForValue().set(&quot;name&quot;, &quot;hello&quot;);
        // 执行单元测试控制台输出：hello
        System.out.println(redisTemplate.opsForValue().get(&quot;name&quot;));
    &#125;
&#125;
</code></pre>
<p>4、用自带客户端 redis-cli 查询</p>
<pre><code class="shell">127.0.0.1:6379&gt; get name
(nil)
127.0.0.1:6379&gt; keys *
1) &quot;\xac\xed\x00\x05t\x00\x04name&quot;
127.0.0.1:6379&gt;    
</code></pre>
<p>通过查询可以发现：存进去的name显示乱码了，实际上转义了。这是因为 RedisTemplate 默认使用了 JDK 的序列化，会使得字符串转义。</p>
<p>看一下源码：RedisTemplate.class、RedisAutoConfiguration.class</p>
<pre><code class="java">// 序列化配置
@Nullable
private RedisSerializer&lt;?&gt; defaultSerializer;
@Nullable
private RedisSerializer keySerializer = null;
@Nullable
private RedisSerializer valueSerializer = null;
@Nullable
private RedisSerializer hashKeySerializer = null;
@Nullable
private RedisSerializer hashValueSerializer = null;
private RedisSerializer&lt;String&gt; stringSerializer = RedisSerializer.string();
public void afterPropertiesSet() &#123;
    super.afterPropertiesSet();
    boolean defaultUsed = false;
    if (this.defaultSerializer == null) &#123;
        // 默认使用了 JDK 的序列化，会使得字符串转义
        this.defaultSerializer = new JdkSerializationRedisSerializer(this.classLoader != null ? this.classLoader : this.getClass().getClassLoader());
    &#125;
    // ...
&#125;
</code></pre>
<pre><code class="java">// 1.Spring Boot 所有的配置类，都有一个自动配置类：RedisTemplate
// 2.自动配置类都会绑定一个 properties 配置文件：RedisProperties
@Configuration(
    proxyBeanMethods = false
)
@ConditionalOnClass(&#123;RedisOperations.class&#125;)
@EnableConfigurationProperties(&#123;RedisProperties.class&#125;)
@Import(&#123;LettuceConnectionConfiguration.class, JedisConnectionConfiguration.class&#125;)
public class RedisAutoConfiguration &#123;
    public RedisAutoConfiguration() &#123;
    &#125;

    @Bean
    @ConditionalOnMissingBean(
        name = &#123;&quot;redisTemplate&quot;&#125;
    )
    @ConditionalOnSingleCandidate(RedisConnectionFactory.class)
    public RedisTemplate&lt;Object, Object&gt; redisTemplate(RedisConnectionFactory redisConnectionFactory) &#123;
        // 默认的 RedisTemplate 没有过多的设置， Redis 对象都是需要序列化的。
        // 两个泛型都是 Object, Object 的类型，我们需要强制装换为 &lt;String, Obejct&gt;
        // 所以我们可以自己定义一个 RedisTemplate 来替换这个默认的。
        RedisTemplate&lt;Object, Object&gt; template = new RedisTemplate();
        template.setConnectionFactory(redisConnectionFactory);
        return template;
    &#125;

    // 由于 String 类型是 Redis 中最常用的，所以单独提出来一个 bean
    @Bean
    @ConditionalOnMissingBean
    @ConditionalOnSingleCandidate(RedisConnectionFactory.class)
    public StringRedisTemplate stringRedisTemplate(RedisConnectionFactory redisConnectionFactory) &#123;
        StringRedisTemplate template = new StringRedisTemplate();
        template.setConnectionFactory(redisConnectionFactory);
        return template;
    &#125;
&#125;
</code></pre>
<p>我们使用 Json 序列化，所以需要自定义配置类。</p>
<h2 id="2、StringRedisTemplate-使用"><a href="#2、StringRedisTemplate-使用" class="headerlink" title="2、StringRedisTemplate 使用"></a>2、StringRedisTemplate 使用</h2><p>1、RedisTemplate 中定义了对5种数据结构操作：</p>
<ul>
<li>ValueOperations：简单 k-v 操作。对应：redisTemplate.opsForValue();</li>
<li>SetOperations：set 类型数据操作。对应：redisTemplate.opsForSet();</li>
<li>ZSetOperations：zset 类型数据操作。对应：redisTemplate.opsForZSet();</li>
<li>HashOperations：map 类型的数据操作。对应：redisTemplate.opsForHash();</li>
<li>ListOperations：list 类型的数据操作。对应：redisTemplate.opsForList();</li>
</ul>
<p>2、RedisTemplate 和 StringRedisTemplate 的区别：</p>
<ul>
<li>StringRedisTemplate 继承 RedisTemplate</li>
<li>两者的数据是不共通的（默认的序列化机制导致 key 不一样）</li>
<li>StringRedisTemplate 默认采用的是 String 的序列化策略</li>
<li>RedisTemplate 默认采用的是JDK的序列化策略，会将数据先序列化成字节数组然后在存入 Redis 数据库</li>
</ul>
<p>3、总结：</p>
<ul>
<li>当 Redis 数据库里面本来操作的是字符串数据的时候，那使用 StringRedisTemplate 即可</li>
<li>数据是复杂的对象类型，那么使用 RedisTemplate 是更好的选择</li>
</ul>
<p>4、StringRedisTemplate 使用案例：</p>
<pre><code class="java">@Autowired
StringRedisTemplate stringRedisTemplate;
@Test
void stringRedisTemplate() &#123;
    stringRedisTemplate.opsForValue().set(&quot;age&quot;, &quot;18&quot;);
    System.out.println(stringRedisTemplate.opsForValue().get(&quot;age&quot;));
&#125;
</code></pre>
<p>5、用客户端 redis-cli 查询：</p>
<pre><code class="java">127.0.0.1:6379&gt; keys *
1) &quot;age&quot;
2) &quot;\xac\xed\x00\x05t\x00\x04name&quot;
127.0.0.1:6379&gt;   
</code></pre>
<p>可以发现使用 StringRedisTemplate 设置 age 显示正常。这是因为 StringRedisTemplate 默认采用的是 String 的序列化策略。</p>
<h2 id="3、RedisTemplate-序列化问题"><a href="#3、RedisTemplate-序列化问题" class="headerlink" title="3、RedisTemplate  序列化问题"></a>3、RedisTemplate  序列化问题</h2><p>上面的问题：同个 key 为啥获取不到值，核心就是序列化机制导致 key 不一样</p>
<p>1、什么是序列化？</p>
<ul>
<li>把对象转换为字节序列的过程称为对象的序列化</li>
<li>把字节序列恢复为对象的过程称为对象的反序列化</li>
<li>对象的序列化主要有两种用途<ul>
<li>把对象的字节序列永久地保存到硬盘上，通常存放在一个文件中</li>
<li>在网络上传送对象的字节序列</li>
</ul>
</li>
</ul>
<p>2、Redis 为什么要序列化？</p>
<ul>
<li>性能可以提高，不同的序列化方式性能不一样</li>
<li>可视化工具更好查看：<ul>
<li>1）采用默认的 JDK 方式会乱码（POJO 类需要实现 Serializable 接口）</li>
<li>2）采用 JSON 方式则不用，且可视化工具更好查看</li>
</ul>
</li>
<li>自定义 Redis 序列化方式，提供了多种可选择策略（需要实现 RedisSerializer 接口）</li>
</ul>
<p>3、Spring 提供的序列化器（使用方式自行百度）</p>
<ul>
<li>JdkSerializationRedisSerializer：<ul>
<li>1）POJO 对象的存取场景，使用 JDK 本身序列化机制</li>
<li>2）默认机制：ObjectInputStream &#x2F; ObjectOutputStream 进行序列化操作</li>
</ul>
</li>
<li>StringRedisSerializer：key 或者 value 为字符串</li>
<li>Jackson2JsonRedisSerializer：利用jackson-json工具，将 POJO 实例序列化成 JSON 格式存储</li>
<li>GenericFastJsonRedisSerializer：另一种 javabean 与 json 之间的转换，同时也需要指定Class类型</li>
<li>GenericJackson2JsonRedisSerializer：另一种 javabean 与 json 之间的转换，同时也需要指定Class类型</li>
<li>GenericToStringRedisSerializer</li>
<li>OxmSerializer</li>
<li>… 等等还有很多种</li>
</ul>
<p>编写一个实体类 User，测试序列化：</p>
<pre><code class="java">@Data
@NoArgsConstructor
@AllArgsConstructor
public class User &#123;
    private String name;
    private int age;
&#125;
</code></pre>
<p>测试序列化：</p>
<pre><code class="java">@Test
public void test() throws JsonProcessingException &#123;
    User user = new User(&quot;xiaoming&quot;, 3);
    redisTemplate.opsForValue().set(&quot;user&quot;, user);
    System.out.println(redisTemplate.opsForValue().get(&quot;user&quot;));
&#125;
</code></pre>
<p>执行 Test 会抛出异常：</p>
<pre><code class="bash">Caused by: java.lang.IllegalArgumentException: DefaultSerializer requires a Serializable payload but received an object of type [cn.itzhouq.pojo.User]
    at org.springframework.core.serializer.DefaultSerializer.serialize(DefaultSerializer.java:43)
    at org.springframework.core.serializer.support.SerializingConverter.convert(SerializingConverter.java:63)
    ... 35 more
</code></pre>
<p><code>DefaultSerializer requires a Serializable</code>默认的序列化需要实体类实现序列化接口。所以修改 User：</p>
<pre><code class="java">@Data
@NoArgsConstructor
@AllArgsConstructor
public class User implements java.io.Serializable &#123;
    private String name;
    private int age;
&#125;
</code></pre>
<p>Java 执行结果：</p>
<pre><code class="java">User(name=xiaoming, age=3)
</code></pre>
<p>结果显示正常，但是控制台还是转义的。</p>
<pre><code class="bash">127.0.0.1:6379&gt; keys *
1) &quot;\xac\xed\x00\x05t\x00\x04user&quot;
127.0.0.1:6379&gt;
</code></pre>
<p>使用 jackson 的序列化：</p>
<pre><code class="java">@Test
public void test() throws JsonProcessingException &#123;
    // 一般开发中都会使用 json 来传递对象
    User user = new User(&quot;xiaoming&quot;, 3);
    String jsonUser = new ObjectMapper().writeValueAsString(user);
    redisTemplate.opsForValue().set(&quot;user&quot;, jsonUser);
    System.out.println(redisTemplate.opsForValue().get(&quot;user&quot;)); // &#123;&quot;name&quot;:&quot;xiaoming&quot;,&quot;age&quot;:3&#125;
&#125;
</code></pre>
<p>无论 User 是否实现了 Serializable 接口，控制台结果显示正常，但是客户端中查看还是被转义了。如果不想使用 JDK 的序列化，可以自己编写 RedisTemplate</p>
<h2 id="4、RedisTemplate-序列化配置"><a href="#4、RedisTemplate-序列化配置" class="headerlink" title="4、RedisTemplate 序列化配置"></a>4、RedisTemplate 序列化配置</h2><pre><code class="java">import com.fasterxml.jackson.annotation.JsonAutoDetect;
import com.fasterxml.jackson.annotation.PropertyAccessor;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.redis.connection.RedisConnectionFactory;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;
import org.springframework.data.redis.serializer.StringRedisSerializer;

/**
 * 编写的自己的 RedisTemplate
 */
@Configuration
public class RedisTemplateConfig &#123;

    @Bean
    @SuppressWarnings(&quot;all&quot;)
    public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory redisConnectionFactory) &#123;
        // 为了开发方便，一般使用 &lt;String, Object&gt;
        RedisTemplate&lt;String, Object&gt; template = new RedisTemplate();
        // Redis 连接工厂设置
        template.setConnectionFactory(redisConnectionFactory);

        // 序列化配置: 使用Jackson2JsonRedisSerialize 替换默认序列化, 将对象解析成可以序列化的对象
        Jackson2JsonRedisSerializer&lt;Object&gt; jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class);
        
        // Jackson的配置, 使用Mapper对象进行转义
        ObjectMapper objectMapper = new ObjectMapper();
        // Jackson 默认自动识别 Public 修饰的成员变量、getter、setter
        // private、protected、public 修饰的成员变量都可以自动识别，无需都指定 getter、setter 或者 public。
        // 参考 https://blog.csdn.net/sdyy321/article/details/40298081
        objectMapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);
        // 对于 8 种基本数据类型及其封装类和 String ，其他的类型在序列化的时候带上该类型和值
        // 参考 https://www.jianshu.com/p/c5fcd2a1ab49
        // om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);
        // 自行查询配置的含义
        // om.activateDefaultTyping(LaissezFaireSubTypeValidator.instance, ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.WRAPPER_ARRAY);
        jackson2JsonRedisSerializer.setObjectMapper(objectMapper);

        // String 类型的序列化
        StringRedisSerializer stringRedisSerializer = new StringRedisSerializer();
        
        // key 采用 String 的序列化方式
        template.setKeySerializer(stringRedisSerializer);
        // value 序列化方式采用 Jackson 序列化方式
        template.setValueSerializer(jackson2JsonRedisSerializer);
        
        // hash 的 key 也采用 String 的序列化方式
        template.setHashKeySerializer(stringRedisSerializer);
        // hash的 value 序列化方式采用 Jackson 序列化方式
        template.setHashKeySerializer(jackson2JsonRedisSerializer);
        
        // 设置支持事物
        // redisTemplate.setEnableTransactionSupport(true);
        
        // 最后必须执行这个函数,初始化RedisTemplate
        template.afterPropertiesSet();
        return template;
    &#125;
&#125;
</code></pre>
<p>注入和测试：</p>
<pre><code class="java">@Autowired
@Qualifier(&quot;redisTemplate&quot;)
private RedisTemplate redisTemplate;

@Test
public void test() throws JsonProcessingException &#123;
    // 一般开发中都会使用 json 来传递对象
    User user = new User(&quot;xiaoming&quot;, 3);
    String jsonUser = new ObjectMapper().writeValueAsString(user);
    redisTemplate.opsForValue().set(&quot;user&quot;, jsonUser);
    System.out.println(redisTemplate.opsForValue().get(&quot;user&quot;)); // &#123;&quot;name&quot;:&quot;xiaoming&quot;,&quot;age&quot;:3&#125;
&#125;
</code></pre>
<p>客户端中查看：</p>
<pre><code class="bash">127.0.0.1:6379&gt; keys *
1) &quot;user&quot;
127.0.0.1:6379&gt;
</code></pre>
<p>这个时候的对象就没有被转义</p>
<h2 id="5、Jedis-Lettuce-连接池配置"><a href="#5、Jedis-Lettuce-连接池配置" class="headerlink" title="5、Jedis &amp; Lettuce 连接池配置"></a>5、Jedis &amp; Lettuce 连接池配置</h2><p>基于 SpringDataRedis 可以快速替换底层实现（默认是 Lettuce 客户端）</p>
<p>1、Lettuce 连接池介绍（添加连接池）</p>
<pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;!--连接池依赖--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;
    &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<pre><code class="properties"># 指定客户端
spring.redis.client-type = lettuce
# 连接池最大连接数（使用负值表示没有限制）
spring.redis.lettuce.pool.max-active = 10
# 连接池中的最大空闲连接
spring.redis.lettuce.pool.max-idle = 10
# 连接池中的最小空闲连接
spring.redis.lettuce.pool.min-idle = 0
# 连接池最大阻塞等待时间（使用负值表示没有限制）
spring.redis.lettuce.pool.max-wait= -1ms
</code></pre>
<p>2、Jedis连接池介绍（也可以不排除 Lettuce 依赖包）</p>
<pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;
    &lt;!-- 可以不排除依赖包，但是需要在 application.properties 中配置 spring.redis.client-type --&gt;
    &lt;exclusions&gt;
        &lt;exclusion&gt;
            &lt;groupId&gt;io.lettuce&lt;/groupId&gt;
            &lt;artifactId&gt;lettuce-core&lt;/artifactId&gt;
        &lt;/exclusion&gt;
    &lt;/exclusions&gt;
&lt;/dependency&gt;

&lt;!-- 不用指定版本号，本身 spring-data-redis 里面有 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;redis.clients&lt;/groupId&gt;
    &lt;artifactId&gt;jedis&lt;/artifactId&gt;
&lt;/dependency&gt;

&lt;dependency&gt;
    &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;
    &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt;
    &lt;version&gt;2.6.1&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<pre><code class="properties"># 指定客户端
spring.redis.client-type = jedis
# 连接池最大连接数（使用负值表示没有限制）
spring.redis.jedis.pool.max-active = 10
# 连接池中的最大空闲连接
spring.redis.jedis.pool.max-idle = 10
# 连接池中的最小空闲连接
spring.redis.jedis.pool.min-idle = 0
# 连接池最大阻塞等待时间（使用负值表示没有限制）
spring.redis.jedis.pool.max-wait= -1ms
</code></pre>
<p>3、切换 Redis 客户端两种方式</p>
<ul>
<li>方式一：引入 Jedis pom依赖，然后 spring-data-redis 中 排除 lettuce 依赖即可</li>
<li>方式二：引入 Jedis pom依赖，项目中同时存在 Jedis 和 Lettuce 依赖，在 application.properties 中指定 spring.redis.client-type 即可</li>
</ul>
<p>4、断点调试 redisTemplate 的 connectionFactory 实现，或者直接代码打印：</p>
<pre><code class="java">@Autowired
RedisTemplate redisTemplate;
@PostConstruct
public void init() &#123;
    // org.springframework.data.redis.connection.lettuce.LettuceConnectionFactory@1ca3d25b
    System.out.println(redisTemplate.getConnectionFactory());
&#125;
</code></pre>
<h2 id="6、Redis-Sentinel-哨兵模式配置"><a href="#6、Redis-Sentinel-哨兵模式配置" class="headerlink" title="6、Redis Sentinel 哨兵模式配置"></a>6、Redis Sentinel 哨兵模式配置</h2><p>哨兵模式变化的就是配置信息；其他的和单机版的没有区别。</p>
<pre><code class="yaml">spring:
  redis:
    # redis集群的密码
    password: 123456
    # 超时时间，单位毫秒
    timeout: 3000
    # 数据库编号
    database: 0
    # 配置lettuce
    lettuce:
      pool:
        # 连接池中的最小空闲连接
        min-idle: 1
        # 连接池中的最大空闲连接
        max-idle: 6
        # 连接池最大连接数（使用负值表示没有限制,不要配置过大，否则可能会影响redis的性能）
        max-active: 10
        # 连接池最大阻塞等待时间（使用负值表示没有限制）；单位毫秒
        max-wait: 1000
      #关闭超时时间；单位毫秒
      shutdown-timeout: 200
    # 哨兵配置
    sentinel:
      master: mymaster
      # 多个使用逗号分开
      nodes: 192.168.56.102:26379
      # 哨兵的密码
      password: 123456
</code></pre>
<pre><code class="properties"># 连接工厂使用的数据库索引,redis默认有16个db,索引0-15
spring.redis.database= 0
# 登录redis服务器的密码,无设置密码可以不填写
spring.redis.password=password
# 给定时间池可以分配的最大连接数 使用负值为无限制
spring.redis.lettuce.pool.max-active= 8
# 连接分配在池耗尽之前在抛出异常之前应阻止的最大时间量（连接池最大阻塞等待时间以毫秒为单位） 使用负值无限期地阻止
spring.redis.lettuce.pool.max-wait= -1
# 连接池中的最大空闲连接 使用负值来表示无限数量的空闲连接
spring.redis.lettuce.pool.max-idle= 8
# 连接池中的最小空闲连接 此设置只有在正值时才有效果
spring.redis.lettuce.pool.min-idle= 0
# 连接超时（毫秒）
spring.redis.timeout=30000
# 哨兵配置过程中,给主机命名的名字
spring.redis.sentinel.master=mymaster
# 哨兵,配置多个 都好隔开
spring.redis.sentinel.nodes=ip1:port1,ip2:port2,ip3:port3
</code></pre>
<p>哨兵模式就是每次通过哨兵来获取redis的master节点信息；同时会订阅其节点切换频道，当发生故障转移时，客户端能收到哨兵的通知，通过重新初始化连接池，完成主节点的切换。</p>
<p>注意：当配置文件哨兵也单机版配置同时存在，哨兵连接机制优先。</p>
<h2 id="7、Redis-Cluster-集群模式配置"><a href="#7、Redis-Cluster-集群模式配置" class="headerlink" title="7、Redis Cluster 集群模式配置"></a>7、Redis Cluster 集群模式配置</h2><p>Redis-Cluster模式变化的也只是配置信息；其他的和单机版的没有区别。</p>
<pre><code class="yaml">spring:
  redis:
    # 密码
    password: 123456
    # 超时时间，单位毫秒
    timeout: 3000
    # 数据库编号
    database: 0
    # 配置lettuce
    lettuce:
      pool:
        # 连接池中的最小空闲连接
        min-idle: 1
        # 连接池中的最大空闲连接
        max-idle: 6
        # 连接池最大连接数（使用负值表示没有限制,不要配置过大，否则可能会影响redis的性能）
        max-active: 10
        # 连接池最大阻塞等待时间（使用负值表示没有限制）；单位毫秒
        max-wait: 1000
      #关闭超时时间；单位毫秒
      shutdown-timeout: 200
    # 集群配置
    cluster:
      # 最大失败次数
      max-redirects: 3
      # 集群节点
      nodes: 192.168.56.101:6379,192.168.56.102:6379,192.168.56.103:6379,192.168.56.104:6379,192.168.56.105:6379,192.168.56.106:6379
</code></pre>
<pre><code class="properties"># 连接工厂使用的数据库索引,redis默认有16个db,索引0-15
spring.redis.database= 0
# 登录redis服务器的密码,无设置密码可以不填写
spring.redis.password=password
# 给定时间池可以分配的最大连接数 使用负值为无限制
spring.redis.lettuce.pool.max-active= 8
# 连接分配在池耗尽之前在抛出异常之前应阻止的最大时间量（连接池最大阻塞等待时间以毫秒为单位） 使用负值无限期地阻止
spring.redis.lettuce.pool.max-wait= -1
# 连接池中的最大空闲连接 使用负值来表示无限数量的空闲连接
spring.redis.lettuce.pool.max-idle= 8
# 连接池中的最小空闲连接 此设置只有在正值时才有效果
spring.redis.lettuce.pool.min-idle= 0
# 连接超时（毫秒）
spring.redis.timeout=30000
# cluster集群连接最大失败次数
spring.redis.cluster.max-redirects=3
# 集群节点,配置多个 都好隔开
spring.redis.cluster.nodes=ip1:port1,ip2:port2,ip3:port3
</code></pre>
<h2 id="8、Redis-Configuration-配置"><a href="#8、Redis-Configuration-配置" class="headerlink" title="8、Redis Configuration 配置"></a>8、Redis Configuration 配置</h2><p>1、使用 Lettuce 配置 RedisTemplate：</p>
<pre><code class="java">import com.fasterxml.jackson.annotation.JsonAutoDetect;
import com.fasterxml.jackson.annotation.PropertyAccessor;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.springframework.cache.CacheManager;
import org.springframework.cache.annotation.CachingConfigurerSupport;
import org.springframework.cache.interceptor.KeyGenerator;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.redis.cache.RedisCacheConfiguration;
import org.springframework.data.redis.cache.RedisCacheManager;
import org.springframework.data.redis.cache.RedisCacheWriter;
import org.springframework.data.redis.connection.lettuce.LettuceConnectionFactory;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;
import org.springframework.data.redis.serializer.StringRedisSerializer;

/**
 * @ClassName RedisConfig
 * @Author admin
 * @Version 1.0
 */
@Configuration
public class RedisConfig extends CachingConfigurerSupport &#123;

    /**
     * 自定义缓存key的生成策略.
     * 默认的生成策略是看不懂的(乱码内容) 通过Spring的依赖注入特性进行自定义的配置注入并且此类是一个配置类可以更多程度的自定义配置
     */
    @Bean
    @Override
    public KeyGenerator keyGenerator() &#123;
        return (target, method, params) -&gt; &#123;
            StringBuilder sb = new StringBuilder();
            sb.append(target.getClass().getName());
            sb.append(method.getName());
            for (Object obj : params) &#123;
                sb.append(obj.toString());
            &#125;
            return sb.toString();
        &#125;;
    &#125;

    /**
     * 缓存配置管理器
     */
    @Bean
    public CacheManager cacheManager(LettuceConnectionFactory factory) &#123;
        // 以锁写入的方式创建RedisCacheWriter对象
        RedisCacheWriter writer = RedisCacheWriter.lockingRedisCacheWriter(factory);
        // 创建默认缓存配置对象
        RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig();
        RedisCacheManager cacheManager = new RedisCacheManager(writer, config);
        return cacheManager;
    &#125;

    @Bean
    public RedisTemplate&lt;String, Object&gt; redisTemplate(LettuceConnectionFactory factory) &#123;
        RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;&gt;();
        // Redis 连接工厂设置
        template.setConnectionFactory(factory);

        // 序列化配置: 使用Jackson2JsonRedisSerialize 替换默认序列化, 将对象解析成可以序列化的对象
        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class);

        // Jackson的配置, 使用Mapper对象进行转义
        ObjectMapper om = new ObjectMapper();
        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);
        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);
        jackson2JsonRedisSerializer.setObjectMapper(om);

        // String 类型的序列化
        StringRedisSerializer stringRedisSerializer = new StringRedisSerializer();
        // 在使用注解@Bean返回RedisTemplate的时候，同时配置hashKey与hashValue的序列化方式。
        template.setKeySerializer(stringRedisSerializer); // key采用String的序列化方式
        template.setValueSerializer(jackson2JsonRedisSerializer); // value序列化方式采用jackson
        template.setHashKeySerializer(stringRedisSerializer); // hash的key也采用String的序列化方式
        template.setHashValueSerializer(jackson2JsonRedisSerializer); // hash的value序列化方式采用jackson
        // 最后必须执行这个函数,初始化RedisTemplate
        template.afterPropertiesSet();
        return template;
    &#125;
&#125;
</code></pre>
<h1 id="Redis-RedisTemplate-详解"><a href="#Redis-RedisTemplate-详解" class="headerlink" title="Redis RedisTemplate 详解"></a>Redis RedisTemplate 详解</h1><h2 id="1、RedisTemplate-简介"><a href="#1、RedisTemplate-简介" class="headerlink" title="1、RedisTemplate 简介"></a>1、RedisTemplate 简介</h2><p>RedisTemplate 是 Spring Data Redis 提供给用户的最高级的抽象客户端，用户可直接通过 RedisTemplate进行多种操作</p>
<h3 id="1、类继承关系"><a href="#1、类继承关系" class="headerlink" title="1、类继承关系"></a>1、类继承关系</h3><pre><code class="java">public class RedisTemplate&lt;K, V&gt; extends RedisAccessor 
    implements RedisOperations&lt;K, V&gt;, BeanClassLoaderAware &#123;
&#125;
</code></pre>
<ul>
<li>RedisAccessor：Base class for RedisTemplate defining common properties. Not intended to be used directly<br>翻译：RedisTemplate 定义通用属性的基类。不打算直接使用</li>
<li>RedisOperations：Interface that specified a basic set of Redis operations, implemented by RedisTemplate. Not often used but a useful option for extensibility and testability （as it can be easily mocked or stubbed）.<br>翻译：指定一组基本 Redis 操作的接口，由 RedisTemplate 实现。不经常使用，但对于可扩展性和可测试性来说是一个有用的选项（因为它可以很容易地被模拟或存根）</li>
<li>BeanClassLoaderAware：Callback that allows a bean to be aware of the bean class loader; that is, the class loader used by the present bean factory to load bean classes. This is mainly intended to be implemented by framework classes which have to pick up application classes by name despite themselves potentially being loaded from a shared class loader.<br>翻译：允许 bean 知道 bean 类加载器的回调；也就是当前bean工厂用来加载bean类的类加载器。这主要是由框架类实现的，这些框架类必须按名称选择应用程序类，尽管它们可能是从共享类加载器加载的</li>
</ul>
<h3 id="2、方法总结"><a href="#2、方法总结" class="headerlink" title="2、方法总结"></a>2、方法总结</h3><pre><code class="java">// 配置默认序列化与反序列化工具类
1.afterPropertiesSet
// 根据参数执行相关operation操作，例如，事务
2.execute
// 执行pipelining流水线相关操作
3.executePipelined
// 执行指定connection连接的相关操作
4.executeWithStickyConnection
// 执行session内的execute方法
5.executeSession
// 创建RedisConnection代理类
6.createRedisConnectionProxy
// connection连接的预处理
7.preProcessConnection
// 结果的后处理，默认什么都不做
8.postProcessResult
// 是否向RedisCallback暴露本地连接
9.isExposeConnection
// 设置是否向RedisCallback暴露本地连接
10.setExposeConnection
// 11到25都是设置和获取相关序列化工具类
11.isEnableDefaultSerializer
12.setEnableDefaultSerializer
13.getDefaultSerializer
14.setDefaultSerializer
15.setKeySerializer
16.getKeySerializer
17.setValueSerializer
18.getValueSerializer
19.getHashKeySerializer
20.setHashKeySerializer
21.getHashValueSerializer
22.setHashValueSerializer
23.getStringSerializer
24.setStringSerializer
25.setScriptExecutor
// 26到33为私有方法，不对外提供使用
26.rawKey
27.rawString
28.rawValue
29.rawKeys
30.deserializeKey
31.deserializeMixedResults
32.deserializeSet
33.convertTupleValues
// 执行事务
34.exec
35.execRaw
// 删除操作
36.delete
// 接触链接
37.unlink
// 查看是否含有指定key
38.hasKey
39.countExistingKeys
// 设置过期时间
40.expire
41.expireAt
// 转换成字节流并向channel发送message
42.convertAndSend
// 获取过期时间
43.getExpire
// 根据传入的正则表达式返回所有的key
44.keys
// 取消指定key的过期时间
45.persist
// 移动指定的key和index到数据库中
46.move
// 从键空间随机获取一个key
47.randomKey
// 将指定key改成目标key
48.rename
// key不存在时，将指定key改成目标key
49.renameIfAbsent
// 设置存储在指定key的类型
50.type
// 检索存储在key的值的序列化版本
51.dump
// 执行Redis的restore的命令
52.restore
// 标记事务阻塞的开始
53.multi
// 丢弃所有在multi之后发出的命令
54.discard
// 观察指定key在事务处理开始即multi之后的修改情况
55.watch
// 刷新先前观察的所有key
56.unwatch
// 为key元素排序
57.sort
// 关闭客户端连接
58.killClient
// 请求连接客户端的相关信息和统计数据
59.getClientList
// 更改复制配置到新的master
60.slaveOf
// 将本机更改为master
61.slaveOfNoOne
// 62到77都是获取相对应的操作
62.opsForCluster
63.opsForGeo
64.boundGeoOps
65.boundHashOps
66.opsForHash
67.opsForHyperLogLog
68.opsForList
69.boundListOps
70.boundSetOps
71.opsForSet
72.opsForStream
73.boundStreamOps
74.boundValueOps
75.opsForValue
76.boundZSetOps
77.opsForZSet
// 设置是否支持事务
78.setEnableTransactionSupport
// 设置bean的类加载器
79.setBeanClassLoader
</code></pre>
<h3 id="3、功能介绍"><a href="#3、功能介绍" class="headerlink" title="3、功能介绍"></a>3、功能介绍</h3><p>spring-data-redis 依赖提供了如下功能：</p>
<ol>
<li>连接池自动管理，提供了一个高度封装的RedisTemplate类</li>
<li>进行了归类封装，将同一类型操作封装为operation接口<ul>
<li>ValueOperations：简单k-v操作</li>
<li>HashOperations：针对map类型的数据操作</li>
<li>ListOperations：针对list类型的数据操作</li>
<li>SetOperations：set类型数据操作</li>
<li>ZSetOperations：zset类型数据操作</li>
</ul>
</li>
<li>提供了对Key的“bound”（绑定）便捷化操作API，可以通过bound封装指定的key，然后进行一系列的操作而无须“显式”的再次指定Key，即：<ul>
<li>BoundKeyOperations</li>
<li>BoundValueOperations</li>
<li>BoundSetOperations</li>
<li>BoundListOperations</li>
<li>BoundSetOperations</li>
<li>BoundHashOperations</li>
</ul>
</li>
<li>将事务操作封装，有容器控制</li>
<li>针对数据的“序列化&#x2F;反序列化”，提供了多种可选择策略（RedisSerializer）<ul>
<li>JdkSerializationRedisSerializer：POJO对象的存取场景，使用JDK本身序列化机制，将pojo类通过ObjectInputStream&#x2F;ObjectOutputStream进行序列化操作，最终redis-server中将存储字节序列。是目前最常用的序列化策略。</li>
<li>StringRedisSerializer：Key或者value为字符串的场景，根据指定的charset对数据的字节序列编码成string，是“newString(bytes,charset)”和“string.getBytes(charset)”的直接封装。是最轻量级和高效的策略。</li>
<li>JacksonJsonRedisSerializer：jackson-json工具提供了javabean与json之间的转换能力，可以将pojo实例序列化成json格式存储在redis中，也可以将json格式的数据转换成pojo实例。因为jackson工具在序列化和反序列化时，需要明确指定Class类型，因此此策略封装起来稍微复杂。</li>
<li>OxmSerializer：提供了将javabean与xml之间的转换能力，目前可用的三方支持包括jaxb，apache-xmlbeans；redis存储的数据将是xml工具。不过使用此策略，编程将会有些难度，而且效率最低；不建议使用。【需要spring-oxm模块的支持】</li>
</ul>
</li>
</ol>
<p>如果你的数据需要被第三方工具解析，那么数据应该使用StringRedisSerializer而不是 JdkSerializationRedisSerializer。</p>
<h3 id="4、RedisTemplate-配置"><a href="#4、RedisTemplate-配置" class="headerlink" title="4、RedisTemplate 配置"></a>4、RedisTemplate 配置</h3><pre><code class="java">@Bean
public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory redisConnectionFactory)&#123;
    Jackson2JsonRedisSerializer&lt;Object&gt; jackson2JsonRedisSerializer = 
        new Jackson2JsonRedisSerializer&lt;Object&gt;(Object.class);
    ObjectMapper om = new ObjectMapper();
    om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);
    om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);
    jackson2JsonRedisSerializer.setObjectMapper(om);
    RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;String, Object&gt;();
    template.setConnectionFactory(redisConnectionFactory);
    template.setKeySerializer(jackson2JsonRedisSerializer);
    template.setValueSerializer(jackson2JsonRedisSerializer);
    template.setHashKeySerializer(jackson2JsonRedisSerializer);
    template.setHashValueSerializer(jackson2JsonRedisSerializer);
    template.afterPropertiesSet();
    return template;
&#125;
</code></pre>
<h2 id="2、RedisTemplate-顶层方法"><a href="#2、RedisTemplate-顶层方法" class="headerlink" title="2、RedisTemplate 顶层方法"></a>2、RedisTemplate 顶层方法</h2><p>1、确定给定 key 是否存在，返回boolean类型，有的话就返回 true，没有就返回 false</p>
<pre><code class="java">redisTemplate.hasKey(K key);
</code></pre>
<p>2、删除给定的 key</p>
<pre><code class="java">redisTemplate.delete(K key);
</code></pre>
<p>3、删除给定 key 的集合</p>
<pre><code class="java">redisTemplate.delete(Collection&lt;K&gt; keys);
</code></pre>
<p>4、执行 Redis 转储命令并返回结果，把key值序列化成byte[]类型</p>
<pre><code class="java">redisTemplate.dump(K key);
</code></pre>
<p>5、对传入的key值设置过期时间</p>
<pre><code class="java">redisTemplate.expire(K key, long timeout, TimeUnit unit);
</code></pre>
<p>6、将给定 key 的过期时间设置为日期时间戳</p>
<pre><code class="java">redisTemplate.expireAt(K key, Date date);
</code></pre>
<p>7、获取当前key的剩下的过期时间，返回值是long</p>
<pre><code class="java">redisTemplate.getExpire(K key);
</code></pre>
<p>8、获取剩余的过期时间，同时设置时间单位，返回值是long</p>
<pre><code class="java">redisTemplate.getExpire(K key, TimeUnit timeUnit);
</code></pre>
<p>9、删除 key 的过期时间</p>
<pre><code class="java">redisTemplate.persist(K key);
</code></pre>
<p>10、查找与给定模式匹配的所有 key ，返回的是一个没有重复的Set类型</p>
<pre><code class="java">redisTemplate.keys(K pattern);
</code></pre>
<p>11、将 oldKey 重命名为 newKey</p>
<pre><code class="java">redisTemplate.rename(K oldKey, K newKey);
</code></pre>
<p>12、获取key值的类型</p>
<pre><code class="java">redisTemplate.type(K key);
</code></pre>
<p>13、仅当 newKey 不存在时，才将密钥 oldKey 重命名为 newKey</p>
<pre><code class="java">redisTemplate.renameIfAbsent(K oldKey, K newKey);
</code></pre>
<p>14、随机从redis中获取一个key</p>
<pre><code class="java">redisTemplate.randomKey();
</code></pre>
<p>15、将给定的 key 移动到带有索引的数据库</p>
<pre><code class="java">redisTemplate.move(K key, int dbIndex);
</code></pre>
<h2 id="3、RedisTemplate-opsForValue"><a href="#3、RedisTemplate-opsForValue" class="headerlink" title="3、RedisTemplate.opsForValue()"></a>3、RedisTemplate.opsForValue()</h2><blockquote>
<p>public interface ValueOperations&lt;K,V&gt;：Redis operations for simple (or in Redis terminology ‘string’) values</p>
<p>注意：如果使用RedisTemplate需要更改序列化方式</p>
<pre><code class="java">RedisSerializer&lt;String&gt; stringSerializer = new StringRedisSerializer();
template.setKeySerializer(stringSerializer );
template.setValueSerializer(stringSerializer );
template.setHashKeySerializer(stringSerializer );
template.setHashValueSerializer(stringSerializer );
</code></pre>
</blockquote>
<p>1、设置key跟value的值：</p>
<pre><code class="java">void redisTemplate.opsForValue().set(K key, V value);
</code></pre>
<pre><code class="java">redisTemplate.opsForValue().set(&quot;name&quot;,&quot;tom&quot;);
redisTemplate.opsForValue().get(&quot;name&quot;);
// 输出结果：tom
</code></pre>
<p>2、设置key跟value的值，同时设置过期时间</p>
<pre><code class="java">void redisTemplate.opsForValue().set(K key, V value, long timeout, TimeUnit unit);
void redisTemplate.opsForValue().set(K key, V value, Duration timeout);
</code></pre>
<pre><code class="java">redisTemplate.opsForValue().set(&quot;name1&quot;, &quot;tom&quot;, 10, TimeUnit.SECONDS);
redisTemplate.opsForValue().set(&quot;name2&quot;, &quot;tom&quot;, Duration.of(10, ChronoUnit.SECONDS));
// 由于设置的是10秒失效，10秒之内查询有结果，10秒之后返回为null
redisTemplate.opsForValue().get(&quot;name1&quot;); 
redisTemplate.opsForValue().get(&quot;name2&quot;); 
</code></pre>
<p>3、用给定值覆盖从指定偏移量开始的 key 的部分</p>
<pre><code class="java">void redisTemplate.opsForValue().set(K key, V value, long offset);
</code></pre>
<pre><code class="java">redisTemplate.opsForValue().set(&quot;key&quot;,&quot;hello world&quot;);
redisTemplate.opsForValue().set(&quot;key&quot;,&quot;redis&quot;, 6);
// 输出结果：hello redis
System.out.println(redisTemplate.opsForValue().get(&quot;key&quot;));
</code></pre>
<p>4、如果 key 不存在，则设置 key 以保存字符串值，存在返回false，否则返回true</p>
<pre><code class="java">Boolean redisTemplate.opsForValue().setIfAbsent(K key, V value);
</code></pre>
<pre><code class="java">// 输出结果：false multi1之前已经存在
System.out.println(redisTemplate.opsForValue().setIfAbsent(&quot;multi1&quot;,&quot;multi1&quot;));
// 输出结果：true  multi111之前不存在
System.out.println(redisTemplate.opsForValue().setIfAbsent(&quot;multi111&quot;,&quot;multi111&quot;));
</code></pre>
<p>5、使用集合中提供的键值对将多个 key 设置为多个值</p>
<pre><code class="java">void redisTemplate.opsForValue().multiSet(Map&lt;? extends K,? extends V&gt; map);
</code></pre>
<pre><code class="java">Map&lt;String,String&gt; maps = new HashMap&lt;String, String&gt;();
maps.put(&quot;multi1&quot;,&quot;multi1&quot;);
maps.put(&quot;multi2&quot;,&quot;multi2&quot;);
maps.put(&quot;multi3&quot;,&quot;multi3&quot;);
// 设置多个值
redisTemplate.opsForValue().multiSet(maps);
List&lt;String&gt; keys = new ArrayList&lt;String&gt;();
keys.add(&quot;multi1&quot;);
keys.add(&quot;multi2&quot;);
keys.add(&quot;multi3&quot;);
// 输出结果：[multi1, multi2, multi3]
System.out.println(redisTemplate.opsForValue().multiGet(keys));
</code></pre>
<p>6、为多个键分别设置它们的值（仅当提供的 key 不存在时才会设置），如果存在则返回false，不存在返回true</p>
<pre><code class="java">Boolean redisTemplate.opsForValue().multiSetIfAbsent(Map&lt;? extends K, ? extends V&gt; m);
</code></pre>
<pre><code class="java">Map&lt;String,String&gt; maps = new HashMap&lt;String, String&gt;();
maps.put(&quot;multi11&quot;,&quot;multi11&quot;);
maps.put(&quot;multi22&quot;,&quot;multi22&quot;);
maps.put(&quot;multi33&quot;,&quot;multi33&quot;);
Map&lt;String,String&gt; maps2 = new HashMap&lt;String, String&gt;();
maps2.put(&quot;multi1&quot;,&quot;multi1&quot;);
maps2.put(&quot;multi2&quot;,&quot;multi2&quot;);
maps2.put(&quot;multi3&quot;,&quot;multi3&quot;);
// 输出结果：true
System.out.println(redisTemplate.opsForValue().multiSetIfAbsent(maps));
// 输出结果：false
System.out.println(redisTemplate.opsForValue().multiSetIfAbsent(maps2));
</code></pre>
<p>7、获取 key 的值</p>
<pre><code class="java">V redisTemplate.opsForValue().get(Object key)
</code></pre>
<pre><code class="java">redisTemplate.opsForValue().set(&quot;key&quot;,&quot;hello world&quot;);
// 输出结果：hello world
System.out.println(redisTemplate.opsForValue().get(&quot;key&quot;));
</code></pre>
<p>8、设置 key 的值，并返回其旧值</p>
<pre><code class="java">V redisTemplate.opsForValue().getAndSet(K key, V value);
</code></pre>
<pre><code class="java">redisTemplate.opsForValue().set(&quot;getSetTest&quot;,&quot;test&quot;);
// 输出结果：test
System.out.println(redisTemplate.opsForValue().getAndSet(&quot;getSetTest&quot;,&quot;test2&quot;));
</code></pre>
<p>9、获取多个 key 的值，返回一个装有 value 的 List 集合</p>
<pre><code class="java">List&lt;V&gt; redisTemplate.opsForValue().multiGet(Collection&lt;K&gt; keys);
</code></pre>
<pre><code class="java">Map&lt;String,String&gt; maps = new HashMap&lt;String, String&gt;();
maps.put(&quot;multi1&quot;,&quot;multi1&quot;);
maps.put(&quot;multi2&quot;,&quot;multi2&quot;);
maps.put(&quot;multi3&quot;,&quot;multi3&quot;);
// 设置多个值
redisTemplate.opsForValue().multiSet(maps);
List&lt;String&gt; keys = new ArrayList&lt;String&gt;();
keys.add(&quot;multi1&quot;);
keys.add(&quot;multi2&quot;);
keys.add(&quot;multi3&quot;);
// 输出结果：[multi1, multi2, multi3]
System.out.println(redisTemplate.opsForValue().multiGet(keys));
</code></pre>
<p>10、在 start 和 end 之间获取键值的子字符串</p>
<pre><code class="java">String redisTemplate.opsForValue().get(K key, long start, long end);
</code></pre>
<pre><code class="java">redisTemplate.opsForValue().set(&quot;appendTest&quot;, &quot;Helloworld&quot;);
System.out.println(redisTemplate.opsForValue().get(&quot;appendTest&quot;, 0, 5));   // Hellow
System.out.println(redisTemplate.opsForValue().get(&quot;appendTest&quot;, 0, -1));  // Helloworld
System.out.println(redisTemplate.opsForValue().get(&quot;appendTest&quot;, -3, -1)); // rld
</code></pre>
<p>11、获取原来的 key 的值后在后面新增上新的字符串</p>
<pre><code class="java">Integer redisTemplate.opsForValue().append(K key, String value);
</code></pre>
<pre><code class="java">redisTemplate.opsForValue().append(&quot;appendTest&quot;, &quot;Hello&quot;);
System.out.println(redisTemplate.opsForValue().get(&quot;appendTest&quot;)); // Hello
redisTemplate.opsForValue().append(&quot;appendTest&quot;, &quot;world&quot;);
System.out.println(redisTemplate.opsForValue().get(&quot;appendTest&quot;)); // Helloworld
</code></pre>
<p>12、增量方式增加long、double值（正值则自增，负值则自减）</p>
<pre><code class="java">Long redisTemplate.opsForValue().increment(K key, long delta);
Double redisTemplate.opsForValue().increment(K key, double delta);
</code></pre>
<pre><code class="java">redisTemplate.opsForValue().append(&quot;increlong&quot;, &quot;1&quot;);
redisTemplate.opsForValue().increment(&quot;increlong&quot;, 1);
System.out.println(redisTemplate.opsForValue().get(&quot;increlong&quot;)); // 2
redisTemplate.opsForValue().increment(&quot;increlong&quot;, 1.2);
System.out.println(redisTemplate.opsForValue().get(&quot;increlong&quot;)); // 2.2
</code></pre>
<p>13、获取指定key的字符串的长度</p>
<pre><code class="java">Long redisTemplate.opsForValue().size(K key);
</code></pre>
<pre><code class="java">redisTemplate.opsForValue().set(&quot;key&quot;,&quot;hello world&quot;);
System.out.println(redisTemplate.opsForValue().size(&quot;key&quot;));
</code></pre>
<p>14、将二进制第offset位值变为value，key键对应的值value对应的ascii码,在offset的位置(从左向右数)变为value</p>
<pre><code class="java">Boolean redisTemplate.opsForValue().setBit(K key, long offset, boolean value);
</code></pre>
<pre><code class="java">redisTemplate.opsForValue().set(&quot;bitTest&quot;, &quot;a&quot;);
// &#39;a&#39; 的ASCII码是 97。转换为二进制是：01100001
// &#39;b&#39; 的ASCII码是 98  转换为二进制是：01100010
// &#39;c&#39; 的ASCII码是 99  转换为二进制是：01100011
// 因为二进制只有0和1，在setbit中true为1，false为0，因此我要变为&#39;b&#39;的话第六位设置为1，第七位设置为0
redisTemplate.opsForValue().setBit(&quot;bitTest&quot;, 6, true);
redisTemplate.opsForValue().setBit(&quot;bitTest&quot;, 7, false);
System.out.println(redisTemplate.opsForValue().get(&quot;bitTest&quot;)); // b
</code></pre>
<p>15、对key所储存的字符串值，获取指定偏移量上的位(bit)</p>
<pre><code class="java">Boolean redisTemplate.opsForValue().getBit(K key, long offset);
</code></pre>
<pre><code class="java">System.out.println(template.opsForValue().getBit(&quot;bitTest&quot;, 7)); // false
</code></pre>
<h2 id="4、RedisTemplate-opsForHash"><a href="#4、RedisTemplate-opsForHash" class="headerlink" title="4、RedisTemplate.opsForHash()"></a>4、RedisTemplate.opsForHash()</h2><blockquote>
<p>public interface HashOperations&lt;H,HK,HV&gt;：Redis的散列可以让用户将多个键值对存储到一个Redis键里面</p>
</blockquote>
<p>1、设置hash hashKey 的值</p>
<pre><code class="java">void redisTemplate.opsForHash().put(H key, HK hashKey, HV value);
</code></pre>
<pre><code class="java">redisTemplate.opsForHash().put(&quot;redisHash&quot;, &quot;name&quot;, &quot;tom&quot;);
redisTemplate.opsForHash().put(&quot;redisHash&quot;, &quot;age&quot;, 26);
redisTemplate.opsForHash().put(&quot;redisHash&quot;, &quot;class&quot;, &quot;6&quot;);
// 输出结果：&#123;age=26, class=6, name=tom&#125;
System.out.println(redisTemplate.opsForHash().entries(&quot;redisHash&quot;));
</code></pre>
<p>2、使用 m 中提供的数据将多个 hash 字段设置为多个值，即使用 map 进行赋值</p>
<pre><code class="java">void redisTemplate.opsForHash().putAll(H key, Map&lt;? extends HK,? extends HV&gt; m);
</code></pre>
<pre><code class="java">Map&lt;String,Object&gt; testMap = new HashMap&lt;&gt;();
testMap.put(&quot;name&quot;, &quot;jack&quot;);
testMap.put(&quot;age&quot;, 27);
testMap.put(&quot;class&quot;, &quot;1&quot;);
template.opsForHash().putAll(&quot;redisHash1&quot;, testMap);
// 输出结果：&#123;class=1, name=jack, age=27&#125;
System.out.println(redisTemplate.opsForHash().entries(&quot;redisHash1&quot;));
</code></pre>
<p>3、仅当 hashKey 不存在时才设置 hash hashKey 的值</p>
<pre><code class="java">Boolean redisTemplate.opsForHash().putIfAbsent(H key, HK hashKey, HV value);
</code></pre>
<pre><code class="java">System.out.println(redisTemplate.opsForHash().putIfAbsent(&quot;redisHash&quot;, &quot;age&quot;, 30));    // false
System.out.println(redisTemplate.opsForHash().putIfAbsent(&quot;redisHash&quot;, &quot;kkk&quot;, &quot;kkk&quot;)); // true
</code></pre>
<p>4、从 key 处的 hash 中获取给定 hashKey 的值，即 key field（hashKey） value</p>
<pre><code class="java">HV redisTemplate.opsForHash().get(H key, Object hashKey);
</code></pre>
<pre><code class="java">System.out.println(redisTemplate.opsForHash().get(&quot;redisHash&quot;,&quot;age&quot;)); // 26
</code></pre>
<p>5、从 hash 中获取给定 hashKey 的值</p>
<pre><code class="java">List&lt;HV&gt; redisTemplate.opsForHash().multiGet(H key, Collection&lt;HK&gt; hashKeys);
</code></pre>
<pre><code class="java">List&lt;Object&gt; kes = new ArrayList&lt;Object&gt;();
kes.add(&quot;name&quot;);
kes.add(&quot;age&quot;);
// 输出结果：[tom, 26]
System.out.println(redisTemplate.opsForHash().multiGet(&quot;redisHash&quot;, kes));
</code></pre>
<p>6、确定给定的hash hashKey 是否存在</p>
<pre><code class="java">Boolean redisTemplate.opsForHash().hasKey(H key, Object hashKey);
</code></pre>
<pre><code class="java">System.out.println(redisTemplate.opsForHash().hasKey(&quot;redisHash&quot;, &quot;age&quot;)); // true
System.out.println(redisTemplate.opsForHash().hasKey(&quot;redisHash&quot;, &quot;ttt&quot;)); // false
</code></pre>
<p>7、删除给定的hash hashKeys</p>
<pre><code class="java">Long redisTemplate.opsForHash().delete(H key, Object... hashKeys);
</code></pre>
<pre><code class="java">System.out.println(redisTemplate.opsForHash().delete(&quot;redisHash&quot;, &quot;name&quot;)); // 1
System.out.println(redisTemplate.opsForHash().entries(&quot;redisHash&quot;)); // // &#123;class=6, age=26&#125;
</code></pre>
<p>8、通过给定的增量增加hash hashKey 的值（整型与浮点型）</p>
<pre><code class="java">Long redisTemplate.opsForHash().increment(H key, HK hashKey, long increment);
Double redisTemplate.opsForHash().increment(H key, HK hashKey, double increment);
</code></pre>
<pre><code class="java">System.out.println(redisTemplate.opsForHash().get(&quot;redisHash&quot;, &quot;age&quot;)); // 26
System.out.println(redisTemplate.opsForHash().increment(&quot;redisHash&quot;, &quot;age&quot;, 1)); // 27
System.out.println(redisTemplate.opsForHash().increment(&quot;redisHash&quot;, &quot;age&quot;, 1.1)); // 28.1
</code></pre>
<p>9、获取存储在 key 的整个 hash，即获取所有值</p>
<pre><code class="java">Map&lt;HK, HV&gt; redisTemplate.opsForHash().entries(H key);
</code></pre>
<pre><code class="java">// 输出结果：&#123;age=26, class=6, name=tom&#125;
System.out.println(template.opsForHash().entries(&quot;redisHash&quot;));
</code></pre>
<p>10、在 key 处获取 hash 的 hashKey 集（字段）</p>
<pre><code class="java">Set&lt;HK&gt; redisTemplate.opsForHash().keys(H key);
</code></pre>
<pre><code class="java">// 输出结果：[name, class, age]
System.out.println(redisTemplate.opsForHash().keys(&quot;redisHash1&quot;));
</code></pre>
<p>11、在 key 处获取 hash 的值</p>
<pre><code class="java">List&lt;HV&gt; redisTemplate.opsForHash().values(H key);
</code></pre>
<pre><code class="java">// 输出结果：[tom, 26, 6]
System.out.println(template.opsForHash().values(&quot;redisHash&quot;));
</code></pre>
<p>12、获取 key 的 hash 大小</p>
<pre><code class="java">Long redisTemplate.opsForHash().size(H key);
</code></pre>
<pre><code class="java">System.out.println(template.opsForHash().size(&quot;redisHash1&quot;)); // 3
</code></pre>
<p>13、查看匹配的键值对，使用Cursor在key的hash中迭代，相当于迭代器</p>
<pre><code class="java">Cursor&lt;Map.Entry&lt;HK, HV&gt;&gt; redisTemplate.opsForHash().scan(H key, ScanOptions options);
</code></pre>
<pre><code class="java">Cursor&lt;Map.Entry&lt;Object, Object&gt;&gt; curosr = template.opsForHash().scan(&quot;redisHash&quot;, ScanOptions.ScanOptions.NONE);
while(curosr.hasNext()) &#123;
    Map.Entry&lt;Object, Object&gt; entry = curosr.next();
    System.out.println(entry.getKey() + &quot;:&quot; + entry.getValue());
&#125;
// 结果：
// age:28.1
// class:6
// kkk:kkk
</code></pre>
<h2 id="5、RedisTemplate-opsForList"><a href="#5、RedisTemplate-opsForList" class="headerlink" title="5、RedisTemplate.opsForList()"></a>5、RedisTemplate.opsForList()</h2><blockquote>
<p>public interface ListOperations&lt;K,V&gt;：Redis列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）</p>
<pre><code class="java">Jackson2JsonRedisSerializer&lt;Object&gt; jackson2JsonRedisSerializer = 
 new Jackson2JsonRedisSerializer&lt;Object&gt;(Object.class);
ObjectMapper om = new ObjectMapper();
om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);
om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);
jackson2JsonRedisSerializer.setObjectMapper(om);
RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;String, Object&gt;();
template.setKeySerializer(jackson2JsonRedisSerializer);
template.setValueSerializer(jackson2JsonRedisSerializer);
template.setHashKeySerializer(jackson2JsonRedisSerializer);
template.setHashValueSerializer(jackson2JsonRedisSerializer);
</code></pre>
</blockquote>
<p>1、根据下表获取列表中的值，下标是从0开始的</p>
<pre><code class="java">V redisTemplate.opsForList().index(K key, long index);
</code></pre>
<pre><code class="java">System.out.println(redisTemplate.opsForList().range(&quot;listRight&quot;, 0, -1)); // [java, oc, c++]
System.out.println(redisTemplate.opsForList().index(&quot;listRight&quot;, 2)); // c++
</code></pre>
<p>2、从 key 的 list 中获取 start 和 end 之间的元素，其中0是列表的第一个元素（列表的头部）</p>
<pre><code class="java">List&lt;V&gt; redisTemplate.opsForList().range(K key, long start, long end);
</code></pre>
<pre><code class="java">System.out.println(template.opsForList().range(&quot;list&quot;, 0, -1)); // [c#, c++, python, java, c#, c#]
</code></pre>
<p>3、为 key 添加值、将数组或集合值添加到 key 中，返回的结果为推送操作后的列表的长度（从左边或者头部插入）</p>
<pre><code class="java">Long redisTemplate.opsForList().leftPush(K key, V value);
Long redisTemplate.opsForList().leftPushAll(K key, V... values);
Long redisTemplate.opsForList().leftPushAll(K key, Collection&lt;V&gt; values);
</code></pre>
<pre><code class="java">redisTemplate.opsForList().leftPush(&quot;list&quot;, &quot;java&quot;);
redisTemplate.opsForList().leftPush(&quot;list&quot;, &quot;python&quot;);
redisTemplate.opsForList().leftPush(&quot;list&quot;, &quot;c++&quot;);
System.out.println(redisTemplate.opsForList().range(&quot;list&quot;, 0, -1)); // [c++, python, java]

redisTemplate.opsForList().leftPushAll(&quot;listarray&quot;, new String[]&#123;&quot;1&quot; ,&quot;2&quot; ,&quot;3&quot;&#125;);
System.out.println(redisTemplate.opsForList().range(&quot;listarray&quot;, 0, -1)); // [3, 2, 1]

redisTemplate.opsForList().leftPushAll(&quot;listCollection&quot;, Arrays.asList(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;));
System.out.println(redisTemplate.opsForList().range(&quot;listCollection&quot;, 0, -1)); // [3, 2, 1]
</code></pre>
<p>4、仅当 list 存在时，才将值添加到 key 中</p>
<pre><code class="java">Long redisTemplate.opsForList().leftPushIfPresent(K key, V value);
</code></pre>
<pre><code class="java">System.out.println(redisTemplate.opsForList().leftPushIfPresent(&quot;leftPushIfPresent&quot;, &quot;aa&quot;)); // 0
System.out.println(redisTemplate.opsForList().leftPushIfPresent(&quot;leftPushIfPresent&quot;, &quot;bb&quot;)); // 0
System.out.println(&quot;==========分割线===========&quot;);
System.out.println(redisTemplate.opsForList().leftPush(&quot;leftPushIfPresent&quot;,&quot;aa&quot;)); // 1
System.out.println(redisTemplate.opsForList().leftPushIfPresent(&quot;leftPushIfPresent&quot;,&quot;bb&quot;)); // 2
</code></pre>
<p>5、把value值放到key对应列表中pivot值的左面，如果pivot值存在的话</p>
<pre><code class="java">Long redisTemplate.opsForList().leftPush(K key, V pivot, V value);
</code></pre>
<pre><code class="java">redisTemplate.opsForList().leftPush(&quot;list&quot;,&quot;java&quot;,&quot;oc&quot;);
System.out.print(redisTemplate.opsForList().range(&quot;list&quot;,0,-1)); // [c++, python, oc, java, c#, c#]
</code></pre>
<p>6、将所有指定的值插入存储在键的列表的尾部。如果键不存在，则在执行推送操作之前将其创建为空列表（从右边插入）</p>
<pre><code class="java">Long redisTemplate.opsForList().rightPush(K key, V value);
Long redisTemplate.opsForList().rightPushAll(K key, V... values);
Long redisTemplate.opsForList().rightPushAll(K key, Collection&lt;V&gt; values);
</code></pre>
<pre><code class="java">redisTemplate.opsForList().leftPush(&quot;list&quot;, &quot;java&quot;);
redisTemplate.opsForList().leftPush(&quot;list&quot;, &quot;python&quot;);
redisTemplate.opsForList().leftPush(&quot;list&quot;, &quot;c++&quot;);
System.out.println(redisTemplate.opsForList().range(&quot;list&quot;, 0, -1)); // [java, python, c++]

redisTemplate.opsForList().leftPushAll(&quot;listarray&quot;, new String[]&#123;&quot;1&quot;, &quot;2&quot;, &quot;3&quot;&#125;);
System.out.println(redisTemplate.opsForList().range(&quot;listarray&quot;, 0, -1)); // [1, 2, 3]

redisTemplate.opsForList().rightPushAll(&quot;listCollectionright&quot;, Arrays.asList(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;));
System.out.println(redisTemplate.opsForList().range(&quot;listCollectionright&quot;, 0, -1)); // [1, 2, 3]
</code></pre>
<p>7、只有存在key对应的列表才能将这个value值插入到key所对应的列表中</p>
<pre><code class="java">Long redisTemplate.opsForList().rightPushIfPresent(K key, V value);
</code></pre>
<pre><code class="java">System.out.println(redisTemplate.opsForList().rightPushIfPresent(&quot;rightPushIfPresent&quot;, &quot;aa&quot;)); // 0
System.out.println(redisTemplate.opsForList().rightPushIfPresent(&quot;rightPushIfPresent&quot;, &quot;bb&quot;)); // 0
System.out.println(&quot;==========分割线===========&quot;);
System.out.println(redisTemplate.opsForList().rightPush(&quot;rightPushIfPresent&quot;, &quot;aa&quot;)); // 1
System.out.println(redisTemplate.opsForList().rightPushIfPresent(&quot;rightPushIfPresent&quot;, &quot;bb&quot;)); // 2
</code></pre>
<p>8、把value值放到key对应列表中pivot值的右面，如果pivot值存在的话</p>
<pre><code class="java">Long redisTemplate.opsForList().rightPush(K key, V pivot, V value);
</code></pre>
<pre><code class="java">System.out.println(redisTemplate.opsForList().range(&quot;listRight&quot;, 0, -1)); // [java, python, c++]
redisTemplate.opsForList().rightPush(&quot;listRight&quot;, &quot;python&quot;, &quot;oc&quot;);
System.out.println(redisTemplate.opsForList().range(&quot;listRight&quot;, 0, -1)); // [java, python, oc, c++]
</code></pre>
<p>9、在列表中index的位置设置value值</p>
<pre><code class="java">void redisTemplate.opsForList().set(K key, long index, V value);
</code></pre>
<pre><code class="java">System.out.println(template.opsForList().range(&quot;listRight&quot;, 0, -1)); // [java, python, oc, c++]
template.opsForList().set(&quot;listRight&quot;, 1, &quot;setValue&quot;);
System.out.println(template.opsForList().range(&quot;listRight&quot;, 0, -1)); // [java, setValue, oc, c++]
</code></pre>
<p>10、删除并返回存储在 key 的列表中的第一个元素（如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止）</p>
<pre><code class="java">redisTemplate.opsForList().leftPop(K key); // 弹出最左边的元素，弹出之后该值在列表中将不复存在
redisTemplate.opsForList().leftPop(K key, long count);
redisTemplate.opsForList().leftPop(K key, Duration timeout);
// 移出并获取列表的第一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止
redisTemplate.opsForList().leftPop(K key, long timeout, TimeUnit unit);
</code></pre>
<p>11、删除并返回存储在 key 的列表中的最后一个元素（如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止）</p>
<pre><code class="java">redisTemplate.opsForList().rightPop(K key);
redisTemplate.opsForList().rightPop(K key, long count);
redisTemplate.opsForList().rightPop(K key, Duration timeout);
redisTemplate.opsForList().rightPop(K key, long timeout, TimeUnit unit);
</code></pre>
<p>12、从 sourceKey 的列表中删除最后一个元素，将其附加到 destinationKey 并返回其值。参数Duration表示：如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</p>
<pre><code class="java">redisTemplate.opsForList().rightPopAndLeftPush(K sourceKey, K destinationKey);
redisTemplate.opsForList().rightPopAndLeftPush(K sourceKey, K destinationKey, Duration timeout);
</code></pre>
<p>13、从存储在 key 的列表中删除第一个 count 出现的 value，计数参数以下列方式影响操作：</p>
<ul>
<li>count&gt; 0：删除等于从头到尾移动的值的元素。</li>
<li>count &lt;0：删除等于从尾到头移动的值的元素。</li>
<li>count &#x3D; 0：删除等于value的所有元素。</li>
</ul>
<pre><code class="java">redisTemplate.opsForList().remove(K key, long count, Object value);
</code></pre>
<p>14、在 start 和 end 之间的元素的 key 处修剪列表，起始和停止都是基于0的索引，无返回值</p>
<pre><code class="java">void redisTemplate.opsForList().trim(K key, long start, long end);
</code></pre>
<pre><code class="java">System.out.println(redisTemplate.opsForList().range(&quot;list&quot;, 0, -1)); // [c#, c++, python, java, c#, c#]
redisTemplate.opsForList().trim(&quot;list&quot;, 1, -1); // 裁剪第一个元素
System.out.println(redisTemplate.opsForList().range(&quot;list&quot;, 0, -1)); // [c++, python, java, c#, c#]
</code></pre>
<p>15、获取存储在 key 的列表的大小，返回值Long</p>
<pre><code class="java">Long redisTemplate.opsForList().size(K key);
</code></pre>
<pre><code class="java">System.out.println(redisTemplate.opsForList().size(&quot;list&quot;)); // 6
</code></pre>
<h2 id="6、RedisTemplate-opsForSet"><a href="#6、RedisTemplate-opsForSet" class="headerlink" title="6、RedisTemplate.opsForSet()"></a>6、RedisTemplate.opsForSet()</h2><blockquote>
<p>public interface SetOperations&lt;K,V&gt;：Redis的Set是string类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据。</p>
<p>Redis 中 集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。</p>
</blockquote>
<p>1、在无序集合中添加元素，返回添加个数</p>
<pre><code class="java">Long redisTemplate.opsForSet().add(K key, V... values);
</code></pre>
<pre><code class="java">System.out.println(redisTemplate.opsForSet().add(&quot;setTest&quot;, new String[]&#123;&quot;aa&quot;,&quot;bb&quot;&#125;)); // 2
</code></pre>
<p>2、移除集合中一个或多个成员，返回已删除元素的数量</p>
<pre><code class="java">Long redisTemplate.opsForSet().remove(K key, Object... values);
</code></pre>
<pre><code class="java">System.out.println(redisTemplate.opsForSet().remove(&quot;setTest&quot;, new String[]&#123;&quot;aa&quot;,&quot;bb&quot;&#125;)); // 2
</code></pre>
<p>3、移除并返回集合中的一个随机元素</p>
<pre><code class="java">V redisTemplate.opsForSet().pop(K key);
</code></pre>
<pre><code class="java">System.out.println(redisTemplate.opsForSet().members(&quot;setTest&quot;)); // [aaa, bbb, ccc]
System.out.println(redisTemplate.opsForSet().pop(&quot;setTest&quot;)); // bbb
System.out.println(redisTemplate.opsForSet().members(&quot;setTest&quot;)); // [aaa, ccc]
</code></pre>
<p>4、无序集合的大小长度</p>
<pre><code class="java">Long redisTemplate.opsForSet().size(K key);
</code></pre>
<pre><code class="java">System.out.println(redisTemplate.opsForSet().members(&quot;setTest&quot;)); // [aaa, bbb, ccc]
System.out.println(redisTemplate.opsForSet().size(&quot;setTest&quot;)); // 3
</code></pre>
<p>5、检查在 key 的 set 中是否包含值member</p>
<pre><code class="java">Boolean redisTemplate.opsForSet().isMember(K key, Object o);
</code></pre>
<pre><code class="java">System.out.println(redisTemplate.opsForSet().isMember(&quot;setTest&quot;, &quot;ccc&quot;)); // true
System.out.println(redisTemplate.opsForSet().isMember(&quot;setTest&quot;, &quot;asd&quot;)); // false
</code></pre>
<p>6、key对应的无序集合与otherKey对应的无序集合求交集</p>
<pre><code class="java">Set&lt;V&gt; redisTemplate.opsForSet().intersect(K key, K otherKey);
</code></pre>
<pre><code class="java">System.out.println(redisTemplate.opsForSet().members(&quot;setTest&quot;)); // [aaa, ccc]
System.out.println(redisTemplate.opsForSet().members(&quot;setTest2&quot;)); // [aaa]
System.out.println(redisTemplate.opsForSet().intersect(&quot;setTest&quot;,&quot;setTest2&quot;)); // [aaa]
</code></pre>
<p>7、key对应的无序集合与多个otherKey对应的无序集合求交集</p>
<pre><code class="java">Set&lt;V&gt; redisTemplate.opsForSet().intersect(K key, Collection&lt;K&gt; otherKeys);
</code></pre>
<pre><code class="java">System.out.println(redisTemplate.opsForSet().members(&quot;setTest1&quot;)); // [aaa, ccc]
System.out.println(redisTemplate.opsForSet().members(&quot;setTest2&quot;)); // [aaa]
System.out.println(redisTemplate.opsForSet().members(&quot;setTest3&quot;)); // [bbb, aaa]
List&lt;String&gt; strlist = Arrays.asList(setTest2, setTest3);
System.out.println(redisTemplate.opsForSet().intersect(&quot;setTest1&quot;, strlist)); // [aaa]
</code></pre>
<p>8、key无序集合与otherkey无序集合的交集存储到destKey无序集合中</p>
<pre><code class="java">Long redisTemplate.opsForSet().intersectAndStore(K key, K otherKey, K destKey);
</code></pre>
<pre><code class="java">System.out.println(redisTemplate.opsForSet().members(&quot;setTest1&quot;)); // [ddd, bbb, aaa, ccc]
System.out.println(redisTemplate.opsForSet().members(&quot;setTest2&quot;)); // [ccc, aaa]
System.out.println(redisTemplate.opsForSet().intersectAndStore(&quot;setTest1&quot;, &quot;setTest2&quot;, &quot;destKey1&quot;)); // 2
System.out.println(redisTemplate.opsForSet().members(&quot;destKey1&quot;)); // [aaa, ccc]
</code></pre>
<p>9、key对应的无序集合与多个otherKey对应的无序集合求交集存储到destKey无序集合中</p>
<pre><code class="java">Long redisTemplate.opsForSet().intersectAndStore(K key, Collection&lt;K&gt; otherKeys, K destKey);
</code></pre>
<pre><code class="java">System.out.println(redisTemplate.opsForSet().members(&quot;setTest1&quot;)); // [ddd, bbb, aaa, ccc]
System.out.println(redisTemplate.opsForSet().members(&quot;setTest2&quot;)); // [ccc, aaa]
System.out.println(redisTemplate.opsForSet().members(&quot;setTest3&quot;)); // [ccc, aaa]
List&lt;String&gt; strlist = Arrays.asList(setTest2, setTest3);
System.out.println(redisTemplate.opsForSet().intersectAndStore(&quot;setTest1&quot;, strlist, &quot;destKey2&quot;)); // 2
System.out.println(redisTemplate.opsForSet().members(&quot;destKey2&quot;)); // [aaa, ccc]
</code></pre>
<p>10、key无序集合与otherKey无序集合的并集</p>
<pre><code class="java">Set&lt;V&gt; redisTemplate.opsForSet().union(K key, K otherKey);
</code></pre>
<pre><code class="java">System.out.println(redisTemplate.opsForSet().members(&quot;setTest1&quot;)); // [ddd, bbb, aaa, ccc]
System.out.println(redisTemplate.opsForSet().members(&quot;setTest2&quot;)); // [ccc, aaa]
System.out.println(redisTemplate.opsForSet().union(&quot;setTest1&quot;,&quot;setTest2&quot;)); // [ccc, aaa, ddd, bbb]
</code></pre>
<p>11、key无序集合与多个otherKey无序集合的并集</p>
<pre><code class="java">Set&lt;V&gt; redisTemplate.opsForSet().union(K key, Collection&lt;K&gt; otherKeys);
</code></pre>
<pre><code class="java">System.out.println(redisTemplate.opsForSet().members(&quot;setTest1&quot;)); // [ddd, bbb, aaa, ccc]
System.out.println(redisTemplate.opsForSet().members(&quot;setTest2&quot;)); // [ccc, aaa]
System.out.println(redisTemplate.opsForSet().members(&quot;setTest3&quot;)); // [xxx, ccc, aaa]
List&lt;String&gt; strlist = Arrays.asList(setTest2, setTest3);
System.out.println(redisTemplate.opsForSet().union(&quot;setTest1&quot;, strlist)); // [ddd, xxx, bbb, aaa, ccc]
</code></pre>
<p>12、key无序集合与otherkey无序集合的并集存储到destKey无序集合中</p>
<pre><code class="java">Long redisTemplate.opsForSet().unionAndStore(K key, K otherKey, K destKey);
</code></pre>
<pre><code class="java">System.out.println(redisTemplate.opsForSet().members(&quot;setTest1&quot;)); // [ddd, bbb, aaa, ccc]
System.out.println(redisTemplate.opsForSet().members(&quot;setTest2&quot;)); // [ccc, aaa]
System.out.println(redisTemplate.opsForSet().unionAndStore(&quot;setTest1&quot;, &quot;setTest2&quot;, &quot;unionAndStoreTest&quot;)); // 4
System.out.println(redisTemplate.opsForSet().members(&quot;unionAndStoreTest&quot;)); // [ccc, aaa, ddd, bbb]
</code></pre>
<p>13、key无序集合与多个otherkey无序集合的并集存储到destKey无序集合中</p>
<pre><code class="java">Long redisTemplate.opsForSet().unionAndStore(K key, Collection&lt;K&gt; otherKeys, K destKey);
</code></pre>
<pre><code class="java">System.out.println(redisTemplate.opsForSet().members(&quot;setTest1&quot;)); // [ddd, bbb, aaa, ccc]
System.out.println(redisTemplate.opsForSet().members(&quot;setTest2&quot;)); // [ccc, aaa]
System.out.println(redisTemplate.opsForSet().members(&quot;setTest3&quot;)); // [xxx, ccc, aaa]
List&lt;String&gt; strlist = Arrays.asList(setTest2, setTest3);
System.out.println(redisTemplate.opsForSet().unionAndStore(&quot;setTest1&quot;, strlist, &quot;unionAndStoreTest&quot;)); // 5
System.out.println(redisTemplate.opsForSet().members(&quot;unionAndStoreTest&quot;)); // [ddd, xxx, bbb, aaa, ccc]
</code></pre>
<p>14、key无序集合与otherKey无序集合的差集</p>
<pre><code class="java">Set&lt;V&gt; redisTemplate.opsForSet().difference(K key, K otherKeys);
</code></pre>
<pre><code class="java">System.out.println(redisTemplate.opsForSet().members(&quot;setTest1&quot;)); // [ddd, bbb, aaa, ccc]
System.out.println(redisTemplate.opsForSet().members(&quot;setTest2&quot;)); // [ccc, aaa]
System.out.println(redisTemplate.opsForSet().difference(&quot;setTest1&quot;,&quot;setTest2&quot;)); // [bbb, ddd]
</code></pre>
<p>15、key无序集合与多个otherKey无序集合的差集</p>
<pre><code class="java">Set&lt;V&gt; redisTemplate.opsForSet().difference(K key, Collection&lt;K&gt; otherKeys);
</code></pre>
<pre><code class="java">System.out.println(redisTemplate.opsForSet().members(&quot;setTest1&quot;)); // [ddd, bbb, aaa, ccc]
System.out.println(redisTemplate.opsForSet().members(&quot;setTest2&quot;)); // [ccc, aaa]
System.out.println(redisTemplate.opsForSet().members(&quot;setTest3&quot;)); // [xxx, ccc, aaa]
List&lt;String&gt; strlist = Arrays.asList(setTest2, setTest3);
System.out.println(redisTemplate.opsForSet().difference(&quot;setTest1&quot;, strlist)); // [bbb, ddd]
</code></pre>
<p>16、key无序集合与otherkey无序集合的差集存储到destKey无序集合中</p>
<pre><code class="java">Long redisTemplate.opsForSet().differenceAndStore(K key, K otherKey, K destKey);
</code></pre>
<pre><code class="java">System.out.println(redisTemplate.opsForSet().members(&quot;setTest1&quot;)); // [ddd, bbb, aaa, ccc]
System.out.println(redisTemplate.opsForSet().members(&quot;setTest2&quot;)); // [ccc, aaa]
System.out.println(redisTemplate.opsForSet().differenceAndStore(&quot;setTest1&quot;, &quot;setTest2&quot;, &quot;differenceAndStore&quot;)); // 2
System.out.println(redisTemplate.opsForSet().members(&quot;differenceAndStore&quot;)); // [bbb, ddd]
</code></pre>
<p>17、key无序集合与多个otherkey无序集合的差集存储到destKey无序集合中</p>
<pre><code class="java">Long redisTemplate.opsForSet().differenceAndStore(K key, Collection&lt;K&gt; otherKeys, K destKey);
</code></pre>
<pre><code class="java">System.out.println(redisTemplate.opsForSet().members(&quot;setTest1&quot;)); // [ddd, bbb, aaa, ccc]
System.out.println(redisTemplate.opsForSet().members(&quot;setTest2&quot;)); // [ccc, aaa]
System.out.println(redisTemplate.opsForSet().members(&quot;setTest3&quot;)); // [xxx, ccc, aaa]
List&lt;String&gt; strlist = Arrays.asList(setTest2, setTest3);
System.out.println(redisTemplate.opsForSet().differenceAndStore(&quot;setTest&quot;, strlist, &quot;differenceAndStore&quot;)); // 2
System.out.println(redisTemplate.opsForSet().members(&quot;differenceAndStore&quot;)); // [bbb, ddd]
</code></pre>
<p>18、获取集合中的所有元素</p>
<pre><code class="java">Set&lt;V&gt; redisTemplate.opsForSet().members(K key);
</code></pre>
<pre><code class="java">System.out.println(redisTemplate.opsForSet().members(&quot;setTest&quot;)); // [ddd, bbb, aaa, ccc]
</code></pre>
<p>19、随机获取集合中的一个元素，返回值V</p>
<pre><code class="java">V redisTemplate.opsForSet().randomMember(K key);
</code></pre>
<pre><code class="java">System.out.println(template.opsForSet().members(&quot;setTest&quot;)); // [ddd, bbb, aaa, ccc]
System.out.println(template.opsForSet().randomMember(&quot;setTest&quot;)); // aaa
System.out.println(template.opsForSet().randomMember(&quot;setTest&quot;)); // bbb
System.out.println(template.opsForSet().randomMember(&quot;setTest&quot;)); // aaa
System.out.println(template.opsForSet().randomMember(&quot;setTest&quot;)); // ddd
</code></pre>
<p>20、随机获取集合中count个值</p>
<pre><code class="java">List&lt;V&gt; redisTemplate.opsForSet().randomMembers(K key, long count);
</code></pre>
<pre><code class="java">System.out.println(redisTemplate.opsForSet().randomMembers(&quot;setTest&quot;, 5)); // [ccc, ddd, ddd, ddd, aaa]
</code></pre>
<p>21、随机获取集合中count个值，但是去重</p>
<pre><code class="java">Set&lt;V&gt; redisTemplate.opsForSet().distinctRandomMembers(K key, long count);
</code></pre>
<pre><code class="java">System.out.println(redisTemplate.opsForSet().distinctRandomMembers(&quot;setTest&quot;, 5)); // [aaa, bbb, ddd, ccc]
</code></pre>
<p>22、遍历set</p>
<pre><code class="java">Cursor&lt;V&gt; redisTemplate.opsForSet().scan(K key, ScanOptions options);
</code></pre>
<pre><code class="java">Cursor&lt;Object&gt; curosr = template.opsForSet().scan(&quot;setTest&quot;, ScanOptions.NONE);
while(curosr.hasNext())&#123;
    System.out.println(curosr.next());
&#125;
// 输出结果：
// ddd
// bbb
// aaa
// ccc
</code></pre>
<h2 id="7、RedisTemplate-opsForZSet"><a href="#7、RedisTemplate-opsForZSet" class="headerlink" title="7、RedisTemplate.opsForZSet()"></a>7、RedisTemplate.opsForZSet()</h2><blockquote>
<p>public interface ZSetOperations&lt;K,V&gt;：Redis 有序集合和无序集合一样也是string类型元素的集合,且不允许重复的成员。<br>不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。<br>有序集合的成员是唯一的，但分数(score)却可以重复。</p>
</blockquote>
<p>1、新增一个有序集合（从小到大排序），存在的话为false，不存在的话为true</p>
<pre><code class="java">Boolean redisTemplate.opsForZSet().add(K key, V value, double score);
</code></pre>
<pre><code class="java">System.out.println(template.opsForZSet().add(&quot;zset1&quot;, &quot;zset-1&quot;, 1.0)); // true
</code></pre>
<p>2、新增一个有序集合</p>
<pre><code class="java">Long redisTemplate.opsForZSet().add(K key, Set&lt;TypedTuple&lt;V&gt;&gt; tuples);
</code></pre>
<pre><code class="java">ZSetOperations.TypedTuple&lt;Object&gt; objectTypedTuple1 = new DefaultTypedTuple&lt;Object&gt;(&quot;zset-5&quot;, 9.6);
ZSetOperations.TypedTuple&lt;Object&gt; objectTypedTuple2 = new DefaultTypedTuple&lt;Object&gt;(&quot;zset-6&quot;, 9.9);
Set&lt;ZSetOperations.TypedTuple&lt;Object&gt;&gt; tuples = new HashSet&lt;ZSetOperations.TypedTuple&lt;Object&gt;&gt;();
tuples.add(objectTypedTuple1);
tuples.add(objectTypedTuple2);
System.out.println(redisTemplate.opsForZSet().add(&quot;zset1&quot;, tuples)); // 2
// [zset-1, zset-2, zset-3, zset-4, zset-5, zset-6]
System.out.println(redisTemplate.opsForZSet().range(&quot;zset1&quot;, 0, -1));
</code></pre>
<p>3、从有序集合中移除一个或者多个元素</p>
<pre><code class="java">Long redisTemplate.opsForZSet().remove(K key, Object... values);
</code></pre>
<pre><code class="java">// [zset-1, zset-2, zset-3, zset-4, zset-5, zset-6]
System.out.println(redisTemplate.opsForZSet().range(&quot;zset1&quot;, 0, -1));
System.out.println(redisTemplate.opsForZSet().remove(&quot;zset1&quot;,&quot;zset-6&quot;)); // 1
// [zset-1, zset-2, zset-3, zset-4, zset-5]
System.out.println(redisTemplate.opsForZSet().range(&quot;zset1&quot;, 0, -1));
</code></pre>
<p>4、增加元素的score值，并返回增加后的值</p>
<pre><code class="java">Double redisTemplate.opsForZSet().incrementScore(K key, V value, double score);
</code></pre>
<pre><code class="java">// 原为1.1，结果：2.2
System.out.println(template.opsForZSet().incrementScore(&quot;zset1&quot;, &quot;zset-1&quot;, 1.1));
</code></pre>
<p>5、返回元素在集合的从小到大排名（索引从0开始）</p>
<pre><code class="java">Long redisTemplate.opsForZSet().rank(K key, Object o);
</code></pre>
<pre><code class="java">// [zset-2, zset-1, zset-3, zset-4, zset-5]
System.out.println(redisTemplate.opsForZSet().range(&quot;zset1&quot;, 0, -1));
// 0  表明排名第一
System.out.println(redisTemplate.opsForZSet().rank(&quot;zset1&quot;, &quot;zset-2&quot;));
</code></pre>
<p>6、返回元素在集合的由大到小排名（索引从0开始）</p>
<pre><code class="java">Long redisTemplate.opsForZSet().reverseRank(K key, Object o);
</code></pre>
<pre><code class="java">// [zset-2, zset-1, zset-3, zset-4, zset-5]
System.out.println(template.opsForZSet().range(&quot;zset1&quot;,0,-1));
// 4 递减之后排到第五位去了
System.out.println(template.opsForZSet().reverseRank(&quot;zset1&quot;,&quot;zset-2&quot;));   
</code></pre>
<p>7、通过索引返回有序集合指定区间内的成员（分数从低到高）</p>
<pre><code class="java">Set&lt;V&gt; redisTemplate.opsForZSet().range(K key, long start, long end);
</code></pre>
<pre><code class="java">// [zset-2, zset-1, zset-3, zset-4, zset-5]
System.out.println(redisTemplate.opsForZSet().range(&quot;zset1&quot;, 0, -1));
</code></pre>
<p>8、通过索引区间返回有序集合指定区间内的成员（分数从低到高）</p>
<pre><code class="java">Set&lt;TypedTuple&lt;V&gt;&gt; redisTemplate.opsForZSet().rangeWithScores(K key, long start, long end);
</code></pre>
<pre><code class="java">Set&lt;ZSetOperations.TypedTuple&lt;Object&gt;&gt; tuples = redisTemplate.opsForZSet().rangeWithScores(&quot;zset1&quot;, 0, -1);
Iterator&lt;ZSetOperations.TypedTuple&lt;Object&gt;&gt; iterator = tuples.iterator();
while (iterator.hasNext()) &#123;
    ZSetOperations.TypedTuple&lt;Object&gt; typedTuple = iterator.next();
    System.out.println(&quot;value:&quot; + typedTuple.getValue() + &quot;score:&quot; + typedTuple.getScore());
&#125;
// 结果：
// value:zset-2score:1.2
// value:zset-1score:2.2
// value:zset-3score:2.3
// value:zset-4score:6.6
// value:zset-5score:9.6
</code></pre>
<p>9、通过分数返回有序集合指定区间内的成员（分数从低到高排序）</p>
<pre><code class="java">Set&lt;V&gt; redisTemplate.opsForZSet().rangeByScore(K key, double min, double max);
</code></pre>
<pre><code class="java">System.out.println(redisTemplate.opsForZSet().rangeByScore(&quot;zset1&quot;,0,5)); // [zset-2, zset-1, zset-3]
</code></pre>
<p>10、通过分数返回有序集合指定区间内的成员（分数从低到高排序）</p>
<pre><code class="java">Set&lt;TypedTuple&lt;V&gt;&gt; redisTemplate.opsForZSet().rangeByScoreWithScores(K key, double min, double max);
</code></pre>
<pre><code class="java">Set&lt;ZSetOperations.TypedTuple&lt;Object&gt;&gt; tuples = redisTemplate.opsForZSet().rangeByScoreWithScores(&quot;zset1&quot;, 0, 5);
Iterator&lt;ZSetOperations.TypedTuple&lt;Object&gt;&gt; iterator = tuples.iterator();
while (iterator.hasNext()) &#123;
    ZSetOperations.TypedTuple&lt;Object&gt; typedTuple = iterator.next();
    System.out.println(&quot;value:&quot; + typedTuple.getValue() + &quot;score:&quot; + typedTuple.getScore());
&#125;
// 结果：
// value:zset-2score:1.2
// value:zset-1score:2.2
// value:zset-3score:2.3
</code></pre>
<p>11、通过分数返回有序集合指定区间内的成员，并在索引范围内（分数从低到高排序）</p>
<pre><code class="java">Set&lt;V&gt; redisTemplate.opsForZSet().rangeByScore(K key, double min, double max, long offset, long count);
</code></pre>
<pre><code class="java">System.out.println(redisTemplate.opsForZSet().rangeByScore(&quot;zset1&quot;, 0, 5)); // [zset-2, zset-1, zset-3]
System.out.println(redisTemplate.opsForZSet().rangeByScore(&quot;zset1&quot;, 0, 5,1,2)); // [zset-1, zset-3]
</code></pre>
<p>12、通过分数返回有序集合指定区间内的成员对象，并在索引范围内（分数从低到高排序）</p>
<pre><code class="java">Set&lt;TypedTuple&lt;V&gt;&gt; redisTemplate.opsForZSet().rangeByScoreWithScores(K key, double min, double max, long offset, long count);
</code></pre>
<pre><code class="java">Set&lt;ZSetOperations.TypedTuple&lt;Object&gt;&gt; tuples = redisTemplate.opsForZSet().rangeByScoreWithScores(&quot;zset1&quot;,0,5,1,2);
Iterator&lt;ZSetOperations.TypedTuple&lt;Object&gt;&gt; iterator = tuples.iterator();
while (iterator.hasNext()) &#123;
    ZSetOperations.TypedTuple&lt;Object&gt; typedTuple = iterator.next();
    System.out.println(&quot;value:&quot; + typedTuple.getValue() + &quot;score:&quot; + typedTuple.getScore());
&#125;
// 结果：
// value:zset-1score:2.2
// value:zset-3score:2.3
</code></pre>
<p>13、通过索引返回有序集合指定区间内的成员（分数从高到低）</p>
<pre><code class="java">Set&lt;V&gt; redisTemplate.opsForZSet().reverseRange(K key, long start, long end);
</code></pre>
<pre><code class="java">// [zset-5, zset-4, zset-3, zset-1, zset-2]
System.out.println(redisTemplate.opsForZSet().reverseRange(&quot;zset1&quot;, 0, -1));
</code></pre>
<p>14、通过索引区间返回有序集合指定区间内的成员（分数从高到低）</p>
<pre><code class="java">Set&lt;TypedTuple&lt;V&gt;&gt; redisTemplate.opsForZSet().reverseRangeWithScores(K key, long start, long end);
</code></pre>
<pre><code class="java">Set&lt;ZSetOperations.TypedTuple&lt;Object&gt;&gt; tuples = redisTemplate.opsForZSet().reverseRangeWithScores(&quot;zset1&quot;,0,-1);
Iterator&lt;ZSetOperations.TypedTuple&lt;Object&gt;&gt; iterator = tuples.iterator();
while (iterator.hasNext()) &#123;
    ZSetOperations.TypedTuple&lt;Object&gt; typedTuple = iterator.next();
    System.out.println(&quot;value:&quot; + typedTuple.getValue() + &quot;score:&quot; + typedTuple.getScore());
&#125;
// 结果：
// value:zset-5score:9.6
// value:zset-4score:6.6
// value:zset-3score:2.3
// value:zset-1score:2.2
// value:zset-2score:1.2
</code></pre>
<p>15、通过分数返回有序集合指定区间内的成员（分数从高到低排序）</p>
<pre><code class="java">Set&lt;V&gt; redisTemplate.opsForZSet().reverseRangeByScore(K key, double min, double max);
</code></pre>
<pre><code class="java">使用：与rangeByScore调用方法一样，其中有序集成员按分数值递减(从大到小)顺序排列
</code></pre>
<p>16、通过分数返回有序集合指定区间内的成员对象，并在索引范围内（分数从高到低排序）</p>
<pre><code class="java">Set&lt;TypedTuple&lt;V&gt;&gt; redisTemplate.opsForZSet().reverseRangeByScoreWithScores(K key, double min, double max);
</code></pre>
<pre><code class="java">使用：与rangeByScoreWithScores调用方法一样，其中有序集成员按分数值递减(从大到小)顺序排列
</code></pre>
<p>17、通过分数返回有序集合指定区间内的成员，并在索引范围内（分数从高到低排序）</p>
<pre><code class="java">Set&lt;V&gt; redisTemplate.opsForZSet().reverseRangeByScore(K key, double min, double max, long offset, long count);
</code></pre>
<pre><code class="java">使用：与rangeByScore调用方法一样，其中有序集成员按分数值递减(从大到小)顺序排列
</code></pre>
<p>18、通过分数返回有序集合指定区间内的成员对象，并在索引范围内（分数从高到低排序）</p>
<pre><code class="java">Set&lt;TypedTuple&lt;V&gt;&gt; redisTemplate.opsForZSet().reverseRangeByScoreWithScores(K key, double min, double max, long offset, long count);
</code></pre>
<pre><code class="java">使用：与rangeByScoreWithScores调用方法一样，其中有序集成员按分数值递减(从大到小)顺序排列
</code></pre>
<p>19、通过分数返回有序集合指定区间内的成员个数</p>
<pre><code class="java">Long redisTemplate.opsForZSet().count(K key, double min, double max);
</code></pre>
<pre><code class="java">System.out.println(redisTemplate.opsForZSet().rangeByScore(&quot;zset1&quot;, 0, 5)); // [zset-2, zset-1, zset-3]
System.out.println(redisTemplate.opsForZSet().count(&quot;zset1&quot;, 0, 5)); // 3
</code></pre>
<p>20、获取有序集合的成员数，内部调用的就是zCard方法</p>
<pre><code class="java">Long redisTemplate.opsForZSet().size(K key);
</code></pre>
<pre><code class="java">System.out.println(redisTemplate.opsForZSet().size(&quot;zset1&quot;)); // 6
</code></pre>
<p>21、获取有序集合的成员数</p>
<pre><code class="java">Long redisTemplate.opsForZSet().zCard(K key);
</code></pre>
<pre><code class="java">System.out.println(redisTemplate.opsForZSet().zCard(&quot;zset1&quot;)); // 6
</code></pre>
<p>22、获取指定成员的score值</p>
<pre><code class="java">Double redisTemplate.opsForZSet().score(K key, Object o);
</code></pre>
<pre><code class="java">System.out.println(redisTemplate.opsForZSet().score(&quot;zset1&quot;, &quot;zset-1&quot;)); // 2.2
</code></pre>
<p>23、移除指定索引位置（索引）的成员（分数从低到高排序）</p>
<pre><code class="java">Long redisTemplate.opsForZSet().removeRange(K key, long start, long end);
</code></pre>
<pre><code class="java">System.out.println(redisTemplate.opsForZSet().range(&quot;zset2&quot;, 0, -1)); // [zset-1, zset-2, zset-3, zset-4]
System.out.println(redisTemplate.opsForZSet().removeRange(&quot;zset2&quot;, 1, 2)); // 2
System.out.println(redisTemplate.opsForZSet().range(&quot;zset2&quot;, 0, -1)); // [zset-1, zset-4]    
</code></pre>
<p>24、根据指定的score值得范围来移除成员</p>
<pre><code class="java">Long redisTemplate.opsForZSet().removeRangeByScore(K key, double min, double max);
</code></pre>
<pre><code class="java">// System.out.println(template.opsForZSet().add(&quot;zset2&quot;, &quot;zset-1&quot;, 1.1));
// System.out.println(template.opsForZSet().add(&quot;zset2&quot;, &quot;zset-2&quot;, 1.2));
// System.out.println(template.opsForZSet().add(&quot;zset2&quot;, &quot;zset-3&quot;, 2.3));
// System.out.println(template.opsForZSet().add(&quot;zset2&quot;, &quot;zset-4&quot;, 6.6));
System.out.println(redisTemplate.opsForZSet().range(&quot;zset2&quot;, 0, -1)); // [zset-1, zset-2, zset-3,zset-4]
System.out.println(redisTemplate.opsForZSet().removeRangeByScore(&quot;zset2&quot;, 2, 3)); // 1
System.out.println(redisTemplate.opsForZSet().range(&quot;zset2&quot;, 0, -1)); // [zset-1, zset-2, zset-4]
</code></pre>
<p>25、计算给定的多个有序集的并集，并存储在新的 destKey中，key相同的话会把score值相加</p>
<pre><code class="java">Long redisTemplate.opsForZSet().unionAndStore(K key, K otherKey, K destKey);
Long redisTemplate.opsForZSet().unionAndStore(K key, Collection&lt;K&gt; otherKeys, K destKey);
</code></pre>
<pre><code class="java">System.out.println(redisTemplate.opsForZSet().add(&quot;zzset1&quot;,&quot;zset-1&quot;,1.0));
System.out.println(redisTemplate.opsForZSet().add(&quot;zzset1&quot;,&quot;zset-2&quot;,2.0));
System.out.println(redisTemplate.opsForZSet().add(&quot;zzset1&quot;,&quot;zset-3&quot;,3.0));
System.out.println(redisTemplate.opsForZSet().add(&quot;zzset1&quot;,&quot;zset-4&quot;,6.0));

System.out.println(redisTemplate.opsForZSet().add(&quot;zzset2&quot;,&quot;zset-1&quot;,1.0));
System.out.println(redisTemplate.opsForZSet().add(&quot;zzset2&quot;,&quot;zset-2&quot;,2.0));
System.out.println(redisTemplate.opsForZSet().add(&quot;zzset2&quot;,&quot;zset-3&quot;,3.0));
System.out.println(redisTemplate.opsForZSet().add(&quot;zzset2&quot;,&quot;zset-4&quot;,6.0));
System.out.println(redisTemplate.opsForZSet().add(&quot;zzset2&quot;,&quot;zset-5&quot;,7.0));
System.out.println(redisTemplate.opsForZSet().unionAndStore(&quot;zzset1&quot;,&quot;zzset2&quot;,&quot;destZset11&quot;));

Set&lt;ZSetOperations.TypedTuple&lt;Object&gt;&gt; tuples = template.opsForZSet().rangeWithScores(&quot;destZset11&quot;,0,-1);
Iterator&lt;ZSetOperations.TypedTuple&lt;Object&gt;&gt; iterator = tuples.iterator();
while (iterator.hasNext()) &#123;
    ZSetOperations.TypedTuple&lt;Object&gt; typedTuple = iterator.next();
    System.out.println(&quot;value:&quot; + typedTuple.getValue() + &quot;score:&quot; + typedTuple.getScore());
&#125;
// 结果：
// value:zset-1score:2.0
// value:zset-2score:4.0
// value:zset-3score:6.0
// value:zset-5score:7.0
// value:zset-4score:12.0
</code></pre>
<pre><code class="java">// System.out.println(template.opsForZSet().add(&quot;zzset1&quot;,&quot;zset-1&quot;,1.0));
// System.out.println(template.opsForZSet().add(&quot;zzset1&quot;,&quot;zset-2&quot;,2.0));
// System.out.println(template.opsForZSet().add(&quot;zzset1&quot;,&quot;zset-3&quot;,3.0));
// System.out.println(template.opsForZSet().add(&quot;zzset1&quot;,&quot;zset-4&quot;,6.0));

// System.out.println(template.opsForZSet().add(&quot;zzset2&quot;,&quot;zset-1&quot;,1.0));
// System.out.println(template.opsForZSet().add(&quot;zzset2&quot;,&quot;zset-2&quot;,2.0));
// System.out.println(template.opsForZSet().add(&quot;zzset2&quot;,&quot;zset-3&quot;,3.0));
// System.out.println(template.opsForZSet().add(&quot;zzset2&quot;,&quot;zset-4&quot;,6.0));
// System.out.println(template.opsForZSet().add(&quot;zzset2&quot;,&quot;zset-5&quot;,7.0));

System.out.println(template.opsForZSet().add(&quot;zzset3&quot;,&quot;zset-1&quot;,1.0));
System.out.println(template.opsForZSet().add(&quot;zzset3&quot;,&quot;zset-2&quot;,2.0));
System.out.println(template.opsForZSet().add(&quot;zzset3&quot;,&quot;zset-3&quot;,3.0));
System.out.println(template.opsForZSet().add(&quot;zzset3&quot;,&quot;zset-4&quot;,6.0));
System.out.println(template.opsForZSet().add(&quot;zzset3&quot;,&quot;zset-5&quot;,7.0));

List&lt;String&gt; stringList = new ArrayList&lt;String&gt;();
stringList.add(&quot;zzset2&quot;);
stringList.add(&quot;zzset3&quot;);
System.out.println(template.opsForZSet().unionAndStore(&quot;zzset1&quot;,stringList,&quot;destZset22&quot;));

Set&lt;ZSetOperations.TypedTuple&lt;Object&gt;&gt; tuples = template.opsForZSet().rangeWithScores(&quot;destZset22&quot;,0,-1);
Iterator&lt;ZSetOperations.TypedTuple&lt;Object&gt;&gt; iterator = tuples.iterator();
while (iterator.hasNext()) &#123;
    ZSetOperations.TypedTuple&lt;Object&gt; typedTuple = iterator.next();
    System.out.println(&quot;value:&quot; + typedTuple.getValue() + &quot;score:&quot; + typedTuple.getScore());
&#125;
// 结果：
// value:zset-1score:3.0
// value:zset-2score:6.0
// value:zset-3score:9.0
// value:zset-5score:14.0
// value:zset-4score:18.0
</code></pre>
<p>26、计算给定的一个或多个有序集的交集并将结果集存储在新的有序集合 key 中</p>
<pre><code class="java">Long redisTemplate.opsForZSet().intersectAndStore(K key, K otherKey, K destKey);
Long redisTemplate.opsForZSet().intersectAndStore(K key, Collection&lt;K&gt; otherKeys, K destKey);
</code></pre>
<pre><code class="java">System.out.println(redisTemplate.opsForZSet().intersectAndStore(&quot;zzset1&quot;, &quot;zzset2&quot; ,&quot;destZset33&quot;));

// 输出有序集合destZset33
Set&lt;ZSetOperations.TypedTuple&lt;Object&gt;&gt; tuples = redisTemplate.opsForZSet().rangeWithScores(&quot;destZset33&quot;,0,-1);
Iterator&lt;ZSetOperations.TypedTuple&lt;Object&gt;&gt; iterator = tuples.iterator();
while (iterator.hasNext()) &#123;
    ZSetOperations.TypedTuple&lt;Object&gt; typedTuple = iterator.next();
    System.out.println(&quot;value:&quot; + typedTuple.getValue() + &quot;score:&quot; + typedTuple.getScore());
&#125;
// 结果：
// value:zset-1score:2.0
// value:zset-2score:4.0
// value:zset-3score:6.0
// value:zset-4score:12.0
</code></pre>
<pre><code class="java">List&lt;String&gt; stringList = Arrays.asList(&quot;zzset2&quot;, &quot;zzset3&quot;);
System.out.println(template.opsForZSet().intersectAndStore(&quot;zzset1&quot;, stringList, &quot;destZset44&quot;));

// 输出有序集合destZset44
Set&lt;ZSetOperations.TypedTuple&lt;Object&gt;&gt; tuples = template.opsForZSet().rangeWithScores(&quot;destZset44&quot;, 0, -1);
Iterator&lt;ZSetOperations.TypedTuple&lt;Object&gt;&gt; iterator = tuples.iterator();
while (iterator.hasNext()) &#123;
    ZSetOperations.TypedTuple&lt;Object&gt; typedTuple = iterator.next();
    System.out.println(&quot;value:&quot; + typedTuple.getValue() + &quot;score:&quot; + typedTuple.getScore());
&#125;
// 结果：
// value:zset-1score:3.0
// value:zset-2score:6.0
// value:zset-3score:9.0
// value:zset-4score:18.0
</code></pre>
<p>27、遍历ZSet</p>
<pre><code class="java">Cursor&lt;TypedTuple&lt;V&gt;&gt; redisTemplate.opsForZSet().scan(K key, ScanOptions options);
</code></pre>
<pre><code class="java">Cursor&lt;ZSetOperations.TypedTuple&lt;Object&gt;&gt; cursor = redisTemplate.opsForZSet().scan(&quot;zzset1&quot;, ScanOptions.NONE);
while (cursor.hasNext()) &#123;
    ZSetOperations.TypedTuple&lt;Object&gt; item = cursor.next();
    System.out.println(item.getValue() + &quot;:&quot; + item.getScore());
&#125;
// 结果：
// zset-1:1.0
// zset-2:2.0
// zset-3:3.0
// zset-4:6.0
</code></pre>
<h2 id="8、RedisUtil-自定义工具类"><a href="#8、RedisUtil-自定义工具类" class="headerlink" title="8、RedisUtil 自定义工具类"></a>8、RedisUtil 自定义工具类</h2><pre><code class="java">/**
 * Redis工具类，使用之前请确保RedisTemplate成功注入
 */
public class RedisUtil &#123;
    private RedisUtil() &#123;
    &#125;

    @SuppressWarnings(&quot;unchecked&quot;)
    private static RedisTemplate&lt;String, Object&gt; redisTemplate = SpringUtil.getBean(&quot;redisTemplate&quot;, RedisTemplate.class);

    /**
     * 设置有效时间
     * 单位默认秒
     *
     * @param key     Redis键
     * @param timeout 超时时间
     * @return true=设置成功；false=设置失败
     */
    public static boolean expire(final String key, final long timeout) &#123;

        return expire(key, timeout, TimeUnit.SECONDS);
    &#125;

    /**
     * 设置有效时间
     *
     * @param key     Redis键
     * @param timeout 超时时间
     * @param unit    时间单位
     * @return true=设置成功；false=设置失败
     */
    public static boolean expire(final String key, final long timeout, final TimeUnit unit) &#123;

        Boolean ret = redisTemplate.expire(key, timeout, unit);
        return ret != null &amp;&amp; ret;
    &#125;

    /**
     * 删除单个key
     *
     * @param key 键
     * @return true=删除成功；false=删除失败
     */
    public static boolean del(final String key) &#123;

        Boolean ret = redisTemplate.delete(key);
        return ret != null &amp;&amp; ret;
    &#125;

    /**
     * 删除多个key
     *
     * @param keys 键集合
     * @return 成功删除的个数
     */
    public static long del(final Collection&lt;String&gt; keys) &#123;

        Long ret = redisTemplate.delete(keys);
        return ret == null ? 0 : ret;
    &#125;

    /**
     * 存入普通对象
     *
     * @param key   Redis键
     * @param value 值
     */
    public static void set(final String key, final Object value) &#123;

        redisTemplate.opsForValue().set(key, value);
    &#125;

    // 存储普通对象操作

    /**
     * 存入普通对象
     *
     * @param key     键
     * @param value   值
     * @param timeout 有效期，单位秒
     */
    public static void set(final String key, final Object value, final long timeout) &#123;

        redisTemplate.opsForValue().set(key, value, timeout, TimeUnit.SECONDS);
    &#125;

    /**
     * 获取普通对象
     *
     * @param key 键
     * @return 对象
     */
    public static Object get(final String key) &#123;

        return redisTemplate.opsForValue().get(key);
    &#125;

    // 存储Hash操作

    /**
     * 往Hash中存入数据
     *
     * @param key   Redis键
     * @param filed Hash filed键
     * @param value 值
     */
    public static void hPut(final String key, final String filed, final Object value) &#123;

        redisTemplate.opsForHash().put(key, filed, value);
    &#125;

    /**
     * 往Hash中存入多个数据
     *
     * @param key      Redis键
     * @param filedMap Hash键值对
     */
    public static void hPutAll(final String key, final Map&lt;String, Object&gt; filedMap) &#123;

        redisTemplate.opsForHash().putAll(key, filedMap);
    &#125;

    /**
     * 获取Hash中的数据
     *
     * @param key   Redis键
     * @param filed Hash filed键
     * @return Hash中的对象
     */
    public static Object hGet(final String key, final String filed) &#123;

        return redisTemplate.opsForHash().get(key, filed);
    &#125;

    /**
     * 获取多个Hash中的数据
     *
     * @param key    Redis键
     * @param fileds Hash filed键集合
     * @return Hash对象集合
     */
    public static List&lt;Object&gt; hMultiGet(final String key, final Collection&lt;Object&gt; fileds) &#123;

        return redisTemplate.opsForHash().multiGet(key, fileds);
    &#125;

    // 存储Set相关操作

    /**
     * 往Set中存入数据
     *
     * @param key    Redis键
     * @param values 值
     * @return 存入的个数
     */
    public static long sSet(final String key, final Object... values) &#123;
        Long count = redisTemplate.opsForSet().add(key, values);
        return count == null ? 0 : count;
    &#125;

    /**
     * 删除Set中的数据
     *
     * @param key    Redis键
     * @param values 值
     * @return 移除的个数
     */
    public static long sDel(final String key, final Object... values) &#123;
        Long count = redisTemplate.opsForSet().remove(key, values);
        return count == null ? 0 : count;
    &#125;

    // 存储List相关操作

    /**
     * 往List左侧中存入数据
     *
     * @param key   Redis键
     * @param value 数据
     * @return 存入的个数
     */
    public static long lPush(final String key, final Object value) &#123;
        Long count = redisTemplate.opsForList().leftPush(key, value);
        return count == null ? 0 : count;
    &#125;

    /**
     * 往List右侧中存入数据
     *
     * @param key   Redis键
     * @param value 数据
     * @return 存入的个数
     */
    public static long rPush(final String key, final Object value) &#123;
        Long count = redisTemplate.opsForList().rightPush(key, value);
        return count == null ? 0 : count;
    &#125;

    /**
     * 往List中左侧存入多个数据
     *
     * @param key    Redis键
     * @param values 多个数据
     * @return 存入的个数
     */
    public static long lPushAll(final String key, final Collection&lt;Object&gt; values) &#123;
        Long count = redisTemplate.opsForList().leftPushAll(key, values);
        return count == null ? 0 : count;
    &#125;

    /**
     * 往List中左侧存入多个数据
     *
     * @param key    Redis键
     * @param values 多个数据
     * @return 存入的个数
     */
    public static long lPushAll(final String key, final Object... values) &#123;
        Long count = redisTemplate.opsForList().leftPushAll(key, values);
        return count == null ? 0 : count;
    &#125;

    /**
     * 往List中右侧存入多个数据
     *
     * @param key    Redis键
     * @param values 多个数据
     * @return 存入的个数
     */
    public static long rPushAll(final String key, final Collection&lt;Object&gt; values) &#123;
        Long count = redisTemplate.opsForList().rightPushAll(key, values);
        return count == null ? 0 : count;
    &#125;


    /**
     * 往List中右侧存入多个数据
     *
     * @param key    Redis键
     * @param values 多个数据
     * @return 存入的个数
     */
    public static long rPushAll(final String key, final Object... values) &#123;
        Long count = redisTemplate.opsForList().rightPushAll(key, values);
        return count == null ? 0 : count;
    &#125;


    /**
     * 从List中获取begin到end之间的元素
     *
     * @param key   Redis键
     * @param start 开始位置
     * @param end   结束位置（start=0，end=-1表示获取全部元素）
     * @return List对象
     */
    public static List&lt;Object&gt; listGetRange(final String key, final int start, final int end) &#123;
        return redisTemplate.opsForList().range(key, start, end);
    &#125;


    /**
     * 从List左侧弹出数据
     *
     * @param key Redis键
     * @return 对象
     */
    public static Object listGetL(final String key) &#123;
        return redisTemplate.opsForList().leftPop(key);
    &#125;


    /**
     * 从List右侧弹出数据
     *
     * @param key Redis键
     * @return 对象
     */
    public static Object listGetR(final String key) &#123;
        return redisTemplate.opsForList().rightPop(key);
    &#125;
&#125;
SpringUtil

/**
 * SpringBoot 容器工具类
 */
@Component
public class SpringUtil implements ApplicationContextAware &#123;
    /**
     * 上下文对象实例
     */
    private static ApplicationContext applicationContext;

    @Override
    @Autowired
    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123;
        SpringUtil.applicationContext = applicationContext;
    &#125;

    /**
     * 获取applicationContext
     * @return
     */
    public static ApplicationContext getApplicationContext() &#123;
        return applicationContext;
    &#125;

    /**
     * 通过name获取 Bean.
     * @param name 参数传入要获取的实例的类名 首字母小写，这是默认的
     * @return
     */
    public static Object getBean(String name)&#123;
        return getApplicationContext().getBean(name);
    &#125;

    /**
     * 通过class获取Bean.
     * @param clazz
     * @param &lt;T&gt;
     * @return
     */
    public static &lt;T&gt; T getBean(Class&lt;T&gt; clazz)&#123;
        return getApplicationContext().getBean(clazz);
    &#125;

    /**
     * 通过name,以及Clazz返回指定的Bean
     * @param name
     * @param clazz
     * @param &lt;T&gt;
     * @return
     */
    public static &lt;T&gt; T getBean(String name,Class&lt;T&gt; clazz)&#123;
        return getApplicationContext().getBean(name, clazz);
    &#125;
&#125;
</code></pre>
<h2 id="9、参考文献-鸣谢-1"><a href="#9、参考文献-鸣谢-1" class="headerlink" title="9、参考文献 &amp; 鸣谢"></a>9、参考文献 &amp; 鸣谢</h2><ol>
<li>RedisTemplate常用方法总结(参考官方文档2.6.2)：<a target="_blank" rel="noopener" href="https://blog.csdn.net/ACE_U_005A/article/details/123158686">https://blog.csdn.net/ACE_U_005A/article/details/123158686</a></li>
<li>RedisTemplate访问Redis数据结构API大全：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/shamo89/p/8622152.html">https://www.cnblogs.com/shamo89/p/8622152.html</a></li>
<li>RedisTemplate操作Redis的相关知识点：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_45498460/article/details/120543253">https://blog.csdn.net/qq_45498460/article/details/120543253</a></li>
<li>RedisTemplate常用方法总结：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/x8QsM8WPD0DzzbxM9DntiA">https://mp.weixin.qq.com/s/x8QsM8WPD0DzzbxM9DntiA</a></li>
</ol>
<h1 id="Redis-实际使用场景"><a href="#Redis-实际使用场景" class="headerlink" title="Redis 实际使用场景"></a>Redis 实际使用场景</h1><p>在微服务和分布式兴起后，Redis 在互联网公司的应用越来越广泛，使用场景也越来越多：</p>
<ul>
<li><strong>缓存</strong>：这是 Redis 使用最多的领域，Redis 将所有的数据直接存在内存中，其访问速度远远快于如 MySQL 等需要从硬盘查询的数据库，如果将 SQL 中常用的数据写入缓存，可以极大的提高系统的性能，减缓数据库的压力。同时也可以通过 Redis 缓存实现跨进程数据的共享；</li>
<li><strong>持久化</strong>：例如：对于各个微服务组件来说，自带的 Session 机制并不能跨进程共享，如果将 Session 写入 Redis，既可以实现不同微服务进程的 Session 共享，通过 Redis 持久化到硬盘中，可以避免因服务器宕机重启等导致服务器 Session 丢失；</li>
<li><strong>分布式锁</strong>：对于进程间共享的数据，需要通过锁的方式避免脏数据的产生，可以利用 Redis 单线程的特性，实现共享数据的加锁和释放；</li>
<li><strong>发布、订阅</strong>：没错，Redis 是可以用作轻量级的消息队列的；</li>
<li><strong>更多</strong>：<ol>
<li>接口访问的限制（String）</li>
<li>分布式锁（String）</li>
<li>缓存用户的行为历史（List、Set、Hash）</li>
<li>内容点赞数量（Set）</li>
<li>排行榜（ZSet、List）</li>
<li>热销榜单（ZSet）</li>
<li>购物车（Hash）</li>
<li>用户画像标签去重（Set）</li>
</ol>
</li>
</ul>
<h1 id="Redis-Session-共享"><a href="#Redis-Session-共享" class="headerlink" title="Redis Session 共享"></a>Redis Session 共享</h1><p>1、Cookie 与 Session</p>
<ul>
<li><p>Cookie是什么？ Cookie 是一小段文本信息，伴随着用户请求和页面在 Web 服务器和浏览器之间传递。Cookie 包含每次用户访问站点时 Web 应用程序都可以读取的信息，我们可以看到在服务器写的cookie，会通过响应头Set-Cookie的方式写入到浏览器</p>
</li>
<li><p>HTTP协议是无状态的，并非TCP一样进行三次握手，对于一个浏览器发出的多次请求，WEB服务器无法区分是不是来源于同一个浏览器。所以服务器为了区分这个过程会通过一个sessionid来区分请求，而这个sessionid是怎么发送给服务端的呢。cookie相对用户是不可见的，用来保存这个sessionid是最好不过了</p>
</li>
</ul>
<p>2、Redis实现分布式集群配置过程：</p>
<ol>
<li><p>引入依赖：</p>
<pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.session&lt;/groupId&gt;
    &lt;artifactId&gt;spring-session-data-redis&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
</li>
<li><p>开启redis-session共享</p>
<pre><code class="java">/**
 * @EnableRedisHttpSession：开启redis session缓存
 * maxInactiveIntervalInSeconds：指定缓存的时间
 * key 为 spring:session:sessions:expires:+‘sessionId’的过期时间
 **/
@EnableRedisHttpSession(maxInactiveIntervalInSeconds= 50)
public class RedisConfig &#123;
&#125;
</code></pre>
</li>
<li><p>测试代码</p>
<pre><code class="java">@RestController
public class SessionController &#123;

    @RequestMapping(value = &quot;/setSession&quot;, method = RequestMethod.GET)
    public Map&lt;String, Object&gt; setSession (HttpServletRequest request)&#123;
        Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();
        request.getSession().setAttribute(&quot;request Url&quot;, request.getRequestURL());
        map.put(&quot;request Url&quot;, request.getRequestURL());
        return map;
    &#125;

    @RequestMapping(value = &quot;/getSession&quot;, method = RequestMethod.GET)
    public Object getSession (HttpServletRequest request)&#123;
        Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();
        map.put(&quot;sessionIdUrl&quot;,request.getSession().getAttribute(&quot;request Url&quot;));
        map.put(&quot;sessionId&quot;, request.getSession().getId());
        return map;
    &#125;
&#125;
</code></pre>
</li>
</ol>
<h1 id="Redis-实现分布式锁"><a href="#Redis-实现分布式锁" class="headerlink" title="Redis 实现分布式锁"></a>Redis 实现分布式锁</h1><h2 id="1、什么是分布式锁"><a href="#1、什么是分布式锁" class="headerlink" title="1、什么是分布式锁"></a>1、什么是分布式锁</h2><p>1、什么是分布式锁</p>
<p>分布式锁其实就是，控制分布式系统不同进程共同访问共享资源的一种锁的实现。如果不同的系统或同一个系统的不同主机之间共享了某个临界资源，往往需要互斥来防止彼此干扰，以保证一致性。我们先来看下，一把靠谱的分布式锁应该有哪些特征：</p>
<ul>
<li><strong>「互斥性」</strong>: 任意时刻，只有一个客户端能持有锁</li>
<li><strong>「锁超时释放」</strong>：持有锁超时，可以释放，防止不必要的资源浪费，也可以防止死锁</li>
<li><strong>「可重入性」</strong>:一个线程如果获取了锁之后,可以再次对其请求加锁</li>
<li><strong>「高性能和高可用」</strong>：加锁和解锁需要开销尽可能低，同时也要保证高可用，避免分布式锁失效</li>
<li><strong>「安全性」</strong>：锁只能被持有的客户端删除，不能被其他客户端删除</li>
</ul>
<p>2、分布式锁实现方案</p>
<p>日常开发中，秒杀下单、抢红包等等业务场景，都需要用到分布式锁。而Redis非常适合作为分布式锁使用。本文将分七个方案展开，跟大家探讨Redis分布式锁的正确使用方式。如果有不正确的地方，欢迎大家指出哈，一起学习一起进步。</p>
<ul>
<li>方案一：SETNX + EXPIRE</li>
<li>方案二：SETNX + value值是（系统时间+过期时间）</li>
<li>方案三：使用Lua脚本(包含SETNX + EXPIRE两条指令)</li>
<li>方案四：SET的扩展命令（SET EX PX NX）</li>
<li>方案五：SET EX PX NX  + 校验唯一随机值,再释放锁</li>
<li>方案六：Redisson 分布式锁（各种类别的锁都有）</li>
</ul>
<h2 id="2、方案一：SETNX-EXPIRE"><a href="#2、方案一：SETNX-EXPIRE" class="headerlink" title="2、方案一：SETNX + EXPIRE"></a>2、方案一：SETNX + EXPIRE</h2><blockquote>
<p>Redis分布式锁方案一：SETNX + EXPIRE</p>
</blockquote>
<p>SETNX 是 SET IF NOT EXISTS 的简写。日常命令格式是 SETNX key value，如果 key 不存在，则 SETNX 成功返回 1，如果这个key已经存在了，则返回 0。</p>
<p>setnx+ expire 命令：即先用 setnx 来抢锁，如果抢到之后，再用 expire 给锁设置一个过期时间，防止锁忘记了释放。</p>
<p>Java + Jedis 方式实现，伪代码如下：</p>
<pre><code class="java">Jedis jedis = new Jedis(&quot;127.0.0.1&quot;);
String key_resource_id = &quot;&quot;; // 锁的key
String lock_value = &quot;&quot;; // value设置任意值
if (jedis.setnx(key_resource_id, lock_value) == 1) &#123; // 加锁
    jedis.expire(key_resource_id, 100); // 设置过期时间
    try &#123;
        // do something 业务请求
    &#125; finally &#123;
        jedis.del(key_resource_id); // 释放锁
    &#125;
&#125;
</code></pre>
<p>但是这个方案中，setnx 和 expire 两个命令分开了，<strong>「不是原子操作」</strong>。如果执行完setnx加锁，正要执行expire设置过期时间时，进程crash或者要重启维护了，那么这个锁就“长生不老”了，<strong>「别的线程永远获取不到锁啦」</strong>。</p>
<hr>
<p>SpringBoot + RedisTemplate 方式实现，伪代码如下：</p>
<pre><code class="java">@Autowired
private RedisTemplate redisTemplate;
@SneakyThrows
public List&lt;Object&gt; getXxxWithRedisLock() &#123;
    Boolean lock = redisTemplate.opsForValue().setIfAbsent(&quot;lock&quot;, &quot;111&quot;);
    if (lock) &#123;
        // 设置过期时间
        redisTemplate.expire(&quot;lock&quot;, 30, TimeUnit.SECONDS);
        // do something 业务请求
        // 释放锁
        redisTemplate.delete(&quot;lock&quot;);
        return Collections.emptyList();
    &#125; else &#123;
        // 获取不到锁, 2秒后重试
        Thread.sleep(2000);
        return getXxxWithRedisLock();
    &#125;
&#125;
</code></pre>
<p><strong>问题：</strong> setnx 和 expire 两个命令分开了，<strong>「不是原子操作」</strong>。setnx设置好，正要去设置过期时间，宕机。又死锁了。</p>
<p><strong>解决：</strong> 设置过期时间和占位必须是原子的。redis支持使用setnx ex命令、支持lua脚本</p>
<h2 id="3、方案二：SETNX-VALUE-存放过期时间"><a href="#3、方案二：SETNX-VALUE-存放过期时间" class="headerlink" title="3、方案二：SETNX + VALUE 存放过期时间"></a>3、方案二：SETNX + VALUE 存放过期时间</h2><blockquote>
<p>Redis分布式锁方案二：SETNX + Value值是：系统时间+过期时间</p>
</blockquote>
<p>为了解决方案一，可以把过期时间放到 setnx 的 value 值里面。如果加锁失败，再拿出 value 值校验一下即可。加锁代码如下：</p>
<pre><code class="java">Jedis jedis = new Jedis(&quot;127.0.0.1&quot;);
String key_resource_id = &quot;&quot;;

// 系统时间 + 设置的过期时间
long expires = System.currentTimeMillis() + expireTime;
String expiresStr = String.valueOf(expires);

// 如果当前锁不存在，返回加锁成功
if (jedis.setnx(key_resource_id, expiresStr) == 1) &#123;
    return true;
&#125; 
// 如果锁已经存在，获取锁的过期时间
String currentValueStr = jedis.get(key_resource_id);

// 如果获取到的过期时间，小于系统当前时间，表示已经过期
if (currentValueStr != null &amp;&amp; Long.parseLong(currentValueStr) &lt; System.currentTimeMillis()) &#123;

    // 锁已过期，获取上一个锁的过期时间，并设置现在锁的过期时间（不了解redis的getSet命令的小伙伴，可以去官网看下哈）
    String oldValueStr = jedis.getSet(key_resource_id, expiresStr);

    if (oldValueStr != null &amp;&amp; oldValueStr.equals(currentValueStr)) &#123;
        // 考虑多线程并发的情况，只有一个线程的设置值和当前值相同，它才可以加锁
        return true;
    &#125;
&#125;

// 其他情况，均返回加锁失败
return false;
</code></pre>
<p>这个方案的优点是，巧妙移除expire单独设置过期时间的操作，把<strong>「过期时间放到setnx的value值」</strong>里面来。解决了方案一发生异常，锁得不到释放的问题。但是这个方案还有别的缺点：</p>
<ul>
<li>过期时间是客户端自己生成的（System.currentTimeMillis()是当前系统的时间）必须要求分布式环境下，每个客户端的时间必须同步</li>
<li>如果锁过期的时候，并发多个客户端同时请求过来，都执行jedis.getSet()，最终只能有一个客户端加锁成功，但是该客户端锁的过期时间，可能被别的客户端覆盖</li>
<li>该锁没有保存持有者的唯一标识，可能被别的客户端释放&#x2F;解锁</li>
</ul>
<h2 id="4、方案三：使用-Lua-脚本实现加锁"><a href="#4、方案三：使用-Lua-脚本实现加锁" class="headerlink" title="4、方案三：使用 Lua 脚本实现加锁"></a>4、方案三：使用 Lua 脚本实现加锁</h2><blockquote>
<p>Redis分布式锁方案三：使用Lua脚本（包含SETNX + EXPIRE两条指令）</p>
</blockquote>
<p>我们还可以使用Lua脚本来保证原子性（包含setnx和expire两条指令），lua脚本如下：</p>
<pre><code class="lua">if redis.call(&#39;setnx&#39;,KEYS[1],ARGV[1]) == 1 then
    redis.call(&#39;expire&#39;,KEYS[1],ARGV[2])
else
    return 0
end;
</code></pre>
<p>加锁代码如下：</p>
<pre><code class="java">String lua_scripts = &quot;if redis.call(&#39;setnx&#39;,KEYS[1],ARGV[1]) == 1 then&quot; +
    &quot; redis.call(&#39;expire&#39;,KEYS[1],ARGV[2]) return 1 else return 0 end&quot;;   
Object result = jedis.eval(lua_scripts, Collections.singletonList(key_resource_id), Collections.singletonList(values));
// 判断是否成功
return result.equals(1L);
</code></pre>
<h2 id="5、方案四：SET-扩展命令-实现加锁"><a href="#5、方案四：SET-扩展命令-实现加锁" class="headerlink" title="5、方案四：SET 扩展命令 实现加锁"></a>5、方案四：SET 扩展命令 实现加锁</h2><blockquote>
<p>Redis分布式锁方案方案四：SET的扩展命令（SET EX PX NX）</p>
</blockquote>
<p>除了使用，使用Lua脚本，保证 SETNX + EXPIRE 两条指令的原子性，我们还可以用Redis的SET指令扩展参数！它也是原子性的！</p>
<pre><code class="shell">SET key value[EX seconds][PX milliseconds][NX|XX]
</code></pre>
<ul>
<li>NX：表示key不存在的时候，才能set成功，也即保证只有第一个客户端请求才能获得锁，而其他客户端请求只能等其释放锁，才能获取</li>
<li>EX seconds：设定key的过期时间，时间单位是秒</li>
<li>PX milliseconds：设定key的过期时间，单位为毫秒</li>
<li>XX：仅当key存在时设置值</li>
</ul>
<p>Java + Jedis 伪代码如下：</p>
<pre><code class="java">Jedis jedis = new Jedis(&quot;127.0.0.1&quot;);
String key_resource_id = &quot;&quot;;
String lock_value = &quot;&quot;;
// 加锁
if (&quot;1&quot;.equals(jedis.set(key_resource_id, lock_value, SetParams.setParams().nx().ex(100)))) &#123;
    try &#123;
        // do something 业务处理
    &#125; finally &#123;
        jedis.del(key_resource_id); // 释放锁
    &#125;
&#125;
</code></pre>
<p>但是呢，这个方案还是可能存在问题：</p>
<ul>
<li>问题一：<strong>「锁过期释放了，业务还没执行完」</strong>。假设线程a获取锁成功，一直在执行临界区的代码。但是100s过去后，它还没执行完。但是，这时候锁已经过期了，此时线程b又请求过来。显然线程b就可以获得锁成功，也开始执行临界区的代码。那么问题就来了，临界区的业务代码都不是严格串行执行的啦。</li>
<li>问题二：<strong>「锁被别的线程误删」</strong>。假设线程a执行完后，去释放锁。但是它不知道当前的锁可能是线程b持有的（线程a去释放锁时，有可能过期时间已经到了，此时线程b进来占有了锁）。那线程a就把线程b的锁释放掉了，但是线程b临界区业务代码可能都还没执行完呢。</li>
</ul>
<hr>
<p>SpringBoot + RedisTemplate 代码实现：</p>
<pre><code class="java">@Autowired
private RedisTemplate redisTemplate;
@SneakyThrows
public List&lt;Object&gt; getXxxWithRedisLock() &#123;
    // 加锁的同时设置过期时间，二者是原子性操作
    Boolean lock = redisTemplate.opsForValue().setIfAbsent(&quot;lock&quot;, &quot;1111&quot;,5, TimeUnit.SECONDS);
    if (lock) &#123;
        // do something 业务请求
        // 模拟超长的业务执行时间
        Thread.sleep(6000);
        redisTemplate.delete(&quot;lock&quot;);
        return Collections.emptyList();
    &#125;else &#123;
        // 获取不到锁, 2秒后重试
        Thread.sleep(2000);
        return getXxxWithRedisLock();
    &#125;
&#125;
</code></pre>
<p><strong>问题：</strong>删除锁直接删除？？？如果由于业务时间很长，锁自己过期了，我们直接删除，有可能把别人正在持有的锁删除了。</p>
<p><strong>解决：</strong>占锁的时候，值指定为uuid，每个人匹配是自己的锁才删除。</p>
<h2 id="6、方案五：SET-扩展命令-校验唯一值"><a href="#6、方案五：SET-扩展命令-校验唯一值" class="headerlink" title="6、方案五：SET 扩展命令  + 校验唯一值"></a>6、方案五：SET 扩展命令  + 校验唯一值</h2><blockquote>
<p>Redis分布式锁方案五：SET EX PX NX  + 校验唯一随机值，再删除锁</p>
</blockquote>
<p>既然锁可能被别的线程误删，那我们给value值设置一个标记当前线程唯一的随机数，在删除的时候，校验一下，不就OK了嘛。伪代码如下：</p>
<pre><code class="java">public static final String UNI_REQUEST_ID = UUID.randomUUID().toString();
public static void main(String[] args) &#123;
    Jedis jedis = new Jedis(&quot;127.0.0.1&quot;);
    String key_resource_id = &quot;&quot;;
    String lock_value = UNI_REQUEST_ID;
    // 加锁
    if (&quot;1&quot;.equals(jedis.set(key_resource_id, lock_value, SetParams.setParams().nx().ex(100)))) &#123;
        try &#123;
            // do something 业务处理
        &#125; finally &#123;
            // 判断是不是当前线程加的锁,是才释放
            if (UNI_REQUEST_ID.equals(jedis.get(key_resource_id))) &#123;
                jedis.del(key_resource_id); // 释放锁
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<p>在这里，<strong>「判断是不是当前线程加的锁」</strong>和<strong>「释放锁」</strong>不是一个原子操作。如果调用jedis.del()释放锁的时候，可能这把锁已经不属于当前客户端，会解除他人加的锁。</p>
<pre><code class="java">// 如下判断是释放锁是两个步骤,非原子操作
// 判断是不是当前线程加的锁,是才释放
if (UNI_REQUEST_ID.equals(jedis.get(key_resource_id))) &#123;
    jedis.del(key_resource_id); // 释放锁
&#125;
</code></pre>
<p>为了更严谨，一般也是用lua脚本代替。lua脚本如下：</p>
<pre><code class="lua">if redis.call(&#39;get&#39;,KEYS[1]) == ARGV[1] then 
    return redis.call(&#39;del&#39;,KEYS[1]) 
else
    return 0
end;
</code></pre>
<p>这种方式比较不错了，一般情况下，已经可以使用这种实现方式。但是还是存在：<strong>锁过期释放了，业务还没执行完的问题</strong>。</p>
<hr>
<p>SpringBoot + RedisTemplate 代码实现：</p>
<pre><code class="java">@Autowired
private RedisTemplate redisTemplate;
@SneakyThrows
public List&lt;Object&gt; getXxxWithRedisLock() &#123;
    String uuid = UUID.randomUUID().toString();
    ValueOperations&lt;String, String&gt; ops = redisTemplate.opsForValue();
    // 为当前锁设置唯一的uuid，只有当uuid相同时才会进行删除锁的操作
    Boolean lock = ops.setIfAbsent(&quot;lock&quot;, uuid, 5, TimeUnit.SECONDS);
    if (lock) &#123;
        // do something 业务请求
        String lockValue = ops.get(&quot;lock&quot;);
        if (lockValue.equals(uuid)) &#123;
            Thread.sleep(6000);
            redisTemplate.delete(&quot;lock&quot;);
        &#125;
        return Collections.emptyList();
    &#125; else &#123;
        // 获取不到锁, 2秒后重试
        Thread.sleep(2000);
        return getXxxWithRedisLock();
    &#125;
&#125;
</code></pre>
<p><strong>问题：</strong> 如果正好判断是当前值，正要删除锁的时候，锁已经过期，别人已经设置到了新的值。那么我们删除的是别人的锁</p>
<p><strong>解决：</strong> 删除锁必须保证原子性。使用redis+Lua脚本完成</p>
<pre><code class="java">@Autowired
private RedisTemplate redisTemplate;
@SneakyThrows
public List&lt;Object&gt; getXxxWithRedisLock() &#123;
    String uuid = UUID.randomUUID().toString();
    ValueOperations&lt;String, String&gt; ops = redisTemplate.opsForValue();
    // 为当前锁设置唯一的uuid，只有当uuid相同时才会进行删除锁的操作
    Boolean lock = ops.setIfAbsent(&quot;lock&quot;, uuid, 5, TimeUnit.SECONDS);
    if (lock) &#123;
        // do something 业务请求
        String lockValue = ops.get(&quot;lock&quot;);
        String script = &quot;if redis.call(&#39;get&#39;,KEYS[1]) == ARGV[1] then\n&quot; +
            &quot;    return redis.call(&#39;del&#39;,KEYS[1])\n&quot; +
            &quot;else\n&quot; +
            &quot;    return 0\n&quot; +
            &quot;end&quot;;
        redisTemplate.execute(new DefaultRedisScript&lt;&gt;(script, Long.class), Arrays.asList(&quot;lock&quot;), lockValue);
        return Collections.emptyList();
    &#125; else &#123;
        // 获取不到锁, 2秒后重试
        Thread.sleep(2000);
        return getXxxWithRedisLock();
    &#125;
&#125;
</code></pre>
<p>lua脚本如下：unlock.lua</p>
<pre><code class="lua">if redis.call(&#39;get&#39;,KEYS[1]) == ARGV[1] then
    return redis.call(&#39;del&#39;,KEYS[1])
else
    return 0
end;
</code></pre>
<p>读取lua脚本工具类：</p>
<pre><code class="java">// 方式一:自定义加载Lua脚本工具类
public Boolean unLock(String key, String value,String unLuaPath) throws IOException &#123;
    DefaultRedisScript&lt;Boolean&gt; lockScript = new DefaultRedisScript&lt;&gt;();
    ClassPathResource resource = new ClassPathResource(luaPath);
    ResourceScriptSource source = new ResourceScriptSource(resource);
    lockScript.setScriptSource(source);
    lockScript.setResultType(Boolean.class);
    Boolean result = (Boolean) redisTemplate.execute(lockScript, Arrays.asList(key, value));
    return result;
&#125;
</code></pre>
<p>保证加锁【占位+过期时间】和删除锁【判断+删除】的原子性。更难的事情，锁的自动续期【自动续期建议使用Redisson的看门狗】</p>
<h2 id="7、方案六：Redisson-实现分布式锁"><a href="#7、方案六：Redisson-实现分布式锁" class="headerlink" title="7、方案六：Redisson 实现分布式锁"></a>7、方案六：Redisson 实现分布式锁</h2><p>官方文档：<a target="_blank" rel="noopener" href="https://github.com/redisson/redisson/wiki/8.-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%92%8C%E5%90%8C%E6%AD%A5%E5%99%A8">https://github.com/redisson/redisson/wiki/8.-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%92%8C%E5%90%8C%E6%AD%A5%E5%99%A8</a></p>
<p>对于可能存在<strong>锁过期释放，业务没执行完</strong>的问题。我们可以稍微把锁过期时间设置长一些，大于正常业务处理时间就好啦。如果你觉得不是很稳，还可以给获得锁的线程，开启一个定时守护线程，每隔一段时间检查锁是否还存在，存在则对锁的过期时间延长，防止锁过期提前释放。</p>
<p>当前开源框架Redisson解决了这个问题，只要线程一加锁成功，就会启动一个watch dog看门狗，它是一个后台线程，会每隔10秒检查一下，如果线程1还持有锁，那么就会不断的延长锁key的生存时间。因此，Redisson就是使用watch dog解决了<strong>锁过期释放，业务没执行完问题</strong>。</p>
<p><img src="/Redis-%E6%9C%80%E5%85%A8%E5%AE%9E%E6%88%98.assets/image-20241017215310006.png"></p>
<p><strong>Redisson 分布式锁</strong>：Redisson实现了Redis文档中提到像分布式锁Lock这样的更高阶应用场景。事实上Redisson并没有不止步于此，在分布式锁的基础上还提供了联锁（MultiLock），读写锁（ReadWriteLock），公平锁（Fair Lock），红锁（RedLock），信号量（Semaphore），可过期性信号量（PermitExpirableSemaphore）和闭锁（CountDownLatch）这些实际当中对多线程高并发应用至关重要的基本部件。正是通过实现基于Redis的高阶应用方案，使Redisson成为构建分布式系统的重要工具。</p>
<p>这里没有继续探讨，感兴趣的同学可以查看官方文档。或者参考下面参考文献中提到其他大神的文章。</p>
<h2 id="8、Redis-分布式锁实践（Lua脚本版）"><a href="#8、Redis-分布式锁实践（Lua脚本版）" class="headerlink" title="8、Redis 分布式锁实践（Lua脚本版）"></a>8、Redis 分布式锁实践（Lua脚本版）</h2><blockquote>
<p>基于Redis实现分布式锁（lua脚本版）<a target="_blank" rel="noopener" href="https://blog.csdn.net/WU4566285/article/details/116622270">https://blog.csdn.net/WU4566285/article/details/116622270</a></p>
</blockquote>
<p>以下代码实现了基于redis中间件的分布式锁。加锁的过程中为了保障setnx（设置KEY）和expire（设置超时时间）尽可能在一个事务中，使用到了lua脚本的方式，将需要完成的指令一并提交到redis中。</p>
<h3 id="1、加锁解锁LUA脚本"><a href="#1、加锁解锁LUA脚本" class="headerlink" title="1、加锁解锁LUA脚本"></a>1、加锁解锁LUA脚本</h3><p>加锁脚本：lock.lua</p>
<pre><code class="lua">if redis.call(&#39;setnx&#39;,KEYS[1],ARGV[1]) == 1 then
    return redis.call(&#39;expire&#39;,KEYS[1],ARGV[2])
else
    return 0
end
</code></pre>
<p>解锁脚本：unlock.lua</p>
<pre><code class="lua">if redis.call(&quot;exists&quot;,KEYS[1]) == 0 then
    return 1
end

if redis.call(&#39;get&#39;,KEYS[1]) == ARGV[1] then
    return redis.call(&#39;del&#39;,KEYS[1])
else
    return 0
end
</code></pre>
<pre><code class="java">// 注意脚本中KYS[l］和KYS[2］ 的写法，它们代表客户端传递的第一个键和第二个键，
// 而ARGV[l］和ARGV[2］则表示客户端传递的第一个和第二个参数
</code></pre>
<h3 id="2、RedisConfig-java"><a href="#2、RedisConfig-java" class="headerlink" title="2、RedisConfig.java"></a>2、RedisConfig.java</h3><pre><code class="java">package com.xyz.redis.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.core.io.ClassPathResource;
import org.springframework.data.redis.connection.RedisConnectionFactory;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.core.script.DefaultRedisScript;
import org.springframework.data.redis.core.script.RedisScript;
import org.springframework.data.redis.serializer.GenericJackson2JsonRedisSerializer;
import org.springframework.data.redis.serializer.StringRedisSerializer;
import org.springframework.scripting.support.ResourceScriptSource;

@Configuration
public class RedisConfig &#123;

    @Bean
    public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory redisConnectionFactory) &#123;
        RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;&gt;();
        template.setConnectionFactory(redisConnectionFactory);
        template.setKeySerializer(new StringRedisSerializer());
        template.setValueSerializer(new GenericJackson2JsonRedisSerializer());
        template.afterPropertiesSet();
        return template;
    &#125;

    @Bean(name = &quot;lock&quot;)
    public RedisScript&lt;Boolean&gt; lock() &#123;
        DefaultRedisScript&lt;Boolean&gt; script = new DefaultRedisScript&lt;&gt;();
        // lua文件存放在resources目录下的redis文件夹内
        script.setScriptSource(new ResourceScriptSource(new ClassPathResource(&quot;redis/lock.lua&quot;)));
        script.setResultType(Boolean.class); // 返回类型
        return script;
    &#125;

    @Bean(name = &quot;unlock&quot;)
    public RedisScript&lt;Boolean&gt; unlock() &#123;
        DefaultRedisScript&lt;Boolean&gt; script = new DefaultRedisScript&lt;&gt;();
        // lua文件存放在resources目录下的redis文件夹内
        script.setScriptSource(new ResourceScriptSource(new ClassPathResource(&quot;redis/unlock.lua&quot;)));
        script.setResultType(Boolean.class); // 返回类型
        return script;
    &#125;
&#125;
</code></pre>
<h3 id="3、RedisLockController-java"><a href="#3、RedisLockController-java" class="headerlink" title="3、RedisLockController.java"></a>3、RedisLockController.java</h3><pre><code class="java">package com.xyz.controller;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.core.script.RedisScript;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RestController;
import java.util.Arrays;

@RestController
public class RedisLockController &#123;
    @Autowired
    private RedisTemplate&lt;String, Object&gt; redisTemplate;
    @Autowired
    private RedisScript&lt;Boolean&gt; lock;
    @Autowired
    private RedisScript&lt;Boolean&gt; unlock;

    @GetMapping(value = &quot;/lock/&#123;key&#125;/&#123;uid&#125;/&#123;expire&#125;&quot;)
    public Boolean lock(@PathVariable(&quot;key&quot;) String key,
                        @PathVariable(&quot;uid&quot;) String uid,
                        @PathVariable(&quot;expire&quot;) Integer expire) &#123;
        // 调用lua脚本并执行
        Boolean result = redisTemplate.execute(lock, Arrays.asList(key), uid, expire);
        System.out.println(&quot;lock==&quot; + result);
        return result;
    &#125;

    @GetMapping(value = &quot;/unlock/&#123;key&#125;/&#123;uid&#125;&quot;)
    public Boolean unlock(@PathVariable(&quot;key&quot;) String key,
                          @PathVariable(&quot;uid&quot;) String uid) &#123;
        // 调用lua脚本并执行
        Boolean result = redisTemplate.execute(unlock, Arrays.asList(key), uid);
        System.out.println(&quot;unlock==&quot; + result);
        return result;
    &#125;
&#125;
</code></pre>
<h3 id="4、分布式锁测试效果"><a href="#4、分布式锁测试效果" class="headerlink" title="4、分布式锁测试效果"></a>4、分布式锁测试效果</h3><p>key123为key，thread12345为value标识锁的主人，300为该锁的超时时间（单位默认为秒）</p>
<ul>
<li>加锁（自己）：锁主人为thread12345：<a target="_blank" rel="noopener" href="http://127.0.0.1:8080/redis/lock/key123/thread12345/300">http://127.0.0.1:8080/redis/lock/key123/thread12345/300</a></li>
<li>解锁（他人）：解锁人为thread123456：<a target="_blank" rel="noopener" href="http://127.0.0.1:8080/redis/unlock/key123/thread123456">http://127.0.0.1:8080/redis/unlock/key123/thread123456</a></li>
<li>解锁（自己）：解锁人为thread12345：<a target="_blank" rel="noopener" href="http://127.0.0.1:8080/redis/unlock/key123/thread12345">http://127.0.0.1:8080/redis/unlock/key123/thread12345</a></li>
</ul>
<p>1、自己加锁，他人解锁</p>
<pre><code class="shell"># 自己加锁
C:\Users\lsx&gt;curl http://127.0.0.1:8080/redis/lock/key123/thread12345/300
true
# 其他人解锁
C:\Users\lsx&gt;curl http://127.0.0.1:8080/redis/unlock/key123/thread123456
false
</code></pre>
<blockquote>
<p>thread12345加的锁，thread123456是解不了的，只有等thread12345自己解锁或者锁的超时时间过期</p>
</blockquote>
<p>2、自己加锁，自己解锁</p>
<pre><code class="shell"># 未解锁情况下,自己给自己再次加锁,同样显示失败
C:\Users\lsx&gt;curl http://127.0.0.1:8080/redis/lock/key123/thread12345/300
false
# 自己给自己解锁,显示解锁成功,这样其他人就可以获取锁了
C:\Users\lsx&gt;curl http://127.0.0.1:8080/redis/unlock/key123/thread12345
true
</code></pre>
<blockquote>
<p>thread12345加的锁，thread12345自己随时可以解锁，也可以等锁的超时时间过期</p>
</blockquote>
<h3 id="5、Redis-Lua-分布式锁总结"><a href="#5、Redis-Lua-分布式锁总结" class="headerlink" title="5、Redis Lua 分布式锁总结"></a>5、Redis Lua 分布式锁总结</h3><ul>
<li>使用Redis锁，会有业务未执行完，锁过期的问题，也就是锁不具有<strong>可重入性</strong>的特点</li>
<li>使用Redis锁，在尝试获取锁的时候，是非阻塞的，不满足在一定期限内不断尝试获取锁的场景</li>
<li>以上两点，都可以采用Redisson锁解决</li>
</ul>
<h2 id="9、参考文献-鸣谢-2"><a href="#9、参考文献-鸣谢-2" class="headerlink" title="9、参考文献 &amp; 鸣谢"></a>9、参考文献 &amp; 鸣谢</h2><p><strong>Redis 原生实现分布式锁：</strong></p>
<ul>
<li>redisTemplate分布式锁演变、redission分布式锁实现！<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/qcst9ZqSwSi-IPOnr3cgzA">https://mp.weixin.qq.com/s/qcst9ZqSwSi-IPOnr3cgzA</a></li>
<li>Redis实现分布式锁的7种方案，及正确使用姿势！<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/enKKnPy0t-J5b7vZvuUeAA">https://mp.weixin.qq.com/s/enKKnPy0t-J5b7vZvuUeAA</a></li>
<li>分布式锁的 3 种实现方案！<a target="_blank" rel="noopener" href="https://blog.csdn.net/sufu1065/article/details/124114052">https://blog.csdn.net/sufu1065/article/details/124114052</a></li>
<li>Redis分布式锁：<a target="_blank" rel="noopener" href="https://blog.piaoruiqing.com/2019/05/19/redis%e5%88%86%e5%b8%83%e5%bc%8f%e9%94%81/">https://blog.piaoruiqing.com/2019/05/19/redis%e5%88%86%e5%b8%83%e5%bc%8f%e9%94%81/</a></li>
</ul>
<p><strong>Redisson 分布式锁框架：</strong></p>
<ul>
<li>分布式锁中的王者方案 - Redisson：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/ZN2xhTrjH-GVNKapWGXTZA">https://mp.weixin.qq.com/s/ZN2xhTrjH-GVNKapWGXTZA</a></li>
<li>Redisson分布式锁：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/jklixin/p/13212864.html">https://www.cnblogs.com/jklixin/p/13212864.html</a></li>
</ul>
<h1 id="Redis-实现访问限流"><a href="#Redis-实现访问限流" class="headerlink" title="Redis 实现访问限流"></a>Redis 实现访问限流</h1><p>利用分布式计数器限制某一路径在一段时间内的访问次数，十秒内同一个API超过5次就返回报错。</p>
<p>1、拦截器：CustomInterceptor.java</p>
<pre><code class="java">package com.xyz.config;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.redis.core.StringRedisTemplate;
import org.springframework.stereotype.Component;
import org.springframework.web.servlet.HandlerInterceptor;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.time.Duration;
import java.util.Objects;

/**
 * 10秒内访问次数超过5次就报错
 */
@Component
public class CustomInterceptor implements HandlerInterceptor &#123;
    @Autowired
    private StringRedisTemplate redisTemplate;
    @Override
    public boolean preHandle(HttpServletRequest request,
                             HttpServletResponse response,
                             Object handler) throws Exception &#123;
        // 获取访问的URI作为Redis的key
        String key = request.getRequestURI();
        // 给value设置10秒过期时间
        if (redisTemplate.boundValueOps(key).get() == null) &#123;
            redisTemplate.boundValueOps(key).set(&quot;1&quot;, Duration.ofSeconds(10L));
            return true;
        &#125; else &#123;
            redisTemplate.opsForValue().increment(key);
        &#125;
        // 访问次数超过5次就报错
        if (Integer.parseInt(Objects.requireNonNull(redisTemplate.opsForValue().get(key))) &gt; 5) &#123;
            response.sendRedirect(&quot;/error&quot;);
        &#125;
        return true;
    &#125;
&#125;
</code></pre>
<p>2、注册拦截器：WebConfig.java</p>
<pre><code class="java">package com.xyz.config;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.InterceptorRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration
public class WebConfig implements WebMvcConfigurer &#123;
    @Autowired
    private CustomInterceptor customInterceptor;
    @Override
    public void addInterceptors(InterceptorRegistry registry) &#123;
        registry.addInterceptor(customInterceptor).addPathPatterns(&quot;/**&quot;);
    &#125;
&#125;
</code></pre>
<p>3、控制层测试代码：</p>
<pre><code class="java">@RestController
public class HelloController &#123;
    @GetMapping(value = &quot;/api&quot;)
    public String api() &#123;
        return &quot;success&quot;;
    &#125;
    @GetMapping(value = &quot;/error&quot;)
    public String error() &#123;
        return &quot;error&quot;;
    &#125;
&#125;
</code></pre>
<p>4、使用测试：10秒访问五次后，重定向到”&#x2F;error”路径</p>
<h1 id="Redis-热点信息查询"><a href="#Redis-热点信息查询" class="headerlink" title="Redis 热点信息查询"></a>Redis 热点信息查询</h1><p>Zset的score存储路径访问次数，进行热门查询排序。</p>
<p>1、拦截器：CustomInterceptor.java</p>
<pre><code class="java">package com.xyz.config;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.redis.core.StringRedisTemplate;
import org.springframework.stereotype.Component;
import org.springframework.web.servlet.HandlerInterceptor;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

@Component
public class CustomInterceptor implements HandlerInterceptor &#123;
    @Autowired
    private StringRedisTemplate redisTemplate;

    @Override
    public boolean preHandle(HttpServletRequest request,
                             HttpServletResponse response,
                             Object handler) &#123;
        String key = request.getRequestURI();
        if (redisTemplate.boundZSetOps(&quot;popular_queries&quot;).rank(key) == null) &#123;
            // 第一次进入,给这个key设置1
            redisTemplate.opsForZSet().add(&quot;popular_queries&quot;, key, 1L);
        &#125; else &#123;
            // 每次进入就+1
            redisTemplate.opsForZSet().incrementScore(&quot;popular_queries&quot;, key, 1L);
        &#125;
        return true;
    &#125;
&#125;
</code></pre>
<p>2、注册拦截器：WebConfig.java</p>
<pre><code class="java">package com.xyz.config;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.InterceptorRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration
public class WebConfig implements WebMvcConfigurer &#123;
    @Autowired
    private CustomInterceptor interceptor;
    @Override
    public void addInterceptors(InterceptorRegistry registry) &#123;
        registry.addInterceptor(interceptor).addPathPatterns(&quot;/**&quot;);
    &#125;
&#125;
</code></pre>
<p>3、控制层测试代码</p>
<pre><code class="java">package com.xyz;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.redis.core.StringRedisTemplate;
import org.springframework.data.redis.core.ZSetOperations;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.Set;

@RestController
public class HelloController &#123;
 
    @Autowired
    private StringRedisTemplate redisTemplate;
 
    @RequestMapping(&quot;/hello1/&#123;id&#125;&quot;)
    public String hello(@PathVariable(&quot;id&quot;) Integer id)&#123;
        System.out.println(id);
        return &quot;hello world1&quot;;
    &#125;
 
    @RequestMapping(&quot;/hello2/&#123;id&#125;&quot;)
    public String hello2(@PathVariable(&quot;id&quot;) Integer id)&#123;
        System.out.println(id);
        return &quot;hello world2&quot;;
    &#125;

    @RequestMapping(&quot;/get&quot;)
    public String get()&#123;
        Set&lt;ZSetOperations.TypedTuple&lt;String&gt;&gt; set=redisTemplate.opsForZSet().reverseRangeWithScores(&quot;popular_queries&quot;,0L,10L);
        assert set != null;
        for (ZSetOperations.TypedTuple&lt;String&gt; i : set) &#123;
            System.out.println(i.getValue() + &quot;  &quot; + i.getScore());
        &#125;
        return &quot;success&quot;;
    &#125;
&#125;
</code></pre>
<p>4、测试接口调用：&#x2F;hello1&#x2F;1：5次、&#x2F;hello1&#x2F;2：2次、&#x2F;hello1&#x2F;3：3次、&#x2F;hello2&#x2F;1：1次、&#x2F;hello2&#x2F;2：2次、&#x2F;hello2&#x2F;3、3次</p>
<p>5、控制台输出</p>
<pre><code>/hello1/1  5.0
/hello2/3  3.0
/hello1/3  3.0
/hello2/2  2.0
/hello1/2  2.0
/hello2/1  1.0
/hello/1  1.0
/get  1.0
/error  1.0
</code></pre>
<h1 id="Redis-遍历所有的键"><a href="#Redis-遍历所有的键" class="headerlink" title="Redis 遍历所有的键"></a>Redis 遍历所有的键</h1><p>如果键的数量很多，keys遍历会造成后续命令阻塞，可使用scan命令遍历键。</p>
<p>1、相关类与接口</p>
<ul>
<li><p>RedisCallback：扫描调用的回调接口</p>
<pre><code class="java">public interface RedisCallback&lt;T&gt; &#123;
    @Nullable
    T doInRedis(RedisConnection var1) throws DataAccessException;
&#125;
  
/**************************/
// RedisConnection
public interface RedisConnection extends RedisCommands &#123;
&#125;

/*************************/
// RedisCommands
public interface RedisCommands extends RedisKeyCommands, RedisStringCommands, RedisListCommands, RedisSetCommands, RedisZSetCommands, RedisHashCommands, RedisTxCommands, RedisPubSubCommands, RedisConnectionCommands, RedisServerCommands, RedisScriptingCommands, RedisGeoCommands, RedisHyperLogLogCommands &#123;
    @Nullable
    Object execute(String var1, byte[]... var2);
&#125;

/**********************/
// RedisKeyCommands
public interface RedisKeyCommands &#123;
    Cursor&lt;byte[]&gt; scan(ScanOptions var1);  //调用该方法执行键的扫描操作
    // 。。。。
&#125;
</code></pre>
</li>
<li><p>ScanOptions：设置扫描返回数量、扫描通配符</p>
<pre><code class="java">public class ScanOptions &#123;
    public static ScanOptions NONE = new ScanOptions((Long)null, (String)null);
    @Nullable
    private final Long count;  // 每次最多返回的数量
    @Nullable
    private final String pattern;  // 通配符模式
 
    private ScanOptions(@Nullable Long count, @Nullable String pattern) &#123;
        this.count = count;
        this.pattern = pattern;
    &#125;
 
    // 返回扫描条件构造器
    public static ScanOptions.ScanOptionsBuilder scanOptions() &#123;
        return new ScanOptions.ScanOptionsBuilder();
    &#125;
 
    public Long getCount() &#123;&#125;
    public String getPattern() &#123;&#125;
    public String toOptionString() &#123;&#125;
 
/**************************/
    // 内部类
    public static class ScanOptionsBuilder &#123;
        @Nullable
        private Long count;
        @Nullable
        private String pattern;
 
        public ScanOptionsBuilder() &#123;&#125;
        public ScanOptions.ScanOptionsBuilder count(long count) &#123;] // 设置每次最多返回的数量
        public ScanOptions.ScanOptionsBuilder match(String pattern) &#123;&#125;  //设置通配符表达式
 
        public ScanOptions build() &#123;
            return new ScanOptions(this.count, this.pattern);
        &#125;
    &#125;
&#125;
</code></pre>
</li>
<li><p>Cursor：接收扫描结果</p>
<pre><code class="java">public interface Cursor&lt;T&gt; extends Iterator&lt;T&gt;, Closeable &#123;
    long getCursorId();

    boolean isClosed();

    Cursor&lt;T&gt; open();

    long getPosition();
&#125;


/*********************************/

public interface Iterator&lt;E&gt; &#123;

    boolean hasNext();

    E next();

    default void remove() &#123;
        throw new UnsupportedOperationException(&quot;remove&quot;);
    &#125;

    default void forEachRemaining(Consumer&lt;? super E&gt; action) &#123;
        Objects.requireNonNull(action);
        while (hasNext())
            action.accept(next());
    &#125;
&#125;


/*********************************/

public interface Closeable extends AutoCloseable &#123;

    public void close() throws IOException;
&#125;
</code></pre>
</li>
</ul>
<p>2、测试示例：HelloController.java</p>
<pre><code class="java">@RestController
public class HelloController &#123;

    @Autowired
    private StringRedisTemplate redisTemplate;

    @RequestMapping(&quot;/save&quot;)
    public String save()&#123;
        for(int i=0;i&lt;100;i++)&#123;
            redisTemplate.opsForValue().set(&quot;瓜田李下&quot;+i,&quot;海贼王&quot;+i);
        &#125;

        return &quot;success&quot;;
    &#125;

    @RequestMapping(&quot;/get&quot;)
    public void get()&#123;
        redisTemplate.execute((RedisCallback&lt;Object&gt;) redisConnection -&gt; &#123;
            try&#123;
                AtomicInteger count= new AtomicInteger();
                Cursor&lt;byte[]&gt; cursor=redisConnection.scan(ScanOptions.scanOptions().count(100).build());
                while(cursor.hasNext())&#123;
                    count.getAndIncrement();
                    byte[] bytes=cursor.next();
                    String s=new String(bytes);

                    System.out.print(s+&quot;  &quot;);
                    if (count.get()%10==0)&#123;
                        System.out.println();
                    &#125;
                &#125;

                System.out.println(count.get());
            &#125;catch (Exception e)&#123;
                e.printStackTrace();
            &#125;

            return null;
        &#125;);
    &#125;
&#125;
</code></pre>
<p>3、控制台输出</p>
<pre><code>瓜田李下10  瓜田李下89  瓜田李下64  瓜田李下47  瓜田李下5  瓜田李下58  瓜田李下97  瓜田李下87  瓜田李下77  瓜田李下23  
瓜田李下12  瓜田李下27  瓜田李下48  瓜田李下96  瓜田李下39  瓜田李下52  瓜田李下41  瓜田李下9  瓜田李下93  瓜田李下21  
瓜田李下66  瓜田李下40  瓜田李下56  瓜田李下91  瓜田李下59  瓜田李下55  瓜田李下32  瓜田李下28  瓜田李下85  瓜田李下11  
瓜田李下82  瓜田李下7  瓜田李下99  瓜田李下50  瓜田李下49  瓜田李下54  瓜田李下98  瓜田李下29  瓜田李下20  瓜田李下45  
瓜田李下31  瓜田李下71  瓜田李下62  瓜田李下38  瓜田李下42  瓜田李下33  瓜田李下57  瓜田李下60  瓜田李下18  瓜田李下94  
瓜田李下78  瓜田李下22  瓜田李下2  瓜田李下69  瓜田李下51  瓜田李下79  瓜田李下76  瓜田李下68  瓜田李下83  瓜田李下37  
瓜田李下95  瓜田李下70  瓜田李下30  瓜田李下73  瓜田李下6  瓜田李下74  瓜田李下34  瓜田李下19  瓜田李下61  瓜田李下63  
瓜田李下81  瓜田李下8  瓜田李下0  瓜田李下46  瓜田李下36  瓜田李下3  瓜田李下16  瓜田李下92  瓜田李下53  瓜田李下88  
瓜田李下4  瓜田李下75  瓜田李下35  瓜田李下25  瓜田李下65  瓜田李下86  瓜田李下80  瓜田李下44  瓜田李下67  瓜田李下72  
瓜田李下15  瓜田李下43  瓜田李下90  瓜田李下17  瓜田李下84  瓜田李下24  瓜田李下1  瓜田李下13  瓜田李下26  瓜田李下14  
100
</code></pre>
<h1 id="Redis-监听键过期提醒"><a href="#Redis-监听键过期提醒" class="headerlink" title="Redis 监听键过期提醒"></a>Redis 监听键过期提醒</h1><h2 id="1、Redis-实现订单30分钟自动取消"><a href="#1、Redis-实现订单30分钟自动取消" class="headerlink" title="1、Redis  实现订单30分钟自动取消"></a>1、Redis  实现订单30分钟自动取消</h2><h3 id="1、业务场景"><a href="#1、业务场景" class="headerlink" title="1、业务场景"></a>1、业务场景</h3><p>我们以订单功能为例说明下：</p>
<p>生成订单后一段时间不支付订单会自动关闭。最简单的想法是设置定时任务轮询，但是每个订单的创建时间不一样，定时任务的规则无法设定，如果将定时任务执行的间隔设置的过短，太影响效率。</p>
<p>还有一种想法，在用户进入订单界面的时候，判断时间执行相关操作。方式可能有很多，在这里介绍一种监听 Redis 键值对过期时间来实现订单自动关闭。</p>
<h3 id="2、实现思路"><a href="#2、实现思路" class="headerlink" title="2、实现思路"></a>2、实现思路</h3><p>在生成订单时，向 Redis 中增加一个 KV 键值对，K 为订单号，保证通过 K 能定位到数据库中的某个订单即可，V 可为任意值。</p>
<p>假设，生成订单时向 Redis 中存放 K 为订单号，V 也为订单号的键值对，并设置过期时间为 30 分钟，如果该键值对在 30 分钟过期后能够发送给程序一个通知，或者执行一个方法，那么即可解决订单关闭问题。</p>
<p>实现：通过监听 Redis 提供的过期队列来实现，监听过期队列后，如果 Redis 中某一个 KV 键值对过期了，那么将向监听者发送消息，监听者可以获取到该键值对的 K，注意，是获取不到 V 的，因为已经过期了，这就是上面所提到的，为什么要保证能通过 K 来定位到订单，而 V 为任意值即可。拿到 K 后，通过 K 定位订单，并判断其状态，如果是未支付，更新为关闭，或者取消状态即可。</p>
<h3 id="3、开启配置"><a href="#3、开启配置" class="headerlink" title="3、开启配置"></a>3、开启配置</h3><p>修改 redis 相关事件配置。找到 redis 配置文件 redis.conf，查看 notify-keyspace-events 配置项，如果没有，添加 notify-keyspace-events Ex，如果有值，则追加 Ex，相关参数说明如下：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>K</td>
<td>键空间通知，所有通知keyspace@ 为前缀，追对key</td>
</tr>
<tr>
<td>E</td>
<td>键事件通知，所有通知已keyspace@为前缀，追对event</td>
</tr>
<tr>
<td>g</td>
<td>一般性的，非特定类型的命令，比如del，expire，rename等</td>
</tr>
<tr>
<td>$</td>
<td>字符串命令通知</td>
</tr>
<tr>
<td>l</td>
<td>列表命令通知</td>
</tr>
<tr>
<td>s</td>
<td>集合命令通知</td>
</tr>
<tr>
<td>h</td>
<td>哈希命令通知</td>
</tr>
<tr>
<td>z</td>
<td>zset命令通知</td>
</tr>
<tr>
<td>x</td>
<td>过期事件，当某个键过期并删除时会产生该事件</td>
</tr>
<tr>
<td>e</td>
<td>驱逐事件，当某个键因 maxmemore 策略而被删除时，产生该事件</td>
</tr>
<tr>
<td>A</td>
<td>g$lshzxe总称，因此”AKE”意味着所有事件</td>
</tr>
</tbody></table>
<h3 id="4、代码实现"><a href="#4、代码实现" class="headerlink" title="4、代码实现"></a>4、代码实现</h3><p>1、在 pom.xml 中添加 org.springframework.boot:spring-boot-starter-data-redis 依赖</p>
<pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<p>2、添加 RedisMessageListenerContainer 配置类， 实现监听 Redis key 过期时间</p>
<pre><code class="java">package com.xyz.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.redis.connection.RedisConnectionFactory;
import org.springframework.data.redis.listener.RedisMessageListenerContainer;

@Configuration
public class RedisListenerConfig &#123;
    @Bean
    RedisMessageListenerContainer container(RedisConnectionFactory connectionFactory) &#123;
        RedisMessageListenerContainer container = new RedisMessageListenerContainer();
        container.setConnectionFactory(connectionFactory);
        return container;
    &#125;
&#125;
</code></pre>
<p>3、定义监听器 RedisKeyExpirationListener，实现 KeyExpirationEventMessageListener 接口，查看源码发现，该接口监听所有 db 的过期事件 <code>keyevent@*:expired&quot;</code>，如果想监听指定 db 就不能实现这个类，需要自定义。</p>
<pre><code class="java">package com.xyz.config;

import lombok.extern.slf4j.Slf4j;
import org.springframework.data.redis.connection.Message;
import org.springframework.data.redis.listener.KeyExpirationEventMessageListener;
import org.springframework.data.redis.listener.RedisMessageListenerContainer;
import org.springframework.stereotype.Component;
import java.nio.charset.StandardCharsets;

/**
 * 监听所有db的过期事件__keyevent@*__:expired&quot;
 */
@Slf4j
@Component
public class RedisKeyExpirationListener extends KeyExpirationEventMessageListener &#123;

    public RedisKeyExpirationListener(RedisMessageListenerContainer listenerContainer) &#123;
        super(listenerContainer);
    &#125;

    /**
     * 针对redis数据失效事件，进行数据处理
     */
    @Override
    public void onMessage(Message message, byte[] pattern) &#123;
        // String key = new String(message.getBody(), StandardCharsets.UTF_8); // 过期的key
        // 用户做自己的业务处理即可,message.toString()可以获取失效的key
        String expiredKey = message.toString();
        String channel = new String(message.getChannel(), StandardCharsets.UTF_8);

        log.info(&quot;接受到消息：expireKey = &#123;&#125;&quot; ,expiredKey);
        log.info(&quot;接受到消息：pattern = &#123;&#125;&quot;,message);
        log.info(&quot;接受到消息：channel = &#123;&#125;&quot;, channel);

        // 如下自己实现业务
    &#125;
&#125;
</code></pre>
<p>4、必须要在redis.conf 中开启 key失效唤醒时间通知</p>
<pre><code class="shell"># key失效事件回调通知开启
notify-keyspace-events EX

# 或者通过config set命令临时配置
config set notify-keyspace-events Ex    # EX代表 expire 和 evicted 过期和驱逐 的时间监听
config rewrite                          # 将配置写入配置文件中
</code></pre>
<p>5、使用 redis-cli 设置一个带过期时间的 key（设置一个3秒过期的key）</p>
<pre><code class="shell">127.0.0.1:6379&gt; setex name 3 sam
OK
</code></pre>
<p>6、等待key过期，观察代码控制台</p>
<pre><code>2022-05-24 18:30:16.557 --- c.xyz.config.RedisCustomListener   : 接受到消息：key = name
2022-05-24 18:30:16.557 --- c.xyz.config.RedisCustomListener   : 接受到消息：pattern = name
2022-05-24 18:30:16.557 --- c.xyz.config.RedisCustomListener   : 接受到消息：channel = __keyevent@0__:expired
</code></pre>
<h2 id="2、Redis-监听键过期海量数据处理"><a href="#2、Redis-监听键过期海量数据处理" class="headerlink" title="2、Redis 监听键过期海量数据处理"></a>2、Redis 监听键过期海量数据处理</h2><blockquote>
<p>Redis监听过期key特殊处理，适用于高并发及其海量数据的场景：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/4yvAtt1DAY9d75JoaR-Stw">https://mp.weixin.qq.com/s/4yvAtt1DAY9d75JoaR-Stw</a></p>
</blockquote>
<p>Redis监听过期key的教程网上都有文章，但大多数都是针对于一般的处理，如果遇上高并发及其海量数据的数据的情况下会有一些问题。本文会分析一般的监听过期key的处理在海量数据情况下出现的问题？怎么去解决，本文的思路和步骤都很清晰哦~</p>
<h3 id="1、抛出问题：Redis监听过期键不及时"><a href="#1、抛出问题：Redis监听过期键不及时" class="headerlink" title="1、抛出问题：Redis监听过期键不及时"></a>1、抛出问题：Redis监听过期键不及时</h3><p>举个简单的例子：</p>
<ul>
<li>现在时间 09:00, 有个key设置一分钟后过期，也就是我在 09:01 的时候redis会告知我这个key过期了</li>
<li>但是如果redis存储了海量数据，可能会导致这个的不及时通知，意思就是可能09:02才通知你</li>
<li>出现这种情况通知不及时很可能影响到业务操作，所以我们需要解决这个问题</li>
</ul>
<h3 id="2、分析问题：为什么会出现通知不及时"><a href="#2、分析问题：为什么会出现通知不及时" class="headerlink" title="2、分析问题：为什么会出现通知不及时"></a>2、分析问题：为什么会出现通知不及时</h3><p>我们首先得了解redis底层是如何知道key过期的，它有三种方案：</p>
<table>
<thead>
<tr>
<th>策略</th>
<th>描述</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>定时删除</td>
<td>就是设置key的时候给这个key创建一个定时器</td>
<td>删除及时</td>
<td>消耗cpu</td>
</tr>
<tr>
<td>定期删除</td>
<td>开一个定时任务定时扫描有哪些key过期了</td>
<td>cpu消耗小</td>
<td>删除不及时，性能和内存消耗介于两者之间</td>
</tr>
<tr>
<td>惰性删除</td>
<td>获取key的时候判断key是否过期了</td>
<td>cpu消耗小</td>
<td>删除不及时，耗内存</td>
</tr>
</tbody></table>
<p>Redis默认采用的是：<strong>定期删除 + 惰性删除</strong></p>
<p><strong>定期删除的过程：</strong></p>
<p>每隔一段时间，Redis 会分别去各个库随机拿 20 个非永久 Key，判断它们是否过期，过期则删除，如果这一次拿的 key 中有超过 1&#x2F;4 的数据过期，则再执行一遍过程 1，直到过期数据不超过当次拿出来的 20 条记录的 1&#x2F;4。（可以通过配置 redis.conf 中的 hz 修改 Redis 执行定期删除的频率，默认 hz&#x3D;10，即每 100ms 执行一次，1&#x2F;4 与每次拿的数量 20 暂时未找到配置项）</p>
<p>如果当前数据库没有非永久 key，则跳过当前数据库；</p>
<p>如果 key 已过期，但没有被定期删除，由于惰性删除策略，在下次请求获取该数据时会将该数据删除；</p>
<p><strong>平时我们都是把所有key都存在一个库里，它去随机获取的时候不一定能拿到过期key，所以就可能造成key过期没有及时通知</strong></p>
<h3 id="3、解决方案：缓存数据与监听数据分离"><a href="#3、解决方案：缓存数据与监听数据分离" class="headerlink" title="3、解决方案：缓存数据与监听数据分离"></a>3、解决方案：缓存数据与监听数据分离</h3><p>1、将缓存数据与监听数据分离，即把不同功能类型的数据分库存放（Redis 默认有 16 个库，库的数量可在 redis.conf 配置修改），例如把缓存数据存在 database0，把监听数据存在 database1；</p>
<p>2、让进行监听的库中 key 尽量少，如果不同业务的监听超时时间差异较大，则考虑将不同业务的超时监听数据存放到不同的数据库；</p>
<p>3、存放不同的库之后意味着执行命令需要动态切换库。</p>
<ol>
<li><p>方式一：使用RedisConnectionFactory手动切换，缺点：使用玩还需要手动切回来</p>
<pre><code class="java">LettuceConnectionFactory lettuceConnectionFactory = (LettuceConnectionFactory) redisTemplate.getConnectionFactory();
lettuceConnectionFactory.setDatabase(8);
redisTemplate.opsForValue().set(&quot;username&quot;, &quot;Sam&quot;);
lettuceConnectionFactory.setDatabase(0);
</code></pre>
</li>
<li><p>方式二：直接定义多个RedisTemplate，指定RedisTemplate为某个库，自行查找。</p>
<ul>
<li>可参考：SpringBoot+RedisTemplate多数据源：<a target="_blank" rel="noopener" href="https://blog.csdn.net/gl794262724/article/details/118552569">https://blog.csdn.net/gl794262724/article/details/118552569</a></li>
</ul>
</li>
</ol>
<h3 id="5、代码实现：缓存数据与监听数据分离"><a href="#5、代码实现：缓存数据与监听数据分离" class="headerlink" title="5、代码实现：缓存数据与监听数据分离"></a>5、代码实现：缓存数据与监听数据分离</h3><p>1、在 pom.xml 中添加 org.springframework.boot:spring-boot-starter-data-redis 依赖</p>
<pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<p>2、添加 RedisMessageListenerContainer 配置类，实现监听 Redis key 过期时间，这里配置了监听指定库</p>
<pre><code class="java">package com.xyz.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.redis.connection.RedisConnectionFactory;
import org.springframework.data.redis.listener.PatternTopic;
import org.springframework.data.redis.listener.RedisMessageListenerContainer;

@Configuration
public class RedisListenerConfig &#123;
    @Bean
    RedisMessageListenerContainer container(RedisConnectionFactory connectionFactory) &#123;
        RedisMessageListenerContainer container = new RedisMessageListenerContainer();
        container.setConnectionFactory(connectionFactory);
        // 指定监听库
         container.addMessageListener(new RedisCustomListener(),new PatternTopic(&quot;__keyevent@2__:expired&quot;));
        return container;
    &#125;
&#125;
</code></pre>
<p>3、定义监听器 MessageListener，与 KeyExpirationEventMessageListener 不同的是该类需要自己自定义监听规则，在上述类中已经指定，而 KeyExpirationEventMessageListener 已经指定 <code>keyevent@*:expired</code> 并且无法更改，只能增加。</p>
<pre><code class="java">package com.xyz.config;

import lombok.extern.slf4j.Slf4j;
import org.springframework.data.redis.connection.Message;
import org.springframework.data.redis.connection.MessageListener;
import org.springframework.data.redis.listener.KeyExpirationEventMessageListener;
import org.springframework.data.redis.listener.RedisMessageListenerContainer;
import org.springframework.stereotype.Component;
import java.nio.charset.StandardCharsets;

/**
 * 监听指定db的过期事件__keyevent@10__:expired&quot;
 */
@Slf4j
@Component
public class RedisCustomListener implements MessageListener &#123;

    /**
     * 针对redis数据失效事件，进行数据处理
     */
    @Override
    public void onMessage(Message message, byte[] pattern) &#123;
        // String key = new String(message.getBody(), StandardCharsets.UTF_8); // 过期的key
        // 用户做自己的业务处理即可,message.toString()可以获取失效的key
        String expiredKey = message.toString();
        String channel = new String(message.getChannel(), StandardCharsets.UTF_8);

        log.info(&quot;接受到消息：expireKey = &#123;&#125;&quot; ,expiredKey);
        log.info(&quot;接受到消息：pattern = &#123;&#125;&quot;,message);
        log.info(&quot;接受到消息：channel = &#123;&#125;&quot;, channel);

    &#125;
&#125;
</code></pre>
<p>4、必须要在redis.conf 中开启 key失效唤醒时间通知</p>
<pre><code class="shell"># key失效事件回调通知开启
notify-keyspace-events EX

# 或者通过config set命令临时配置
config set notify-keyspace-events Ex    # EX代表 expire 和 evicted 过期和驱逐 的时间监听
config rewrite                          # 将配置写入配置文件中
</code></pre>
<p>5、使用 redis-cli 设置一个带过期时间的 key（设置一个3秒过期的key）</p>
<pre><code class="shell">127.0.0.1:6379&gt; setex name 3 sam
OK
</code></pre>
<p>6、等待key过期，观察代码控制台</p>
<pre><code>2022-05-24 18:30:16.557 --- c.xyz.config.RedisCustomListener   : 接受到消息：key = name
2022-05-24 18:30:16.557 --- c.xyz.config.RedisCustomListener   : 接受到消息：pattern = name
2022-05-24 18:30:16.557 --- c.xyz.config.RedisCustomListener   : 接受到消息：channel = __keyevent@2__:expired
</code></pre>
<h2 id="3、Redis-监听键过期提醒总结"><a href="#3、Redis-监听键过期提醒总结" class="headerlink" title="3、Redis 监听键过期提醒总结"></a>3、Redis 监听键过期提醒总结</h2><p>键过期事件的监听实际使用的不是很多。因为Redis大部分都是缓存作用。缓存本来就会可有可无的。所以监听意义不大。但是也可以在不少场景下使用。</p>
<ol>
<li>订单30分钟未付款自动取消场景</li>
<li>系统定时提醒功能</li>
</ol>
<h1 id="Redis-SpringBoot-Pipeline"><a href="#Redis-SpringBoot-Pipeline" class="headerlink" title="Redis SpringBoot Pipeline"></a>Redis SpringBoot Pipeline</h1><p>作用：批量发送命令，较一条一条发送命令节省网络传输时间。</p>
<p>1、操作示例：HelloController.java</p>
<pre><code class="java">@RestController
public class HelloController &#123;
    @Autowired
    private StringRedisTemplate redisTemplate;

    @RequestMapping(&quot;/hello&quot;)
    public String hello()&#123;
        long start=System.currentTimeMillis();
        System.out.println(&quot;开始时间：&quot;+start);

        redisTemplate.executePipelined(new SessionCallback&lt;Object&gt;() &#123;

            public Object execute(RedisOperations redisOperations) throws DataAccessException &#123;
                for(int i=0;i&lt;10000;i++)&#123;
                    redisOperations.opsForValue().set(&quot;瓜田李下&quot;+i,i+&quot;&quot;);
                &#125;
                return null;
            &#125;
        &#125;);

        long end=System.currentTimeMillis();
        System.out.println(&quot;结束时间：&quot;+end);
        System.out.println(&quot;花费时间：&quot;+(end-start));

        return &quot;花费时间：&quot;+(end-start);
    &#125;

    @RequestMapping(&quot;/hello2&quot;)
    public String hello2()&#123;
        long start=System.currentTimeMillis();
        System.out.println(&quot;开始时间：&quot;+start);

        for (int i=0;i&lt;10000;i++)&#123;
            redisTemplate.opsForValue().set(&quot;海贼王&quot;+i,i+&quot;&quot;);
        &#125;

        long end=System.currentTimeMillis();
        System.out.println(&quot;结束时间：&quot;+end);
        System.out.println(&quot;花费时间：&quot;+(end-start));

        return &quot;花费时间：&quot;+(end-start);
    &#125;
&#125;
</code></pre>
<p>2、控制台输出</p>
<pre><code>开始时间：1570067655395
结束时间：1570067657005
花费时间：1610

开始时间：1570067688485
结束时间：1570067694345
花费时间：5860
</code></pre>
<p>3、10000数据设置耗时对比：</p>
<ul>
<li>Pipeline时间消耗：1610ms</li>
<li>单条发送时间消耗：5860ms</li>
</ul>
<h1 id="参考文献-鸣谢"><a href="#参考文献-鸣谢" class="headerlink" title="参考文献 &amp; 鸣谢"></a>参考文献 &amp; 鸣谢</h1><ol>
<li>Redis系列6.0.3版【CSDN：王义凯】<a target="_blank" rel="noopener" href="https://blog.csdn.net/wsdc0521/category_9887941.html">https://blog.csdn.net/wsdc0521/category_9887941.html</a></li>
<li>Redis Tag【博客园：天宇轩-王】<a target="_blank" rel="noopener" href="https://www.cnblogs.com/dalianpai/category/1605657.html">https://www.cnblogs.com/dalianpai/category/1605657.html</a></li>
<li>Redis 客户端大全【博客园：咏吟】<a target="_blank" rel="noopener" href="https://www.cnblogs.com/wuyongyin/tag/NoSQL">https://www.cnblogs.com/wuyongyin/tag/NoSQL</a></li>
<li>Redis &amp; Redisson 实战示例【CSDN：瓜田李下】<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43931625/category_9397188.html">https://blog.csdn.net/weixin_43931625/category_9397188.html</a></li>
<li>进击Redis【CSDN：AnAnDawn】：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_34090008/category_10643273.html">https://blog.csdn.net/qq_34090008/category_10643273.html</a></li>
<li>Redis Tag【CSDN：緈諨の約錠】：<a target="_blank" rel="noopener" href="https://blog.csdn.net/smilehappiness/category_10081896.html">https://blog.csdn.net/smilehappiness/category_10081896.html</a></li>
</ol>

      
       <hr><span style="font-style: italic;color: gray;"> 转载请注明来源，欢迎对文章中的引用来源进行考证，欢迎指出任何有错误或不够清晰的表达。可以在下面评论区评论，也可以邮件至 8629303@qq.com </span>
    </div>
</article>


<p>
    <a  class="dashang" onclick="dashangToggle()">赏</a>
</p>






    




    </div>
    <div class="copyright">
        <p class="footer-entry">
    ©2017-2024 Sam
</p>
<p class="footer-entry">Built with <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/yelog/hexo-theme-3-hexo" target="_blank">3-hexo</a> theme</p>

    </div>
    <div class="full-toc">
        <button class="full" data-title="切换全屏 快捷键 s"><span class="min "></span></button>
<a class="" id="rocket" ></a>

    </div>
</div>

<div class="hide_box" onclick="dashangToggle()"></div>
<div class="shang_box">
    <a class="shang_close"  onclick="dashangToggle()">×</a>
    <div class="shang_tit">
        <p>喜欢就点赞,疼爱就打赏</p>
    </div>
    <div class="shang_payimg">
        <div class="pay_img">
            <img src="/img/alipay.jpg" class="alipay" title="扫码支持">
            <img src="/img/weixin.jpg" class="weixin" title="扫码支持">
        </div>
    </div>
    <div class="shang_payselect">
        <span><label><input type="radio" name="pay" checked value="alipay">支付宝</label></span><span><label><input type="radio" name="pay" value="weixin">微信</label></span>
    </div>
</div>


</body>
<script src="/js/jquery.pjax.js?v=1.1.0" ></script>

<script src="/js/script.js?v=1.1.0" ></script>
<script>
    var img_resize = 'default';
    function initArticle() {
        /*渲染对应的表格样式*/
        
            $("#post .pjax table").addClass("green_title");
        

        /*渲染打赏样式*/
        
        $("input[name=pay]").on("click", function () {
            if($("input[name=pay]:checked").val()=="weixin"){
                $(".shang_box .shang_payimg .pay_img").addClass("weixin_img");
            } else {
                $(".shang_box .shang_payimg .pay_img").removeClass("weixin_img");
            }
        })
        

        /*高亮代码块行号*/
        
        $('pre code').each(function(){
            var lines = $(this).text().trim().split('\n').length, widther='';
            if (lines>99) {
                widther = 'widther'
            }
            var $numbering = $('<ul/>').addClass('pre-numbering ' + widther).attr("unselectable","on");
            $(this).addClass('has-numbering ' + widther)
                    .parent()
                    .append($numbering);
            for(var i=1;i<=lines;i++){
                $numbering.append($('<li/>').text(i));
            }
        });
        

        /*访问数量*/
        
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js");
        

        /*代码高亮，行号对齐*/
        $('.pre-numbering').css('line-height',$('.has-numbering').css('line-height'));

        
        
    }

    /*打赏页面隐藏与展示*/
    
    function dashangToggle() {
        $(".shang_box").fadeToggle();
        $(".hide_box").fadeToggle();
    }
    

</script>

<!--加入行号的高亮代码块样式-->

<style>
    pre{
        position: relative;
        margin-bottom: 24px;
        border-radius: 10px;
        border: 1px solid #e2dede;
        background: #FFF;
        overflow: hidden;
    }
    code.has-numbering{
        margin-left: 30px;
    }
    code.has-numbering.widther{
        margin-left: 35px;
    }
    .pre-numbering{
        margin: 0;
        position: absolute;
        top: 0;
        left: 0;
        width: 20px;
        padding: 18px 3px 15px 5px;
        border-right: 1px solid #C3CCD0;
        text-align: right;
        color: #AAA;
        background-color: #fafafa;
    }
    .pre-numbering.widther {
        width: 35px;
    }
</style>

<!--自定义样式设置-->
<style>
    
    
    .nav {
        width: 582px;
    }
    .nav.fullscreen {
        margin-left: -582px;
    }
    .nav-left {
        width: 160px;
    }
    
    
    @media screen and (max-width: 1468px) {
        .nav {
            width: 492px;
        }
        .nav.fullscreen {
            margin-left: -492px;
        }
        .nav-left {
            width: 100px;
        }
    }
    
    
    @media screen and (max-width: 1024px) {
        .nav {
            width: 492px;
            margin-left: -492px
        }
        .nav.fullscreen {
            margin-left: 0;
        }
    }
    
    @media screen and (max-width: 426px) {
        .nav {
            width: 100%;
        }
        .nav-left {
            width: 100%;
        }
    }
    
    
    .nav-right .title-list nav a .post-title, .nav-right .title-list #local-search-result a .post-title {
        color: #383636;
    }
    
    
    .nav-right .title-list nav a .post-date, .nav-right .title-list #local-search-result a .post-date {
        color: #5e5e5f;
    }
    
    
    .nav-right nav a.hover, #local-search-result a.hover{
        background-color: #e2e0e0;
    }
    
    

    /*列表样式*/
    

    /* 背景图样式 */
    
    


    /*引用块样式*/
    

    /*文章列表背景图*/
    

    
</style>







</html>
