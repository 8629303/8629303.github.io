<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Spring 实现多数据源实战 | Hexo</title>
  <meta name="keywords" content="">
  <meta name="description" content="Spring 实现多数据源实战 | Hexo">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="description" content="请不要自己写，Spring Boot非常实用的内置功能：https:&#x2F;&#x2F;juejin.cn&#x2F;post&#x2F;7417630844100231206  在 SpringBoot 框架中，内置了许多实用的功能，这些功能可以帮助开发者高效地开发和维护应用程序。 一、请求数据记录器SpringBoot 提供了一个内置的日志记录解决方案，通过 AbstractRequestLoggingFilter 可以记录请">
<meta property="og:type" content="article">
<meta property="og:title" content="SpringBoot2.x 内置功能 - 内置过滤器和 AOP 工具类">
<meta property="og:url" content="http://example.com/2024/10/08/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot2.x%20%E5%86%85%E7%BD%AE%E5%8A%9F%E8%83%BD%20-%20%E5%86%85%E7%BD%AE%E8%BF%87%E6%BB%A4%E5%99%A8%E5%92%8C%20AOP%20%E5%B7%A5%E5%85%B7%E7%B1%BB/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="请不要自己写，Spring Boot非常实用的内置功能：https:&#x2F;&#x2F;juejin.cn&#x2F;post&#x2F;7417630844100231206  在 SpringBoot 框架中，内置了许多实用的功能，这些功能可以帮助开发者高效地开发和维护应用程序。 一、请求数据记录器SpringBoot 提供了一个内置的日志记录解决方案，通过 AbstractRequestLoggingFilter 可以记录请">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2024-10-08T08:44:19.743Z">
<meta property="article:modified_time" content="2024-10-19T16:48:33.715Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">


<link rel="icon" href="/img/avatar.jpg">

<link href="/css/style.css?v=1.1.0" rel="stylesheet">

<link href="/css/hl_theme/atom-light.css?v=1.1.0" rel="stylesheet">

<link href="//cdn.jsdelivr.net/npm/animate.css@4.1.0/animate.min.css" rel="stylesheet">

<script src="//cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
<script src="/js/titleTip.js?v=1.1.0" ></script>

<script src="//cdn.jsdelivr.net/npm/highlightjs@9.16.2/highlight.pack.min.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>

<script src="//cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script>



<script src="//cdn.jsdelivr.net/npm/jquery.cookie@1.4.1/jquery.cookie.min.js" ></script>

<script src="/js/iconfont.js?v=1.1.0" ></script>

<meta name="generator" content="Hexo 7.3.0"></head>
<div style="display: none">
  <input class="theme_disqus_on" value="false">
  <input class="theme_preload_comment" value="">
  <input class="theme_blog_path" value="">
  <input id="theme_shortcut" value="true" />
  <input id="theme_highlight_on" value="true" />
  <input id="theme_code_copy" value="true" />
</div>



<body>
<aside class="nav">
    <div class="nav-left">
        <a href="/"
   class="avatar_target">
    <img class="avatar"
         src="/img/avatar.jpg"/>
</a>
<div class="author">
    <span>John Doe</span>
</div>

<div class="icon">
    
        
            <a title="github"
               href="https://github.com/8629303"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-github"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="email"
               href="mailto:8629303@qq.com"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-email"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="qq"
               href="http://wpa.qq.com/msgrd?v=3&uin=8629303&site=qq&menu=yes"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-qq"></use>
                    </svg>
                
            </a>
        
    
</div>





<ul>
    <li>
        <div class="all active" data-rel="全部文章">全部文章
            
                <small>(172)</small>
            
        </div>
    </li>
    
        
            
                
    <li>
        <div data-rel="数据库">
            
            数据库
            <small>(5)</small>
        </div>
        
    </li>

            
        
    
        
            
        
    
        
            
        
    
        
            
                
    <li>
        <div data-rel="开发工具">
            <i class="fold iconfont icon-right"></i>
            开发工具
            <small>(16)</small>
        </div>
        
            <ul class="sub hide">
                
                    
    <li>
        <div data-rel="开发工具&lt;---&gt;Maven">
            
            Maven
            <small>(8)</small>
        </div>
        
    </li>

                
            </ul>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="面试篇">
            
            面试篇
            <small>(1)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="微服务开发">
            <i class="fold iconfont icon-right"></i>
            微服务开发
            <small>(61)</small>
        </div>
        
            <ul class="sub hide">
                
                    
    <li>
        <div data-rel="微服务开发&lt;---&gt;Shiro">
            
            Shiro
            <small>(2)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="微服务开发&lt;---&gt;Spring">
            
            Spring
            <small>(3)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="微服务开发&lt;---&gt;SpringBoot">
            
            SpringBoot
            <small>(44)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="微服务开发&lt;---&gt;SpringCloudAlibaba">
            
            SpringCloudAlibaba
            <small>(1)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="微服务开发&lt;---&gt;SpringDataJPA">
            
            SpringDataJPA
            <small>(4)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="微服务开发&lt;---&gt;SpringMVC">
            
            SpringMVC
            <small>(1)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="微服务开发&lt;---&gt;SpringSecurity">
            
            SpringSecurity
            <small>(1)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="微服务开发&lt;---&gt;SpringTransaction">
            
            SpringTransaction
            <small>(5)</small>
        </div>
        
    </li>

                
            </ul>
        
    </li>

            
        
    
        
            
        
    
        
            
                
    <li>
        <div data-rel="中间件">
            <i class="fold iconfont icon-right"></i>
            中间件
            <small>(8)</small>
        </div>
        
            <ul class="sub hide">
                
                    
    <li>
        <div data-rel="中间件&lt;---&gt;ElasticSearch">
            
            ElasticSearch
            <small>(1)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="中间件&lt;---&gt;MongoDB">
            
            MongoDB
            <small>(2)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="中间件&lt;---&gt;RabbitMQ">
            
            RabbitMQ
            <small>(3)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="中间件&lt;---&gt;Redis">
            
            Redis
            <small>(2)</small>
        </div>
        
    </li>

                
            </ul>
        
    </li>

            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
                
    <li>
        <div data-rel="Java基础篇">
            <i class="fold iconfont icon-right"></i>
            Java基础篇
            <small>(8)</small>
        </div>
        
            <ul class="sub hide">
                
                    
    <li>
        <div data-rel="Java基础篇&lt;---&gt;Java常用类库">
            
            Java常用类库
            <small>(1)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="Java基础篇&lt;---&gt;Java多线程">
            
            Java多线程
            <small>(2)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="Java基础篇&lt;---&gt;Java反射与注解">
            
            Java反射与注解
            <small>(1)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="Java基础篇&lt;---&gt;Java基础语法">
            
            Java基础语法
            <small>(1)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="Java基础篇&lt;---&gt;Java集合类">
            
            Java集合类
            <small>(1)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="Java基础篇&lt;---&gt;JavaIO流">
            
            JavaIO流
            <small>(1)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="Java基础篇&lt;---&gt;JavaNIO流">
            
            JavaNIO流
            <small>(1)</small>
        </div>
        
    </li>

                
            </ul>
        
    </li>

            
        
    
        
            
        
    
        
            
        
    
        
            
                
    <li>
        <div data-rel="Java进阶篇">
            <i class="fold iconfont icon-right"></i>
            Java进阶篇
            <small>(4)</small>
        </div>
        
            <ul class="sub hide">
                
                    
    <li>
        <div data-rel="Java进阶篇&lt;---&gt;Java设计模式">
            
            Java设计模式
            <small>(1)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="Java进阶篇&lt;---&gt;JVM虚拟机">
            
            JVM虚拟机
            <small>(3)</small>
        </div>
        
    </li>

                
            </ul>
        
    </li>

            
        
    
        
            
        
    
        
            
        
    
        
            
                
    <li>
        <div data-rel="Java新特性">
            <i class="fold iconfont icon-right"></i>
            Java新特性
            <small>(16)</small>
        </div>
        
            <ul class="sub hide">
                
                    
    <li>
        <div data-rel="Java新特性&lt;---&gt;Java10新特性">
            
            Java10新特性
            <small>(1)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="Java新特性&lt;---&gt;Java11新特性">
            
            Java11新特性
            <small>(1)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="Java新特性&lt;---&gt;Java12新特性">
            
            Java12新特性
            <small>(1)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="Java新特性&lt;---&gt;Java13新特性">
            
            Java13新特性
            <small>(1)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="Java新特性&lt;---&gt;Java14新特性">
            
            Java14新特性
            <small>(1)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="Java新特性&lt;---&gt;Java15新特性">
            
            Java15新特性
            <small>(1)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="Java新特性&lt;---&gt;Java16新特性">
            
            Java16新特性
            <small>(1)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="Java新特性&lt;---&gt;Java17新特性">
            
            Java17新特性
            <small>(1)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="Java新特性&lt;---&gt;Java18新特性">
            
            Java18新特性
            <small>(1)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="Java新特性&lt;---&gt;Java19新特性">
            
            Java19新特性
            <small>(1)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="Java新特性&lt;---&gt;Java20新特性">
            
            Java20新特性
            <small>(1)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="Java新特性&lt;---&gt;Java8新特性">
            
            Java8新特性
            <small>(4)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="Java新特性&lt;---&gt;Java9新特性">
            
            Java9新特性
            <small>(1)</small>
        </div>
        
    </li>

                
            </ul>
        
    </li>

            
        
    
        
            
        
    
        
            
                
    <li>
        <div data-rel="JavaEE">
            <i class="fold iconfont icon-right"></i>
            JavaEE
            <small>(6)</small>
        </div>
        
            <ul class="sub hide">
                
                    
    <li>
        <div data-rel="JavaEE&lt;---&gt;JavaWeb">
            
            JavaWeb
            <small>(2)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="JavaEE&lt;---&gt;SSM框架">
            
            SSM框架
            <small>(4)</small>
        </div>
        
    </li>

                
            </ul>
        
    </li>

            
        
    
        
            
        
    
        
            
        
    
        
            
                
    <li>
        <div data-rel="JavaSE">
            <i class="fold iconfont icon-right"></i>
            JavaSE
            <small>(34)</small>
        </div>
        
            <ul class="sub hide">
                
                    
    <li>
        <div data-rel="JavaSE&lt;---&gt;Java汇总篇">
            
            Java汇总篇
            <small>(28)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="JavaSE&lt;---&gt;Java新特性">
            
            Java新特性
            <small>(1)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="JavaSE&lt;---&gt;Java性能测试与安全">
            
            Java性能测试与安全
            <small>(5)</small>
        </div>
        
    </li>

                
            </ul>
        
    </li>

            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
                
    <li>
        <div data-rel="Linux">
            <i class="fold iconfont icon-right"></i>
            Linux
            <small>(7)</small>
        </div>
        
            <ul class="sub hide">
                
                    
    <li>
        <div data-rel="Linux&lt;---&gt;虚拟机工具">
            
            虚拟机工具
            <small>(2)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="Linux&lt;---&gt;Docker">
            
            Docker
            <small>(2)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="Linux&lt;---&gt;Kubernetes">
            
            Kubernetes
            <small>(2)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="Linux&lt;---&gt;Nginx">
            
            Nginx
            <small>(1)</small>
        </div>
        
    </li>

                
            </ul>
        
    </li>

            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
                
    <li>
        <div data-rel="Redis">
            <i class="fold iconfont icon-right"></i>
            Redis
            <small>(1)</small>
        </div>
        
            <ul class="sub hide">
                
                    
    <li>
        <div data-rel="Redis&lt;---&gt;backup">
            
            backup
            <small>(1)</small>
        </div>
        
    </li>

                
            </ul>
        
    </li>

            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
                
    <li>
        <div data-rel="SpringTransaction">
            <i class="fold iconfont icon-right"></i>
            SpringTransaction
            <small>(5)</small>
        </div>
        
            <ul class="sub hide">
                
                    
    <li>
        <div data-rel="SpringTransaction&lt;---&gt;多数据源事务处理">
            
            多数据源事务处理
            <small>(3)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="SpringTransaction&lt;---&gt;多线程下事务处理">
            
            多线程下事务处理
            <small>(2)</small>
        </div>
        
    </li>

                
            </ul>
        
    </li>

            
        
    
        
            
        
    
</ul>
<div class="left-bottom">
    <div class="menus">
        
            
            
            
    </div>
    <div>
        
            <a class="about  hasFriend  site_url"
               
               href="/about">关于</a>
        
        <a style="width: 50%"
                
                                           class="friends">友链</a>
        
    </div>
</div>
<input type="hidden" id="yelog_site_posts_number" value="172">

<div style="display: none">
    <span id="busuanzi_value_site_uv"></span>
    <span id="busuanzi_value_site_pv"></span>
</div>

    </div>
    <div class="nav-right">
        <div class="friends-area">
    <div class="friends-title">
        友情链接
        <i class="iconfont icon-left"></i>
    </div>
    <div class="friends-content">
        <ul>
            
            <li><a target="_blank" href="http://yelog.org/">叶落阁</a></li>
            
        </ul>
    </div>
</div>
        <div class="title-list">
    <div class="right-top">
        <div id="default-panel">
            <i class="iconfont icon-search" data-title="搜索 快捷键 i"></i>
            <div class="right-title">全部文章</div>
            <i class="iconfont icon-file-tree" data-title="切换到大纲视图 快捷键 w"></i>
        </div>
        <div id="search-panel">
            <i class="iconfont icon-left" data-title="返回"></i>
            <input id="local-search-input" autocomplete="off"/>
            <label class="border-line" for="input"></label>
            <i class="iconfont icon-case-sensitive" data-title="大小写敏感"></i>
            <i class="iconfont icon-tag" data-title="标签"></i>
        </div>
        <div id="outline-panel" style="display: none">
            <div class="right-title">大纲</div>
            <i class="iconfont icon-list" data-title="切换到文章列表"></i>
        </div>
    </div>

    <div class="tags-list">
    <input id="tag-search" />
    <div class="tag-wrapper">
        
    </div>

</div>

    
    <nav id="title-list-nav">
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2024/10/08/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot2.x%20%E5%86%85%E7%BD%AE%E5%8A%9F%E8%83%BD%20-%20%E5%86%85%E7%BD%AE%E8%BF%87%E6%BB%A4%E5%99%A8%E5%92%8C%20AOP%20%E5%B7%A5%E5%85%B7%E7%B1%BB/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot2.x 内置功能 - 内置过滤器和 AOP 工具类">SpringBoot2.x 内置功能 - 内置过滤器和 AOP 工具类</span>
            <span class="post-date" title="2024-10-08 16:44:19">2024/10/08</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2024/10/08/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%E7%B3%BB%E5%88%97-%E5%85%A8%E7%BD%91%E6%9C%80%E5%85%A8%E7%9A%84%E7%89%88%E6%9C%AC%E5%8F%98%E6%9B%B4%E5%8F%B2/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot系列-全网最全的版本变更史">SpringBoot系列-全网最全的版本变更史</span>
            <span class="post-date" title="2024-10-08 16:38:53">2024/10/08</span>
        </a>
        
        
        <a  class="全部文章 开发工具 Maven "
           href="/2024/10/08/6%E3%80%81%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Maven/Maven%20%E6%95%99%E7%A8%8B%E4%B9%8B%20%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE%20&%20%E9%B8%A3%E8%B0%A2/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Maven 教程之 参考文献 &amp; 鸣谢">Maven 教程之 参考文献 &amp; 鸣谢</span>
            <span class="post-date" title="2024-10-08 15:50:47">2024/10/08</span>
        </a>
        
        
        <a  class="全部文章 开发工具 "
           href="/2024/10/07/6%E3%80%81%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/GitHub%20%E5%AE%9E%E6%88%98%E6%8A%80%E5%B7%A7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="GitHub 实战技巧">GitHub 实战技巧</span>
            <span class="post-date" title="2024-10-07 15:55:34">2024/10/07</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2024/10/07/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot2.x%20%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AF%87%20-%20%E9%9B%86%E6%88%90%20HirakiCP%20%E4%B8%8E%20Druid%20%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot2.x 数据库篇 - 集成 HirakiCP 与 Druid 数据库连接池">SpringBoot2.x 数据库篇 - 集成 HirakiCP 与 Druid 数据库连接池</span>
            <span class="post-date" title="2024-10-07 14:19:43">2024/10/07</span>
        </a>
        
        
        <a  class="全部文章 开发工具 "
           href="/2024/09/30/6%E3%80%81%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/MacOS%20%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%8F%8A%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E5%8D%B8%E8%BD%BD/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="MacOS 开发环境搭建及软件安装卸载">MacOS 开发环境搭建及软件安装卸载</span>
            <span class="post-date" title="2024-09-30 23:56:52">2024/09/30</span>
        </a>
        
        
        <a  class="全部文章 开发工具 Maven "
           href="/2024/09/30/6%E3%80%81%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Maven/Maven%20%E6%95%99%E7%A8%8B%E4%B9%8B%20JDK%20%E7%89%88%E6%9C%AC%E9%BB%98%E8%AE%A4%E8%AE%BE%E7%BD%AE%20/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Maven 教程之 JDK 版本默认设置">Maven 教程之 JDK 版本默认设置</span>
            <span class="post-date" title="2024-09-30 16:37:08">2024/09/30</span>
        </a>
        
        
        <a  class="全部文章 开发工具 Maven "
           href="/2024/09/26/6%E3%80%81%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Maven/Maven%20%E6%95%99%E7%A8%8B%E4%B9%8B%20profiles%20%E5%A4%9A%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Maven 教程之 profiles 多环境配置">Maven 教程之 profiles 多环境配置</span>
            <span class="post-date" title="2024-09-26 17:40:34">2024/09/26</span>
        </a>
        
        
        <a  class="全部文章 开发工具 Maven "
           href="/2024/09/25/6%E3%80%81%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Maven/Maven%20%E6%95%99%E7%A8%8B%E4%B9%8B%20plugin%20%E8%AF%A6%E8%A7%A3/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Maven 教程之 plugin 详解">Maven 教程之 plugin 详解</span>
            <span class="post-date" title="2024-09-25 11:32:44">2024/09/25</span>
        </a>
        
        
        <a  class="全部文章 开发工具 Maven "
           href="/2024/09/21/6%E3%80%81%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Maven/Maven%20%E6%95%99%E7%A8%8B%E4%B9%8B%20pom.xml%20%E8%AF%A6%E8%A7%A3/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Maven 教程之 pom.xml 详解">Maven 教程之 pom.xml 详解</span>
            <span class="post-date" title="2024-09-21 16:14:13">2024/09/21</span>
        </a>
        
        
        <a  class="全部文章 开发工具 Maven "
           href="/2024/09/21/6%E3%80%81%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Maven/Maven%20%E6%95%99%E7%A8%8B%E4%B9%8B%20settings.xml%20%E8%AF%A6%E8%A7%A3/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Maven 教程之 settings.xml 详解">Maven 教程之 settings.xml 详解</span>
            <span class="post-date" title="2024-09-21 16:14:09">2024/09/21</span>
        </a>
        
        
        <a  class="全部文章 面试篇 "
           href="/2024/08/27/0%E3%80%81%E9%9D%A2%E8%AF%95%E7%AF%87/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8%E6%B1%87%E6%80%BB/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="面试宝典汇总">面试宝典汇总</span>
            <span class="post-date" title="2024-08-27 16:20:25">2024/08/27</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/2024/08/26/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E8%87%AA%E5%AE%9A%E4%B9%89%E9%9B%86%E5%90%88%E5%B8%B8%E9%87%8F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 自定义集合常量">Java 自定义集合常量</span>
            <span class="post-date" title="2024-08-26 12:11:54">2024/08/26</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringMVC "
           href="/2024/08/26/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20MVC/SpringMVC%E4%B9%8B@InitBinder%E6%B3%A8%E8%A7%A3%EF%BC%88%E6%97%A5%E6%9C%9F%E8%BD%AC%E6%8D%A2%EF%BC%89/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringMVC之@InitBinder注解（日期转换）">SpringMVC之@InitBinder注解（日期转换）</span>
            <span class="post-date" title="2024-08-26 11:10:28">2024/08/26</span>
        </a>
        
        
        <a  class="全部文章 SpringTransaction 多线程下事务处理 "
           href="/2024/08/21/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Transaction/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8B%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/Java%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BA%8B%E5%8A%A1%E6%8F%90%E4%BA%A4%E7%9A%84%E5%A4%84%E7%90%86/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 多线程事务提交的处理">Java 多线程事务提交的处理</span>
            <span class="post-date" title="2024-08-21 16:32:52">2024/08/21</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2024/08/20/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%20Cache%20%E6%95%B4%E5%90%88%20Redis%20%E7%BC%93%E5%AD%98%E6%A1%86%E6%9E%B6/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot Cache 整合 Redis 缓存框架">SpringBoot Cache 整合 Redis 缓存框架</span>
            <span class="post-date" title="2024-08-20 16:11:47">2024/08/20</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringTransaction "
           href="/2024/08/16/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Transaction/Spring%20%E4%BA%8B%E5%8A%A1%E5%BA%94%E7%94%A8%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Spring 事务应用及源码分析">Spring 事务应用及源码分析</span>
            <span class="post-date" title="2024-08-16 10:33:57">2024/08/16</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringTransaction "
           href="/2024/08/16/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Transaction/Spring%20JDBC%20-%20NamedParameterJdbcTemplate/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Spring JDBC - NamedParameterJdbcTemplate">Spring JDBC - NamedParameterJdbcTemplate</span>
            <span class="post-date" title="2024-08-16 00:18:18">2024/08/16</span>
        </a>
        
        
        <a  class="全部文章 开发工具 "
           href="/2024/07/18/6%E3%80%81%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Git%20&%20GitHub/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Git &amp; GitHub">Git &amp; GitHub</span>
            <span class="post-date" title="2024-07-18 10:34:58">2024/07/18</span>
        </a>
        
        
        <a  class="全部文章 开发工具 Maven "
           href="/2024/06/28/6%E3%80%81%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Maven/Maven%20%E5%AE%9E%E6%88%98/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Maven 实战">Maven 实战</span>
            <span class="post-date" title="2024-06-28 16:50:35">2024/06/28</span>
        </a>
        
        
        <a  class="全部文章 数据库 "
           href="/2024/06/26/3%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%9D%A2%E8%AF%95%E5%AE%98%EF%BC%9A%E4%B8%8D%E4%BC%9A%E7%9C%8B%20Explain%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%EF%BC%8C%E7%AE%80%E5%8E%86%E6%95%A2%E5%86%99%20SQL%20%E4%BC%98%E5%8C%96%EF%BC%9F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="面试官：不会看 Explain执行计划，简历敢写 SQL 优化？">面试官：不会看 Explain执行计划，简历敢写 SQL 优化？</span>
            <span class="post-date" title="2024-06-26 19:33:03">2024/06/26</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/2024/04/22/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%AF%87%E4%B9%8B%20IDEA%20-%20VM%20Options%E3%80%81Program%20Arguments%E3%80%81Environment%20Variable%20%E8%A7%A3%E6%9E%90/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 命令行篇之 IDEA - VM Options、Program Arguments、Environment Variable 解析">Java 命令行篇之 IDEA - VM Options、Program Arguments、Environment Variable 解析</span>
            <span class="post-date" title="2024-04-22 10:53:10">2024/04/22</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2024/04/19/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6-%E9%85%8D%E7%BD%AE%E5%A4%96%E9%83%A8%E5%8C%96/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 配置文件-配置外部化">SpringBoot 2.x 配置文件-配置外部化</span>
            <span class="post-date" title="2024-04-19 09:18:55">2024/04/19</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/2024/04/16/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E5%8E%9F%E7%90%86%E7%AF%87%E4%B9%8B%20SPI%20%E6%9C%BA%E5%88%B6/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 原理篇之 SPI 机制">Java 原理篇之 SPI 机制</span>
            <span class="post-date" title="2024-04-16 17:26:15">2024/04/16</span>
        </a>
        
        
        <a  class="全部文章 开发工具 Maven "
           href="/2024/01/14/6%E3%80%81%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Maven/Maven%20%E6%95%99%E7%A8%8B%E4%B9%8B%20mirror%20&%20repository%20%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Maven 教程之 mirror &amp; repository 配置详解">Maven 教程之 mirror &amp; repository 配置详解</span>
            <span class="post-date" title="2024-01-14 22:51:03">2024/01/14</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2023/12/07/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E4%B8%BA%E4%BB%80%E4%B9%88SpringBoot%20jar%20%E5%8F%AF%E4%BB%A5%E7%9B%B4%E6%8E%A5%E8%BF%90%E8%A1%8C/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 为什么SpringBoot jar 可以直接运行">SpringBoot 2.x 为什么SpringBoot jar 可以直接运行</span>
            <span class="post-date" title="2023-12-07 15:13:56">2023/12/07</span>
        </a>
        
        
        <a  class="全部文章 Java基础篇 Java多线程 "
           href="/2023/12/04/1%E3%80%81JavaSE/1.Java%20%E5%9F%BA%E7%A1%80%E7%AF%87/5%E3%80%81Java%20%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%BF%9B%E9%98%B6/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 多线程进阶">Java 多线程进阶</span>
            <span class="post-date" title="2023-12-04 16:37:09">2023/12/04</span>
        </a>
        
        
        <a  class="全部文章 数据库 "
           href="/2023/11/18/3%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BB%BA%E6%A8%A1%E5%B7%A5%E5%85%B7%E6%B1%87%E6%80%BB/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="数据库建模工具汇总">数据库建模工具汇总</span>
            <span class="post-date" title="2023-11-18 15:31:11">2023/11/18</span>
        </a>
        
        
        <a  class="全部文章 JavaEE SSM框架 "
           href="/2023/10/08/2%E3%80%81JavaEE/2%E3%80%81SSM%E6%A1%86%E6%9E%B6/Mybatis/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Mybatis">Mybatis</span>
            <span class="post-date" title="2023-10-08 19:45:47">2023/10/08</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java性能测试与安全 "
           href="/2023/08/28/1%E3%80%81JavaSE/5.Java%20%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E4%B8%8E%E5%AE%89%E5%85%A8/Java%20%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E7%AF%87%E4%B9%8B%20%E5%8E%8B%E6%B5%8B%E5%B7%A5%E5%85%B7%E6%B1%87%E6%80%BB/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 性能测试篇之 压测工具汇总">Java 性能测试篇之 压测工具汇总</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java性能测试与安全 "
           href="/2023/08/28/1%E3%80%81JavaSE/5.Java%20%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E4%B8%8E%E5%AE%89%E5%85%A8/Java%20%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E7%AF%87%E4%B9%8B%20%E9%AB%98%E5%B9%B6%E5%8F%91%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87%EF%BC%9AQPS%E3%80%81TPS%E3%80%81RT%E3%80%81%E5%B9%B6%E5%8F%91%E6%95%B0%E3%80%81%E5%90%9E%E5%90%90%E9%87%8F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 性能测试篇之 高并发性能指标：QPS、TPS、RT、并发数、吞吐量">Java 性能测试篇之 高并发性能指标：QPS、TPS、RT、并发数、吞吐量</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java性能测试与安全 "
           href="/2023/08/28/1%E3%80%81JavaSE/5.Java%20%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E4%B8%8E%E5%AE%89%E5%85%A8/Java%20%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E7%AF%87%E4%B9%8B%20JMH%20%E5%B7%A5%E5%85%B7%E7%B1%BB/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 性能测试篇之 JMH 工具类">Java 性能测试篇之 JMH 工具类</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java性能测试与安全 "
           href="/2023/08/28/1%E3%80%81JavaSE/5.Java%20%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E4%B8%8E%E5%AE%89%E5%85%A8/Java%20%E5%AE%89%E5%85%A8%E7%AF%87%E4%B9%8B%20API%20%E6%8E%A5%E5%8F%A3%E9%98%B2%E6%AD%A2%E5%8F%82%E6%95%B0%E7%AF%A1%E6%94%B9%E5%92%8C%E9%87%8D%E6%94%BE%E6%94%BB%E5%87%BB/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 安全篇之 API 接口防止参数篡改和重放攻击">Java 安全篇之 API 接口防止参数篡改和重放攻击</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java性能测试与安全 "
           href="/2023/08/28/1%E3%80%81JavaSE/5.Java%20%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E4%B8%8E%E5%AE%89%E5%85%A8/Java%20%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E7%AF%87%E4%B9%8B%2048%E5%BC%A0%E5%9B%BE%E5%AD%A6%E4%BC%9A%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E3%80%81%E5%8E%8B%E6%B5%8B%E5%92%8C%E8%B0%83%E4%BC%98/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 性能测试篇之 48张图学会性能监控、压测和调优">Java 性能测试篇之 48张图学会性能监控、压测和调优</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 开发工具 "
           href="/2023/08/28/6%E3%80%81%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/IDEA%20%E6%8F%92%E4%BB%B6%E5%AE%89%E8%A3%85/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="IDEA 插件安装">IDEA 插件安装</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 开发工具 "
           href="/2023/08/28/6%E3%80%81%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/IDEA%20%E5%BF%AB%E6%8D%B7%E9%94%AE/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="IDEA 快捷键">IDEA 快捷键</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 开发工具 "
           href="/2023/08/28/6%E3%80%81%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/IDEA%20%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="IDEA 基本使用">IDEA 基本使用</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 开发工具 "
           href="/2023/08/28/6%E3%80%81%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/PostMan%20%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="PostMan 工具的使用">PostMan 工具的使用</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 开发工具 "
           href="/2023/08/28/6%E3%80%81%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Git/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Git">Git</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E4%BC%98%E5%8C%96%E7%AF%87%E4%B9%8B%20%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3%20%E6%A0%A1%E9%AA%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 优化篇之 自定义注解 校验数据库表中的数据不可重复">Java 优化篇之 自定义注解 校验数据库表中的数据不可重复</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E5%B7%A5%E5%85%B7%E7%AF%87%E4%B9%8B%20API%20%E6%8E%A5%E5%8F%A3%E5%85%8D%E8%B4%B9%20JSONPlaceholder/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 工具篇之 API 接口免费 JSONPlaceholder">Java 工具篇之 API 接口免费 JSONPlaceholder</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E5%B7%A5%E5%85%B7%E7%AF%87%E4%B9%8B%20%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E7%BB%9F%E8%AE%A1%E4%BB%A3%E7%A0%81%E8%80%97%E6%97%B6/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 工具篇之 如何优雅的统计代码耗时">Java 工具篇之 如何优雅的统计代码耗时</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B9%8B%20%E4%B8%8D%E5%8F%AF%E4%B8%8D%E7%9F%A5%E7%9A%84%207%20%E4%B8%AA%20JDK%20%E5%91%BD%E4%BB%A4/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 命令行之 不可不知的 7 个 JDK 命令">Java 命令行之 不可不知的 7 个 JDK 命令</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%AF%87%E4%B9%8B%20Window%20%E5%90%8E%E5%8F%B0%E5%90%AF%E5%8A%A8%20JAR%20%E7%A8%8B%E5%BA%8F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 命令行篇之 Window 后台启动 JAR 程序">Java 命令行篇之 Window 后台启动 JAR 程序</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E5%B7%A5%E5%85%B7%E7%AF%87%E4%B9%8B%20Lombok/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 工具篇之 Lombok">Java 工具篇之 Lombok</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E5%B7%A5%E5%85%B7%E7%AF%87%E4%B9%8B%20API%20%E6%96%87%E6%A1%A3%E5%B7%A5%E5%85%B7%20Swagger3.x-2.x/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 工具篇之 API 文档工具 Swagger3.x-2.x">Java 工具篇之 API 文档工具 Swagger3.x-2.x</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E5%B7%A5%E5%85%B7%E7%AF%87%E4%B9%8B%20%E6%8E%8C%E6%8F%A114%E7%A7%8DUML%E5%9B%BE/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 工具篇之 掌握14种UML图">Java 工具篇之 掌握14种UML图</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E5%B7%A5%E5%85%B7%E7%B1%BB%E4%B9%8B%20%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B7%A5%E5%85%B7%E7%B1%BB/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 工具类之 自定义工具类">Java 工具类之 自定义工具类</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20Bean%20%E4%B9%8B%20DTO%E3%80%81VO%E3%80%81PO%E3%80%81DO%E3%80%81BO%20%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java Bean 之 DTO、VO、PO、DO、BO 类的区别">Java Bean 之 DTO、VO、PO、DO、BO 类的区别</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20JSON%20%E7%AF%87%E4%B9%8B%20Jackson/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java JSON 篇之 Jackson">Java JSON 篇之 Jackson</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20JSON%20%E7%AF%87%E4%B9%8B%20Gson/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java JSON 篇之 Gson">Java JSON 篇之 Gson</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Curl%20%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%91%BD%E4%BB%A4%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Curl 的使用及命令参数说明">Curl 的使用及命令参数说明</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20JSON%20%E7%AF%87%E4%B9%8B%20FastJson/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java JSON 篇之 FastJson">Java JSON 篇之 FastJson</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Redis backup "
           href="/2023/08/28/5%E3%80%81%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/backup/Redis6/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Redis6">Redis6</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 中间件 Redis "
           href="/2023/08/28/5%E3%80%81%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/Redis-%E6%9C%80%E5%85%A8%E5%AE%9E%E6%88%98/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Redis-最全实战">Redis-最全实战</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 中间件 Redis "
           href="/2023/08/28/5%E3%80%81%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/Redis-%E4%BB%A3%E7%A0%81%E5%AE%9E%E6%88%98/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Redis-代码实战">Redis-代码实战</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 中间件 RabbitMQ "
           href="/2023/08/28/5%E3%80%81%E4%B8%AD%E9%97%B4%E4%BB%B6/RabbitMQ/RabbitMQ-3.8.14/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="RabbitMQ-3.8.14">RabbitMQ-3.8.14</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 中间件 RabbitMQ "
           href="/2023/08/28/5%E3%80%81%E4%B8%AD%E9%97%B4%E4%BB%B6/RabbitMQ/RabbitMQ-3.7.x/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="RabbitMQ-3.7.x">RabbitMQ-3.7.x</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 中间件 RabbitMQ "
           href="/2023/08/28/5%E3%80%81%E4%B8%AD%E9%97%B4%E4%BB%B6/RabbitMQ/RabbitMQ-3.8.14-%E5%8D%9A%E5%AE%A2%E7%89%88/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="RabbitMQ-3.8.14-博客版">RabbitMQ-3.8.14-博客版</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 中间件 MongoDB "
           href="/2023/08/28/5%E3%80%81%E4%B8%AD%E9%97%B4%E4%BB%B6/MongoDB/MongDB-4.4.2-%E5%8D%9A%E5%AE%A2%E7%89%88/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="MongDB-4.4.2-博客版">MongDB-4.4.2-博客版</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 中间件 MongoDB "
           href="/2023/08/28/5%E3%80%81%E4%B8%AD%E9%97%B4%E4%BB%B6/MongoDB/MongDB-4.4.2/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="MongDB-4.4.2">MongDB-4.4.2</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 中间件 ElasticSearch "
           href="/2023/08/28/5%E3%80%81%E4%B8%AD%E9%97%B4%E4%BB%B6/ElasticSearch/ElasticSearch7.6.x%E5%AE%9E%E6%88%98/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="ElasticSearch7.6.x实战">ElasticSearch7.6.x实战</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Linux 虚拟机工具 "
           href="/2023/08/28/4%E3%80%81Linux/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%B7%A5%E5%85%B7/Virtualbox%E7%BD%91%E7%BB%9C%E8%AE%BE%E7%BD%AE%E6%88%96%E9%85%8D%E7%BD%AE/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Virtualbox网络设置或配置">Virtualbox网络设置或配置</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Linux 虚拟机工具 "
           href="/2023/08/28/4%E3%80%81Linux/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%B7%A5%E5%85%B7/Virtualbox%E5%AE%89%E8%A3%85Centos7%E5%AE%9E%E6%88%98/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Virtualbox安装Centos7实战">Virtualbox安装Centos7实战</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Linux Kubernetes "
           href="/2023/08/28/4%E3%80%81Linux/Kubernetes/Minikube-k8s/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Minikube-k8s">Minikube-k8s</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Linux Kubernetes "
           href="/2023/08/28/4%E3%80%81Linux/Kubernetes/k0s%20%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B%EF%BC%9A%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%20Kubernetes%20%E9%9B%86%E7%BE%A4/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="k0s 使用教程：如何快速搭建 Kubernetes 集群">k0s 使用教程：如何快速搭建 Kubernetes 集群</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Linux Nginx "
           href="/2023/08/28/4%E3%80%81Linux/Nginx/Nginx-1.8.0/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Nginx-1.8.0">Nginx-1.8.0</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Linux Docker "
           href="/2023/08/28/4%E3%80%81Linux/Docker/Docker%E5%88%9D%E7%BA%A7%E5%88%B0%E5%AE%9E%E6%88%98/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Docker初级到实战">Docker初级到实战</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Linux Docker "
           href="/2023/08/28/4%E3%80%81Linux/Docker/Docker&Docker-Compose%E5%AE%9E%E6%88%98-%E5%93%88%E5%96%BD%E6%B2%83%E5%BE%B7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Docker&amp;Docker-Compose实战-哈喽沃德">Docker&amp;Docker-Compose实战-哈喽沃德</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 Spring "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring/Spring%20Bean%20%E7%9A%8412%E7%A7%8D%E5%AE%9A%E4%B9%89%E6%96%B9%E6%B3%95/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Spring Bean 的12种定义方法">Spring Bean 的12种定义方法</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 Spring "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring/Spring%20Bean%20%E7%9A%84%E5%8A%A8%E6%80%81%E5%88%9B%E5%BB%BA%E8%8E%B7%E5%8F%96%E5%88%A0%E9%99%A4/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Spring Bean 的动态创建获取删除">Spring Bean 的动态创建获取删除</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 Spring "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring/Spring%20Bean%20%E6%B3%A8%E5%85%A5%E7%9A%843%E7%A7%8D%E6%96%B9%E5%BC%8F,%20%E4%B8%BA%E4%BD%95%E5%AE%98%E6%96%B9%E5%BB%BA%E8%AE%AE%E4%BD%BF%E7%94%A8%E6%9E%84%E9%80%A0%E5%99%A8%E6%B3%A8%E5%85%A5/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Spring Bean 注入的3种方式, 为何官方建议使用构造器注入">Spring Bean 注入的3种方式, 为何官方建议使用构造器注入</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 SpringTransaction 多数据源事务处理 "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Transaction/%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/Spring%20%E8%A7%A3%E5%86%B3%E5%8D%95%E6%9C%BA%E7%8E%AF%E5%A2%83%E4%B8%8B%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E7%9A%84%E4%BA%8B%E5%8A%A1%E9%97%AE%E9%A2%98/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Spring 解决单机环境下多数据源的事务问题">Spring 解决单机环境下多数据源的事务问题</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 SpringTransaction 多数据源事务处理 "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Transaction/%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/Spring%20%E5%AE%9E%E7%8E%B0%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E5%AE%9E%E6%88%98/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Spring 实现多数据源实战">Spring 实现多数据源实战</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 SpringTransaction 多数据源事务处理 "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Transaction/%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/Spring%20%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81%E6%95%B0%E6%8D%AE%E6%BA%90%E3%80%81%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E5%88%87%E6%8D%A2%E6%96%B9%E5%BC%8F%E3%80%81%E5%A4%9A%E6%95%B0%E6%8D%AE%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Spring 实现动态数据源、多数据源切换方式、多数据事务管理">Spring 实现动态数据源、多数据源切换方式、多数据事务管理</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringTransaction "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Transaction/Spring%20%E4%BA%8B%E5%8A%A1%E5%8E%9F%E7%90%86%E6%B7%B1%E5%85%A5%E4%B8%8E%E5%88%86%E6%9E%90/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Spring 事务原理深入与分析">Spring 事务原理深入与分析</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringTransaction "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Transaction/JDBC/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="JDBC">JDBC</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringTransaction "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Transaction/Spring%20JDBC%20-%20JdbcTemplate/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Spring JDBC - JdbcTemplate">Spring JDBC - JdbcTemplate</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringSecurity "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Security/SpringSecurity/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringSecurity">SpringSecurity</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 SpringTransaction 多线程下事务处理 "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Transaction/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8B%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/JDBC%E6%89%B9%E5%A4%84%E7%90%86%E5%AE%9E%E7%8E%B0%E6%89%8B%E5%8A%A8%E4%BA%8B%E5%8A%A1%E6%8F%92%E5%85%A51000%E4%B8%87%E6%95%B0%E6%8D%AE%EF%BC%88%E5%8D%95%E7%BA%BF%E7%A8%8B%20&%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%89/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="JDBC批处理实现手动事务插入1000万数据（单线程 &amp; 多线程）">JDBC批处理实现手动事务插入1000万数据（单线程 &amp; 多线程）</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringDataJPA "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Data%20JPA/SpringData%20JPA%20%E7%B1%BB%E5%9B%BE%E5%8F%8A%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringData JPA 类图及使用方法整理">SpringData JPA 类图及使用方法整理</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringDataJPA "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Data%20JPA/SpringData%20JPA/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringData JPA">SpringData JPA</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringDataJPA "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Data%20JPA/Spring%20Data%20JPA%20%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E6%88%98/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Spring Data JPA 原理与实战">Spring Data JPA 原理与实战</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringDataJPA "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Data%20JPA/Hibernata%20JPA/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Hibernata JPA">Hibernata JPA</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringCloudAlibaba "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Cloud%20Alibaba/SpringCloud%20Alibaba/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringCloud Alibaba">SpringCloud Alibaba</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot2.x%20%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AF%87%20-%20%E6%95%B4%E5%90%88H2%E6%95%B0%E6%8D%AE%E5%BA%93/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot2.x 数据库篇 - 整合H2数据库">SpringBoot2.x 数据库篇 - 整合H2数据库</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AD%A6/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot从零开始学">SpringBoot从零开始学</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot2.x%20%E9%A1%B9%E7%9B%AE%E7%BB%9F%E4%B8%80%E6%9E%9A%E4%B8%BE%E8%BD%AC%E6%8D%A2%E5%AE%9E%E8%B7%B5/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot2.x 项目统一枚举转换实践">SpringBoot2.x 项目统一枚举转换实践</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SprinigBoot%E6%96%87%E7%AB%A0%E6%91%98%E8%A6%81%E5%8F%8A%E8%BD%AC%E8%BD%BD/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SprinigBoot文章摘要及转载">SprinigBoot文章摘要及转载</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%E9%85%8D%E7%BD%AE%E5%B1%9E%E6%80%A7%E4%B9%8BDataSource/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot配置属性之DataSource">SpringBoot配置属性之DataSource</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/%E4%BB%A3%E7%A0%81%E5%AE%A1%E6%9F%A5%E7%9A%84%E5%BF%85%E8%A6%81%E6%80%A7%E5%92%8C%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="代码审查的必要性和最佳实践">代码审查的必要性和最佳实践</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6-%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9A%84N%E7%A7%8D%E6%96%B9%E5%BC%8F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 配置文件-读取配置文件的N种方式">SpringBoot 2.x 配置文件-读取配置文件的N种方式</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6-%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%B9%8B@Value%E8%BF%9B%E9%98%B6/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 配置文件-读取配置文件之@Value进阶">SpringBoot 2.x 配置文件-读取配置文件之@Value进阶</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E7%BB%9F%E4%B8%80%E6%8E%A5%E5%8F%A3%E8%BF%94%E5%9B%9E%E6%A0%BC%E5%BC%8F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 统一接口返回格式">SpringBoot 2.x 统一接口返回格式</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6-%E8%AF%BB%E5%8F%96%20Resources%20%E6%96%87%E4%BB%B6%E4%B9%8B%E6%97%A0%E6%B3%95%E8%AF%BB%E5%8F%96Jar%E5%8C%85classpath%E4%B8%8B%E7%9A%84%E6%96%87%E4%BB%B6/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 配置文件-读取 Resources 文件之无法读取Jar包classpath下的文件">SpringBoot 2.x 配置文件-读取 Resources 文件之无法读取Jar包classpath下的文件</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6-%E8%AF%BB%E5%8F%96%20Resources%20%E6%96%87%E4%BB%B6%E7%9A%84N%E7%A7%8D%E6%96%B9%E5%BC%8F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 配置文件-读取 Resources 文件的N种方式">SpringBoot 2.x 配置文件-读取 Resources 文件的N种方式</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B%E7%AF%87-%E6%8B%A6%E6%88%AA%E5%99%A8%E8%BF%87%E6%BB%A4%E5%99%A8%E4%B8%8E%E7%9B%91%E5%90%AC%E5%99%A8/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 切面编程篇-拦截器过滤器与监听器">SpringBoot 2.x 切面编程篇-拦截器过滤器与监听器</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3%E8%AF%A6%E8%A7%A3/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 常用注解详解">SpringBoot 2.x 常用注解详解</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E5%AE%89%E5%85%A8%E5%AF%86%E7%A0%81%E5%AD%A6%E4%B9%8B%E5%8A%A0%E8%A7%A3%E5%AF%86%E7%AE%97%E6%B3%95/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 安全密码学之加解密算法">SpringBoot 2.x 安全密码学之加解密算法</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3%E5%A4%A7%E5%85%A8/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 常用注解大全">SpringBoot 2.x 常用注解大全</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E5%90%AF%E5%8A%A8%E6%97%B6%E5%8A%A0%E8%BD%BD%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84N%E7%A7%8D%E6%96%B9%E5%BC%8F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 启动时加载初始化的N种方式">SpringBoot 2.x 启动时加载初始化的N种方式</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%8F%8A%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E8%BF%87%E7%A8%8B/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 启动流程及自动装配过程">SpringBoot 2.x 启动流程及自动装配过程</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E5%8A%A8%E6%80%81%E8%A3%85%E9%85%8DBean%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 动态装配Bean的三种方式">SpringBoot 2.x 动态装配Bean的三种方式</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E5%88%A9%E5%99%A8-1%20JUnit5/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 单元测试利器-1 JUnit5">SpringBoot 2.x 单元测试利器-1 JUnit5</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E5%88%A9%E5%99%A8-3%20MockMvc/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 单元测试利器-3 MockMvc">SpringBoot 2.x 单元测试利器-3 MockMvc</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E5%88%A9%E5%99%A8-2%20Mockito/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 单元测试利器-2 Mockito">SpringBoot 2.x 单元测试利器-2 Mockito</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E5%88%86%E7%89%87%E4%B8%8A%E4%BC%A0%E3%80%81%E6%96%AD%E7%82%B9%E7%BB%AD%E4%BC%A0%E3%80%81%E5%A4%A7%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E3%80%81%E7%A7%92%E4%BC%A0/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 分片上传、断点续传、大文件上传、秒传">SpringBoot 2.x 分片上传、断点续传、大文件上传、秒传</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20Validation%20%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C%EF%BC%88TODO%EF%BC%89/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x Validation 参数校验（TODO）">SpringBoot 2.x Validation 参数校验（TODO）</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20WebMvcConfigurer%20%E8%AF%A6%E8%A7%A3%E3%80%90SpringMVC%E3%80%91/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x WebMvcConfigurer 详解【SpringMVC】">SpringBoot 2.x WebMvcConfigurer 详解【SpringMVC】</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20YML%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x YML配置文件详解">SpringBoot 2.x YML配置文件详解</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E5%88%86%E5%B8%83%E5%BC%8F%E5%85%A8%E5%B1%80%E5%94%AF%E4%B8%80ID%E7%94%9F%E6%88%90%E6%96%B9%E6%A1%88/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 分布式全局唯一ID生成方案">SpringBoot 2.x 分布式全局唯一ID生成方案</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20JWT%20%E6%A6%82%E5%BF%B5%E7%AF%87/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x JWT 概念篇">SpringBoot 2.x JWT 概念篇</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20Jar%20%E5%8C%85%E5%90%AF%E5%8A%A8%E3%80%81%E5%81%9C%E6%AD%A2%E3%80%81%E9%87%8D%E5%90%AF%E8%84%9A%E6%9C%AC/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x Jar 包启动、停止、重启脚本">SpringBoot 2.x Jar 包启动、停止、重启脚本</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20Java%20%E7%A8%8B%E5%BA%8F%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0%E6%80%BB%E7%BB%93/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x Java 程序命令行参数总结">SpringBoot 2.x Java 程序命令行参数总结</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20Java%20%E5%AE%9E%E7%8E%B0%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E7%9A%848%E7%A7%8D%E6%96%B9%E5%BC%8F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x Java 实现异步编程的8种方式">SpringBoot 2.x Java 实现异步编程的8种方式</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20@ConfigurationProperties%E4%BB%A5%E5%8F%8A@NestedConfigurationProperty%E7%9A%84%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x @ConfigurationProperties以及@NestedConfigurationProperty的使用详解">SpringBoot 2.x @ConfigurationProperties以及@NestedConfigurationProperty的使用详解</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20@ControllerAdvice%E4%B8%89%E7%A7%8D%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x @ControllerAdvice三种使用场景">SpringBoot 2.x @ControllerAdvice三种使用场景</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20HTTP%20Content-Type%20%E8%AF%A6%E8%A7%A3/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x HTTP Content-Type 详解">SpringBoot 2.x HTTP Content-Type 详解</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20HTTP%20Headers%20%E5%A4%B4%E4%BF%A1%E6%81%AF%E8%AF%BB%E5%8F%96/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x HTTP Headers 头信息读取">SpringBoot 2.x HTTP Headers 头信息读取</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20JWT%20%E5%AE%9E%E6%88%98%E7%AF%87/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x JWT 实战篇">SpringBoot 2.x JWT 实战篇</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%20%E6%8E%A5%E5%8F%A3%E5%B9%82%E7%AD%89%E6%80%A7%E5%AE%9E%E7%8E%B0/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x  接口幂等性实现">SpringBoot 2.x  接口幂等性实现</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/Spring%20IO%20Platform%EF%BC%9A%E8%A7%A3%E5%86%B3%E4%BE%9D%E8%B5%96%E7%89%88%E6%9C%AC%E5%86%B2%E7%AA%81/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Spring IO Platform：解决依赖版本冲突">Spring IO Platform：解决依赖版本冲突</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B%E7%AF%87-AOP%20%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%8E%9F%E7%90%86/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 切面编程篇-AOP 的使用及原理">SpringBoot 2.x 切面编程篇-AOP 的使用及原理</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE SSM框架 "
           href="/2023/08/28/2%E3%80%81JavaEE/2%E3%80%81SSM%E6%A1%86%E6%9E%B6/SpringMVC/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringMVC">SpringMVC</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 Shiro "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Shiro/Shiro%E6%9D%83%E9%99%90%E5%AE%9E%E6%88%98%E8%AF%BE%E7%A8%8B/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Shiro权限实战课程">Shiro权限实战课程</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 Shiro "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Shiro/Shiro%E6%9D%83%E9%99%90%E5%AE%9E%E6%88%98/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Shiro权限实战">Shiro权限实战</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE SSM框架 "
           href="/2023/08/28/2%E3%80%81JavaEE/2%E3%80%81SSM%E6%A1%86%E6%9E%B6/Spring/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Spring">Spring</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE SSM框架 "
           href="/2023/08/28/2%E3%80%81JavaEE/2%E3%80%81SSM%E6%A1%86%E6%9E%B6/MybatisPlus/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="MybatisPlus">MybatisPlus</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE JavaWeb "
           href="/2023/08/28/2%E3%80%81JavaEE/1%E3%80%81JavaWeb/%E4%BD%A0%E8%BF%98%E5%9C%A8%E4%B8%BA%20HTTP%20%E7%9A%84%E8%BF%99%E4%BA%9B%E6%A6%82%E5%BF%B5%E5%A4%B4%E7%96%BC%E5%90%97/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="你还在为 HTTP 的这些概念头疼吗">你还在为 HTTP 的这些概念头疼吗</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE JavaWeb "
           href="/2023/08/28/2%E3%80%81JavaEE/1%E3%80%81JavaWeb/Cookie%E3%80%81Session%E3%80%81Token%E3%80%81JWT%E7%BB%88%E4%BA%8E%E8%AE%B2%E6%B8%85%E6%A5%9A%E4%BA%86/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Cookie、Session、Token、JWT终于讲清楚了">Cookie、Session、Token、JWT终于讲清楚了</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 数据库 "
           href="/2023/08/28/3%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL-%E9%AB%98%E7%BA%A7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="MySQL-高级">MySQL-高级</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 数据库 "
           href="/2023/08/28/3%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL-%E5%88%9D%E7%BA%A7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="MySQL-初级">MySQL-初级</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 数据库 "
           href="/2023/08/28/3%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93/H2%20Database/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="H2 Database">H2 Database</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E4%BC%98%E5%8C%96%E7%AF%87%E4%B9%8B%20%E5%BB%B6%E6%97%B6%E9%98%9F%E5%88%97%20-%20%E8%AE%A2%E5%8D%95%E8%B6%85%E6%97%B6%E8%87%AA%E5%8A%A8%E5%8F%96%E6%B6%88%E7%9A%84N%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 优化篇之 延时队列 - 订单超时自动取消的N种实现方式">Java 优化篇之 延时队列 - 订单超时自动取消的N种实现方式</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E4%BC%98%E5%8C%96%E7%AF%87%E4%B9%8B%20%E6%B3%A8%E8%A7%A3%20+%20%E5%8F%8D%E5%B0%84%E6%B6%88%E9%99%A4%E9%87%8D%E5%A4%8D%E4%BB%A3%E7%A0%81/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 优化篇之 注解 + 反射消除重复代码">Java 优化篇之 注解 + 反射消除重复代码</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E9%9B%86%E5%90%88%E7%AF%87%E4%B9%8B%20%E8%8E%B7%E5%8F%96%E4%B8%A4%E4%B8%AA%E9%9B%86%E5%90%88List%E7%9A%84%E4%BA%A4%E9%9B%86%E3%80%81%E8%A1%A5%E9%9B%86%E3%80%81%E5%B9%B6%E9%9B%86%E3%80%81%E5%B7%AE%E9%9B%86%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 集合篇之 获取两个集合List的交集、补集、并集、差集的几种方式">Java 集合篇之 获取两个集合List的交集、补集、并集、差集的几种方式</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E4%BC%98%E5%8C%96%E7%AF%87%E4%B9%8B%20if-else%20%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 优化篇之 if-else 代码优化方案">Java 优化篇之 if-else 代码优化方案</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4%E5%90%84%E7%B1%BB%E5%9E%8B%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 日期时间各类型相互转换">Java 日期时间各类型相互转换</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E9%9B%86%E5%90%88%E7%AF%87%E4%B9%8B%20Lambda%20%E5%AE%9E%E7%8E%B0%E8%B6%85%E5%BC%BA%E6%8E%92%E5%BA%8F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 集合篇之 Lambda 实现超强排序">Java 集合篇之 Lambda 实现超强排序</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E5%9F%BA%E6%9C%AC%E5%8A%9F%E7%AF%87%E4%B9%8B%20for%E3%80%81for-each%E3%80%81forEach()%20%E7%9A%84%20break%E3%80%81continue%E3%80%81return/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 基本功篇之 for、for-each、forEach() 的 break、continue、return">Java 基本功篇之 for、for-each、forEach() 的 break、continue、return</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 动态代理">Java 动态代理</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6%E8%AF%A6%E8%A7%A3/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 日志框架详解">Java 日志框架详解</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java新特性 "
           href="/2023/08/28/1%E3%80%81JavaSE/3.Java%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%20%E6%96%B0%E7%89%B9%E6%80%A7%E6%A6%82%E8%BF%B0%E5%8F%8A%E7%89%88%E6%9C%AC%E5%8F%91%E8%A1%8C%E5%8F%B2/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 新特性概述及版本发行史">Java 新特性概述及版本发行史</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20Bean%20%E4%B9%8B%20Record%20%E7%B1%BB/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java Bean 之 Record 类">Java Bean 之 Record 类</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E4%BC%98%E5%8C%96%E7%AF%87%E4%B9%8B%20GZIP%E5%8E%8B%E7%BC%A9%E5%AD%97%E7%AC%A6%E4%B8%B2/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 优化篇之 GZIP压缩字符串">Java 优化篇之 GZIP压缩字符串</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java进阶篇 JVM虚拟机 "
           href="/2023/08/28/1%E3%80%81JavaSE/2.Java%20%E8%BF%9B%E9%98%B6%E7%AF%87/JVM%20%E8%99%9A%E6%8B%9F%E6%9C%BA/Java%20GC%20%E6%80%BB%E7%BB%93/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java GC 总结">Java GC 总结</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java新特性 Java9新特性 "
           href="/2023/08/28/1%E3%80%81JavaSE/3.Java%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%209%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%209%20%E6%96%B0%E7%89%B9%E6%80%A7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 9 新特性">Java 9 新特性</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java新特性 Java8新特性 "
           href="/2023/08/28/1%E3%80%81JavaSE/3.Java%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%208%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%208%20%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8B%20Optional%20%E7%B1%BB/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 8 新特性之 Optional 类">Java 8 新特性之 Optional 类</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java新特性 Java8新特性 "
           href="/2023/08/28/1%E3%80%81JavaSE/3.Java%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%208%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%208%20%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8B%20Stream%20%E6%B5%81/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 8 新特性之 Stream 流">Java 8 新特性之 Stream 流</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java新特性 Java8新特性 "
           href="/2023/08/28/1%E3%80%81JavaSE/3.Java%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%208%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%208%20%E6%96%B0%E7%89%B9%E6%80%A7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 8 新特性">Java 8 新特性</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java新特性 Java8新特性 "
           href="/2023/08/28/1%E3%80%81JavaSE/3.Java%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%208%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%208%20%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8B%20DateTime%20API/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 8 新特性之 DateTime API">Java 8 新特性之 DateTime API</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java新特性 Java18新特性 "
           href="/2023/08/28/1%E3%80%81JavaSE/3.Java%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2018%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2018%20%E6%96%B0%E7%89%B9%E6%80%A7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 18 新特性">Java 18 新特性</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java新特性 Java20新特性 "
           href="/2023/08/28/1%E3%80%81JavaSE/3.Java%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2020%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2020%20%E6%96%B0%E7%89%B9%E6%80%A7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 20 新特性">Java 20 新特性</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java新特性 Java19新特性 "
           href="/2023/08/28/1%E3%80%81JavaSE/3.Java%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2019%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2019%20%E6%96%B0%E7%89%B9%E6%80%A7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 19 新特性">Java 19 新特性</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java新特性 Java17新特性 "
           href="/2023/08/28/1%E3%80%81JavaSE/3.Java%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2017%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2017%20%E6%96%B0%E7%89%B9%E6%80%A7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 17 新特性">Java 17 新特性</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java新特性 Java15新特性 "
           href="/2023/08/28/1%E3%80%81JavaSE/3.Java%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2015%E6%96%B0%E7%89%B9%E6%80%A7/Java%2015%20%E6%96%B0%E7%89%B9%E6%80%A7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 15 新特性">Java 15 新特性</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java新特性 Java16新特性 "
           href="/2023/08/28/1%E3%80%81JavaSE/3.Java%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2016%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2016%20%E6%96%B0%E7%89%B9%E6%80%A7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 16 新特性">Java 16 新特性</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java新特性 Java13新特性 "
           href="/2023/08/28/1%E3%80%81JavaSE/3.Java%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2013%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2013%20%E6%96%B0%E7%89%B9%E6%80%A7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 13 新特性">Java 13 新特性</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java新特性 Java14新特性 "
           href="/2023/08/28/1%E3%80%81JavaSE/3.Java%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2014%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2014%20%E6%96%B0%E7%89%B9%E6%80%A7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 14 新特性">Java 14 新特性</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java新特性 Java12新特性 "
           href="/2023/08/28/1%E3%80%81JavaSE/3.Java%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2012%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2012%20%E6%96%B0%E7%89%B9%E6%80%A7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 12 新特性">Java 12 新特性</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java新特性 Java10新特性 "
           href="/2023/08/28/1%E3%80%81JavaSE/3.Java%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2010%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2010%20%E6%96%B0%E7%89%B9%E6%80%A7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 10 新特性">Java 10 新特性</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java新特性 Java11新特性 "
           href="/2023/08/28/1%E3%80%81JavaSE/3.Java%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2011%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2011%20%E6%96%B0%E7%89%B9%E6%80%A7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 11 新特性">Java 11 新特性</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java基础篇 Java基础语法 "
           href="/2023/08/28/1%E3%80%81JavaSE/1.Java%20%E5%9F%BA%E7%A1%80%E7%AF%87/1%E3%80%81Java%20%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/Java%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 面向对象编程">Java 面向对象编程</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java基础篇 Java集合类 "
           href="/2023/08/28/1%E3%80%81JavaSE/1.Java%20%E5%9F%BA%E7%A1%80%E7%AF%87/3%E3%80%81Java%20%E9%9B%86%E5%90%88%E7%B1%BB/Java%20%E7%B1%BB%E9%9B%86%E6%A1%86%E6%9E%B6/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 类集框架">Java 类集框架</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java基础篇 Java常用类库 "
           href="/2023/08/28/1%E3%80%81JavaSE/1.Java%20%E5%9F%BA%E7%A1%80%E7%AF%87/2%E3%80%81Java%20%E5%B8%B8%E7%94%A8%E7%B1%BB%E5%BA%93/Java%20%E5%B8%B8%E7%94%A8%E7%B1%BB%E5%BA%93/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 常用类库">Java 常用类库</span>
            <span class="post-date" title="2023-08-28 09:23:44">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java基础篇 Java多线程 "
           href="/2023/08/28/1%E3%80%81JavaSE/1.Java%20%E5%9F%BA%E7%A1%80%E7%AF%87/5%E3%80%81Java%20%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 多线程基础">Java 多线程基础</span>
            <span class="post-date" title="2023-08-28 09:23:44">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java基础篇 Java反射与注解 "
           href="/2023/08/28/1%E3%80%81JavaSE/1.Java%20%E5%9F%BA%E7%A1%80%E7%AF%87/4%E3%80%81Java%20%E5%8F%8D%E5%B0%84%E4%B8%8E%E6%B3%A8%E8%A7%A3/Java%20%E5%8F%8D%E5%B0%84%E4%B8%8E%E6%B3%A8%E8%A7%A3/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 反射与注解">Java 反射与注解</span>
            <span class="post-date" title="2023-08-28 09:23:44">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java基础篇 JavaNIO流 "
           href="/2023/08/28/1%E3%80%81JavaSE/1.Java%20%E5%9F%BA%E7%A1%80%E7%AF%87/7%E3%80%81Java%20NIO%20%E6%B5%81/Java%20NIO%20%E6%B5%81/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java NIO 流">Java NIO 流</span>
            <span class="post-date" title="2023-08-28 09:23:44">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java基础篇 JavaIO流 "
           href="/2023/08/28/1%E3%80%81JavaSE/1.Java%20%E5%9F%BA%E7%A1%80%E7%AF%87/6%E3%80%81Java%20IO%20%E6%B5%81/Java%20IO%20%E6%B5%81/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java IO 流">Java IO 流</span>
            <span class="post-date" title="2023-08-28 09:23:44">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java进阶篇 Java设计模式 "
           href="/2023/08/28/1%E3%80%81JavaSE/2.Java%20%E8%BF%9B%E9%98%B6%E7%AF%87/Java%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/Java%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 设计模式">Java 设计模式</span>
            <span class="post-date" title="2023-08-28 09:23:44">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java进阶篇 JVM虚拟机 "
           href="/2023/08/28/1%E3%80%81JavaSE/2.Java%20%E8%BF%9B%E9%98%B6%E7%AF%87/JVM%20%E8%99%9A%E6%8B%9F%E6%9C%BA/JVM%20%E8%99%9A%E6%8B%9F%E6%9C%BA/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="JVM 虚拟机">JVM 虚拟机</span>
            <span class="post-date" title="2023-08-28 09:23:44">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java进阶篇 JVM虚拟机 "
           href="/2023/08/28/1%E3%80%81JavaSE/2.Java%20%E8%BF%9B%E9%98%B6%E7%AF%87/JVM%20%E8%99%9A%E6%8B%9F%E6%9C%BA/7%20%E6%AE%B5%E5%B0%8F%E4%BB%A3%E7%A0%81%EF%BC%8C%E7%8E%A9%E8%BD%ACJava%E7%A8%8B%E5%BA%8F%E5%B8%B8%E8%A7%81%E7%9A%84%E5%B4%A9%E6%BA%83%E5%9C%BA%E6%99%AF/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="7 段小代码，玩转Java程序常见的崩溃场景">7 段小代码，玩转Java程序常见的崩溃场景</span>
            <span class="post-date" title="2023-08-28 09:23:44">2023/08/28</span>
        </a>
        
        <div id="no-item-tips">

        </div>
    </nav>
    <div id="outline-list">
    </div>
</div>

    </div>
    <div class="hide-list">
        <div class="semicircle" data-title="切换全屏 快捷键 s">
            <div class="brackets first"><</div>
            <div class="brackets">&gt;</div>
        </div>
    </div>
</aside>
<div id="post">
    <div class="pjax">
        <article id="post-2、JavaEE/3、微服务开发/Spring Transaction/多数据源事务处理/Spring 实现多数据源实战" class="article article-type-post" itemscope itemprop="blogPost">
    
        <h1 class="article-title">Spring 实现多数据源实战</h1>
    
    <div class="article-meta">
        
        
        
        <span class="book">
            <i class="iconfont icon-category"></i>
            
            
            <a  data-rel="SpringTransaction">SpringTransaction</a> > 
            
            <a  data-rel="SpringTransaction&lt;---&gt;多数据源事务处理">多数据源事务处理</a>
            
        </span>
        
        
    </div>
    <div class="article-meta">
        
            发布时间 : <time class="date" title='最后更新: 2024-10-20 00:48:33'>2023-08-28 09:23</time>
        
    </div>
    <div class="article-meta">
        
        
        <span id="busuanzi_container_page_pv">
            阅读 :<span id="busuanzi_value_page_pv">
                <span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </span>
        </span>
        
        
    </div>
    
    <div class="toc-ref">
    
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1%E3%80%81SpringBoot-%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E5%89%8D%E8%A8%80"><span class="toc-text">1、SpringBoot 多数据源前言</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">1、使用场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90"><span class="toc-text">2、思路分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-text">3、实现方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E4%BA%8B%E5%8A%A1%E5%88%86%E6%9E%90"><span class="toc-text">4、事务分析</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2%E3%80%81SpringBoot-%E9%9D%99%E6%80%81%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90"><span class="toc-text">2、SpringBoot 静态多数据源</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81JdbcTemplate-H2-%E9%9D%99%E6%80%81%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E9%85%8D%E7%BD%AE"><span class="toc-text">1、JdbcTemplate + H2 静态多数据源配置</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE%E5%B7%A5%E7%A8%8B"><span class="toc-text">1、搭建项目工程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E9%85%8D%E7%BD%AE"><span class="toc-text">2、多数据源配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E4%BD%BF%E7%94%A8"><span class="toc-text">3、多数据源使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81spring-data-jdbc-%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E9%85%8D%E7%BD%AE%E5%8F%8A%E4%BD%BF%E7%94%A8"><span class="toc-text">4、spring-data-jdbc 多数据源配置及使用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81Mybatis-H2-%E9%9D%99%E6%80%81%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E9%85%8D%E7%BD%AE"><span class="toc-text">2、Mybatis + H2 静态多数据源配置</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE%E5%B7%A5%E7%A8%8B-1"><span class="toc-text">1、搭建项目工程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E9%85%8D%E7%BD%AE-1"><span class="toc-text">2、多数据源配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E4%BD%BF%E7%94%A8-1"><span class="toc-text">3、多数据源使用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81Spring-Data-JPA-H2-%E9%9D%99%E6%80%81%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E9%85%8D%E7%BD%AE"><span class="toc-text">3、Spring Data JPA + H2 静态多数据源配置</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE%E5%B7%A5%E7%A8%8B-2"><span class="toc-text">1、搭建项目工程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E9%85%8D%E7%BD%AE-2"><span class="toc-text">2、多数据源配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E4%BD%BF%E7%94%A8-2"><span class="toc-text">3、多数据源使用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E9%9D%99%E6%80%81%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">4、静态多数据源优缺点</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3%E3%80%81SpringBoot-%E5%8A%A8%E6%80%81%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90"><span class="toc-text">3、SpringBoot 动态多数据源</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81JdbcTemplate-H2-%E5%8A%A8%E6%80%81%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E9%85%8D%E7%BD%AE"><span class="toc-text">1、JdbcTemplate + H2 动态多数据源配置</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E5%8A%A8%E6%80%81%E6%95%B0%E6%8D%AE%E6%BA%90%E9%85%8D%E7%BD%AE"><span class="toc-text">1、动态数据源配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E5%8A%A8%E6%80%81%E6%95%B0%E6%8D%AE%E6%BA%90%E8%AE%BE%E7%BD%AE"><span class="toc-text">2、动态数据源设置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E5%8A%A8%E6%80%81%E6%95%B0%E6%8D%AE%E7%9A%84%E4%BD%BF%E7%94%A8%E3%80%90%E6%89%8B%E5%8A%A8%E5%88%87%E6%8D%A2%E3%80%91"><span class="toc-text">3、动态数据的使用【手动切换】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E5%8A%A8%E6%80%81%E6%95%B0%E6%8D%AE%E6%BA%90%E4%BD%BF%E7%94%A8%E3%80%90AOP%E5%88%87%E6%8D%A2%E3%80%91"><span class="toc-text">4、动态数据源使用【AOP切换】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81spring-data-jdbc-%E5%8A%A8%E6%80%81%E6%95%B0%E6%8D%AE%E6%BA%90%E6%89%8B%E5%8A%A8%E5%8F%8AAOP%E5%88%87%E6%8D%A2"><span class="toc-text">5、spring-data-jdbc 动态数据源手动及AOP切换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81Mybatis-H2-%E5%8A%A8%E6%80%81%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E9%85%8D%E7%BD%AE"><span class="toc-text">2、Mybatis + H2 动态多数据源配置</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E5%8A%A8%E6%80%81%E6%95%B0%E6%8D%AE%E6%BA%90%E9%85%8D%E7%BD%AE-1"><span class="toc-text">1、动态数据源配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E5%8A%A8%E6%80%81%E6%95%B0%E6%8D%AE%E6%BA%90%E8%AE%BE%E7%BD%AE-1"><span class="toc-text">2、动态数据源设置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E5%8A%A8%E6%80%81%E6%95%B0%E6%8D%AE%E6%BA%90%E4%BD%BF%E7%94%A8%E3%80%90%E6%89%8B%E5%8A%A8%E5%88%87%E6%8D%A2%E3%80%91"><span class="toc-text">3、动态数据源使用【手动切换】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E5%8A%A8%E6%80%81%E6%95%B0%E6%8D%AE%E6%BA%90%E4%BD%BF%E7%94%A8%E3%80%90AOP%E5%88%87%E6%8D%A2%E3%80%91-1"><span class="toc-text">4、动态数据源使用【AOP切换】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81Spring-Data-JPA-H2-%E5%8A%A8%E6%80%81%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E9%85%8D%E7%BD%AE"><span class="toc-text">3、Spring Data JPA + H2 动态多数据源配置</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E5%8A%A8%E6%80%81%E6%95%B0%E6%8D%AE%E6%BA%90%E9%85%8D%E7%BD%AE-2"><span class="toc-text">1、动态数据源配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E5%8A%A8%E6%80%81%E6%95%B0%E6%8D%AE%E6%BA%90%E8%AE%BE%E7%BD%AE-2"><span class="toc-text">2、动态数据源设置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E5%8A%A8%E6%80%81%E6%95%B0%E6%8D%AE%E6%BA%90%E4%BD%BF%E7%94%A8%E3%80%90%E6%89%8B%E5%8A%A8%E5%88%87%E6%8D%A2%E3%80%91-1"><span class="toc-text">3、动态数据源使用【手动切换】</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E6%95%B0%E6%8D%AE%E8%A1%A8%E5%AF%B9%E5%BA%94%E5%AE%9E%E4%BD%93%E7%B1%BB%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-text">1、数据表对应实体类的创建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E6%95%B0%E6%8D%AE%E6%BA%90%E9%9C%80%E8%A6%81%E7%9A%84-Repository-%E6%8E%A5%E5%8F%A3%E5%88%9B%E5%BB%BA"><span class="toc-text">2、数据源需要的 Repository 接口创建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA-Controller%E4%BD%BF%E7%94%A8%E5%8A%A8%E6%80%81%E6%95%B0%E6%8D%AE%E6%BA%90"><span class="toc-text">3、编写一个 Controller使用动态数据源</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81%E6%B5%8B%E8%AF%95-PostConstruct-%E5%86%85%E5%8A%A8%E6%80%81%E5%88%87%E6%8D%A2%E6%95%B0%E6%8D%AE%E6%BA%90"><span class="toc-text">4、测试 @PostConstruct 内动态切换数据源</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E3%80%81%E8%B0%83%E7%94%A8%E5%88%9D%E5%A7%8B%E5%8C%96%E8%A1%A8%E5%92%8C%E6%95%B0%E6%8D%AE%E7%9A%84%E6%8E%A5%E5%8F%A3-initData"><span class="toc-text">5、调用初始化表和数据的接口 &#x2F;initData</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6%E3%80%81%E8%B0%83%E7%94%A8-test1-%E6%95%B0%E6%8D%AE%E6%BA%90%E6%8E%A5%E5%8F%A3-test1"><span class="toc-text">6、调用 test1 数据源接口 &#x2F;test1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7%E3%80%81%E8%B0%83%E7%94%A8-test2-%E6%95%B0%E6%8D%AE%E6%BA%90%E6%8E%A5%E5%8F%A3-test2"><span class="toc-text">7、调用 test2 数据源接口 &#x2F;test2</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8%E3%80%81%E8%B0%83%E7%94%A8-test3-%E6%95%B0%E6%8D%AE%E6%BA%90%E6%8E%A5%E5%8F%A3-test3"><span class="toc-text">8、调用 test3 数据源接口 &#x2F;test3</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E5%8A%A8%E6%80%81%E6%95%B0%E6%8D%AE%E6%BA%90%E4%BD%BF%E7%94%A8%E3%80%90AOP%E5%88%87%E6%8D%A2%E3%80%91-2"><span class="toc-text">4、动态数据源使用【AOP切换】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81JPA-%E5%A4%9A%E6%AC%A1%E5%88%87%E6%8D%A2%E6%95%B0%E6%8D%AE%E6%BA%90%E5%A4%B1%E6%95%88%E5%8E%9F%E5%9B%A0%E5%88%86%E6%9E%90%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-text">5、JPA 多次切换数据源失效原因分析及解决方案</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E4%B8%A4%E7%A7%8D%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-text">1、两种解决方案</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81JPA-%E6%95%B0%E6%8D%AE%E6%BA%90%E5%88%87%E6%8D%A2%E5%A4%B1%E6%95%88%E5%88%86%E6%9E%90%E5%8F%8A%E6%89%A9%E5%B1%95"><span class="toc-text">2、JPA 数据源切换失效分析及扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%97%AE%E9%A2%98-1%EF%BC%9ASpringBoot%E6%95%B4%E5%90%88JPA%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E6%97%B6%EF%BC%8C%E4%B8%80%E4%B8%AA%E8%AF%B7%E6%B1%82%E4%B8%AD%E6%97%A0%E6%B3%95%E5%A4%9A%E6%AC%A1%E5%88%87%E6%8D%A2%E6%95%B0%E6%8D%AE%E6%BA%90%E3%80%82%E5%8F%AF%E6%98%AF%E4%BD%BF%E7%94%A8-PostConstruct%E6%B3%A8%E9%87%8A%E7%9A%84%E6%96%B9%E6%B3%95%E5%8D%B4%E5%8F%AF%E4%BB%A5%E5%A4%9A%E6%AC%A1%E5%88%87%E6%8D%A2%E6%95%B0%E6%8D%AE%E6%BA%90%EF%BC%8C%E8%BF%99%E6%98%AF%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">问题 1：SpringBoot整合JPA多数据源时，一个请求中无法多次切换数据源。可是使用@PostConstruct注释的方法却可以多次切换数据源，这是为什么？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%97%AE%E9%A2%98-2%EF%BC%9ASpringBoot%E6%95%B4%E5%90%88JPA%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E6%97%B6%EF%BC%8C%E4%B8%80%E4%B8%AA%E8%AF%B7%E6%B1%82%E4%B8%AD%E6%97%A0%E6%B3%95%E5%A4%9A%E6%AC%A1%E5%88%87%E6%8D%A2%E6%95%B0%E6%8D%AE%E6%BA%90%E3%80%82%E5%8F%AF%E6%95%B4%E5%90%88Mybatis%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E6%97%B6%EF%BC%8C%E4%B8%80%E4%B8%AA%E8%AF%B7%E6%B1%82%E4%B8%AD%E5%8D%B4%E5%8F%AF%E4%BB%A5%E5%88%87%E6%8D%A2%E5%A4%9A%E6%AC%A1%E6%95%B0%E6%8D%AE%E6%BA%90%EF%BC%8C%E8%BF%99%E6%98%AF%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">问题 2：SpringBoot整合JPA多数据源时，一个请求中无法多次切换数据源。可整合Mybatis多数据源时，一个请求中却可以切换多次数据源，这是为什么？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%97%AE%E9%A2%98-3%EF%BC%9Aspring-jpa-open-in-view-false-%E9%85%8D%E7%BD%AE%E7%9A%84%E8%A7%A3%E9%87%8A"><span class="toc-text">问题 3：spring.jpa.open-in-view &#x3D; false 配置的解释</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE-%E9%B8%A3%E8%B0%A2"><span class="toc-text">参考文献 &amp; 鸣谢</span></a></li></ol>
    
<style>
    .left-col .switch-btn,
    .left-col .switch-area {
        display: none;
    }
    .toc-level-3 i,
    .toc-level-3 ol {
        display: none !important;
    }
</style>
</div>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1、SpringBoot-多数据源前言"><a href="#1、SpringBoot-多数据源前言" class="headerlink" title="1、SpringBoot 多数据源前言"></a>1、SpringBoot 多数据源前言</h1><h2 id="1、使用场景"><a href="#1、使用场景" class="headerlink" title="1、使用场景"></a>1、使用场景</h2><p>在开发过程中，避免不了需要同时操作多个数据库的情况，通常的应用场景如下 ：</p>
<ul>
<li>同构或异构数据的业务处理：需要处理的数据存储在不同的数据库中，包括同构（如都是 MySQL ），异构（如一个MySQL ，另外是 PG 或者 Oracle ）。</li>
<li>数据库高性能场景：主从，包括一主一从，一主多从等，在主库进行增删改操作，在从库进行读操作。</li>
<li>数据库高可用场景：主备，包括一往一备，多主多备等，在数据库无法访问时可以切换。</li>
</ul>
<p>使用 Spring Boot 该如何处理多个数据库的读写，一般有以下几种策略：</p>
<ul>
<li>多套数据源：即针对一个数据库建立一套数据处理逻辑，每套数据库都包括数据源配置、会话工厂（ sessionFactory ）、连接、SQL 操作、实体。各套数据库相互独立。</li>
<li>动态数据源：确定数量的多个数据源共用一个会话工厂，根据条件动态选取数据源进行连接、SQL 操作。</li>
<li>参数化变更数据源：根据参数添加数据源，并进行数据源切换，数据源数量不确定。通常用于对多个数据库的管理工作</li>
</ul>
<h2 id="2、思路分析"><a href="#2、思路分析" class="headerlink" title="2、思路分析"></a>2、思路分析</h2><ul>
<li>要想配置多个数据源，必须新增配置文件。（你不写配置，系统怎么知道）</li>
<li>要有地方能够配置多数据源。（读出配置，告诉系统）</li>
<li>要能够选择用什么数据源。（系统知道有哪些，但是要我们自己指定用哪个）</li>
</ul>
<h2 id="3、实现方式"><a href="#3、实现方式" class="headerlink" title="3、实现方式"></a>3、实现方式</h2><ul>
<li>一种是静态数据源配置，配置好确定的数据源，想用哪个切换到哪个</li>
<li>另一种是动态数据源配置，我们可以运行时新增数据源以及切换数据源</li>
</ul>
<h2 id="4、事务分析"><a href="#4、事务分析" class="headerlink" title="4、事务分析"></a>4、事务分析</h2><ol>
<li>事务的使用必须要指明是哪个数据源的事务管理器，否则事务失效。 例如：@Transactional(value &#x3D; “userTransactionManager”)</li>
<li>如果一个方法涉及多个数据源操作，此时无法做到同时回滚，尽量避免这种操作，这里涉及到分布式事务处理，可自行研究。</li>
</ol>
<h1 id="2、SpringBoot-静态多数据源"><a href="#2、SpringBoot-静态多数据源" class="headerlink" title="2、SpringBoot 静态多数据源"></a>2、SpringBoot 静态多数据源</h1><p>多套数据源，顾名思义每一个数据库有一套独立的操作。从下往上，数据库、会话工厂、DAO操作，服务层都是独立的一套，本示例中，以一主一从两个数据库，两数据库的分别有一个表 <code>USER_INFO</code>，表结构一致，为便于说明，两个表中的数据是不一样的。</p>
<h2 id="1、JdbcTemplate-H2-静态多数据源配置"><a href="#1、JdbcTemplate-H2-静态多数据源配置" class="headerlink" title="1、JdbcTemplate + H2 静态多数据源配置"></a>1、JdbcTemplate + H2 静态多数据源配置</h2><h3 id="1、搭建项目工程"><a href="#1、搭建项目工程" class="headerlink" title="1、搭建项目工程"></a>1、搭建项目工程</h3><p>1、创建 SpringBoot 项目工程</p>
<p>2、添加项目依赖</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;parent&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
        &lt;version&gt;2.7.18&lt;/version&gt;
        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;
    &lt;/parent&gt;
    &lt;groupId&gt;com.example&lt;/groupId&gt;
    &lt;artifactId&gt;h2-jdbctemplate-multi-datasource-static&lt;/artifactId&gt;
    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;
    &lt;name&gt;h2-jdbctemplate-multi-datasource-static&lt;/name&gt;
    &lt;description&gt;Demo project for Spring Boot&lt;/description&gt;
    &lt;properties&gt;
        &lt;maven.compiler.source&gt;11&lt;/maven.compiler.source&gt;
        &lt;maven.compiler.target&gt;11&lt;/maven.compiler.target&gt;
    &lt;/properties&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!-- https://mvnrepository.com/artifact/com.h2database/h2 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.h2database&lt;/groupId&gt;
            &lt;artifactId&gt;h2&lt;/artifactId&gt;
            &lt;scope&gt;runtime&lt;/scope&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
            &lt;artifactId&gt;lombok&lt;/artifactId&gt;
            &lt;optional&gt;true&lt;/optional&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

    &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;

&lt;/project&gt;
</code></pre>
<h3 id="2、多数据源配置"><a href="#2、多数据源配置" class="headerlink" title="2、多数据源配置"></a>2、多数据源配置</h3><p>1、独立数据库连接信息配置 application.yml</p>
<pre><code class="yaml">server:
  port: 8090
spring:
  #################### H2 数据库配置 ####################
  # 文件数据库
  # spring.datasource.url = jdbc:h2:file:./dbh2/dbc2m;AUTO_SERVER=TRUE
  # 内存数据库，platform #表明使用的数据库平台是 h2
  datasource:
    master:
      driver-class-name: org.h2.Driver
      jdbc-url: jdbc:h2:mem:master
      password: sa
      username: sa
      platform: h2
    slave:
      driver-class-name: org.h2.Driver
      jdbc-url: jdbc:h2:mem:slave
      password: sa
      username: sa
      platform: h2
  #################### H2 Web Console设置 ####################
  ### enabled：程序开启时就会启动 H2 Web Console, 默认就是启动的
  ### path：配置访问地址为：/h2，访问 H2 Web Console，默认:/h2-console
  ### settings.web-allow-others：开启H2 Web Console远程访问，默认为false不开启只能在本机访问
  h2:
    console:
      enabled: true
      path: /h2
      settings:
        web-allow-others: true
</code></pre>
<p>2、SpringBoot 多套数据源配置</p>
<pre><code class="java">package com.example.config;

import com.zaxxer.hikari.HikariDataSource;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.boot.jdbc.DataSourceBuilder;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Primary;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.datasource.DataSourceTransactionManager;
import org.springframework.transaction.PlatformTransactionManager;

import javax.sql.DataSource;

@Configuration
public class DataSourceConfig &#123;
    @Primary
    @Bean(name = &quot;dataSourceMaster&quot;)
    @ConfigurationProperties(prefix = &quot;spring.datasource.master&quot;)
    public DataSource dataSourceMaster() &#123;
        return DataSourceBuilder.create().type(HikariDataSource.class).build();
    &#125;

    @Bean(name = &quot;dataSourceSlave&quot;)
    @ConfigurationProperties(prefix = &quot;spring.datasource.slave&quot;)
    public DataSource dataSourceSlave() &#123;
        return DataSourceBuilder.create().type(HikariDataSource.class).build();
    &#125;

    @Primary
    @Bean(name = &quot;jdbcTemplateMaster&quot;)
    public JdbcTemplate jdbcTemplateMaster(@Qualifier(&quot;dataSourceMaster&quot;)DataSource dataSource) &#123;
        return new JdbcTemplate(dataSource);
    &#125;

    @Bean(name = &quot;jdbcTemplateSlave&quot;)
    public JdbcTemplate jdbcTemplateSlave(@Qualifier(&quot;dataSourceSlave&quot;) DataSource dataSource) &#123;
        return new JdbcTemplate(dataSource);
    &#125;

    @Primary
    @Bean(name = &quot;platformTransactionManagerMaster&quot;)
    public PlatformTransactionManager platformTransactionManagerMaster() &#123;
        return new DataSourceTransactionManager(dataSourceMaster());
    &#125;

    @Bean(name = &quot;platformTransactionManagerSlave&quot;)
    public PlatformTransactionManager platformTransactionManagerSlave() &#123;
        return new DataSourceTransactionManager(dataSourceSlave());
    &#125;
&#125;
</code></pre>
<h3 id="3、多数据源使用"><a href="#3、多数据源使用" class="headerlink" title="3、多数据源使用"></a>3、多数据源使用</h3><p>1、经过上面的多套数据源配置，可知道，若需要操作哪个数据库，直接使用对应的 JdbcTemplate 进行 CRUD 操作即可。</p>
<pre><code class="java">package com.example.controller;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;
import javax.annotation.PostConstruct;
import javax.annotation.Resource;
import java.util.List;
import java.util.Map;
import java.util.UUID;

@RestController
public class MultiController &#123;

    @Autowired
    @Qualifier(&quot;jdbcTemplateMaster&quot;)
    JdbcTemplate jdbcTemplateMaster;
    @Resource(name = &quot;jdbcTemplateSlave&quot;)
    JdbcTemplate jdbcTemplateSlave;

    /**
     * 数据Master: 创建表 USER_INFO, 并初始化数据
     */
    @PostConstruct
    public void initUserInfo() &#123;
        jdbcTemplateMaster.execute(&quot;DROP TABLE IF EXISTS USER_INFO&quot;);
        jdbcTemplateMaster.execute(&quot;CREATE TABLE USER_INFO (&quot;
                                   + &quot;id VARCHAR(50) NOT NULL,&quot;
                                   + &quot;email VARCHAR(50) NOT NULL,&quot;
                                   + &quot;name VARCHAR(50) NOT NULL,&quot;
                                   + &quot;gender BOOLEAN NOT NULL,&quot;
                                   + &quot;createdAt BIGINT NOT NULL,&quot;
                                   + &quot;updatedAt BIGINT NOT NULL,&quot;
                                   + &quot;PRIMARY KEY (id))&quot;);
        String id = randomString();
        String email = randomString() + &quot;@test.io&quot;;
        String name = &quot;Mr &quot; + randomString();
        boolean gender = randomString().hashCode() % 2 == 0;
        Long now = System.currentTimeMillis();
        String sql = &quot;INSERT INTO USER_INFO (id, email, name, gender, createdAt, updatedAt) VALUES (?, ?, ?, ?, ?, ?)&quot;;
        jdbcTemplateMaster.update(sql, id, email, name, gender, now, now);
    &#125;

    /**
     * 数据Slave: 创建表 USER_INFO, 并初始化数据
     */
    @PostConstruct
    public void initBookInfo() &#123;
        jdbcTemplateSlave.execute(&quot;DROP TABLE IF EXISTS BOOK_INFO&quot;);
        jdbcTemplateSlave.execute(&quot;CREATE TABLE BOOK_INFO (&quot;
                                  + &quot;id VARCHAR(50) NOT NULL,&quot;
                                  + &quot;name VARCHAR(50) NOT NULL,&quot;
                                  + &quot;isbn VARCHAR(50) NOT NULL,&quot;
                                  + &quot;createdAt BIGINT NOT NULL,&quot;
                                  + &quot;updatedAt BIGINT NOT NULL,&quot;
                                  + &quot;PRIMARY KEY (id))&quot;);
        String id = randomString();
        String name = &quot;Java-&quot; + randomString();
        String isbn = &quot;ISBN-&quot; + randomString().hashCode() % 2017;
        Long now = System.currentTimeMillis();
        String sql = &quot;INSERT INTO BOOK_INFO (id, name, isbn, createdAt, updatedAt) VALUES (?, ?, ?, ?, ?)&quot;;
        jdbcTemplateSlave.update(sql, id, name, isbn, now, now);
    &#125;

    private String randomString() &#123;
        return UUID.randomUUID().toString();
    &#125;

    @GetMapping(&quot;/api/users&quot;)
    public List&lt;Map&lt;String, Object&gt;&gt; getUsers2() &#123;
        return jdbcTemplateMaster.queryForList(&quot;SELECT * FROM USER_INFO ORDER BY createdAt&quot;);
    &#125;

    @GetMapping(&quot;/api/books&quot;)
    public List&lt;Map&lt;String, Object&gt;&gt; getBooks() &#123;
        return jdbcTemplateSlave.queryForList(&quot;SELECT * FROM BOOK_INFO ORDER BY createdAt&quot;);
    &#125;
&#125;
</code></pre>
<p>2、测试主数据源</p>
<pre><code class="bash">curl -X GET &quot;localhost:8090/api/users&quot; 
[
  &#123;
    &quot;ID&quot;: &quot;9415439a-24a2-4563-8e7d-c9c08ea7794c&quot;,
    &quot;EMAIL&quot;: &quot;0425cbac-93a7-4872-a03b-2807d096c826@test.io&quot;,
    &quot;NAME&quot;: &quot;Mr d4a004a7-e673-4dbc-9c60-00ecc813966d&quot;,
    &quot;GENDER&quot;: false,
    &quot;CREATEDAT&quot;: 1724902823690,
    &quot;UPDATEDAT&quot;: 1724902823690
  &#125;
]
</code></pre>
<p>3、测试从数据源</p>
<pre><code class="bash">curl -X GET &quot;localhost:8090/api/books&quot;
[
  &#123;
    &quot;ID&quot;: &quot;77cd3fad-6642-4798-aca7-b5f755d0e072&quot;,
    &quot;NAME&quot;: &quot;Java-1ccf73bf-8d92-4abf-ab40-feb37897796c&quot;,
    &quot;ISBN&quot;: &quot;ISBN-1131&quot;,
    &quot;CREATEDAT&quot;: 1724902823703,
    &quot;UPDATEDAT&quot;: 1724902823703
  &#125;
]
</code></pre>
<h3 id="4、spring-data-jdbc-多数据源配置及使用"><a href="#4、spring-data-jdbc-多数据源配置及使用" class="headerlink" title="4、spring-data-jdbc 多数据源配置及使用"></a>4、spring-data-jdbc 多数据源配置及使用</h3><blockquote>
<p>在上面项目配置的基础上我们做一些增加与改动即可</p>
</blockquote>
<p>1、替换spring-boot-starter-jdbc依赖为spring-boot-starter-data-jdbc</p>
<pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-data-jdbc&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<p>2、多套数据源配置 JdbcAggregateTemplate，由于上面已经配置过多个 DataSource 和 JdbcTemplate 这里就不重复配置了。</p>
<pre><code class="java">package com.example.config;

import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationEventPublisher;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Primary;
import org.springframework.data.jdbc.core.JdbcAggregateTemplate;
import org.springframework.data.jdbc.core.convert.*;
import org.springframework.data.relational.core.dialect.Dialect;
import org.springframework.data.relational.core.mapping.RelationalMappingContext;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;
import javax.sql.DataSource;

@Configuration
public class JdbcAggregateTemplateConfig &#123;

    @Primary
    @Bean(name = &quot;dataAccessStrategy1&quot;)
    public DataAccessStrategy dataAccessStrategy1(
            @Qualifier(&quot;dataSourceMaster&quot;) DataSource dataSource,
            @Qualifier(&quot;jdbcTemplateMaster&quot;) JdbcTemplate jdbcTemplate,
            RelationalMappingContext mappingContext,
            JdbcConverter converter,
            Dialect dialect) &#123;
        NamedParameterJdbcTemplate namedParameterJdbcTemplate = new NamedParameterJdbcTemplate(dataSource);
        BatchJdbcOperations batchJdbcOperations = new BatchJdbcOperations(jdbcTemplate);
        return new DefaultDataAccessStrategy(
                new SqlGeneratorSource(mappingContext, converter, dialect),
                mappingContext,
                converter,
                namedParameterJdbcTemplate,
                new SqlParametersFactory(mappingContext, converter, dialect),
                new InsertStrategyFactory(namedParameterJdbcTemplate, batchJdbcOperations, dialect));
    &#125;

    @Bean(name = &quot;dataAccessStrategy2&quot;)
    public DataAccessStrategy dataAccessStrategy2(
            @Qualifier(&quot;dataSourceSlave&quot;) DataSource dataSource,
            @Qualifier(&quot;jdbcTemplateSlave&quot;) JdbcTemplate jdbcTemplate,
            RelationalMappingContext mappingContext,
            JdbcConverter converter,
            Dialect dialect) &#123;
        NamedParameterJdbcTemplate namedParameterJdbcTemplate = new NamedParameterJdbcTemplate(dataSource);
        BatchJdbcOperations batchJdbcOperations = new BatchJdbcOperations(jdbcTemplate);
        return new DefaultDataAccessStrategy(
                new SqlGeneratorSource(mappingContext, converter, dialect),
                mappingContext,
                converter,
                namedParameterJdbcTemplate,
                new SqlParametersFactory(mappingContext, converter, dialect),
                new InsertStrategyFactory(namedParameterJdbcTemplate, batchJdbcOperations, dialect));
    &#125;

    @Primary
    @Bean(name = &quot;jdbcAggregateTemplateMaster&quot;)
    public JdbcAggregateTemplate jdbcAggregateTemplate1(
            ApplicationContext applicationContext,
            RelationalMappingContext relationalMappingContext,
            JdbcConverter jdbcConverter,
            @Qualifier(&quot;dataAccessStrategy1&quot;) DataAccessStrategy dataAccessStrategy) &#123;

        // 根据dataSource1配置 JdbcAggregateTemplate
        return new JdbcAggregateTemplate(applicationContext, relationalMappingContext, jdbcConverter, dataAccessStrategy);
    &#125;

    @Bean(name = &quot;jdbcAggregateTemplateSlave&quot;)
    public JdbcAggregateTemplate jdbcAggregateTemplate2(
            ApplicationEventPublisher publisher,
            RelationalMappingContext relationalMappingContext,
            JdbcConverter jdbcConverter,
            @Qualifier(&quot;dataAccessStrategy2&quot;) DataAccessStrategy dataAccessStrategy) &#123;

        // 根据dataSource2配置 JdbcAggregateTemplate
        return new JdbcAggregateTemplate(publisher, relationalMappingContext, jdbcConverter, dataAccessStrategy);
    &#125;
&#125;
</code></pre>
<p>3、数据表对应实体类的创建</p>
<pre><code class="java">package com.example.model;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.springframework.data.annotation.Id;
import org.springframework.data.relational.core.mapping.Column;
import java.io.Serializable;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class UserInfo implements Serializable &#123;
    @Id
    private String id;
    private String email;
    private String name;
    private boolean gender;
    @Column(&quot;CREATEDAT&quot;)
    private Long createdAt;
    @Column(&quot;UPDATEDAT&quot;)
    private Long updatedAt;
&#125;
</code></pre>
<pre><code class="java">package com.example.model;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.springframework.data.annotation.Id;
import org.springframework.data.relational.core.mapping.Column;
import java.io.Serializable;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class BookInfo implements Serializable &#123;
    @Id
    private String id;
    private String name;
    private String isbn;
    @Column(&quot;CREATEDAT&quot;)
    private Long createdAt;
    @Column(&quot;UPDATEDAT&quot;)
    private Long updatedAt;
&#125;
</code></pre>
<p>4、新建 Controller 测试多数据源下 JdbcAggregateTemplate 的使用</p>
<pre><code class="java">package com.example.controller;

import com.example.model.BookInfo;
import com.example.model.UserInfo;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.data.jdbc.core.JdbcAggregateTemplate;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;
import javax.annotation.PostConstruct;
import javax.annotation.Resource;
import java.util.UUID;

@RestController
public class MultiControllerDataJdbc &#123;

    @Autowired
    @Qualifier(&quot;jdbcTemplateMaster&quot;)
    JdbcTemplate jdbcTemplateMaster;
    @Resource(name = &quot;jdbcTemplateSlave&quot;)
    JdbcTemplate jdbcTemplateSlave;
    @Resource(name = &quot;jdbcAggregateTemplateMaster&quot;)
    JdbcAggregateTemplate jdbcAggregateTemplateMaster;
    @Resource(name = &quot;jdbcAggregateTemplateSlave&quot;)
    JdbcAggregateTemplate jdbcAggregateTemplateSlave;

    /**
     * 数据Master: 创建表 USER_INFO, 并初始化数据
     */
    @PostConstruct
    public void initUserInfo() &#123;
        jdbcTemplateMaster.execute(&quot;DROP TABLE IF EXISTS USER_INFO&quot;);
        jdbcTemplateMaster.execute(&quot;CREATE TABLE USER_INFO (&quot;
                + &quot;id VARCHAR(50) NOT NULL,&quot;
                + &quot;email VARCHAR(50) NOT NULL,&quot;
                + &quot;name VARCHAR(50) NOT NULL,&quot;
                + &quot;gender BOOLEAN NOT NULL,&quot;
                + &quot;createdAt BIGINT NOT NULL,&quot;
                + &quot;updatedAt BIGINT NOT NULL,&quot;
                + &quot;PRIMARY KEY (id))&quot;);
        String id = randomString();
        String email = randomString() + &quot;@test.io&quot;;
        String name = &quot;Mr &quot; + randomString();
        boolean gender = randomString().hashCode() % 2 == 0;
        Long now = System.currentTimeMillis();
        jdbcAggregateTemplateMaster.insert(new UserInfo(id, email, name, gender, now, now));
    &#125;

    /**
     * 数据Slave: 创建表 USER_INFO, 并初始化数据
     */
    @PostConstruct
    public void initBookInfo() &#123;
        jdbcTemplateSlave.execute(&quot;DROP TABLE IF EXISTS BOOK_INFO&quot;);
        jdbcTemplateSlave.execute(&quot;CREATE TABLE BOOK_INFO (&quot;
                + &quot;id VARCHAR(50) NOT NULL,&quot;
                + &quot;name VARCHAR(50) NOT NULL,&quot;
                + &quot;isbn VARCHAR(50) NOT NULL,&quot;
                + &quot;createdAt BIGINT NOT NULL,&quot;
                + &quot;updatedAt BIGINT NOT NULL,&quot;
                + &quot;PRIMARY KEY (id))&quot;);
        String id = randomString();
        String name = &quot;Java-&quot; + randomString();
        String isbn = &quot;ISBN-&quot; + randomString().hashCode() % 2017;
        Long now = System.currentTimeMillis();
        jdbcAggregateTemplateSlave.insert(new BookInfo(id, name, isbn, now, now));
    &#125;

    private String randomString() &#123;
        return UUID.randomUUID().toString();
    &#125;

    @GetMapping(&quot;/api/users&quot;)
    public Iterable&lt;UserInfo&gt; getUsers2() &#123;
        return jdbcAggregateTemplateMaster.findAll(UserInfo.class);
    &#125;

    @GetMapping(&quot;/api/books&quot;)
    public Iterable&lt;BookInfo&gt; getBooks() &#123;
        return jdbcAggregateTemplateSlave.findAll(BookInfo.class);
    &#125;
&#125;
</code></pre>
<p>5、启动项目，测试主数据源</p>
<pre><code class="shell">curl -X GET &quot;localhost:8090/data/users&quot;
[
  &#123;
    &quot;id&quot;: &quot;0d47d00a-fa56-436b-a67b-67487496c7a1&quot;,
    &quot;email&quot;: &quot;98badf32-a345-4a33-913e-d901b606e540@test.io&quot;,
    &quot;name&quot;: &quot;Mr 8ba7c6b6-cf54-43a9-85b8-e98c91952f70&quot;,
    &quot;gender&quot;: true,
    &quot;createdAt&quot;: 1725439181252,
    &quot;updatedAt&quot;: 1725439181252
  &#125;
]
</code></pre>
<p>6、测试从数据源</p>
<pre><code class="shell">curl -X GET &quot;localhost:8090/data/books
[
  &#123;
    &quot;id&quot;: &quot;0b0cbe1b-3f5c-46a7-ada4-52e31252c304&quot;,
    &quot;name&quot;: &quot;Java-89bd45ee-8851-461d-8b60-a31e410d5a4b&quot;,
    &quot;isbn&quot;: &quot;ISBN-357&quot;,
    &quot;createdAt&quot;: 1725439181368,
    &quot;updatedAt&quot;: 1725439181368
  &#125;
]
</code></pre>
<h2 id="2、Mybatis-H2-静态多数据源配置"><a href="#2、Mybatis-H2-静态多数据源配置" class="headerlink" title="2、Mybatis + H2 静态多数据源配置"></a>2、Mybatis + H2 静态多数据源配置</h2><h3 id="1、搭建项目工程-1"><a href="#1、搭建项目工程-1" class="headerlink" title="1、搭建项目工程"></a>1、搭建项目工程</h3><p>1、创建 SpringBoot 项目工程</p>
<p>2、添加项目依赖</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;parent&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
        &lt;version&gt;2.7.18&lt;/version&gt;
        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;
    &lt;/parent&gt;
    &lt;groupId&gt;com.example&lt;/groupId&gt;
    &lt;artifactId&gt;h2-mybaits-multi-datasource-static&lt;/artifactId&gt;
    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;
    &lt;name&gt;h2-mybaits-multi-datasource-static&lt;/name&gt;
    &lt;description&gt;Demo project for Spring Boot&lt;/description&gt;
    &lt;properties&gt;
        &lt;maven.compiler.source&gt;11&lt;/maven.compiler.source&gt;
        &lt;maven.compiler.target&gt;11&lt;/maven.compiler.target&gt;
    &lt;/properties&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;
            &lt;version&gt;2.1.4&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!-- https://mvnrepository.com/artifact/com.h2database/h2 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.h2database&lt;/groupId&gt;
            &lt;artifactId&gt;h2&lt;/artifactId&gt;
            &lt;scope&gt;runtime&lt;/scope&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
            &lt;artifactId&gt;lombok&lt;/artifactId&gt;
            &lt;optional&gt;true&lt;/optional&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

    &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;

&lt;/project&gt;
</code></pre>
<h3 id="2、多数据源配置-1"><a href="#2、多数据源配置-1" class="headerlink" title="2、多数据源配置"></a>2、多数据源配置</h3><p>1、独立数据库连接信息配置 application.yml</p>
<pre><code class="yaml">server:
  port: 8090
spring:
  #################### H2 数据库配置 ####################
  # 文件数据库
  # spring.datasource.url = jdbc:h2:file:./dbh2/dbc2m;AUTO_SERVER=TRUE
  # 内存数据库，platform #表明使用的数据库平台是 h2
  datasource:
    master:
      driver-class-name: org.h2.Driver
      jdbc-url: jdbc:h2:mem:master
      username: sa
      password:
    slave:
      driver-class-name: org.h2.Driver
      jdbc-url: jdbc:h2:mem:slave
      username: sa
      password:
  #################### H2 Web Console设置 ####################
  ### enabled：程序开启时就会启动 H2 Web Console, 默认就是启动的
  ### path：配置访问地址为：/h2，访问 H2 Web Console，默认:/h2-console
  ### settings.web-allow-others：开启H2 Web Console远程访问，默认为false不开启只能在本机访问
  h2:
    console:
      enabled: true
      path: /h2
      settings:
        web-allow-others: true
</code></pre>
<p>2、SpringBoot 主数据源配置</p>
<pre><code class="java">package com.example.config;

import com.zaxxer.hikari.HikariDataSource;
import org.apache.ibatis.session.SqlSessionFactory;
import org.mybatis.spring.SqlSessionFactoryBean;
import org.mybatis.spring.SqlSessionTemplate;
import org.mybatis.spring.annotation.MapperScan;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.boot.jdbc.DataSourceBuilder;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Primary;
import org.springframework.jdbc.datasource.DataSourceTransactionManager;
import org.springframework.transaction.PlatformTransactionManager;

import javax.sql.DataSource;

/**
 * @MapperScan.basePackages：扫描packages使用master数据源
 * @MapperScan.sqlSessionTemplateRef：注入sqlSessionTemplate
 */
@Configuration
@MapperScan(
        basePackages = &quot;com.example.mapper.master&quot;,
        sqlSessionTemplateRef = &quot;masterSqlSessionTemplate&quot;
)
public class MasterDataSourceConfig &#123;

    /**
     * 创建master主DataSource
     */
    @Primary
    @Bean(name = &quot;masterDataSource&quot;)
    @ConfigurationProperties(prefix = &quot;spring.datasource.master&quot;)
    public DataSource masterDataSource() &#123;
        return DataSourceBuilder.create().type(HikariDataSource.class).build();
    &#125;

    /**
     * 创建sqlSessionFactory
     */
    @Primary
    @Bean(name = &quot;masterSqlSessionFactory&quot;)
    public SqlSessionFactory masterSqlSessionFactory(@Qualifier(&quot;masterDataSource&quot;) DataSource dataSource) throws Exception &#123;
        SqlSessionFactoryBean bean = new SqlSessionFactoryBean();
        bean.setDataSource(dataSource);
        // 如果需要使用xml配置文件的形式的话，那么需要扫描XML文件的存放路径
        // String locationPattern = &quot;classpath:mapper/master/*.xml&quot;;
        // bean.setMapperLocations(new PathMatchingResourcePatternResolver().getResources(locationPattern));
        return bean.getObject();
    &#125;

    /**
     * 创建sqlSession模板
     */
    @Primary
    @Bean(name = &quot;masterSqlSessionTemplate&quot;)
    public SqlSessionTemplate masterSqlSessionTemplate(@Qualifier(&quot;masterSqlSessionFactory&quot;) SqlSessionFactory sqlSessionFactory) &#123;
        return new SqlSessionTemplate(sqlSessionFactory);
    &#125;

    /**
     * 创建事务管理器：需要使用事务的时候，加上@Transactional(&quot;masterTransactionManager&quot;)
     */
    @Primary
    @Bean(name = &quot;masterTransactionManager&quot;)
    public PlatformTransactionManager masterTransactionManager(@Qualifier(&quot;masterDataSource&quot;) DataSource dataSource) &#123;
        return new DataSourceTransactionManager(dataSource);
    &#125;

&#125;
</code></pre>
<p>3、SpringBoot 从数据源配置</p>
<pre><code class="java">package com.example.config;

import com.zaxxer.hikari.HikariDataSource;
import org.apache.ibatis.session.SqlSessionFactory;
import org.mybatis.spring.SqlSessionFactoryBean;
import org.mybatis.spring.SqlSessionTemplate;
import org.mybatis.spring.annotation.MapperScan;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.boot.jdbc.DataSourceBuilder;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.core.io.support.PathMatchingResourcePatternResolver;
import org.springframework.jdbc.datasource.DataSourceTransactionManager;
import org.springframework.transaction.PlatformTransactionManager;

import javax.sql.DataSource;

@Configuration
@MapperScan(
        basePackages = &quot;com.example.mapper.slave&quot;,
        sqlSessionTemplateRef = &quot;slaveSqlSessionTemplate&quot;
)
public class SlaveDataSourceConfig &#123;
    /**
     * 设置XML文件存放位置，扫描路径
     */
    private final String locationPattern = &quot;classpath:mapper/slave/*.xml&quot;;

    /**
     * 创建salve主DataSource
     */
    @Bean(name = &quot;slaveDataSource&quot;)
    @ConfigurationProperties(prefix = &quot;spring.datasource.slave&quot;)
    public DataSource slaveDataSource() &#123;
        return DataSourceBuilder.create().type(HikariDataSource.class).build();
    &#125;

    /**
     * 创建sqlSessionFactory
     */
    @Bean(name = &quot;slaveSqlSessionFactory&quot;)
    public SqlSessionFactory slaveSqlSessionFactory(@Qualifier(&quot;slaveDataSource&quot;) DataSource dataSource) throws Exception &#123;
        SqlSessionFactoryBean bean = new SqlSessionFactoryBean();
        bean.setDataSource(dataSource);
        // 如果需要使用xml配置文件的形式的话，那么需要扫描XML文件的存放路径
        // bean.setMapperLocations(new PathMatchingResourcePatternResolver().getResources(locationPattern));
        return bean.getObject();
    &#125;

    /**
     * 创建sqlSession模板
     */
    @Bean(name = &quot;slaveSqlSessionTemplate&quot;)
    public SqlSessionTemplate slaveSqlSessionTemplate(@Qualifier(&quot;slaveSqlSessionFactory&quot;) SqlSessionFactory sqlSessionFactory) &#123;
        return new SqlSessionTemplate(sqlSessionFactory);
    &#125;

    /**
     * 创建事务管理器：需要使用事务的时候，加上@Transactional(&quot;slaveTransactionManager&quot;)
     */
    @Bean(name = &quot;slaveTransactionManager&quot;)
    public PlatformTransactionManager slaveTransactionManager(@Qualifier(&quot;slaveDataSource&quot;) DataSource dataSource) &#123;
        return new DataSourceTransactionManager(dataSource);
    &#125;

&#125;
</code></pre>
<p>4、数据表对应实体类的创建</p>
<pre><code class="java">package com.example.model;

import lombok.Data;
import java.io.Serializable;

@Data
public class UserInfo implements Serializable &#123;
    private Integer Id;
    private String name;
    private String type;
&#125;
</code></pre>
<p>5、主数据源Mapper的创建</p>
<pre><code class="java">package com.example.mapper.master;

import com.example.model.UserInfo;
import org.apache.ibatis.annotations.*;

import java.util.List;

public interface MasterUserMapper &#123;
    @Select(&quot;select * from user_info&quot;)
    List&lt;UserInfo&gt; masterFindAllUser();

    @Insert(&quot;insert into user_info (name,type) values (#&#123;name&#125;,&#39;master&#39;);&quot;)
    int masterSaveUser(@Param(&quot;name&quot;) String name);

    @Update(&quot;drop table if exists user_info;&quot;)
    void dropUserExistTable();

    @Update(&quot;create TABLE user_info (id BIGINT NOT NULL AUTO_INCREMENT,name VARCHAR(50) DEFAULT NULL,type VARCHAR(50) DEFAULT NULL,PRIMARY KEY (id))&quot;)
    void createUserTable();

    @Insert(&quot;insert into user_info (id, name, type) values (1, &#39;Jone&#39;, &#39;master&#39;),(2, &#39;Kath&#39;, &#39;master&#39;),(3, &#39;Tom&#39;, &#39;master&#39;),(4, &#39;Sandy&#39;, &#39;master&#39;),(5, &#39;Oliver&#39;, &#39;master&#39;);&quot;)
    int initTableData();
&#125;
</code></pre>
<p>5、从数据源Mapper的创建</p>
<pre><code class="java">package com.example.mapper.slave;

import com.example.model.UserInfo;
import org.apache.ibatis.annotations.*;

import java.util.List;

public interface SlaveUserMapper &#123;
    @Select(&quot;select * from user_info&quot;)
    List&lt;UserInfo&gt; slaveFindAllUser();

    @Insert(&quot;insert into user_info (name,type) values (#&#123;name&#125;,&#39;master&#39;);&quot;)
    int slaveSaveUser(@Param(&quot;name&quot;) String name);

    @Update(&quot;drop table if exists user_info;&quot;)
    void dropUserExistTable();

    @Update(&quot;create table user_info (id BIGINT  NOT NULL AUTO_INCREMENT,name VARCHAR(50) DEFAULT NULL,type VARCHAR(50) DEFAULT NULL,PRIMARY KEY (id))&quot;)
    void createUserTable();

    @Insert(&quot;insert into user_info (id, name, type) values (1, &#39;Jone&#39;, &#39;slave&#39;),(2, &#39;Kath&#39;, &#39;slave&#39;),(3, &#39;Tom&#39;, &#39;slave&#39;),(4, &#39;Sandy&#39;, &#39;slave&#39;),(5, &#39;Oliver&#39;, &#39;slave&#39;);&quot;)
    int initTableData();
&#125;
</code></pre>
<h3 id="3、多数据源使用-1"><a href="#3、多数据源使用-1" class="headerlink" title="3、多数据源使用"></a>3、多数据源使用</h3><p>1、经过上面的多套数据源配置，可知道，若需要操作哪个数据库，直接使用对应的 mapper 进行 CRUD 操作即可。</p>
<pre><code class="java">package com.example.controller;

import com.example.mapper.master.MasterUserMapper;
import com.example.mapper.slave.SlaveUserMapper;
import com.example.model.UserInfo;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.ResponseEntity;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RestController;

import javax.annotation.PostConstruct;
import javax.annotation.Resource;
import java.util.List;
import java.util.UUID;

@Slf4j
@RestController
public class UserController &#123;
    @Resource
    MasterUserMapper masterUserMapper;
    @Resource
    SlaveUserMapper slaveUserMapper;

    @PostConstruct
    public void init() &#123;
        log.info(&quot;-----------------初始化数据开始--------------------&quot;);
        // 初始化master表和数据
        masterUserMapper.dropUserExistTable();
        masterUserMapper.createUserTable();
        masterUserMapper.initTableData();
        // 初始化slave表和数据
        slaveUserMapper.dropUserExistTable();
        slaveUserMapper.createUserTable();
        slaveUserMapper.initTableData();
        log.info(&quot;-----------------初始化数据结束--------------------&quot;);

        log.info(&quot;============查询主数据源数据===============&quot;);
        masterUserMapper.masterFindAllUser().forEach(System.out::println);
        log.info(&quot;============查询从数据源数据===============&quot;);
        slaveUserMapper.slaveFindAllUser().forEach(System.out::println);
    &#125;

    @GetMapping(&quot;/masterFindAllUser&quot;)
    public ResponseEntity&lt;List&lt;UserInfo&gt;&gt; masterFindAllUser() &#123;
        return ResponseEntity.ok(masterUserMapper.masterFindAllUser());
    &#125;

    @GetMapping(&quot;/slaveFindAllUser&quot;)
    public ResponseEntity&lt;List&lt;UserInfo&gt;&gt; slaveFindAllUser() &#123;
        return ResponseEntity.ok(slaveUserMapper.slaveFindAllUser());
    &#125;

    @Transactional(rollbackFor = Exception.class, transactionManager = &quot;masterTransactionManager&quot;)
    @GetMapping(&quot;/saveMasterUser&quot;)
    public ResponseEntity&lt;String&gt; saveMasterUser(Integer number) &#123;
        String response = masterUserMapper.masterSaveUser(UUID.randomUUID().toString()) &gt; 0 ? &quot;success&quot; : &quot;fail&quot;;
        // 如果number=0，则会报错，插入数据回滚
        System.out.println(10 / number);
        return ResponseEntity.ok(response);
    &#125;

    @Transactional(rollbackFor = Exception.class, transactionManager = &quot;slaveTransactionManager&quot;)
    @GetMapping(&quot;/saveSalveUser&quot;)
    public ResponseEntity&lt;String&gt; saveSalveUser(Integer number) &#123;
        String response = slaveUserMapper.slaveSaveUser(UUID.randomUUID().toString()) &gt; 0 ? &quot;success&quot; : &quot;fail&quot;;
        // 如果number=0，则会报错，插入数据回滚
        System.out.println(10 / number);
        return ResponseEntity.ok(response);
    &#125;
&#125;
</code></pre>
<p>2、项目启动就会执行 @PostConstruct 中的代码，进行数据初始化，我们可以查看日志</p>
<pre><code>2024-08-29 14:20:09.428  INFO 85224 --- [           main] com.example.controller.UserController    : -----------------初始化数据开始--------------------
2024-08-29 14:20:09.449  INFO 85224 --- [           main] com.example.controller.UserController    : -----------------初始化数据结束--------------------
2024-08-29 14:20:09.449  INFO 85224 --- [           main] com.example.controller.UserController    : ============查询主数据源数据===============
UserInfo(Id=1, name=Jone, type=master)
UserInfo(Id=2, name=Kath, type=master)
UserInfo(Id=3, name=Tom, type=master)
UserInfo(Id=4, name=Sandy, type=master)
UserInfo(Id=5, name=Oliver, type=master)
2024-08-29 14:20:09.476  INFO 85224 --- [           main] com.example.controller.UserController    : ============查询从数据源数据===============
UserInfo(Id=1, name=Jone, type=slave)
UserInfo(Id=2, name=Kath, type=slave)
UserInfo(Id=3, name=Tom, type=slave)
UserInfo(Id=4, name=Sandy, type=slave)
UserInfo(Id=5, name=Oliver, type=slave)
</code></pre>
<p>3、测试查询主数据源的 API</p>
<pre><code class="bash">curl -X GET &quot;localhost:8090/masterFindAllUser&quot;
[
  &#123;
    &quot;name&quot;: &quot;Jone&quot;,
    &quot;type&quot;: &quot;master&quot;,
    &quot;id&quot;: 1
  &#125;,
  &#123;
    &quot;name&quot;: &quot;Kath&quot;,
    &quot;type&quot;: &quot;master&quot;,
    &quot;id&quot;: 2
  &#125;,
  &#123;
    &quot;name&quot;: &quot;Tom&quot;,
    &quot;type&quot;: &quot;master&quot;,
    &quot;id&quot;: 3
  &#125;,
  &#123;
    &quot;name&quot;: &quot;Sandy&quot;,
    &quot;type&quot;: &quot;master&quot;,
    &quot;id&quot;: 4
  &#125;,
  &#123;
    &quot;name&quot;: &quot;Oliver&quot;,
    &quot;type&quot;: &quot;master&quot;,
    &quot;id&quot;: 5
  &#125;
]
</code></pre>
<p>4、测试查询从数据源的 API</p>
<pre><code class="bash">curl -X GET &quot;localhost:8090/slaveFindAllUser&quot;
[
  &#123;
    &quot;name&quot;: &quot;Jone&quot;,
    &quot;type&quot;: &quot;slave&quot;,
    &quot;id&quot;: 1
  &#125;,
  &#123;
    &quot;name&quot;: &quot;Kath&quot;,
    &quot;type&quot;: &quot;slave&quot;,
    &quot;id&quot;: 2
  &#125;,
  &#123;
    &quot;name&quot;: &quot;Tom&quot;,
    &quot;type&quot;: &quot;slave&quot;,
    &quot;id&quot;: 3
  &#125;,
  &#123;
    &quot;name&quot;: &quot;Sandy&quot;,
    &quot;type&quot;: &quot;slave&quot;,
    &quot;id&quot;: 4
  &#125;,
  &#123;
    &quot;name&quot;: &quot;Oliver&quot;,
    &quot;type&quot;: &quot;slave&quot;,
    &quot;id&quot;: 5
  &#125;
]
</code></pre>
<h2 id="3、Spring-Data-JPA-H2-静态多数据源配置"><a href="#3、Spring-Data-JPA-H2-静态多数据源配置" class="headerlink" title="3、Spring Data JPA + H2 静态多数据源配置"></a>3、Spring Data JPA + H2 静态多数据源配置</h2><h3 id="1、搭建项目工程-2"><a href="#1、搭建项目工程-2" class="headerlink" title="1、搭建项目工程"></a>1、搭建项目工程</h3><p>1、创建 SpringBoot 项目工程</p>
<p>2、添加项目依赖</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;parent&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
        &lt;version&gt;2.7.18&lt;/version&gt;
        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;
    &lt;/parent&gt;
    &lt;groupId&gt;com.example&lt;/groupId&gt;
    &lt;artifactId&gt;h2-jpa-multi-datasource-static&lt;/artifactId&gt;
    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;
    &lt;name&gt;h2-jpa-multi-datasource-static&lt;/name&gt;
    &lt;description&gt;Demo project for Spring Boot&lt;/description&gt;
    &lt;properties&gt;
        &lt;maven.compiler.source&gt;11&lt;/maven.compiler.source&gt;
        &lt;maven.compiler.target&gt;11&lt;/maven.compiler.target&gt;
    &lt;/properties&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;
            &lt;scope&gt;runtime&lt;/scope&gt;
            &lt;optional&gt;true&lt;/optional&gt;
        &lt;/dependency&gt;
        &lt;!-- https://mvnrepository.com/artifact/com.h2database/h2 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.h2database&lt;/groupId&gt;
            &lt;artifactId&gt;h2&lt;/artifactId&gt;
            &lt;scope&gt;runtime&lt;/scope&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
            &lt;artifactId&gt;lombok&lt;/artifactId&gt;
            &lt;optional&gt;true&lt;/optional&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

    &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;

&lt;/project&gt;
</code></pre>
<h3 id="2、多数据源配置-2"><a href="#2、多数据源配置-2" class="headerlink" title="2、多数据源配置"></a>2、多数据源配置</h3><p>1、独立数据库连接信息配置 application.yml</p>
<pre><code class="yaml">server:
  port: 8090
spring:
  #################### H2 数据库配置 ####################
  # 文件数据库
  # spring.datasource.url = jdbc:h2:file:./dbh2/dbc2m;AUTO_SERVER=TRUE
  # 内存数据库，platform #表明使用的数据库平台是 h2
  datasource:
    master:
      driver-class-name: org.h2.Driver
      jdbc-url: jdbc:h2:mem:master
      password: sa
      username: sa
      platform: h2
    slave:
      driver-class-name: org.h2.Driver
      jdbc-url: jdbc:h2:mem:slave
      password: sa
      username: sa
      platform: h2
  #################### H2 Web Console设置 ####################
  ### enabled：程序开启时就会启动 H2 Web Console, 默认就是启动的
  ### path：配置访问地址为：/h2，访问 H2 Web Console，默认:/h2-console
  ### settings.web-allow-others：开启H2 Web Console远程访问，默认为false不开启只能在本机访问
  h2:
    console:
      enabled: true
      path: /h2
      settings:
        web-allow-others: true
  #################### JPA 的配置 ####################
  # database-platform: 数据库方言的配置
  # hibernate.ddl-auto = none, 不启动 jpa 的自动通过实体类自动建表功能
  # show-sql = true 开启 SQL 打印功能
  # properties.hibernate.format_sql = true 开启SQL格式化功能
  jpa:
    database-platform: org.hibernate.dialect.H2Dialect
    hibernate:
      ddl-auto: none
    properties:
      hibernate:
        format_sql: true
    show-sql: true
</code></pre>
<p>2、SpringBoot 主数据配置。步骤：创建DataSource—》创建EntityManagerFactory—》创建TransactionManager—》开启JPA</p>
<pre><code class="java">package com.example.config;

import com.zaxxer.hikari.HikariDataSource;
import org.springframework.boot.autoconfigure.orm.jpa.HibernateProperties;
import org.springframework.boot.autoconfigure.orm.jpa.HibernateSettings;
import org.springframework.boot.autoconfigure.orm.jpa.JpaProperties;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.boot.jdbc.DataSourceBuilder;
import org.springframework.boot.orm.jpa.EntityManagerFactoryBuilder;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Primary;
import org.springframework.data.jpa.repository.config.EnableJpaRepositories;
import org.springframework.orm.jpa.JpaTransactionManager;
import org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean;
import org.springframework.transaction.PlatformTransactionManager;
import org.springframework.transaction.annotation.EnableTransactionManagement;

import javax.annotation.Resource;
import javax.persistence.EntityManager;
import javax.sql.DataSource;
import java.util.Map;

/**
 * 配置顺序如下：
 *   创建DataSource—》创建EntityManagerFactory—》创建TransactionManager—》@EnableJpaRepositories开启JPA
 *
 * 在多数据源配置中还是需要手动开启事务 @EnableTransactionManagement，并受用 @Primary 注解指定了主要的事务管理器
 * 利⽤ EnableJpaRepositories 配置哪些包下⾯的 Repositories，采⽤哪个 EntityManagerFactory 和哪个 TransactionManagement
 */
@Configuration
@EnableTransactionManagement  // 开启事务
@EnableJpaRepositories(
        entityManagerFactoryRef=&quot;entityManagerFactoryMaster&quot;,  // 数据源的 repository 的包路径
        transactionManagerRef=&quot;transactionManagerMaster&quot;,  // 实体管理器工厂
        basePackages= &#123; &quot;com.example.repository.master&quot;&#125;)  // 扫描Repository所在位置
public class JPAConfigMaster &#123;
    @Resource
    private JpaProperties jpaProperties;

    @Resource
    private HibernateProperties hibernateProperties;

    @Primary
    @Bean(name = &quot;masterDataSource&quot;)
    @ConfigurationProperties(prefix=&quot;spring.datasource.master&quot;)
    public DataSource masterDataSource() &#123;
        return DataSourceBuilder.create().type(HikariDataSource.class).build();
    &#125;

    /**
     * primary实体工厂
     */
    @Primary
    @Bean(name = &quot;entityManagerFactoryMaster&quot;)
    public LocalContainerEntityManagerFactoryBean entityManagerFactoryMaster(EntityManagerFactoryBuilder builder) &#123;
        // 可以使用注入 EntityManagerFactoryBuilder 或者直接 new 来创建 LocalContainerEntityManagerFactoryBean
        // LocalContainerEntityManagerFactoryBean factoryBean = new LocalContainerEntityManagerFactoryBean();
        Map&lt;String,Object&gt; properties = hibernateProperties.determineHibernateProperties(jpaProperties.getProperties(), new HibernateSettings());

        return builder.dataSource(masterDataSource())
                .properties(properties)
                // 扫描的实体类所在位置.所有带有 @Entity 注解的类
                .packages(&quot;com.example.model&quot;)
                // jpa定义的名称, Spring会将EntityManagerFactory注入到Repository之中.有了 EntityManagerFactory之后,
                // Repository就能用它来创建 EntityManager 了,然后 EntityManager 就可以针对数据库执行操作
                .persistenceUnit(&quot;masterPersistenceUnit&quot;)
                .build();
    &#125;

    /**
     * master实体管理器
     */
    @Primary
    @Bean(name = &quot;entityManagerMaster&quot;)
    public EntityManager entityManagerMaster(EntityManagerFactoryBuilder builder) &#123;
        return entityManagerFactoryMaster(builder).getObject().createEntityManager();
    &#125;

    /**
     * master事务管理器
     */
    @Primary
    @Bean(name = &quot;transactionManagerMaster&quot;)
    public PlatformTransactionManager transactionManagerMaster(EntityManagerFactoryBuilder builder) &#123;
        return new JpaTransactionManager(entityManagerFactoryMaster(builder).getObject());
    &#125;
&#125;
</code></pre>
<p>3、SpringBoot 从数据配置。步骤：创建DataSource—》创建EntityManagerFactory—》创建TransactionManager—》开启JPA</p>
<pre><code class="java">package com.example.config;

import com.zaxxer.hikari.HikariDataSource;
import org.springframework.boot.autoconfigure.orm.jpa.HibernateProperties;
import org.springframework.boot.autoconfigure.orm.jpa.HibernateSettings;
import org.springframework.boot.autoconfigure.orm.jpa.JpaProperties;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.boot.jdbc.DataSourceBuilder;
import org.springframework.boot.orm.jpa.EntityManagerFactoryBuilder;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Primary;
import org.springframework.data.jpa.repository.config.EnableJpaRepositories;
import org.springframework.orm.jpa.JpaTransactionManager;
import org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean;
import org.springframework.transaction.PlatformTransactionManager;
import org.springframework.transaction.annotation.EnableTransactionManagement;

import javax.annotation.Resource;
import javax.persistence.EntityManager;
import javax.sql.DataSource;
import java.util.Map;

/**
 * 配置顺序如下：
 *  创建DataSource—》创建EntityManagerFactory—》创建TransactionManager—》@EnableJpaRepositories开启JPA
 * 利⽤ EnableJpaRepositories 配置哪些包下⾯的 Repositories，采⽤哪个 EntityManagerFactory 和哪个 TransactionManagement
 */
@Configuration
@EnableTransactionManagement  // 开启事务
@EnableJpaRepositories(
        entityManagerFactoryRef=&quot;entityManagerFactorySlave&quot;,  // 数据源的 repository 的包路径
        transactionManagerRef=&quot;transactionManagerSlave&quot;,  // 实体管理器工厂
        basePackages= &#123; &quot;com.example.repository.slave&quot;&#125;)  // 扫描Repository所在位置
public class JPAConfigSlave &#123;
    @Resource
    private JpaProperties jpaProperties;

    @Resource
    private HibernateProperties hibernateProperties;

    @Bean(name = &quot;slaveDataSource&quot;)
    @ConfigurationProperties(prefix=&quot;spring.datasource.slave&quot;)
    public DataSource slaveDataSource() &#123;
        return DataSourceBuilder.create().type(HikariDataSource.class).build();
    &#125;

    /**
     * Slave实体工厂
     */
    @Bean(name = &quot;entityManagerFactorySlave&quot;)
    public LocalContainerEntityManagerFactoryBean entityManagerFactorySlave(EntityManagerFactoryBuilder builder) &#123;

        Map&lt;String,Object&gt; properties = hibernateProperties.determineHibernateProperties(jpaProperties.getProperties(), new HibernateSettings());

        return builder.dataSource(slaveDataSource())
                .properties(properties)
                .packages(&quot;com.example.model&quot;)
                .persistenceUnit(&quot;slavePersistenceUnit&quot;)
                .build();
    &#125;

    /**
     * Slave实体管理器
     */
    @Bean(name = &quot;entityManagerSlave&quot;)
    public EntityManager entityManagerSlave(EntityManagerFactoryBuilder builder) &#123;
        return entityManagerFactorySlave(builder).getObject().createEntityManager();
    &#125;

    /**
     * Slave事务管理器
     */
    @Bean(name = &quot;transactionManagerSlave&quot;)
    public PlatformTransactionManager transactionManagerSlave(EntityManagerFactoryBuilder builder) &#123;
        return new JpaTransactionManager(entityManagerFactorySlave(builder).getObject());
    &#125;
&#125;
</code></pre>
<p>4、数据表对应实体类的创建</p>
<ul>
<li><p>创建主数据源对应的实体类</p>
<pre><code class="java">package com.example.model.master;

import lombok.Data;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.Id;
import javax.persistence.Table;

@Data
@Entity
@Table(name = &quot;USER_INFO&quot;)
public class UserInfoMaster &#123;
    @Id
    @GeneratedValue
    private Integer Id;
    private String name;
    private String type;
&#125;
</code></pre>
</li>
<li><p>创建从数据源对应的实体类</p>
<pre><code class="java">package com.example.model.slave;

import lombok.Data;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.Id;
import javax.persistence.Table;

@Data
@Entity
@Table(name = &quot;USER_INFO&quot;)
public class UserInfoSlave &#123;
    @Id
    @GeneratedValue
    private Integer Id;
    private String name;
    private String type;
&#125;
</code></pre>
</li>
<li><p>如果主从数据源中的表子段和类型一模一样可以使用同一个实体类</p>
<pre><code class="java">package com.example.model;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.Id;
import javax.persistence.Table;

@Data
@Builder
@AllArgsConstructor
@NoArgsConstructor
@Entity
@Table(name = &quot;USER_INFO&quot;)
public class UserInfo &#123;
    @Id
    @GeneratedValue
    private Integer Id;
    private String name;
    private String type;
&#125;
</code></pre>
</li>
</ul>
<p>5、主数据源Repository的创建</p>
<pre><code class="java">package com.example.repository.master;

import com.example.model.UserInfo;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Modifying;
import org.springframework.data.jpa.repository.Query;
import org.springframework.transaction.annotation.Transactional;

public interface UserRepositoryMaster extends JpaRepository&lt;UserInfo, Integer&gt; &#123;
    @Transactional
    @Query(value = &quot;drop table if exists USER_INFO;&quot;,nativeQuery=true)
    @Modifying
    void dropUserExistTable();

    @Transactional
    @Query( value= &quot;create TABLE USER_INFO (id BIGINT NOT NULL AUTO_INCREMENT,name VARCHAR(50) DEFAULT NULL,type VARCHAR(50) DEFAULT NULL,PRIMARY KEY (id))&quot;,nativeQuery=true)
    @Modifying
    void createUserTable();

    @Transactional
    @Query(value=&quot;insert into USER_INFO (id, name, type) values (1, &#39;Jone&#39;, &#39;master&#39;),(2, &#39;Kath&#39;, &#39;master&#39;),(3, &#39;Tom&#39;, &#39;master&#39;),(4, &#39;Sandy&#39;, &#39;master&#39;),(5, &#39;Oliver&#39;, &#39;master&#39;);&quot;,nativeQuery=true)
    @Modifying
    int initTableData();
&#125;
</code></pre>
<p>6、从数据源Repository的创建</p>
<pre><code class="java">package com.example.repository.slave;

import com.example.model.UserInfo;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Modifying;
import org.springframework.data.jpa.repository.Query;
import org.springframework.transaction.annotation.Transactional;

public interface UserRepositorySlave extends JpaRepository&lt;UserInfo, Integer&gt; &#123;
    @Transactional
    @Query(value = &quot;drop table if exists USER_INFO;&quot;,nativeQuery=true)
    @Modifying
    void dropUserExistTable();

    @Transactional
    @Query( value= &quot;create TABLE USER_INFO (id BIGINT NOT NULL AUTO_INCREMENT,name VARCHAR(50) DEFAULT NULL,type VARCHAR(50) DEFAULT NULL,PRIMARY KEY (id))&quot;,nativeQuery=true)
    @Modifying
    void createUserTable();

    @Transactional
    @Query(value=&quot;insert into USER_INFO (id, name, type) values (1, &#39;Jone&#39;, &#39;slave&#39;),(2, &#39;Kath&#39;, &#39;slave&#39;),(3, &#39;Tom&#39;, &#39;slave&#39;),(4, &#39;Sandy&#39;, &#39;slave&#39;),(5, &#39;Oliver&#39;, &#39;slave&#39;);&quot;,nativeQuery=true)
    @Modifying
    int initTableData();
&#125;
</code></pre>
<h3 id="3、多数据源使用-2"><a href="#3、多数据源使用-2" class="headerlink" title="3、多数据源使用"></a>3、多数据源使用</h3><p>1、经过上面的多套数据源配置，可知道，若需要操作哪个数据库，直接使用对应的 repository 进行 CRUD 操作即可。</p>
<pre><code class="java">package com.example.controller;

import com.example.repository.master.UserRepositoryMaster;
import com.example.repository.slave.UserRepositorySlave;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

import javax.annotation.PostConstruct;
import javax.annotation.Resource;

@Slf4j
@RestController
public class UserController &#123;
    @Resource
    UserRepositoryMaster master;
    @Resource
    UserRepositorySlave slave;
    @PostConstruct
    public void init()&#123;
        log.info(&quot;-----------------初始化数据开始--------------------&quot;);
        // 初始化master数据源
        master.dropUserExistTable();
        master.createUserTable();
        master.initTableData();
        // 初始化slave数据源，
        slave.dropUserExistTable();
        slave.createUserTable();
        slave.initTableData();
        log.info(&quot;-----------------初始化数据结束--------------------&quot;);

        // 查询master初始化的数据
        log.info(&quot;============查询主数据源数据===============&quot;);
        master.findAll().forEach(System.out::println);
        // 查询slave初始化的数据
        log.info(&quot;============查询从数据源数据===============&quot;);
        slave.findAll().forEach(System.out::println);
    &#125;

    @GetMapping(&quot;/masterFindAllUser&quot;)
    public ResponseEntity masterFindAllUser()&#123;
        return ResponseEntity.ok(master.findAll());
    &#125;

    @GetMapping(&quot;/slaveFindAllUser&quot;)
    public ResponseEntity slaveFindAllUser()&#123;
        return ResponseEntity.ok(slave.findAll());
    &#125;
&#125;
</code></pre>
<p>2、项目启动就会执行 @PostConstruct 中的代码，进行数据初始化，我们可以查看日志</p>
<pre><code>2024-08-29 15:09:05.556  INFO 88210 --- [  restartedMain] com.example.controller.UserController    : -----------------初始化数据开始--------------------
2024-08-29 15:09:05.643  INFO 88210 --- [  restartedMain] com.example.controller.UserController    : -----------------初始化数据结束--------------------
2024-08-29 15:09:05.643  INFO 88210 --- [  restartedMain] com.example.controller.UserController    : ============查询主数据源数据===============
UserInfo(Id=1, name=Jone, type=master)
UserInfo(Id=2, name=Kath, type=master)
UserInfo(Id=3, name=Tom, type=master)
UserInfo(Id=4, name=Sandy, type=master)
UserInfo(Id=5, name=Oliver, type=master)
2024-08-29 15:09:05.693  INFO 88210 --- [  restartedMain] com.example.controller.UserController    : ============查询从数据源数据===============
UserInfo(Id=1, name=Jone, type=slave)
UserInfo(Id=2, name=Kath, type=slave)
UserInfo(Id=3, name=Tom, type=slave)
UserInfo(Id=4, name=Sandy, type=slave)
UserInfo(Id=5, name=Oliver, type=slave)
</code></pre>
<p>3、测试查询主数据源的 API</p>
<pre><code class="bash">curl -X GET &quot;localhost:8090/masterFindAllUser&quot;
[
  &#123;
    &quot;name&quot;: &quot;Jone&quot;,
    &quot;type&quot;: &quot;master&quot;,
    &quot;id&quot;: 1
  &#125;,
  &#123;
    &quot;name&quot;: &quot;Kath&quot;,
    &quot;type&quot;: &quot;master&quot;,
    &quot;id&quot;: 2
  &#125;,
  &#123;
    &quot;name&quot;: &quot;Tom&quot;,
    &quot;type&quot;: &quot;master&quot;,
    &quot;id&quot;: 3
  &#125;,
  &#123;
    &quot;name&quot;: &quot;Sandy&quot;,
    &quot;type&quot;: &quot;master&quot;,
    &quot;id&quot;: 4
  &#125;,
  &#123;
    &quot;name&quot;: &quot;Oliver&quot;,
    &quot;type&quot;: &quot;master&quot;,
    &quot;id&quot;: 5
  &#125;
]
</code></pre>
<p>4、测试查询从数据源的 API</p>
<pre><code class="bash">curl -X GET &quot;localhost:8090/slaveFindAllUser&quot; 
[
  &#123;
    &quot;name&quot;: &quot;Jone&quot;,
    &quot;type&quot;: &quot;slave&quot;,
    &quot;id&quot;: 1
  &#125;,
  &#123;
    &quot;name&quot;: &quot;Kath&quot;,
    &quot;type&quot;: &quot;slave&quot;,
    &quot;id&quot;: 2
  &#125;,
  &#123;
    &quot;name&quot;: &quot;Tom&quot;,
    &quot;type&quot;: &quot;slave&quot;,
    &quot;id&quot;: 3
  &#125;,
  &#123;
    &quot;name&quot;: &quot;Sandy&quot;,
    &quot;type&quot;: &quot;slave&quot;,
    &quot;id&quot;: 4
  &#125;,
  &#123;
    &quot;name&quot;: &quot;Oliver&quot;,
    &quot;type&quot;: &quot;slave&quot;,
    &quot;id&quot;: 5
  &#125;
]
</code></pre>
<h2 id="4、静态多数据源优缺点"><a href="#4、静态多数据源优缺点" class="headerlink" title="4、静态多数据源优缺点"></a>4、静态多数据源优缺点</h2><p>1、优点</p>
<ul>
<li>简单、直接：一个库对应一套处理方式，很好理解。</li>
<li>符合开闭原则（ OCP ）：开发的设计模式告诉我们，对扩展开放，对修改关闭，添加多一个数据库，原来的那一套不需要改动，只添加即可。</li>
</ul>
<p>2、缺点</p>
<ul>
<li>资源浪费：针对每一个数据源写一套操作，连接数据库的资源也是独立的，分别占用同样多的资源。<code>SqlSessionFactory</code> 是一个工厂，建议是使用单例，完全可以重用，不需要建立多个，只需要更改数据源即可，跟多线程，使用线程池减少资源消耗是同一道理。</li>
<li>代码冗余：在前面的多数据源配置中可以看出，其实 master 和 slave 的很多操作是一样的，只是改个名称而已，因此会造成代码冗余。</li>
<li>缺乏灵活：所有需要使用的地方都需要引入对应的mapper，对于很多操作，只是选择数据源的不一样，代码逻辑是一致的。另外，对于一主多从的情况，若需要对多个从库进行负载均衡，相对比较麻烦。</li>
</ul>
<p>正因为有上述的缺点，所以还有改进的空间。于是就有了动态数据源，至于动态数据源如何实现，下回分解。</p>
<h1 id="3、SpringBoot-动态多数据源"><a href="#3、SpringBoot-动态多数据源" class="headerlink" title="3、SpringBoot 动态多数据源"></a>3、SpringBoot 动态多数据源</h1><p>动态数据源可以解决多套数据源的处理不够灵活、占用资源多等问题。用户可以根据实际的业务需要，统一操作逻辑，只要在需要切换数据源的进行处理即可。何为动态，其实是批切换数据源的时机可以动态选择，在需要的地方进行切换即可。</p>
<p>Spring Boot 的动态数据源，本质上是把多个数据源存储在一个 Map 中，当需要使用某个数据源时，从 Map 中获取此数据源进行处理。而在 Spring 中，已提供了抽象类 <code>AbstractRoutingDataSource</code> 来实现此功能。因此，我们在实现动态数据源的，只需要继承它，实现自己的获取数据源逻辑即可。</p>
<p>用户访问应用，在需要访问不同的数据源时，根据自己的数据源路由逻辑，访问不同的数据源，实现对应数据源的操作。</p>
<h2 id="1、JdbcTemplate-H2-动态多数据源配置"><a href="#1、JdbcTemplate-H2-动态多数据源配置" class="headerlink" title="1、JdbcTemplate + H2 动态多数据源配置"></a>1、JdbcTemplate + H2 动态多数据源配置</h2><h3 id="1、动态数据源配置"><a href="#1、动态数据源配置" class="headerlink" title="1、动态数据源配置"></a>1、动态数据源配置</h3><p>1、添加项目依赖</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;parent&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
        &lt;version&gt;2.7.18&lt;/version&gt;
        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;
    &lt;/parent&gt;
    &lt;groupId&gt;com.example&lt;/groupId&gt;
    &lt;artifactId&gt;h2-jdbctemplate-multi-datasource-dynamic&lt;/artifactId&gt;
    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;
    &lt;name&gt;h2-jdbctemplate-multi-datasource-dynamic&lt;/name&gt;
    &lt;description&gt;Demo project for Spring Boot&lt;/description&gt;
    &lt;properties&gt;
        &lt;maven.compiler.source&gt;11&lt;/maven.compiler.source&gt;
        &lt;maven.compiler.target&gt;11&lt;/maven.compiler.target&gt;   
    &lt;/properties&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!-- https://mvnrepository.com/artifact/com.h2database/h2 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.h2database&lt;/groupId&gt;
            &lt;artifactId&gt;h2&lt;/artifactId&gt;
            &lt;scope&gt;runtime&lt;/scope&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
            &lt;artifactId&gt;lombok&lt;/artifactId&gt;
            &lt;optional&gt;true&lt;/optional&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

    &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;

&lt;/project&gt;
</code></pre>
<p>2、添加以下自定义的主从数据库配置 application.yml，这里暂时值定义了2个数据源，后面可以通过代码逻辑手动添加新的数据源</p>
<pre><code class="yaml">server:
  port: 8090
spring:
  #################### H2 数据库配置 ####################
  # 文件数据库
  # spring.datasource.url = jdbc:h2:file:./dbh2/dbc2m;AUTO_SERVER=TRUE
  # 内存数据库，platform #表明使用的数据库平台是 h2
  datasource:
    master:
      driver-class-name: org.h2.Driver
      jdbc-url: jdbc:h2:mem:master
      password: sa
      username: sa
      platform: h2
    slave:
      driver-class-name: org.h2.Driver
      jdbc-url: jdbc:h2:mem:slave
      password: sa
      username: sa
      platform: h2
  #################### H2 Web Console设置 ####################
  ### enabled：程序开启时就会启动 H2 Web Console, 默认就是启动的
  ### path：配置访问地址为：/h2，访问 H2 Web Console，默认:/h2-console
  ### settings.web-allow-others：开启H2 Web Console远程访问，默认为false不开启只能在本机访问
  h2:
    console:
      enabled: true
      path: /h2
      settings:
        web-allow-others: true
</code></pre>
<h3 id="2、动态数据源设置"><a href="#2、动态数据源设置" class="headerlink" title="2、动态数据源设置"></a>2、动态数据源设置</h3><p>1、 多数据源配置类：DataSourceConfig</p>
<pre><code class="java">package com.example.config;

import com.zaxxer.hikari.HikariDataSource;
import org.springframework.boot.autoconfigure.EnableAutoConfiguration;
import org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.boot.jdbc.DataSourceBuilder;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Primary;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.datasource.DataSourceTransactionManager;
import org.springframework.transaction.PlatformTransactionManager;

import javax.sql.DataSource;
import java.util.HashMap;
import java.util.Map;

/**
 * @EnableAutoConfiguration 就是去掉springboot默认自动配置数据源
 */
@Configuration
@EnableAutoConfiguration(exclude = &#123; DataSourceAutoConfiguration.class &#125;)
public class DataSourceConfig &#123;

    @Bean
    @ConfigurationProperties(prefix = &quot;spring.datasource.master&quot;)
    public DataSource dataSourceMaster() &#123;
        return DataSourceBuilder.create().type(HikariDataSource.class).build();
    &#125;

    @Bean
    @ConfigurationProperties(prefix = &quot;spring.datasource.slave&quot;)
    public DataSource dataSourceSlave() &#123;
        return DataSourceBuilder.create().type(HikariDataSource.class).build();
    &#125;

    /**
     * 使用 Map 保存多个数据源，并设置到动态数据源对象中。
     * 设置默认的数据源是 master 数据源
     * 使用注解 Primary 优先从动态数据源中获取
     * 注意: 这个才是主数据源
     */
    @Primary
    @Bean
    public DynamicDataSource dynamicDataSource()&#123;
        DynamicDataSource dynamicDataSource = new DynamicDataSource();
        Map&lt;Object, Object&gt; targetDataSources = new HashMap&lt;&gt;();
        targetDataSources.put(&quot;master&quot;,dataSourceMaster());
        targetDataSources.put(&quot;slave&quot;, dataSourceSlave());
        // 设置默认数据源
        dynamicDataSource.setDefaultTargetDataSource(dataSourceMaster());
        // 添加数据源集合
        dynamicDataSource.setTargetDataSources(targetDataSources);
        return dynamicDataSource;
    &#125;

    /**
     * 事务管理
     */
    @Bean(name = &quot;transactionManagerMaster&quot;)
    public PlatformTransactionManager platformTransactionManager() &#123;
        return new DataSourceTransactionManager(dynamicDataSource());
    &#125;

    /**
     * 初始化JdbcTemplate，实际上也可以不配置。
     * JdbcTemplate 在动态多数据源配置中的工作原理依赖于 Spring 的数据源抽象、事务管理器以及 AbstractRoutingDataSource 的动态路由能力。
     * 这些机制使得 Spring JDBC 能够在不显式配置 @Bean 的情况下，自动选择并使用正确的数据源进行数据库操作。
     */
    @Bean
    public JdbcTemplate jdbcTemplate() &#123;
        return new JdbcTemplate(dynamicDataSource());
    &#125;
&#125;
</code></pre>
<p>2、动态数据设置以及获取类：实现 AbstractRoutingDataSource 的方法，使用 DynamicDataSourceContextHolder 统一数据源管理</p>
<pre><code class="java">package com.example.config;

import org.springframework.jdbc.datasource.lookup.AbstractRoutingDataSource;
import java.util.HashMap;
import java.util.Map;

public class DynamicDataSource extends AbstractRoutingDataSource &#123;
    /**
     * 添加一个DataSources Map，用来获取数据源集合
     */
    private final Map&lt;Object, Object&gt; targetDataSources = new HashMap&lt;&gt;();
    public Map&lt;Object, Object&gt; getTargetDataSources() &#123;
        return targetDataSources;
    &#125;

    /**
     * 重写setTargetDataSources方法，为了可以让自己实现动态添加数据源
     * @param targetDataSources
     */
    @Override
    public void setTargetDataSources(Map&lt;Object, Object&gt; targetDataSources) &#123;
        this.targetDataSources.putAll(targetDataSources);
        super.setTargetDataSources(this.targetDataSources);
        super.afterPropertiesSet(); // 必须添加该句，否则新添加数据源无法识别到
    &#125;

    /**
     * 必须实现该接口。用来获取当前数据源
     */
    @Override
    protected Object determineCurrentLookupKey() &#123;
        // 或者return null.细节看源码AbstractRoutingDataSource.determineTargetDataSource
        return DynamicDataSourceContextHolder.getDataSource();
    &#125;
&#125;
</code></pre>
<p>3、DynamicDataSourceContextHolder 类的实现，通过 ThreadLocal 获取和设置线程安全的数据源 key</p>
<pre><code class="java">package com.example.config;

import lombok.extern.slf4j.Slf4j;

@Slf4j
public class DynamicDataSourceContextHolder &#123;
    /**
     * 动态数据源名称上下文
     */
    private static final ThreadLocal&lt;String&gt; contextLocal = ThreadLocal.withInitial(() -&gt; &quot;master&quot;);
    // private static final ThreadLocal&lt;String&gt; contextLocal = new ThreadLocal&lt;&gt;();

    /**
     * 设置数据源
     */
    public static void setDataSource(String key) &#123;
        log.info(&quot;-----------切换数据源：&quot; + key + &quot;---------------&quot;);
        contextLocal.set(key);
    &#125;

    /**
     * 获取数据源
     */
    public static String getDataSource() &#123;
        String key = contextLocal.get();
        log.info(&quot;-----------当前数据源：&quot; + key + &quot;---------------&quot;);
        return key;
    &#125;

    /**
     * 重置/释放数据源
     */
    public static void clearDataSource() &#123;
        contextLocal.remove();
        String key = contextLocal.get();
        log.info(&quot;-----------重置数据源：&quot; + key + &quot;---------------&quot;);
    &#125;
&#125;
</code></pre>
<h3 id="3、动态数据的使用【手动切换】"><a href="#3、动态数据的使用【手动切换】" class="headerlink" title="3、动态数据的使用【手动切换】"></a>3、动态数据的使用【手动切换】</h3><p>1、动态数据源使用，这里编写一个 Controller，里面有一个动态初始化数据源接口，一个初始化每个数据源的表和数据的接口，另外还有3个查询不同数据源中数据的接口</p>
<pre><code class="java">package com.example.controller;

import com.example.config.DynamicDataSource;
import com.example.config.DynamicDataSourceContextHolder;
import lombok.extern.slf4j.Slf4j;
import org.springframework.boot.jdbc.DataSourceBuilder;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import javax.annotation.Resource;
import javax.sql.DataSource;
import java.util.List;
import java.util.Map;
import java.util.stream.Stream;

@Slf4j
@RestController
public class MultiController &#123;

    @Resource
    JdbcTemplate jdbcTemplate;
    @Resource
    DynamicDataSource dynamicDataSource;

    /**
     * 动态数据源配置 &amp; 运行时新增数据源
     * 可以从数据库中加载, 也可以通过API新增
     */
    @RequestMapping(&quot;initDataSource&quot;)
    public String initDataSource() &#123;
        log.info(&quot;===============初始化动态数据源===============&quot;);
        Map&lt;Object, Object&gt; dataSourceMap = dynamicDataSource.getTargetDataSources();
        Stream.of(1, 2, 3).forEach(i -&gt; &#123;
            DataSource build = DataSourceBuilder.create()
                    .username(&quot;sa&quot;)
                    .password(&quot;sa&quot;)
                    .url(&quot;jdbc:h2:mem:test_&quot; + i)
                    .build();
            dataSourceMap.put(&quot;test_&quot; + i, build);
        &#125;);
        dynamicDataSource.setTargetDataSources(dataSourceMap);
        log.info(&quot;===============动态数据源初始完毕===============&quot;);
        return &quot;init dataSource success&quot;;
    &#125;

    /**
     * 给新增的数据源创建表和初始化数据
     */
    @RequestMapping(&quot;initData&quot;)
    public String initData() &#123;
        Stream.of(1, 2, 3).forEach(i -&gt; &#123;
            // 切换数据源
            DynamicDataSourceContextHolder.setDataSource(&quot;test_&quot; + i);
            // 初始化表和数据
            jdbcTemplate.execute(&quot;DROP TABLE IF EXISTS USER_INFO&quot;);
            jdbcTemplate.execute(&quot;CREATE TABLE USER_INFO (&quot;
                    + &quot;id BIGINT NOT NULL,&quot;
                    + &quot;name VARCHAR(50) DEFAULT NULL,&quot;
                    + &quot;type VARCHAR(50) DEFAULT NULL,&quot;
                    + &quot;PRIMARY KEY (id))&quot;);
            String sql = &quot;INSERT INTO USER_INFO (id, name, type) VALUES (?, ?, ?)&quot;;
            jdbcTemplate.update(sql, 1, &quot;Jone&quot;, &quot;db_test_&quot; + i);
            jdbcTemplate.update(sql, 2, &quot;Kath&quot;, &quot;db_test_&quot; + i);
            jdbcTemplate.update(sql, 3, &quot;Tom&quot;, &quot;db_test_&quot; + i);
            jdbcTemplate.update(sql, 4, &quot;Sandy&quot;, &quot;db_test_&quot; + i);
            jdbcTemplate.update(sql, 5, &quot;Oliver&quot;, &quot;db_test_&quot; + i);
            // 还原数据源
            DynamicDataSourceContextHolder.clearDataSource();
        &#125;);
        return &quot;init data success&quot;;
    &#125;

    @RequestMapping(&quot;/test1&quot;)
    public List&lt;Map&lt;String, Object&gt;&gt; test1() &#123;
        DynamicDataSourceContextHolder.setDataSource(&quot;test_1&quot;);
        List&lt;Map&lt;String, Object&gt;&gt; list = jdbcTemplate.queryForList(&quot;select * from USER_INFO&quot;);
        DynamicDataSourceContextHolder.clearDataSource();
        return list;
    &#125;

    @RequestMapping(&quot;/test2&quot;)
    public List&lt;Map&lt;String, Object&gt;&gt; test2() &#123;
        DynamicDataSourceContextHolder.setDataSource(&quot;test_2&quot;);
        List&lt;Map&lt;String, Object&gt;&gt; list = jdbcTemplate.queryForList(&quot;select * from USER_INFO&quot;);
        DynamicDataSourceContextHolder.clearDataSource();
        return list;
    &#125;

    @RequestMapping(&quot;/test3&quot;)
    public List&lt;Map&lt;String, Object&gt;&gt; test3() &#123;
        DynamicDataSourceContextHolder.setDataSource(&quot;test_3&quot;);
        List&lt;Map&lt;String, Object&gt;&gt; list = jdbcTemplate.queryForList(&quot;select * from USER_INFO&quot;);
        DynamicDataSourceContextHolder.clearDataSource();
        return list;
    &#125;
&#125;
</code></pre>
<p>2、调用新增动态数据源 &amp; 运行时新增数据源的接口</p>
<pre><code class="bash">curl -X GET &quot;localhost:8090/initDataSource&quot;
init dataSource success
</code></pre>
<p>3、调用初始化每个数据源表和数据的接口</p>
<pre><code class="bash">curl -X GET &quot;localhost:8090/initData&quot;      
init data succes
</code></pre>
<p>4、查询不同数据源中数据的接口</p>
<pre><code class="bash">curl -X GET &quot;localhost:8090/test1&quot;   
[&#123;&quot;ID&quot;:1,&quot;NAME&quot;:&quot;Jone&quot;,&quot;TYPE&quot;:&quot;db_test_1&quot;&#125;,
&#123;&quot;ID&quot;:2,&quot;NAME&quot;:&quot;Kath&quot;,&quot;TYPE&quot;:&quot;db_test_1&quot;&#125;,
&#123;&quot;ID&quot;:3,&quot;NAME&quot;:&quot;Tom&quot;,&quot;TYPE&quot;:&quot;db_test_1&quot;&#125;,
&#123;&quot;ID&quot;:4,&quot;NAME&quot;:&quot;Sandy&quot;,&quot;TYPE&quot;:&quot;db_test_1&quot;&#125;,
&#123;&quot;ID&quot;:5,&quot;NAME&quot;:&quot;Oliver&quot;,&quot;TYPE&quot;:&quot;db_test_1&quot;&#125;]

curl -X GET &quot;localhost:8090/test2&quot;
[&#123;&quot;ID&quot;:1,&quot;NAME&quot;:&quot;Jone&quot;,&quot;TYPE&quot;:&quot;db_test_2&quot;&#125;,
&#123;&quot;ID&quot;:2,&quot;NAME&quot;:&quot;Kath&quot;,&quot;TYPE&quot;:&quot;db_test_2&quot;&#125;,
&#123;&quot;ID&quot;:3,&quot;NAME&quot;:&quot;Tom&quot;,&quot;TYPE&quot;:&quot;db_test_2&quot;&#125;,
&#123;&quot;ID&quot;:4,&quot;NAME&quot;:&quot;Sandy&quot;,&quot;TYPE&quot;:&quot;db_test_2&quot;&#125;,
&#123;&quot;ID&quot;:5,&quot;NAME&quot;:&quot;Oliver&quot;,&quot;TYPE&quot;:&quot;db_test_2&quot;&#125;]

curl -X GET &quot;localhost:8090/test3&quot; 
[&#123;&quot;ID&quot;:1,&quot;NAME&quot;:&quot;Jone&quot;,&quot;TYPE&quot;:&quot;db_test_3&quot;&#125;,
&#123;&quot;ID&quot;:2,&quot;NAME&quot;:&quot;Kath&quot;,&quot;TYPE&quot;:&quot;db_test_3&quot;&#125;,
&#123;&quot;ID&quot;:3,&quot;NAME&quot;:&quot;Tom&quot;,&quot;TYPE&quot;:&quot;db_test_3&quot;&#125;,
&#123;&quot;ID&quot;:4,&quot;NAME&quot;:&quot;Sandy&quot;,&quot;TYPE&quot;:&quot;db_test_3&quot;&#125;,
&#123;&quot;ID&quot;:5,&quot;NAME&quot;:&quot;Oliver&quot;,&quot;TYPE&quot;:&quot;db_test_3&quot;&#125;]
</code></pre>
<h3 id="4、动态数据源使用【AOP切换】"><a href="#4、动态数据源使用【AOP切换】" class="headerlink" title="4、动态数据源使用【AOP切换】"></a>4、动态数据源使用【AOP切换】</h3><p>1、增加 AOP 依赖</p>
<pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<p>2、定义数据源注解</p>
<pre><code class="java">package com.example.annotation;

import java.lang.annotation.*;

/**
 * 数据源切换扫描注解
 */
@Documented
@Target(&#123;ElementType.METHOD&#125;)
@Retention(RetentionPolicy.RUNTIME)
public @interface DS &#123;
    String value() default &quot;master&quot;;
&#125;
</code></pre>
<p>3、定义数据源切面</p>
<pre><code class="java">package com.example.aop;

import com.example.annotation.DS;
import lombok.extern.slf4j.Slf4j;
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Pointcut;
import org.aspectj.lang.reflect.MethodSignature;
import org.springframework.stereotype.Component;

import java.lang.reflect.Method;

@Slf4j
@Aspect
@Component
public class DataSourceAspect &#123;

    @Pointcut(&quot;@annotation(com.example.annotation.DS)&quot;)
    public void dataSourcePointCut() &#123;
    &#125;

    @Around(&quot;dataSourcePointCut()&quot;)
    public Object around(ProceedingJoinPoint point) throws Throwable &#123;
        MethodSignature signature = (MethodSignature) point.getSignature();
        Method method = signature.getMethod();
        DS DS = method.getAnnotation(DS.class);
        log.info(&quot;注解的拦截方法名注解内容前: &#123;&#125;&quot;, DS.value());
        DynamicDataSourceContextHolder.setDataSource(DS.value());
        try &#123;
            return point.proceed();
        &#125; finally &#123;
            DynamicDataSourceContextHolder.clearDataSource();
        &#125;
    &#125;
&#125;
</code></pre>
<p>4、使用 AOP 进行数据源切换</p>
<pre><code class="java">package com.example.controller;

import com.example.annotation.DS;
import com.example.config.DynamicDataSource;
import com.example.config.DynamicDataSourceContextHolder;
import lombok.extern.slf4j.Slf4j;
import org.springframework.boot.jdbc.DataSourceBuilder;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import javax.annotation.Resource;
import javax.sql.DataSource;
import java.util.List;
import java.util.Map;
import java.util.stream.Stream;

@Slf4j
@RestController
public class MultiController &#123;

    @Resource
    JdbcTemplate jdbcTemplate;
    @Resource
    DynamicDataSource dynamicDataSource;

    /**
     * 动态数据源配置 &amp; 运行时新增数据源
     * 可以从数据库中加载, 也可以通过API新增
     */
    @RequestMapping(&quot;initDataSource&quot;)
    public String initDataSource() &#123;
        log.info(&quot;===============初始化动态数据源===============&quot;);
        Map&lt;Object, Object&gt; dataSourceMap = dynamicDataSource.getTargetDataSources();
        Stream.of(1, 2, 3).forEach(i -&gt; &#123;
            DataSource build = DataSourceBuilder.create()
                    .username(&quot;sa&quot;)
                    .password(&quot;sa&quot;)
                    .url(&quot;jdbc:h2:mem:test_&quot; + i)
                    .build();
            dataSourceMap.put(&quot;test_&quot; + i, build);
        &#125;);
        dynamicDataSource.setTargetDataSources(dataSourceMap);
        log.info(&quot;===============动态数据源初始完毕===============&quot;);
        return &quot;init dataSource success&quot;;
    &#125;

    /**
     * 给新增的数据源创建表和初始化数据
     */
    @RequestMapping(&quot;initData&quot;)
    public String initData() &#123;
        Stream.of(1, 2, 3).forEach(i -&gt; &#123;
            // 切换数据源
            DynamicDataSourceContextHolder.setDataSource(&quot;test_&quot; + i);
            // 初始化表和数据
            jdbcTemplate.execute(&quot;DROP TABLE IF EXISTS USER_INFO&quot;);
            jdbcTemplate.execute(&quot;CREATE TABLE USER_INFO (&quot;
                    + &quot;id BIGINT NOT NULL,&quot;
                    + &quot;name VARCHAR(50) DEFAULT NULL,&quot;
                    + &quot;type VARCHAR(50) DEFAULT NULL,&quot;
                    + &quot;PRIMARY KEY (id))&quot;);
            String sql = &quot;INSERT INTO USER_INFO (id, name, type) VALUES (?, ?, ?)&quot;;
            jdbcTemplate.update(sql, 1, &quot;Jone&quot;, &quot;db_test_&quot; + i);
            jdbcTemplate.update(sql, 2, &quot;Kath&quot;, &quot;db_test_&quot; + i);
            jdbcTemplate.update(sql, 3, &quot;Tom&quot;, &quot;db_test_&quot; + i);
            jdbcTemplate.update(sql, 4, &quot;Sandy&quot;, &quot;db_test_&quot; + i);
            jdbcTemplate.update(sql, 5, &quot;Oliver&quot;, &quot;db_test_&quot; + i);
            // 还原数据源
            DynamicDataSourceContextHolder.clearDataSource();
        &#125;);
        return &quot;init data success&quot;;
    &#125;

    @DS(&quot;test_1&quot;)
    @RequestMapping(&quot;/test11&quot;)
    public List&lt;Map&lt;String, Object&gt;&gt; test11() &#123;
        return jdbcTemplate.queryForList(&quot;select * from USER_INFO&quot;);
    &#125;

    @DS(&quot;test_2&quot;)
    @RequestMapping(&quot;/test22&quot;)
    public List&lt;Map&lt;String, Object&gt;&gt; test22() &#123;
        return jdbcTemplate.queryForList(&quot;select * from USER_INFO&quot;);
    &#125;

    @DS(&quot;test_3&quot;)
    @RequestMapping(&quot;/test33&quot;)
    public List&lt;Map&lt;String, Object&gt;&gt; test33() &#123;
        return jdbcTemplate.queryForList(&quot;select * from USER_INFO&quot;);
    &#125;
&#125;
</code></pre>
<p>5、调用新增动态数据源 &amp; 运行时新增数据源的接口</p>
<pre><code class="bash">curl -X GET &quot;localhost:8090/initDataSource&quot;
init dataSource success
</code></pre>
<p>6、调用初始化每个数据源表和数据的接口</p>
<pre><code class="bash">curl -X GET &quot;localhost:8090/initData&quot;      
init data succes
</code></pre>
<p>7、查询不同数据源中数据的接口</p>
<pre><code class="bash">curl -X GET &quot;localhost:8090/test11&quot;   
[&#123;&quot;ID&quot;:1,&quot;NAME&quot;:&quot;Jone&quot;,&quot;TYPE&quot;:&quot;db_test_1&quot;&#125;,
&#123;&quot;ID&quot;:2,&quot;NAME&quot;:&quot;Kath&quot;,&quot;TYPE&quot;:&quot;db_test_1&quot;&#125;,
&#123;&quot;ID&quot;:3,&quot;NAME&quot;:&quot;Tom&quot;,&quot;TYPE&quot;:&quot;db_test_1&quot;&#125;,
&#123;&quot;ID&quot;:4,&quot;NAME&quot;:&quot;Sandy&quot;,&quot;TYPE&quot;:&quot;db_test_1&quot;&#125;,
&#123;&quot;ID&quot;:5,&quot;NAME&quot;:&quot;Oliver&quot;,&quot;TYPE&quot;:&quot;db_test_1&quot;&#125;]

curl -X GET &quot;localhost:8090/test22&quot;
[&#123;&quot;ID&quot;:1,&quot;NAME&quot;:&quot;Jone&quot;,&quot;TYPE&quot;:&quot;db_test_2&quot;&#125;,
&#123;&quot;ID&quot;:2,&quot;NAME&quot;:&quot;Kath&quot;,&quot;TYPE&quot;:&quot;db_test_2&quot;&#125;,
&#123;&quot;ID&quot;:3,&quot;NAME&quot;:&quot;Tom&quot;,&quot;TYPE&quot;:&quot;db_test_2&quot;&#125;,
&#123;&quot;ID&quot;:4,&quot;NAME&quot;:&quot;Sandy&quot;,&quot;TYPE&quot;:&quot;db_test_2&quot;&#125;,
&#123;&quot;ID&quot;:5,&quot;NAME&quot;:&quot;Oliver&quot;,&quot;TYPE&quot;:&quot;db_test_2&quot;&#125;]

curl -X GET &quot;localhost:8090/test33&quot; 
[&#123;&quot;ID&quot;:1,&quot;NAME&quot;:&quot;Jone&quot;,&quot;TYPE&quot;:&quot;db_test_3&quot;&#125;,
&#123;&quot;ID&quot;:2,&quot;NAME&quot;:&quot;Kath&quot;,&quot;TYPE&quot;:&quot;db_test_3&quot;&#125;,
&#123;&quot;ID&quot;:3,&quot;NAME&quot;:&quot;Tom&quot;,&quot;TYPE&quot;:&quot;db_test_3&quot;&#125;,
&#123;&quot;ID&quot;:4,&quot;NAME&quot;:&quot;Sandy&quot;,&quot;TYPE&quot;:&quot;db_test_3&quot;&#125;,
&#123;&quot;ID&quot;:5,&quot;NAME&quot;:&quot;Oliver&quot;,&quot;TYPE&quot;:&quot;db_test_3&quot;&#125;]
</code></pre>
<h3 id="5、spring-data-jdbc-动态数据源手动及AOP切换"><a href="#5、spring-data-jdbc-动态数据源手动及AOP切换" class="headerlink" title="5、spring-data-jdbc 动态数据源手动及AOP切换"></a>5、spring-data-jdbc 动态数据源手动及AOP切换</h3><blockquote>
<p>在上面配置的基础上增加和修改</p>
</blockquote>
<p>1、替换spring-boot-starter-jdbc依赖为spring-boot-starter-data-jdbc</p>
<pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-data-jdbc&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<p>2、【<strong>此步骤可以省略</strong>】动态数据源源配置 JdbcAggregateTemplate，由于上面已经配置过DataSource 和 JdbcTemplate 这里就不展示了。</p>
<pre><code class="java">package com.example.config;

import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationEventPublisher;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Primary;
import org.springframework.data.jdbc.core.JdbcAggregateTemplate;
import org.springframework.data.jdbc.core.convert.*;
import org.springframework.data.relational.core.dialect.Dialect;
import org.springframework.data.relational.core.mapping.RelationalMappingContext;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;
import javax.sql.DataSource;

/**
 * 动态数据源配置: 初始化JdbcAggregateTemplate，实际上也可以不用显示配置。
 * JdbcTemplate 在动态多数据源配置中的工作原理依赖于 Spring 的数据源抽象、事务管理器以及 AbstractRoutingDataSource 的动态路由能力。
 * 这些机制使得 Spring JDBC 能够在不显式配置 @Bean 的情况下，自动选择并使用正确的数据源进行数据库操作。
 */
@Configuration
public class JdbcAggregateTemplateConfig &#123;

    @Primary
    @Bean(&quot;dataAccessStrategyMaster&quot;)
    public DataAccessStrategy dataAccessStrategy(
            @Qualifier(&quot;dynamicDataSource&quot;) DynamicDataSource dataSource,
            @Qualifier(&quot;jdbcTemplate&quot;) JdbcTemplate jdbcTemplate,
            RelationalMappingContext mappingContext,
            JdbcConverter converter,
            Dialect dialect) &#123;
        NamedParameterJdbcTemplate namedParameterJdbcTemplate = new NamedParameterJdbcTemplate(dataSource);
        BatchJdbcOperations batchJdbcOperations = new BatchJdbcOperations(jdbcTemplate);
        return new DefaultDataAccessStrategy(
                new SqlGeneratorSource(mappingContext, converter, dialect),
                mappingContext,
                converter,
                namedParameterJdbcTemplate,
                new SqlParametersFactory(mappingContext, converter, dialect),
                new InsertStrategyFactory(namedParameterJdbcTemplate, batchJdbcOperations, dialect));
    &#125;

    @Primary
    @Bean(&quot;jdbcAggregateTemplateMaster&quot;)
    public JdbcAggregateTemplate jdbcAggregateTemplate(
            // ApplicationEventPublisher publisher,
            ApplicationContext applicationContext,
            RelationalMappingContext relationalMappingContext,
            JdbcConverter jdbcConverter,
            @Qualifier(&quot;dataAccessStrategyMaster&quot;) DataAccessStrategy dataAccessStrategy) &#123;
        // 根据dataSource1配置 JdbcAggregateTemplate
        // return new JdbcAggregateTemplate(publisher, relationalMappingContext, jdbcConverter, dataAccessStrategy);
        return new JdbcAggregateTemplate(applicationContext, relationalMappingContext, jdbcConverter, dataAccessStrategy);
    &#125;
&#125;
</code></pre>
<p>3、数据表对应实体类的创建</p>
<pre><code class="java">package com.example.model;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.springframework.data.annotation.Id;
import org.springframework.data.relational.core.mapping.Table;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Table(name = &quot;USER_INFO&quot;)
public class UserInfo &#123;
    @Id
    private Integer Id;
    private String name;
    private String type;
&#125;
</code></pre>
<p>4、Copy 上面的 Controller 稍作改造，使用 SpringDataJDBC 的类 JdbcAggregateTemplate 来查询。需要搭配 JdbcTemplate。</p>
<pre><code class="java">package com.example.controller;

import com.example.annotation.DS;
import com.example.config.DynamicDataSource;
import com.example.config.DynamicDataSourceContextHolder;
import com.example.model.UserInfo;
import lombok.extern.slf4j.Slf4j;
import org.springframework.boot.jdbc.DataSourceBuilder;
import org.springframework.data.jdbc.core.JdbcAggregateTemplate;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import javax.annotation.Resource;
import javax.sql.DataSource;
import java.util.Map;
import java.util.stream.Stream;

@Slf4j
@RestController
public class MultiControllerDataJdbc &#123;

    @Resource
    JdbcTemplate jdbcTemplate;
    // 这里没有使用我们配置的JdbcAggregateTemplate，而是使用Spring自动配置的。使用2个中任意一个都是可以的
    @Resource
    JdbcAggregateTemplate jdbcAggregateTemplate;
    @Resource
    DynamicDataSource dynamicDataSource;

    /**
     * 动态数据源配置 &amp; 运行时新增数据源
     * 可以从数据库中加载, 也可以通过API新增
     */
    @RequestMapping(&quot;/data/initDataSource&quot;)
    public String initDataSource() &#123;
        log.info(&quot;===============初始化动态数据源===============&quot;);
        Map&lt;Object, Object&gt; dataSourceMap = dynamicDataSource.getTargetDataSources();
        Stream.of(1, 2, 3).forEach(i -&gt; &#123;
            DataSource build = DataSourceBuilder.create()
                    .username(&quot;sa&quot;)
                    .password(&quot;sa&quot;)
                    .url(&quot;jdbc:h2:mem:test_&quot; + i)
                    .build();
            dataSourceMap.put(&quot;test_&quot; + i, build);
        &#125;);
        dynamicDataSource.setTargetDataSources(dataSourceMap);
        log.info(&quot;===============动态数据源初始完毕===============&quot;);
        return &quot;init dataSource success&quot;;
    &#125;

    /**
     * 给新增的数据源创建表和初始化数据
     */
    @RequestMapping(&quot;/data/initData&quot;)
    public String initData() &#123;
        Stream.of(1, 2, 3).forEach(i -&gt; &#123;
            // 切换数据源
            DynamicDataSourceContextHolder.setDataSource(&quot;test_&quot; + i);
            // 初始化表和数据
            jdbcTemplate.execute(&quot;DROP TABLE IF EXISTS USER_INFO&quot;);
            jdbcTemplate.execute(&quot;CREATE TABLE USER_INFO (&quot;
                    + &quot;id BIGINT NOT NULL,&quot;
                    + &quot;name VARCHAR(50) DEFAULT NULL,&quot;
                    + &quot;type VARCHAR(50) DEFAULT NULL,&quot;
                    + &quot;PRIMARY KEY (id))&quot;);
            jdbcAggregateTemplate.insert(new UserInfo(1, &quot;Jone&quot;, &quot;db_test_&quot; + i));
            jdbcAggregateTemplate.insert(new UserInfo(2, &quot;Kath&quot;, &quot;db_test_&quot; + i));
            jdbcAggregateTemplate.insert(new UserInfo(3, &quot;Tom&quot;, &quot;db_test_&quot; + i));
            jdbcAggregateTemplate.insert(new UserInfo(4, &quot;Sandy&quot;, &quot;db_test_&quot; + i));
            jdbcAggregateTemplate.insert(new UserInfo(5, &quot;Oliver&quot;, &quot;db_test_&quot; + i));
            jdbcAggregateTemplate.findAll(UserInfo.class).forEach(x -&gt; log.info(&quot;&#123;&#125;&quot;, x));
            // 还原数据源
            DynamicDataSourceContextHolder.clearDataSource();
        &#125;);
        return &quot;init data success&quot;;
    &#125;

    @RequestMapping(&quot;/data/test1&quot;)
    public Iterable&lt;UserInfo&gt; test1() &#123;
        DynamicDataSourceContextHolder.setDataSource(&quot;test_1&quot;);
        Iterable&lt;UserInfo&gt; iterable = jdbcAggregateTemplate.findAll(UserInfo.class);
        DynamicDataSourceContextHolder.clearDataSource();
        return iterable;
    &#125;

    @RequestMapping(&quot;/data/test2&quot;)
    public Iterable&lt;UserInfo&gt; test2() &#123;
        DynamicDataSourceContextHolder.setDataSource(&quot;test_2&quot;);
        Iterable&lt;UserInfo&gt; iterable = jdbcAggregateTemplate.findAll(UserInfo.class);
        DynamicDataSourceContextHolder.clearDataSource();
        return iterable;
    &#125;

    @RequestMapping(&quot;/data/test3&quot;)
    public Iterable&lt;UserInfo&gt; test3() &#123;
        DynamicDataSourceContextHolder.setDataSource(&quot;test_3&quot;);
        Iterable&lt;UserInfo&gt; iterable = jdbcAggregateTemplate.findAll(UserInfo.class);
        DynamicDataSourceContextHolder.clearDataSource();
        return iterable;
    &#125;

    @DS(&quot;test_1&quot;)
    @RequestMapping(&quot;/data/test11&quot;)
    public Iterable&lt;UserInfo&gt; test11() &#123;
        return jdbcAggregateTemplate.findAll(UserInfo.class);
    &#125;

    @DS(&quot;test_2&quot;)
    @RequestMapping(&quot;/data/test22&quot;)
    public Iterable&lt;UserInfo&gt; test22() &#123;
        return jdbcAggregateTemplate.findAll(UserInfo.class);
    &#125;

    @DS(&quot;test_3&quot;)
    @RequestMapping(&quot;/data/test33&quot;)
    public Iterable&lt;UserInfo&gt; test33() &#123;
        return jdbcAggregateTemplate.findAll(UserInfo.class);
    &#125;
&#125;
</code></pre>
<p>5、调用新增动态数据源 &amp; 运行时新增数据源的接口，然后调用初始化每个数据源表和数据的接口</p>
<pre><code class="bash">curl -X GET &quot;localhost:8090/data/initDataSource&quot;
init dataSource success
curl -X GET &quot;localhost:8090/data/initData&quot;      
init data succes
###### test1接口 控制台输出的内容 ######
2024-09-04 11:16:40.955  INFO 21153 --- [nio-8090-exec-3] c.e.c.DynamicDataSourceContextHolder     : -----------切换数据源：test_1---------------
2024-09-04 11:16:40.956  INFO 21153 --- [nio-8090-exec-3] c.e.c.DynamicDataSourceContextHolder     : -----------当前数据源：test_1---------------
2024-09-04 11:16:40.968  INFO 21153 --- [nio-8090-exec-3] c.e.c.DynamicDataSourceContextHolder     : -----------当前数据源：test_1---------------
2024-09-04 11:16:40.984  INFO 21153 --- [nio-8090-exec-3] c.e.c.DynamicDataSourceContextHolder     : -----------当前数据源：test_1---------------
2024-09-04 11:16:40.988  INFO 21153 --- [nio-8090-exec-3] c.e.c.DynamicDataSourceContextHolder     : -----------当前数据源：test_1---------------
2024-09-04 11:16:40.990  INFO 21153 --- [nio-8090-exec-3] c.e.c.DynamicDataSourceContextHolder     : -----------当前数据源：test_1---------------
2024-09-04 11:16:40.992  INFO 21153 --- [nio-8090-exec-3] c.e.c.DynamicDataSourceContextHolder     : -----------当前数据源：test_1---------------
2024-09-04 11:16:40.995  INFO 21153 --- [nio-8090-exec-3] c.e.c.DynamicDataSourceContextHolder     : -----------当前数据源：test_1---------------
2024-09-04 11:16:40.996  INFO 21153 --- [nio-8090-exec-3] c.e.c.DynamicDataSourceContextHolder     : -----------当前数据源：test_1---------------
2024-09-04 11:16:40.998  INFO 21153 --- [nio-8090-exec-3] c.e.controller.MultiControllerDataJdbc   : UserInfo(Id=1, name=Jone, type=db_test_1)
2024-09-04 11:16:40.998  INFO 21153 --- [nio-8090-exec-3] c.e.controller.MultiControllerDataJdbc   : UserInfo(Id=2, name=Kath, type=db_test_1)
2024-09-04 11:16:40.998  INFO 21153 --- [nio-8090-exec-3] c.e.controller.MultiControllerDataJdbc   : UserInfo(Id=3, name=Tom, type=db_test_1)
2024-09-04 11:16:40.998  INFO 21153 --- [nio-8090-exec-3] c.e.controller.MultiControllerDataJdbc   : UserInfo(Id=4, name=Sandy, type=db_test_1)
2024-09-04 11:16:40.998  INFO 21153 --- [nio-8090-exec-3] c.e.controller.MultiControllerDataJdbc   : UserInfo(Id=5, name=Oliver, type=db_test_1)
2024-09-04 11:16:40.998  INFO 21153 --- [nio-8090-exec-3] c.e.c.DynamicDataSourceContextHolder     : -----------还原数据源：master---------------
2024-09-04 11:16:40.998  INFO 21153 --- [nio-8090-exec-3] c.e.c.DynamicDataSourceContextHolder     : -----------切换数据源：test_2---------------
2024-09-04 11:16:40.998  INFO 21153 --- [nio-8090-exec-3] c.e.c.DynamicDataSourceContextHolder     : -----------当前数据源：test_2---------------
2024-09-04 11:16:40.999  INFO 21153 --- [nio-8090-exec-3] c.e.c.DynamicDataSourceContextHolder     : -----------当前数据源：test_2---------------
2024-09-04 11:16:41.004  INFO 21153 --- [nio-8090-exec-3] c.e.c.DynamicDataSourceContextHolder     : -----------当前数据源：test_2---------------
2024-09-04 11:16:41.006  INFO 21153 --- [nio-8090-exec-3] c.e.c.DynamicDataSourceContextHolder     : -----------当前数据源：test_2---------------
2024-09-04 11:16:41.007  INFO 21153 --- [nio-8090-exec-3] c.e.c.DynamicDataSourceContextHolder     : -----------当前数据源：test_2---------------
2024-09-04 11:16:41.013  INFO 21153 --- [nio-8090-exec-3] c.e.c.DynamicDataSourceContextHolder     : -----------当前数据源：test_2---------------
2024-09-04 11:16:41.016  INFO 21153 --- [nio-8090-exec-3] c.e.c.DynamicDataSourceContextHolder     : -----------当前数据源：test_2---------------
2024-09-04 11:16:41.017  INFO 21153 --- [nio-8090-exec-3] c.e.c.DynamicDataSourceContextHolder     : -----------当前数据源：test_2---------------
2024-09-04 11:16:41.020  INFO 21153 --- [nio-8090-exec-3] c.e.controller.MultiControllerDataJdbc   : UserInfo(Id=1, name=Jone, type=db_test_2)
2024-09-04 11:16:41.020  INFO 21153 --- [nio-8090-exec-3] c.e.controller.MultiControllerDataJdbc   : UserInfo(Id=2, name=Kath, type=db_test_2)
2024-09-04 11:16:41.020  INFO 21153 --- [nio-8090-exec-3] c.e.controller.MultiControllerDataJdbc   : UserInfo(Id=3, name=Tom, type=db_test_2)
2024-09-04 11:16:41.020  INFO 21153 --- [nio-8090-exec-3] c.e.controller.MultiControllerDataJdbc   : UserInfo(Id=4, name=Sandy, type=db_test_2)
2024-09-04 11:16:41.020  INFO 21153 --- [nio-8090-exec-3] c.e.controller.MultiControllerDataJdbc   : UserInfo(Id=5, name=Oliver, type=db_test_2)
2024-09-04 11:16:41.020  INFO 21153 --- [nio-8090-exec-3] c.e.c.DynamicDataSourceContextHolder     : -----------还原数据源：master---------------
2024-09-04 11:16:41.020  INFO 21153 --- [nio-8090-exec-3] c.e.c.DynamicDataSourceContextHolder     : -----------切换数据源：test_3---------------
2024-09-04 11:16:41.020  INFO 21153 --- [nio-8090-exec-3] c.e.c.DynamicDataSourceContextHolder     : -----------当前数据源：test_3---------------
2024-09-04 11:16:41.022  INFO 21153 --- [nio-8090-exec-3] c.e.c.DynamicDataSourceContextHolder     : -----------当前数据源：test_3---------------
2024-09-04 11:16:41.027  INFO 21153 --- [nio-8090-exec-3] c.e.c.DynamicDataSourceContextHolder     : -----------当前数据源：test_3---------------
2024-09-04 11:16:41.029  INFO 21153 --- [nio-8090-exec-3] c.e.c.DynamicDataSourceContextHolder     : -----------当前数据源：test_3---------------
2024-09-04 11:16:41.033  INFO 21153 --- [nio-8090-exec-3] c.e.c.DynamicDataSourceContextHolder     : -----------当前数据源：test_3---------------
2024-09-04 11:16:41.036  INFO 21153 --- [nio-8090-exec-3] c.e.c.DynamicDataSourceContextHolder     : -----------当前数据源：test_3---------------
2024-09-04 11:16:41.038  INFO 21153 --- [nio-8090-exec-3] c.e.c.DynamicDataSourceContextHolder     : -----------当前数据源：test_3---------------
2024-09-04 11:16:41.038  INFO 21153 --- [nio-8090-exec-3] c.e.c.DynamicDataSourceContextHolder     : -----------当前数据源：test_3---------------
2024-09-04 11:16:41.041  INFO 21153 --- [nio-8090-exec-3] c.e.controller.MultiControllerDataJdbc   : UserInfo(Id=1, name=Jone, type=db_test_3)
2024-09-04 11:16:41.041  INFO 21153 --- [nio-8090-exec-3] c.e.controller.MultiControllerDataJdbc   : UserInfo(Id=2, name=Kath, type=db_test_3)
2024-09-04 11:16:41.041  INFO 21153 --- [nio-8090-exec-3] c.e.controller.MultiControllerDataJdbc   : UserInfo(Id=3, name=Tom, type=db_test_3)
2024-09-04 11:16:41.041  INFO 21153 --- [nio-8090-exec-3] c.e.controller.MultiControllerDataJdbc   : UserInfo(Id=4, name=Sandy, type=db_test_3)
2024-09-04 11:16:41.041  INFO 21153 --- [nio-8090-exec-3] c.e.controller.MultiControllerDataJdbc   : UserInfo(Id=5, name=Oliver, type=db_test_3)
2024-09-04 11:16:41.041  INFO 21153 --- [nio-8090-exec-3] c.e.c.DynamicDataSourceContextHolder     : -----------还原数据源：master---------------
</code></pre>
<p>6、查询不同数据源中数据的接口</p>
<pre><code class="bash">curl -X GET &quot;localhost:8090/data/test1&quot;   
[&#123;&quot;ID&quot;:1,&quot;NAME&quot;:&quot;Jone&quot;,&quot;TYPE&quot;:&quot;db_test_1&quot;&#125;,
&#123;&quot;ID&quot;:2,&quot;NAME&quot;:&quot;Kath&quot;,&quot;TYPE&quot;:&quot;db_test_1&quot;&#125;,
&#123;&quot;ID&quot;:3,&quot;NAME&quot;:&quot;Tom&quot;,&quot;TYPE&quot;:&quot;db_test_1&quot;&#125;,
&#123;&quot;ID&quot;:4,&quot;NAME&quot;:&quot;Sandy&quot;,&quot;TYPE&quot;:&quot;db_test_1&quot;&#125;,
&#123;&quot;ID&quot;:5,&quot;NAME&quot;:&quot;Oliver&quot;,&quot;TYPE&quot;:&quot;db_test_1&quot;&#125;]

curl -X GET &quot;localhost:8090/data/test2&quot;
[&#123;&quot;ID&quot;:1,&quot;NAME&quot;:&quot;Jone&quot;,&quot;TYPE&quot;:&quot;db_test_2&quot;&#125;,
&#123;&quot;ID&quot;:2,&quot;NAME&quot;:&quot;Kath&quot;,&quot;TYPE&quot;:&quot;db_test_2&quot;&#125;,
&#123;&quot;ID&quot;:3,&quot;NAME&quot;:&quot;Tom&quot;,&quot;TYPE&quot;:&quot;db_test_2&quot;&#125;,
&#123;&quot;ID&quot;:4,&quot;NAME&quot;:&quot;Sandy&quot;,&quot;TYPE&quot;:&quot;db_test_2&quot;&#125;,
&#123;&quot;ID&quot;:5,&quot;NAME&quot;:&quot;Oliver&quot;,&quot;TYPE&quot;:&quot;db_test_2&quot;&#125;]

curl -X GET &quot;localhost:8090/data/test3&quot; 
[&#123;&quot;ID&quot;:1,&quot;NAME&quot;:&quot;Jone&quot;,&quot;TYPE&quot;:&quot;db_test_3&quot;&#125;,
&#123;&quot;ID&quot;:2,&quot;NAME&quot;:&quot;Kath&quot;,&quot;TYPE&quot;:&quot;db_test_3&quot;&#125;,
&#123;&quot;ID&quot;:3,&quot;NAME&quot;:&quot;Tom&quot;,&quot;TYPE&quot;:&quot;db_test_3&quot;&#125;,
&#123;&quot;ID&quot;:4,&quot;NAME&quot;:&quot;Sandy&quot;,&quot;TYPE&quot;:&quot;db_test_3&quot;&#125;,
&#123;&quot;ID&quot;:5,&quot;NAME&quot;:&quot;Oliver&quot;,&quot;TYPE&quot;:&quot;db_test_3&quot;&#125;]

curl -X GET &quot;localhost:8090/data/test11&quot;   
[&#123;&quot;ID&quot;:1,&quot;NAME&quot;:&quot;Jone&quot;,&quot;TYPE&quot;:&quot;db_test_1&quot;&#125;,
&#123;&quot;ID&quot;:2,&quot;NAME&quot;:&quot;Kath&quot;,&quot;TYPE&quot;:&quot;db_test_1&quot;&#125;,
&#123;&quot;ID&quot;:3,&quot;NAME&quot;:&quot;Tom&quot;,&quot;TYPE&quot;:&quot;db_test_1&quot;&#125;,
&#123;&quot;ID&quot;:4,&quot;NAME&quot;:&quot;Sandy&quot;,&quot;TYPE&quot;:&quot;db_test_1&quot;&#125;,
&#123;&quot;ID&quot;:5,&quot;NAME&quot;:&quot;Oliver&quot;,&quot;TYPE&quot;:&quot;db_test_1&quot;&#125;]

curl -X GET &quot;localhost:8090/data/test22&quot;
[&#123;&quot;ID&quot;:1,&quot;NAME&quot;:&quot;Jone&quot;,&quot;TYPE&quot;:&quot;db_test_2&quot;&#125;,
&#123;&quot;ID&quot;:2,&quot;NAME&quot;:&quot;Kath&quot;,&quot;TYPE&quot;:&quot;db_test_2&quot;&#125;,
&#123;&quot;ID&quot;:3,&quot;NAME&quot;:&quot;Tom&quot;,&quot;TYPE&quot;:&quot;db_test_2&quot;&#125;,
&#123;&quot;ID&quot;:4,&quot;NAME&quot;:&quot;Sandy&quot;,&quot;TYPE&quot;:&quot;db_test_2&quot;&#125;,
&#123;&quot;ID&quot;:5,&quot;NAME&quot;:&quot;Oliver&quot;,&quot;TYPE&quot;:&quot;db_test_2&quot;&#125;]

curl -X GET &quot;localhost:8090/data/test33&quot; 
[&#123;&quot;ID&quot;:1,&quot;NAME&quot;:&quot;Jone&quot;,&quot;TYPE&quot;:&quot;db_test_3&quot;&#125;,
&#123;&quot;ID&quot;:2,&quot;NAME&quot;:&quot;Kath&quot;,&quot;TYPE&quot;:&quot;db_test_3&quot;&#125;,
&#123;&quot;ID&quot;:3,&quot;NAME&quot;:&quot;Tom&quot;,&quot;TYPE&quot;:&quot;db_test_3&quot;&#125;,
&#123;&quot;ID&quot;:4,&quot;NAME&quot;:&quot;Sandy&quot;,&quot;TYPE&quot;:&quot;db_test_3&quot;&#125;,
&#123;&quot;ID&quot;:5,&quot;NAME&quot;:&quot;Oliver&quot;,&quot;TYPE&quot;:&quot;db_test_3&quot;&#125;]
</code></pre>
<h2 id="2、Mybatis-H2-动态多数据源配置"><a href="#2、Mybatis-H2-动态多数据源配置" class="headerlink" title="2、Mybatis + H2 动态多数据源配置"></a>2、Mybatis + H2 动态多数据源配置</h2><h3 id="1、动态数据源配置-1"><a href="#1、动态数据源配置-1" class="headerlink" title="1、动态数据源配置"></a>1、动态数据源配置</h3><p>1、添加项目依赖</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;parent&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
        &lt;version&gt;2.7.18&lt;/version&gt;
        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;
    &lt;/parent&gt;
    &lt;groupId&gt;com.example&lt;/groupId&gt;
    &lt;artifactId&gt;h2-mybaits-multi-datasource-dynamic&lt;/artifactId&gt;
    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;
    &lt;name&gt;h2-mybaits-multi-datasource-dynamic&lt;/name&gt;
    &lt;description&gt;Demo project for Spring Boot&lt;/description&gt;

    &lt;properties&gt;
        &lt;maven.compiler.source&gt;11&lt;/maven.compiler.source&gt;
        &lt;maven.compiler.target&gt;11&lt;/maven.compiler.target&gt;
    &lt;/properties&gt;

    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;
            &lt;version&gt;2.3.2&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
            &lt;artifactId&gt;lombok&lt;/artifactId&gt;
            &lt;optional&gt;true&lt;/optional&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.h2database&lt;/groupId&gt;
            &lt;artifactId&gt;h2&lt;/artifactId&gt;
            &lt;scope&gt;runtime&lt;/scope&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

    &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;

&lt;/project&gt;
</code></pre>
<p>2、添加以下自定义的主从数据库配置 application.yml，这里暂时值定义了2个数据源，后面可以通过代码逻辑手动添加新的数据源</p>
<pre><code class="yaml">server:
  port: 8090
spring:
  #################### H2 数据库配置 ####################
  # 文件数据库
  # spring.datasource.url = jdbc:h2:file:./dbh2/dbc2m;AUTO_SERVER=TRUE
  # 内存数据库，platform #表明使用的数据库平台是 h2
  datasource:
    master:
      driver-class-name: org.h2.Driver
      jdbc-url: jdbc:h2:mem:master
      username: sa
      password:
    slave:
      driver-class-name: org.h2.Driver
      jdbc-url: jdbc:h2:mem:slave
      username: sa
      password:
  #################### H2 Web Console设置 ####################
  ### enabled：程序开启时就会启动 H2 Web Console, 默认就是启动的
  ### path：配置访问地址为：/h2，访问 H2 Web Console，默认:/h2-console
  ### settings.web-allow-others：开启H2 Web Console远程访问，默认为false不开启只能在本机访问
  h2:
    console:
      enabled: true
      path: /h2
      settings:
        web-allow-others: true

# 开启控制台打印sql
mybatis:
  configuration:
    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl
</code></pre>
<h3 id="2、动态数据源设置-1"><a href="#2、动态数据源设置-1" class="headerlink" title="2、动态数据源设置"></a>2、动态数据源设置</h3><p>1、 多数据源配置类：DataSourceConfig</p>
<pre><code class="java">package com.example.config;

import com.zaxxer.hikari.HikariDataSource;
import org.apache.ibatis.logging.stdout.StdOutImpl;
import org.apache.ibatis.session.SqlSessionFactory;
import org.mybatis.spring.SqlSessionFactoryBean;
import org.mybatis.spring.SqlSessionTemplate;
import org.mybatis.spring.annotation.MapperScan;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.boot.autoconfigure.EnableAutoConfiguration;
import org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.boot.jdbc.DataSourceBuilder;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Primary;
import org.springframework.jdbc.datasource.DataSourceTransactionManager;
import org.springframework.transaction.PlatformTransactionManager;
import javax.sql.DataSource;
import java.util.HashMap;
import java.util.Map;

/**
 * @EnableAutoConfiguration 就是去掉springboot默认自动配置数据源
 */
@Configuration
@MapperScan(basePackages = &quot;com.example.mapper&quot;)
@EnableAutoConfiguration(exclude = &#123; DataSourceAutoConfiguration.class &#125;)
public class DataSourceConfig &#123;

    @Bean(name = &quot;masterDataSource&quot;)
    @ConfigurationProperties(prefix = &quot;spring.datasource.master&quot;)
    public DataSource masterDataSource() &#123;
        return DataSourceBuilder.create().type(HikariDataSource.class).build();
    &#125;

    @Bean(name = &quot;slave1DataSource&quot;)
    @ConfigurationProperties(prefix = &quot;spring.datasource.slave&quot;)
    public DataSource slave1DataSource() &#123;
        return DataSourceBuilder.create().type(HikariDataSource.class).build();
    &#125;

    /**
     * 使用 Map 保存多个数据源，并设置到动态数据源对象中。
     * 设置默认的数据源是 master 数据源
     * 使用注解 Primary 优先从动态数据源中获取
     * 注意: 这个才是主数据源
     */
    @Primary
    @Bean
    public DynamicDataSource dynamicDataSource()&#123;
        DynamicDataSource dynamicDataSource = new DynamicDataSource();
        Map&lt;Object, Object&gt; targetDataSources = new HashMap&lt;&gt;();
        targetDataSources.put(&quot;master&quot;,masterDataSource());
        targetDataSources.put(&quot;slave&quot;, slave1DataSource());
        // 设置默认数据源
        dynamicDataSource.setDefaultTargetDataSource(masterDataSource());
        // 添加数据源集合
        dynamicDataSource.setTargetDataSources(targetDataSources);
        return dynamicDataSource;
    &#125;

    /**
     * Spring-Mybatis 配置第一步：先配置SqlSessionFactory
     */
    @Bean(name = &quot;sqlSessionFactory&quot;)
    public SqlSessionFactory sqlSessionFactory(@Qualifier(&quot;dynamicDataSource&quot;) DataSource dataSource) throws Exception &#123;
        SqlSessionFactoryBean bean = new SqlSessionFactoryBean();
        // 传入数据源
        bean.setDataSource(dataSource);
        // 指定扫描的xml文件所在位置，在配置文件里面配置，会报Invalid bound statement
        // bean.setMapperLocations(new PathMatchingResourcePatternResolver().getResources(&quot;classpath:mapper/*.xml&quot;));
        org.apache.ibatis.session.Configuration configuration = new org.apache.ibatis.session.Configuration();
        // 开启驼峰转换
        configuration.setMapUnderscoreToCamelCase(true);
        //配置sql日志
        configuration.setLogImpl(StdOutImpl.class);
        bean.setConfiguration(configuration);
        return bean.getObject();
    &#125;

    /**
     * Spring-Mybatis 配置第一步：先配置SqlSessionTemplate
     */
    @Bean(name = &quot;sqlSessionTemplate&quot;)
    public SqlSessionTemplate sqlSessionTemplate(@Qualifier(&quot;sqlSessionFactory&quot;) SqlSessionFactory sqlSessionFactory) &#123;
        return new SqlSessionTemplate(sqlSessionFactory);
    &#125;

    /**
     * 事务管理
     * @param dataSource 数据源
     * @return 事务管理
     */
    @Bean(name = &quot;transactionManagerMaster&quot;)
    public PlatformTransactionManager platformTransactionManager(@Qualifier(&quot;dynamicDataSource&quot;) DataSource dataSource) &#123;
        return new DataSourceTransactionManager(dataSource);
    &#125;
&#125;
</code></pre>
<p>2、动态数据设置以及获取类：实现 AbstractRoutingDataSource 的方法，使用 DynamicDataSourceContextHolder 统一数据源管理</p>
<pre><code class="java">package com.example.config;

import org.springframework.jdbc.datasource.lookup.AbstractRoutingDataSource;
import java.util.HashMap;
import java.util.Map;

public class DynamicDataSource extends AbstractRoutingDataSource &#123;
    /**
     * 添加一个DataSources Map，用来获取数据源集合
     */
    private final Map&lt;Object, Object&gt; targetDataSources = new HashMap&lt;&gt;();
    public Map&lt;Object, Object&gt; getTargetDataSources() &#123;
        return targetDataSources;
    &#125;

    /**
     * 重写setTargetDataSources方法，为了可以让自己实现动态添加数据源
     * @param targetDataSources
     */
    @Override
    public void setTargetDataSources(Map&lt;Object, Object&gt; targetDataSources) &#123;
        this.targetDataSources.putAll(targetDataSources);
        super.setTargetDataSources(this.targetDataSources);
        super.afterPropertiesSet(); // 必须添加该句，否则新添加数据源无法识别到
    &#125;

    /**
     * 必须实现该接口。用来获取当前数据源
     */
    @Override
    protected Object determineCurrentLookupKey() &#123;
        // 或者return null.细节看源码AbstractRoutingDataSource.determineTargetDataSource
        return DynamicDataSourceContextHolder.getDataSource();
    &#125;
&#125;
</code></pre>
<p>3、DynamicDataSourceContextHolder 类的实现，通过 ThreadLocal 获取和设置线程安全的数据源 key</p>
<pre><code class="java">package com.example.config;

import lombok.extern.slf4j.Slf4j;

@Slf4j
public class DynamicDataSourceContextHolder &#123;
    /**
     * 动态数据源名称上下文
     */
    private static final ThreadLocal&lt;String&gt; contextLocal = ThreadLocal.withInitial(() -&gt; &quot;master&quot;);
    // private static final ThreadLocal&lt;String&gt; contextLocal = new ThreadLocal&lt;&gt;();

    /**
     * 设置数据源
     */
    public static void setDataSource(String key) &#123;
        log.info(&quot;-----------切换数据源：&quot; + key + &quot;---------------&quot;);
        contextLocal.set(key);
    &#125;

    /**
     * 获取数据源
     */
    public static String getDataSource() &#123;
        String key = contextLocal.get();
        log.info(&quot;-----------当前数据源：&quot; + key + &quot;---------------&quot;);
        return key;
    &#125;

    /**
     * 重置/释放数据源
     */
    public static void clearDataSource() &#123;
        contextLocal.remove();
        String key = contextLocal.get();
        log.info(&quot;-----------重置数据源：&quot; + key + &quot;---------------&quot;);
    &#125;
&#125;
</code></pre>
<h3 id="3、动态数据源使用【手动切换】"><a href="#3、动态数据源使用【手动切换】" class="headerlink" title="3、动态数据源使用【手动切换】"></a>3、动态数据源使用【手动切换】</h3><p>1、数据表对应实体类的创建</p>
<pre><code class="java">package com.example.model;
import lombok.Data;
import java.io.Serializable;

@Data
public class UserInfo implements Serializable &#123;
    private Integer Id;
    private String name;
    private String type;
&#125;
</code></pre>
<p>2、数据源需要的 Mapper 接口创建</p>
<pre><code class="java">package com.example.mapper;

import com.example.model.UserInfo;
import org.apache.ibatis.annotations.Insert;
import org.apache.ibatis.annotations.Param;
import org.apache.ibatis.annotations.Select;
import org.apache.ibatis.annotations.Update;
import java.util.List;

public interface UserMapper &#123;
    @Select(&quot;select * from USER_INFO&quot;)
    List&lt;UserInfo&gt; findAll();

    @Update(&quot;drop table if exists USER_INFO;&quot;)
    void dropUserExistTable();

    @Update(&quot;create TABLE USER_INFO (id BIGINT NOT NULL AUTO_INCREMENT,name VARCHAR(50) DEFAULT NULL,type VARCHAR(50) DEFAULT NULL,PRIMARY KEY (id))&quot;)
    void createUserTable();

    @Insert(&quot;insert into USER_INFO (id, name, type) values (1, &#39;Jone&#39;, #&#123;type&#125;),(2, &#39;Kath&#39;, #&#123;type&#125;),(3, &#39;Tom&#39;, #&#123;type&#125;),(4, &#39;Sandy&#39;, #&#123;type&#125;),(5, &#39;Oliver&#39;, #&#123;type&#125;);&quot;)
    int initTableData(@Param(&quot;type&quot;) String type);
&#125;
</code></pre>
<p>3、动态数据源使用，这里编写一个 Controller，里面有一个动态初始化数据源接口，一个初始化每个数据源的表和数据的接口，另外还有3个查询不同数据源中数据的接口</p>
<pre><code class="java">package com.example.controller;

import com.example.config.DynamicDataSource;
import com.example.config.DynamicDataSourceContextHolder;
import com.example.mapper.UserMapper;
import com.example.model.UserInfo;
import lombok.extern.slf4j.Slf4j;
import org.springframework.boot.jdbc.DataSourceBuilder;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import javax.annotation.Resource;
import javax.sql.DataSource;
import java.util.List;
import java.util.Map;
import java.util.stream.Stream;

@Slf4j
@RestController
public class MultiController &#123;

    @Resource
    UserMapper userMapper;
    @Resource
    DynamicDataSource dynamicDataSource;

    /**
     * 动态数据源配置 &amp; 运行时新增数据源
     * 可以从数据库中加载, 也可以通过API新增
     */
    @RequestMapping(&quot;initDataSource&quot;)
    public String initDataSource() &#123;
        log.info(&quot;===============初始化动态数据源===============&quot;);
        Map&lt;Object, Object&gt; dataSourceMap = dynamicDataSource.getTargetDataSources();
        Stream.of(1, 2, 3).forEach(i -&gt; &#123;
            DataSource build = DataSourceBuilder.create()
                    .username(&quot;sa&quot;)
                    .password(&quot;&quot;)
                    .url(&quot;jdbc:h2:mem:test&quot; + i)
                    .build();
            dataSourceMap.put(&quot;test&quot; + i, build);
        &#125;);
        dynamicDataSource.setTargetDataSources(dataSourceMap);
        log.info(&quot;===============动态数据源初始完毕===============&quot;);
        return &quot;init dataSource success&quot;;
    &#125;

    /**
     * 给新增的数据源创建表和初始化数据
     */
    @RequestMapping(&quot;initData&quot;)
    public String initData() &#123;
        Map&lt;Object, Object&gt; targetDataSources = dynamicDataSource.getTargetDataSources();
        targetDataSources.forEach((k, v) -&gt; &#123;
            DynamicDataSourceContextHolder.setDataSource(k.toString());
            userMapper.dropUserExistTable();
            userMapper.createUserTable();
            userMapper.initTableData(k.toString());
            DynamicDataSourceContextHolder.clearDataSource();
        &#125;);
        return &quot;init data success&quot;;
    &#125;

    @RequestMapping(&quot;/test1&quot;)
    public List&lt;UserInfo&gt; test1() &#123;
        DynamicDataSourceContextHolder.setDataSource(&quot;test1&quot;);
        List&lt;UserInfo&gt; all = userMapper.findAll();
        DynamicDataSourceContextHolder.clearDataSource();
        return all;
    &#125;

    @RequestMapping(&quot;/test2&quot;)
    public List&lt;UserInfo&gt; test2() &#123;
        DynamicDataSourceContextHolder.setDataSource(&quot;test2&quot;);
        List&lt;UserInfo&gt; all = userMapper.findAll();
        DynamicDataSourceContextHolder.clearDataSource();
        return all;
    &#125;

    @RequestMapping(&quot;/test3&quot;)
    public List&lt;UserInfo&gt; test3() &#123;
        DynamicDataSourceContextHolder.setDataSource(&quot;test3&quot;);
        List&lt;UserInfo&gt; all = userMapper.findAll();
        DynamicDataSourceContextHolder.clearDataSource();
        return all;
    &#125;
&#125;
</code></pre>
<p>4、调用新增动态数据源 &amp; 运行时新增数据源的接口</p>
<pre><code class="bash">curl -X GET &quot;localhost:8090/initDataSource&quot;
init dataSource success
</code></pre>
<p>5、调用初始化每个数据源表和数据的接口</p>
<pre><code class="bash">curl -X GET &quot;localhost:8090/initData&quot;      
init data succes
</code></pre>
<p>6、查询不同数据源中数据的接口</p>
<pre><code class="bash">curl -X GET &quot;localhost:8090/test1&quot;   
[&#123;&quot;name&quot;:&quot;Jone&quot;,&quot;type&quot;:&quot;test1&quot;,&quot;id&quot;:1&#125;,
&#123;&quot;name&quot;:&quot;Kath&quot;,&quot;type&quot;:&quot;test1&quot;,&quot;id&quot;:2&#125;,
&#123;&quot;name&quot;:&quot;Tom&quot;,&quot;type&quot;:&quot;test1&quot;,&quot;id&quot;:3&#125;,
&#123;&quot;name&quot;:&quot;Sandy&quot;,&quot;type&quot;:&quot;test1&quot;,&quot;id&quot;:4&#125;,
&#123;&quot;name&quot;:&quot;Oliver&quot;,&quot;type&quot;:&quot;test1&quot;,&quot;id&quot;:5&#125;]

curl -X GET &quot;localhost:8090/test2&quot;
[&#123;&quot;name&quot;:&quot;Jone&quot;,&quot;type&quot;:&quot;test2&quot;,&quot;id&quot;:1&#125;,
&#123;&quot;name&quot;:&quot;Kath&quot;,&quot;type&quot;:&quot;test2&quot;,&quot;id&quot;:2&#125;,
&#123;&quot;name&quot;:&quot;Tom&quot;,&quot;type&quot;:&quot;test2&quot;,&quot;id&quot;:3&#125;,
&#123;&quot;name&quot;:&quot;Sandy&quot;,&quot;type&quot;:&quot;test2&quot;,&quot;id&quot;:4&#125;,
&#123;&quot;name&quot;:&quot;Oliver&quot;,&quot;type&quot;:&quot;test2&quot;,&quot;id&quot;:5&#125;]

curl -X GET &quot;localhost:8090/test3&quot; 
[&#123;&quot;name&quot;:&quot;Jone&quot;,&quot;type&quot;:&quot;test3&quot;,&quot;id&quot;:1&#125;,
&#123;&quot;name&quot;:&quot;Kath&quot;,&quot;type&quot;:&quot;test3&quot;,&quot;id&quot;:2&#125;,
&#123;&quot;name&quot;:&quot;Tom&quot;,&quot;type&quot;:&quot;test3&quot;,&quot;id&quot;:3&#125;,
&#123;&quot;name&quot;:&quot;Sandy&quot;,&quot;type&quot;:&quot;test3&quot;,&quot;id&quot;:4&#125;,
&#123;&quot;name&quot;:&quot;Oliver&quot;,&quot;type&quot;:&quot;test3&quot;,&quot;id&quot;:5&#125;]
</code></pre>
<h3 id="4、动态数据源使用【AOP切换】-1"><a href="#4、动态数据源使用【AOP切换】-1" class="headerlink" title="4、动态数据源使用【AOP切换】"></a>4、动态数据源使用【AOP切换】</h3><p>1、增加 AOP 依赖</p>
<pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<p>2、定义数据源注解</p>
<pre><code class="java">package com.example.annotation;

import java.lang.annotation.*;

/**
 * 数据源切换扫描注解
 */
@Documented
@Target(&#123;ElementType.METHOD&#125;)
@Retention(RetentionPolicy.RUNTIME)
public @interface DS &#123;
    String value() default &quot;master&quot;;
&#125;
</code></pre>
<p>3、定义数据源切面</p>
<pre><code class="java">package com.example.aop;

import com.example.annotation.DS;
import com.example.config.DynamicDataSourceContextHolder;
import lombok.extern.slf4j.Slf4j;
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Pointcut;
import org.aspectj.lang.reflect.MethodSignature;
import org.springframework.stereotype.Component;
import java.lang.reflect.Method;

@Slf4j
@Aspect
@Component
public class DataSourceAspect &#123;
    @Pointcut(&quot;@annotation(com.example.annotation.DS)&quot;)
    public void dataSourcePointCut() &#123;
    &#125;

    @Around(&quot;dataSourcePointCut()&quot;)
    public Object around(ProceedingJoinPoint point) throws Throwable &#123;
        MethodSignature signature = (MethodSignature) point.getSignature();
        Method method = signature.getMethod();
        DS DS = method.getAnnotation(DS.class);
        log.info(&quot;注解的拦截方法名注解内容前：&#123;&#125;&quot;, DS.value());
        DynamicDataSourceContextHolder.setDataSource(DS.value());
        try &#123;
            return point.proceed();
        &#125; finally &#123;
            DynamicDataSourceContextHolder.clearDataSource();
        &#125;
    &#125;
&#125;
</code></pre>
<p>4、使用 AOP 进行数据源切换</p>
<pre><code class="java">package com.example.controller;

import com.example.annotation.DS;
import com.example.config.DynamicDataSource;
import com.example.config.DynamicDataSourceContextHolder;
import com.example.mapper.UserMapper;
import com.example.model.UserInfo;
import lombok.extern.slf4j.Slf4j;
import org.springframework.boot.jdbc.DataSourceBuilder;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import javax.annotation.Resource;
import javax.sql.DataSource;
import java.util.List;
import java.util.Map;
import java.util.stream.Stream;

@Slf4j
@RestController
public class MultiController &#123;

    @Resource
    UserMapper userMapper;
    @Resource
    DynamicDataSource dynamicDataSource;

    /**
     * 动态数据源配置 &amp; 运行时新增数据源
     * 可以从数据库中加载, 也可以通过API新增
     */
    @RequestMapping(&quot;initDataSource&quot;)
    public String initDataSource() &#123;
        log.info(&quot;===============初始化动态数据源===============&quot;);
        Map&lt;Object, Object&gt; dataSourceMap = dynamicDataSource.getTargetDataSources();
        Stream.of(1, 2, 3).forEach(i -&gt; &#123;
            DataSource build = DataSourceBuilder.create()
                    .username(&quot;sa&quot;)
                    .password(&quot;&quot;)
                    .url(&quot;jdbc:h2:mem:test&quot; + i)
                    .build();
            dataSourceMap.put(&quot;test&quot; + i, build);
        &#125;);
        dynamicDataSource.setTargetDataSources(dataSourceMap);
        log.info(&quot;===============动态数据源初始完毕===============&quot;);
        return &quot;init dataSource success&quot;;
    &#125;

    /**
     * 给新增的数据源创建表和初始化数据
     */
    @RequestMapping(&quot;initData&quot;)
    public String initData() &#123;
        Map&lt;Object, Object&gt; targetDataSources = dynamicDataSource.getTargetDataSources();
        targetDataSources.forEach((k, v) -&gt; &#123;
            DynamicDataSourceContextHolder.setDataSource(k.toString());
            userMapper.dropUserExistTable();
            userMapper.createUserTable();
            userMapper.initTableData(k.toString());
            DynamicDataSourceContextHolder.clearDataSource();
        &#125;);
        return &quot;init data success&quot;;
    &#125;

    @DS(&quot;test1&quot;)
    @RequestMapping(&quot;/test11&quot;)
    public List&lt;UserInfo&gt; test11() &#123;
        return userMapper.findAll();
    &#125;

    @DS(&quot;test2&quot;)
    @RequestMapping(&quot;/test22&quot;)
    public List&lt;UserInfo&gt; test22() &#123;
        return userMapper.findAll();
    &#125;

    @DS(&quot;test3&quot;)
    @RequestMapping(&quot;/test33&quot;)
    public List&lt;UserInfo&gt; test33() &#123;
        return userMapper.findAll();
    &#125;
&#125;
</code></pre>
<p>5、调用新增动态数据源 &amp; 运行时新增数据源的接口</p>
<pre><code class="bash">curl -X GET &quot;localhost:8090/initDataSource&quot;
init dataSource success
</code></pre>
<p>6、调用初始化每个数据源表和数据的接口</p>
<pre><code class="bash">curl -X GET &quot;localhost:8090/initData&quot;      
init data succes
</code></pre>
<p>7、查询不同数据源中数据的接口</p>
<pre><code class="bash">curl -X GET &quot;localhost:8090/test1&quot;   
[&#123;&quot;ID&quot;:1,&quot;NAME&quot;:&quot;Jone&quot;,&quot;TYPE&quot;:&quot;db_test_1&quot;&#125;,
&#123;&quot;ID&quot;:2,&quot;NAME&quot;:&quot;Kath&quot;,&quot;TYPE&quot;:&quot;db_test_1&quot;&#125;,
&#123;&quot;ID&quot;:3,&quot;NAME&quot;:&quot;Tom&quot;,&quot;TYPE&quot;:&quot;db_test_1&quot;&#125;,
&#123;&quot;ID&quot;:4,&quot;NAME&quot;:&quot;Sandy&quot;,&quot;TYPE&quot;:&quot;db_test_1&quot;&#125;,
&#123;&quot;ID&quot;:5,&quot;NAME&quot;:&quot;Oliver&quot;,&quot;TYPE&quot;:&quot;db_test_1&quot;&#125;]

curl -X GET &quot;localhost:8090/test2&quot;
[&#123;&quot;ID&quot;:1,&quot;NAME&quot;:&quot;Jone&quot;,&quot;TYPE&quot;:&quot;db_test_2&quot;&#125;,
&#123;&quot;ID&quot;:2,&quot;NAME&quot;:&quot;Kath&quot;,&quot;TYPE&quot;:&quot;db_test_2&quot;&#125;,
&#123;&quot;ID&quot;:3,&quot;NAME&quot;:&quot;Tom&quot;,&quot;TYPE&quot;:&quot;db_test_2&quot;&#125;,
&#123;&quot;ID&quot;:4,&quot;NAME&quot;:&quot;Sandy&quot;,&quot;TYPE&quot;:&quot;db_test_2&quot;&#125;,
&#123;&quot;ID&quot;:5,&quot;NAME&quot;:&quot;Oliver&quot;,&quot;TYPE&quot;:&quot;db_test_2&quot;&#125;]

curl -X GET &quot;localhost:8090/test3&quot; 
[&#123;&quot;ID&quot;:1,&quot;NAME&quot;:&quot;Jone&quot;,&quot;TYPE&quot;:&quot;db_test_3&quot;&#125;,
&#123;&quot;ID&quot;:2,&quot;NAME&quot;:&quot;Kath&quot;,&quot;TYPE&quot;:&quot;db_test_3&quot;&#125;,
&#123;&quot;ID&quot;:3,&quot;NAME&quot;:&quot;Tom&quot;,&quot;TYPE&quot;:&quot;db_test_3&quot;&#125;,
&#123;&quot;ID&quot;:4,&quot;NAME&quot;:&quot;Sandy&quot;,&quot;TYPE&quot;:&quot;db_test_3&quot;&#125;,
&#123;&quot;ID&quot;:5,&quot;NAME&quot;:&quot;Oliver&quot;,&quot;TYPE&quot;:&quot;db_test_3&quot;&#125;]
</code></pre>
<h2 id="3、Spring-Data-JPA-H2-动态多数据源配置"><a href="#3、Spring-Data-JPA-H2-动态多数据源配置" class="headerlink" title="3、Spring Data JPA + H2 动态多数据源配置"></a>3、Spring Data JPA + H2 动态多数据源配置</h2><pre><code class="java">package com.example.config;

import org.springframework.jdbc.datasource.lookup.AbstractRoutingDataSource;

import java.util.HashMap;
import java.util.Map;

public class DynamicDataSource extends AbstractRoutingDataSource &#123;
    /**
     * 添加一个DataSources Map，用来获取数据源集合
     */
    private final Map&lt;Object, Object&gt; targetDataSources = new HashMap&lt;&gt;();
    public Map&lt;Object, Object&gt; getTargetDataSources() &#123;
        return targetDataSources;
    &#125;

    /**
     * 重写setTargetDataSources方法，为了可以让自己得到
     * @param targetDataSources
     */
    @Override
    public void setTargetDataSources(Map&lt;Object, Object&gt; targetDataSources) &#123;
        this.targetDataSources.putAll(targetDataSources);
        super.setTargetDataSources(this.targetDataSources);
        super.afterPropertiesSet(); // 必须添加该句，否则新添加数据源无法识别到
    &#125;

    /**
     * 必须实现该接口。用来获取当前数据源
     */
    @Override
    protected Object determineCurrentLookupKey() &#123;
        // 或者return null.细节看源码AbstractRoutingDataSource.determineTargetDataSource
        return DynamicDataSourceContextHolder.getDataSource();
    &#125;
&#125;
</code></pre>
<pre><code class="java">package com.example.config;

import lombok.extern.slf4j.Slf4j;

@Slf4j
public class DynamicDataSourceContextHolder &#123;
    /**
     * 动态数据源名称上下文
     */
    private static final ThreadLocal&lt;String&gt; contextLocal = ThreadLocal.withInitial(() -&gt; &quot;master&quot;);
    // private static final ThreadLocal&lt;String&gt; contextLocal = new ThreadLocal&lt;&gt;();

    /**
     * 设置数据源
     */
    public static void setDataSource(String key) &#123;
        log.info(&quot;-----------切换数据源：&quot; + key + &quot;---------------&quot;);
        contextLocal.set(key);
    &#125;

    /**
     * 获取数据源
     */
    public static String getDataSource() &#123;
        String key = contextLocal.get();
        log.info(&quot;-----------当前数据源：&quot; + key + &quot;---------------&quot;);
        return key;
    &#125;

    /**
     * 重置/释放数据源
     */
    public static void clearDataSource() &#123;
        contextLocal.remove();
        String key = contextLocal.get();
        log.info(&quot;-----------重置数据源：&quot; + key + &quot;---------------&quot;);
    &#125;
&#125;
</code></pre>
<h3 id="1、动态数据源配置-2"><a href="#1、动态数据源配置-2" class="headerlink" title="1、动态数据源配置"></a>1、动态数据源配置</h3><p>1、添加项目依赖</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;parent&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
        &lt;version&gt;2.7.18&lt;/version&gt;
        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;
    &lt;/parent&gt;
    &lt;groupId&gt;com.example&lt;/groupId&gt;
    &lt;artifactId&gt;h2-jpa-multi-datasource-dynamic&lt;/artifactId&gt;
    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;
    &lt;name&gt;h2-jpa-multi-datasource-dynamic&lt;/name&gt;
    &lt;description&gt;Demo project for Spring Boot&lt;/description&gt;
    &lt;properties&gt;
        &lt;maven.compiler.source&gt;11&lt;/maven.compiler.source&gt;
        &lt;maven.compiler.target&gt;11&lt;/maven.compiler.target&gt;
    &lt;/properties&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.h2database&lt;/groupId&gt;
            &lt;artifactId&gt;h2&lt;/artifactId&gt;
            &lt;scope&gt;runtime&lt;/scope&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
            &lt;artifactId&gt;lombok&lt;/artifactId&gt;
            &lt;optional&gt;true&lt;/optional&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

    &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;

&lt;/project&gt;
</code></pre>
<p>2、添加以下自定义的主从数据库配置 application.yml，这里暂时值定义了2个数据源，后面可以通过代码逻辑手动添加新的数据源</p>
<pre><code class="yaml">server:
  port: 8090
spring:
  #################### H2 数据库配置 ####################
  # 文件数据库
  # spring.datasource.url = jdbc:h2:file:./dbh2/dbc2m;AUTO_SERVER=TRUE
  # 内存数据库，platform #表明使用的数据库平台是 h2
  datasource:
    master:
      driver-class-name: org.h2.Driver
      jdbc-url: jdbc:h2:mem:master
      username: sa
      password:
      platform: h2
  #################### H2 Web Console设置 ####################
  ### enabled：程序开启时就会启动 H2 Web Console, 默认就是启动的
  ### path：配置访问地址为：/h2，访问 H2 Web Console，默认:/h2-console
  ### settings.web-allow-others：开启H2 Web Console远程访问，默认为false不开启只能在本机访问
  h2:
    console:
      enabled: true
      path: /h2
      settings:
        web-allow-others: true
  #################### JPA 的配置 ####################
  # database-platform: 数据库方言的配置
  # hibernate.ddl-auto = none, 不启动 jpa 的自动通过实体类自动建表功能
  # show-sql = true 开启 SQL 打印功能
  # properties.hibernate.format_sql = true 开启SQL格式化功能
  jpa:
    database-platform: org.hibernate.dialect.H2Dialect
    hibernate:
      ddl-auto: none
    properties:
      hibernate:
        format_sql: false
    show-sql: true
    #open-in-view: false

### 此配置是为了调试, 每个HTTP请求进来会打印 Open Hibernate 和 Open Session, 还有从当前线程中取出EntityManager ###
#################### 修改日志级别 ####################
#logging:
#  level:
#    org.hibernate.engine.transaction.internal: trace
#    org.springframework.orm.jpa.JpaTransactionManager: trace
#    org.hibernate.internal: trace
</code></pre>
<h3 id="2、动态数据源设置-2"><a href="#2、动态数据源设置-2" class="headerlink" title="2、动态数据源设置"></a>2、动态数据源设置</h3><p>1、 多数据源配置类：DataSourceConfig</p>
<pre><code class="java">package com.example.config;

import com.zaxxer.hikari.HikariDataSource;
import org.springframework.boot.autoconfigure.EnableAutoConfiguration;
import org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration;
import org.springframework.boot.autoconfigure.orm.jpa.HibernateProperties;
import org.springframework.boot.autoconfigure.orm.jpa.HibernateSettings;
import org.springframework.boot.autoconfigure.orm.jpa.JpaProperties;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.boot.jdbc.DataSourceBuilder;
import org.springframework.boot.orm.jpa.EntityManagerFactoryBuilder;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Primary;
import org.springframework.data.jpa.repository.config.EnableJpaRepositories;
import org.springframework.orm.jpa.JpaTransactionManager;
import org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean;
import org.springframework.transaction.PlatformTransactionManager;
import org.springframework.transaction.annotation.EnableTransactionManagement;

import javax.annotation.Resource;
import javax.persistence.EntityManager;
import javax.sql.DataSource;
import java.util.HashMap;
import java.util.Map;

/**
 * 配置顺序如下：
 * 创建DataSource—》创建EntityManagerFactory—》创建TransactionManager—》@EnableJpaRepositories开启JPA
 * &lt;p&gt;
 * 在多数据源配置中还是需要手动开启事务 @EnableTransactionManagement，并受用 @Primary 注解指定了主要的事务管理器
 * 利⽤ EnableJpaRepositories 配置哪些包下⾯的 Repositories，采⽤哪个 EntityManagerFactory 和哪个 TransactionManagement
 */
@Configuration
@EnableTransactionManagement // 开启事务
@EnableJpaRepositories(
        entityManagerFactoryRef = &quot;entityManagerFactoryMaster&quot;, // 数据源的 repository 的包路径
        transactionManagerRef = &quot;transactionManagerMaster&quot;,  // 实体管理器工厂
        basePackages = &#123;&quot;com.example.repository&quot;&#125;)  // 事务管理器
@EnableAutoConfiguration(exclude = &#123;DataSourceAutoConfiguration.class&#125;)
public class DataSourceConfig &#123;
    @Resource
    private JpaProperties jpaProperties;

    @Resource
    private HibernateProperties hibernateProperties;

    @Bean(name = &quot;masterDataSource&quot;)
    @ConfigurationProperties(prefix = &quot;spring.datasource.master&quot;)
    public DataSource masterDataSource() &#123;
        return DataSourceBuilder.create().type(HikariDataSource.class).build();
    &#125;

    @Primary
    @Bean
    public DynamicDataSource dynamicDataSource() &#123;
        DynamicDataSource dynamicDataSource = new DynamicDataSource();
        Map&lt;Object, Object&gt; targetDataSources = new HashMap&lt;&gt;(16);
        targetDataSources.put(&quot;master&quot;, masterDataSource());
        // 设置默认数据源
        dynamicDataSource.setDefaultTargetDataSource(masterDataSource());
        // 添加数据源集合
        dynamicDataSource.setTargetDataSources(targetDataSources);
        return dynamicDataSource;
    &#125;

    /**
     * primary实体工厂
     */
    @Primary
    @Bean(name = &quot;entityManagerFactoryMaster&quot;)
    public LocalContainerEntityManagerFactoryBean entityManagerFactoryMaster(EntityManagerFactoryBuilder builder) &#123;
        /**
         * LocalContainerEntityManagerFactoryBean entityManagerFactoryMaster(
         *          HibernateProperties hibernateProperties, JpaProperties jpaProperties) &#123;&#125;
         * 还可以使用 new 来创建 LocalContainerEntityManagerFactoryBean
         * LocalContainerEntityManagerFactoryBean factoryBean = new LocalContainerEntityManagerFactoryBean();
         * factoryBean.setDataSource(dataSource);
         * factoryBean.setPackagesToScan(&quot;com.example.model&quot;); // 实体类包路径
         * factoryBean.setJpaVendorAdapter(new HibernateJpaVendorAdapter()); // 设置Hibernate适配器
         * factoryBean.setJpaPropertyMap(jpaProperties.getProperties()); // 只设置了JpaProperties
         */

        // 配置 JPA 和 Hibernate 的属性, 相当于合并2个配置
        Map&lt;String, Object&gt; properties = hibernateProperties.
                determineHibernateProperties(jpaProperties.getProperties(), new HibernateSettings());
        // 使用 EntityManagerFactoryBuilder 构建 EntityManagerFactory
        // 调用 build() 方法时，会自动应用配置中的 JpaVendorAdapter, 这里默认构建 HibernateJpaVendorAdapter
        return builder.dataSource(dynamicDataSource())
                .properties(properties)
                // 扫描的实体类所在位置.所有带有 @Entity 注解的类
                .packages(&quot;com.example.model&quot;)
                // jpa定义的名称, persistenceUnit 的名字采⽤ masterPersistenceUnit
                // Spring会将EntityManagerFactory注入到Repository之中.有了 EntityManagerFactory之后,
                // Repository就能用它来创建 EntityManager 了,然后 EntityManager 就可以针对数据库执行操作
                .persistenceUnit(&quot;masterPersistenceUnit&quot;)
                .build();
    &#125;

    /**
     * master事务管理器
     */
    @Primary
    @Bean(name = &quot;transactionManagerMaster&quot;)
    public PlatformTransactionManager transactionManagerMaster(EntityManagerFactoryBuilder builder) &#123;
        LocalContainerEntityManagerFactoryBean entityManagerFactoryBean = entityManagerFactoryMaster(builder);
        return new JpaTransactionManager(entityManagerFactoryBean.getObject());
    &#125;

    /**
     * master实体管理器
     */
    @Primary
    @Bean(name = &quot;entityManagerMaster&quot;)
    public EntityManager entityManagerMaster(EntityManagerFactoryBuilder builder) &#123;
        LocalContainerEntityManagerFactoryBean entityManagerFactoryBean = entityManagerFactoryMaster(builder);
        return entityManagerFactoryBean.getObject().createEntityManager();
    &#125;
&#125;
</code></pre>
<p>2、动态数据设置以及获取类：实现 AbstractRoutingDataSource 的方法，使用 DynamicDataSourceContextHolder 统一数据源管理</p>
<pre><code class="java">package com.example.config;

import org.springframework.jdbc.datasource.lookup.AbstractRoutingDataSource;
import java.util.HashMap;
import java.util.Map;

public class DynamicDataSource extends AbstractRoutingDataSource &#123;
    /**
     * 添加一个DataSources Map，用来获取数据源集合
     */
    private final Map&lt;Object, Object&gt; targetDataSources = new HashMap&lt;&gt;();
    public Map&lt;Object, Object&gt; getTargetDataSources() &#123;
        return targetDataSources;
    &#125;

    /**
     * 重写setTargetDataSources方法，为了可以让自己实现动态添加数据源
     * @param targetDataSources
     */
    @Override
    public void setTargetDataSources(Map&lt;Object, Object&gt; targetDataSources) &#123;
        this.targetDataSources.putAll(targetDataSources);
        super.setTargetDataSources(this.targetDataSources);
        super.afterPropertiesSet(); // 必须添加该句，否则新添加数据源无法识别到
    &#125;

    /**
     * 必须实现该接口。用来获取当前数据源
     */
    @Override
    protected Object determineCurrentLookupKey() &#123;
        // 或者return null.细节看源码AbstractRoutingDataSource.determineTargetDataSource
        return DynamicDataSourceContextHolder.getDataSource();
    &#125;
&#125;
</code></pre>
<p>3、DynamicDataSourceContextHolder 类的实现，通过 ThreadLocal 获取和设置线程安全的数据源 key</p>
<pre><code class="java">package com.example.config;

import lombok.extern.slf4j.Slf4j;

@Slf4j
public class DynamicDataSourceContextHolder &#123;
    /**
     * 动态数据源名称上下文
     */
    private static final ThreadLocal&lt;String&gt; contextLocal = ThreadLocal.withInitial(() -&gt; &quot;master&quot;);
    // private static final ThreadLocal&lt;String&gt; contextLocal = new ThreadLocal&lt;&gt;();

    /**
     * 设置数据源
     */
    public static void setDataSource(String key) &#123;
        log.info(&quot;-----------切换数据源：&quot; + key + &quot;---------------&quot;);
        contextLocal.set(key);
    &#125;

    /**
     * 获取数据源
     */
    public static String getDataSource() &#123;
        String key = contextLocal.get();
        log.info(&quot;-----------当前数据源：&quot; + key + &quot;---------------&quot;);
        return key;
    &#125;

    /**
     * 重置/释放数据源
     */
    public static void clearDataSource() &#123;
        contextLocal.remove();
        String key = contextLocal.get();
        log.info(&quot;-----------重置数据源：&quot; + key + &quot;---------------&quot;);
    &#125;
&#125;
</code></pre>
<p>4、由于 JPA 的事务与数据源处理机制特殊性，会导致在一个请求中，Spring会管理这个EntityManager的生命周期。如果在请求中尝试多次切换数据源，可能会导致EntityManager的状态不一致。但是在@PostConstruct方法中，由于它是在请求上下文之外执行的，因此可以自由地切换数据源，而不会受到当前事务的限制。</p>
<pre><code class="java">package com.example.config;

import com.example.repository.UserRepository;
import lombok.extern.slf4j.Slf4j;
import org.springframework.boot.jdbc.DataSourceBuilder;
import org.springframework.context.annotation.Configuration;
import javax.annotation.PostConstruct;
import javax.annotation.Resource;
import javax.sql.DataSource;
import java.util.Map;
import java.util.stream.Stream;

/**
 * 数据源初始化（从数据库中加载）
 * &lt;p&gt;
 * &#39;@PostConstruct&#39; 可以多次切换数据源
 * 没有事务绑定: @PostConstruct 方法中，Spring 并没有开启事务，也不会进行事务管理。由于没有事务的约束，数据源切换不会受到事务管理器的限制，每次切换都会生效。
 * 单线程执行: @PostConstruct 方法是在单线程中执行的，且不会与其他请求并发执行。数据源的上下文是通过 ThreadLocal 存储的，因此在方法内的每次切换都是独立的，不会受到其他线程的干扰。
 */
@Slf4j
@Configuration
public class DynamicDataSourceInit &#123;
    @Resource
    DynamicDataSource dynamicDataSource;
    @Resource
    UserRepository userRepository;

    @PostConstruct
    public void InitDataSource() &#123;
        log.info(&quot;===============初始化动态数据源===============&quot;);
        Map&lt;Object, Object&gt; dataSourceMap = dynamicDataSource.getTargetDataSources();
        Stream.of(1, 2, 3).forEach(i -&gt; &#123;
            DataSource dataSource = DataSourceBuilder.create()
                    .username(&quot;sa&quot;)
                    .password(&quot;&quot;)
                    .url(&quot;jdbc:h2:mem:test&quot; + i)
                    .build();
            dataSourceMap.put(&quot;test&quot; + i, dataSource);
        &#125;);
        dynamicDataSource.setTargetDataSources(dataSourceMap);
        log.info(&quot;===============动态数据源初始完毕===============&quot;);

        log.info(&quot;===============初始化每个数据源数据开始===============&quot;);
        dynamicDataSource.getTargetDataSources().forEach((k, y) -&gt; &#123;
            DynamicDataSourceContextHolder.setDataSource(k.toString());
            userRepository.dropUserExistTable();
            userRepository.createUserTable();
            userRepository.initTableData(k.toString());
            userRepository.findAll().forEach(System.out::println);
            DynamicDataSourceContextHolder.clearDataSource();
        &#125;);
        log.info(&quot;===============初始化动态数据源结束===============&quot;);
    &#125;
&#125;
</code></pre>
<h3 id="3、动态数据源使用【手动切换】-1"><a href="#3、动态数据源使用【手动切换】-1" class="headerlink" title="3、动态数据源使用【手动切换】"></a>3、动态数据源使用【手动切换】</h3><h4 id="1、数据表对应实体类的创建"><a href="#1、数据表对应实体类的创建" class="headerlink" title="1、数据表对应实体类的创建"></a>1、数据表对应实体类的创建</h4><pre><code class="java">package com.example.model;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.Id;
import javax.persistence.Table;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
@Entity
@Table(name = &quot;USER_INFO&quot;)
public class UserInfo &#123;
    @Id
    @GeneratedValue
    private Integer Id;
    private String name;
    private String type;
&#125;
</code></pre>
<h4 id="2、数据源需要的-Repository-接口创建"><a href="#2、数据源需要的-Repository-接口创建" class="headerlink" title="2、数据源需要的 Repository 接口创建"></a>2、数据源需要的 Repository 接口创建</h4><pre><code class="java">package com.example.repository;

import com.example.model.UserInfo;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Modifying;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.transaction.annotation.Transactional;

public interface UserInfoRepository extends JpaRepository&lt;UserInfo, Integer&gt; &#123;
    @Modifying
    @Transactional
    @Query(value = &quot;drop table if exists USER_INFO;&quot;,nativeQuery=true)
    void dropUserExistTable();

    @Modifying
    @Transactional
    @Query( value= &quot;create TABLE USER_INFO (id BIGINT NOT NULL AUTO_INCREMENT,name VARCHAR(50) DEFAULT NULL,type VARCHAR(50) DEFAULT NULL,PRIMARY KEY (id))&quot;,nativeQuery=true)
    void createUserTable();

    @Modifying
    @Transactional
    @Query(value=&quot;insert into USER_INFO (id, name, type) values (1, &#39;Jone&#39;, :type),(2, &#39;Kath&#39;, :type),(3, &#39;Tom&#39;, :type),(4, &#39;Sandy&#39;, :type),(5, &#39;Oliver&#39;, :type);&quot;,nativeQuery=true)
    int initTableData(@Param(&quot;type&quot;)String type);
&#125;
</code></pre>
<h4 id="3、编写一个-Controller使用动态数据源"><a href="#3、编写一个-Controller使用动态数据源" class="headerlink" title="3、编写一个 Controller使用动态数据源"></a>3、编写一个 Controller使用动态数据源</h4><p>使用里面有一个动态初始化每个数据源的表和数据的接口，另外还有3个查询不同数据源中数据的接口。</p>
<p>通过此 Controller 可以发现如下几个问题【<strong>重点</strong>】：</p>
<ol>
<li>SpringBoot整合JPA多数据源时，一个请求中无法无法多次切换数据源。可是使用@PostConstruct注释的方法却可以多次切换数据源，这是为什么？</li>
<li>SpringBoot整合JPA多数据源时，一个请求中无法无法多次切换数据源。可是整合Mybatis多数据源时，一个请求中却可以切换多次数据源，这是为什么？</li>
<li>spring.jpa.open-in-view &#x3D; false 配置的解释，为什么加上此配置后，一个请求中就可以多次切换数据源</li>
</ol>
<pre><code class="java">package com.example.controller;

import com.example.annotation.DS;
import com.example.config.DynamicDataSource;
import com.example.config.DynamicDataSourceContextHolder;
import com.example.model.UserInfo;
import com.example.repository.UserInfoRepository;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.jpa.repository.support.JpaRepositoryFactory;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import javax.annotation.Resource;
import javax.persistence.*;
import java.util.List;

/**
 * 由于SpringMVC默认启用 “Open Session in View” 模式。
 * 这意味着在处理一个请求时，Hibernate 会在整个请求的生命周期内保持一个持久化的Session或EntityManager.
 * 虽然我们手动切换了数据源，但是在JPA事务中依旧是去获取当前请求线程中已经创建的EntityManager.
 * 所以会导致一个请求进来, 只有第一次数据源切换成功, 之后的切换都是无效的.
 * &lt;p&gt;
 * 详解可以参考：
 * 问题 1：SpringBoot整合JPA多数据源时，一个请求中无法无法多次切换数据源。可是使用@PostConstruct注释的方法却可以多次切换数据源，这是为什么？
 * 问题 2：SpringBoot整合JPA多数据源时，一个请求中无法无法多次切换数据源。可是整合Mybatis多数据源时，一个请求中却可以切换多次数据源，这是为什么？
 * 问题 3：spring.jpa.open-in-view = false 配置的解释
 */
@Slf4j
@RestController
public class MultiController &#123;
    @Resource
    DynamicDataSource dynamicDataSource;
    @Resource
    UserInfoRepository userInfoRepository;
    @PersistenceContext
    EntityManager entityManager;
    @PersistenceUnit
    EntityManagerFactory entityManagerFactory;

    /**
     * 给新增的数据源创建表和初始化数据
     */
    @RequestMapping(&quot;/initData&quot;)
    public String initData() &#123;
        dynamicDataSource.getTargetDataSources().forEach((k, y) -&gt; &#123;
            // 循环切换数据源, 因为手动多次切换数据源, 所以使用到entityManagerFactory+手动事务
            DynamicDataSourceContextHolder.setDataSource(k.toString());
            EntityManager manager = entityManagerFactory.createEntityManager();
            EntityTransaction transaction = manager.getTransaction();
            transaction.begin();
            UserInfoRepository repository = new JpaRepositoryFactory(manager).getRepository(UserInfoRepository.class);
            repository.dropUserExistTable();
            repository.createUserTable();
            repository.initTableData(k.toString());
            repository.findAll().forEach(System.out::println);
            transaction.commit();
            manager.close();
            DynamicDataSourceContextHolder.clearDataSource();
        &#125;);
        return &quot;init data success&quot;;
    &#125;

    /**
     * 【失效】多数据源切换案例一: repository 接口失效
     * 可以发现使用 repository 接口时，多次切换数据源会失效。只有第一次切换是成功的
     * 【解决】
     * 方案一：参考test3(),直接使用entityManagerFactory来创建EntityManager
     * 方案二：配置 spring.jpa.open-in-view = false
     * 【注意】使用此方式需要手动事务处理，声明式事务会失效
     */
    @RequestMapping(&quot;/test1&quot;)
    public List&lt;UserInfo&gt; test1() &#123;
        DynamicDataSourceContextHolder.setDataSource(&quot;test1&quot;);
        List&lt;UserInfo&gt; userInfos1 = userInfoRepository.findAll();
        userInfos1.forEach(System.out::println);
        DynamicDataSourceContextHolder.clearDataSource();

        DynamicDataSourceContextHolder.setDataSource(&quot;test2&quot;);
        List&lt;UserInfo&gt; userInfos2 = userInfoRepository.findAll();
        userInfos2.forEach(System.out::println);
        DynamicDataSourceContextHolder.clearDataSource();
        return userInfos1;
    &#125;

    /**
     * 【失效】多数据源切换案例二: 注入使用线程安全的 EntityManager 接口失效
     * 可以发现使用 EntityManager 接口时，多次切换数据源会失效。只有第一次切换是成功的
     * 【解决】
     * 方案一：参考test3(),直接使用entityManagerFactory来创建EntityManager
     * 方案二：配置 spring.jpa.open-in-view = false
     * 【注意】使用此方式需要手动事务处理，声明式事务会失效
     */
    @RequestMapping(&quot;/test2&quot;)
    public List&lt;UserInfo&gt; test2() &#123;
        DynamicDataSourceContextHolder.setDataSource(&quot;test1&quot;);
        List&lt;UserInfo&gt; userInfos1 = entityManager.createQuery(&quot;from UserInfo&quot;, UserInfo.class).getResultList();
        userInfos1.forEach(System.out::println);
        DynamicDataSourceContextHolder.clearDataSource();

        DynamicDataSourceContextHolder.setDataSource(&quot;test2&quot;);
        List&lt;UserInfo&gt; userInfos2 = entityManager.createQuery(&quot;from UserInfo&quot;, UserInfo.class).getResultList();
        userInfos2.forEach(System.out::println);
        DynamicDataSourceContextHolder.clearDataSource();
        return userInfos2;
    &#125;

    /**
     * 【成功】多数据源切换案例三: 使用注入的 EntityManagerFactory，重新手动创建EntityManager/Session
     * 或者使用 JpaRepositoryFactory + EntityManagerFactory 创建 repository
     * 【结论】最后发现都能正确的切换数据源，并且查询数据正确。
     * 【注意】使用此方式需要手动事务处理，声明式事务会失效
     */
    @RequestMapping(&quot;/test3&quot;)
    public List&lt;UserInfo&gt; test3() &#123;
        DynamicDataSourceContextHolder.setDataSource(&quot;test1&quot;);
        EntityManager entityManager1 = entityManagerFactory.createEntityManager();
        entityManager1.createQuery(&quot;from UserInfo&quot;, UserInfo.class).getResultList().forEach(System.out::println);
        JpaRepositoryFactory jpaRepositoryFactory1 = new JpaRepositoryFactory(entityManager1);
        jpaRepositoryFactory1.getRepository(UserInfoRepository.class).findAll().forEach(System.out::println);
        entityManager1.close();
        DynamicDataSourceContextHolder.clearDataSource();

        DynamicDataSourceContextHolder.setDataSource(&quot;test2&quot;);
        EntityManager entityManager2 = entityManagerFactory.createEntityManager();
        entityManager2.createQuery(&quot;from UserInfo&quot;, UserInfo.class).getResultList().forEach(System.out::println);
        JpaRepositoryFactory jpaRepositoryFactory2 = new JpaRepositoryFactory(entityManager2);
        jpaRepositoryFactory2.getRepository(UserInfoRepository.class).findAll().forEach(System.out::println);
        entityManager1.close();
        DynamicDataSourceContextHolder.clearDataSource();

        DynamicDataSourceContextHolder.setDataSource(&quot;test3&quot;);
        EntityManager entityManager3 = entityManagerFactory.createEntityManager();
        entityManager3.createQuery(&quot;from UserInfo&quot;, UserInfo.class).getResultList().forEach(System.out::println);
        JpaRepositoryFactory jpaRepositoryFactory3 = new JpaRepositoryFactory(entityManager3);
        UserInfoRepository userInfoRepository3 = jpaRepositoryFactory3.getRepository(UserInfoRepository.class);
        List&lt;UserInfo&gt; userInfos3 = userInfoRepository3.findAll();
        userInfos3.forEach(System.out::println);
        entityManager3.close();
        DynamicDataSourceContextHolder.clearDataSource();

        return userInfos3;
    &#125;

    @DS(&quot;test1&quot;)
    @RequestMapping(&quot;/test11&quot;)
    public List&lt;UserInfo&gt; slave11() &#123;
        return userInfoRepository.findAll();
    &#125;

    @DS(&quot;test2&quot;)
    @RequestMapping(&quot;/test22&quot;)
    public List&lt;UserInfo&gt; slave22() &#123;
        return userInfoRepository.findAll();
    &#125;

    @DS(&quot;test3&quot;)
    @RequestMapping(&quot;/test33&quot;)
    public List&lt;UserInfo&gt; slave33() &#123;
        return userInfoRepository.findAll();
    &#125;

&#125;
</code></pre>
<h4 id="4、测试-PostConstruct-内动态切换数据源"><a href="#4、测试-PostConstruct-内动态切换数据源" class="headerlink" title="4、测试 @PostConstruct 内动态切换数据源"></a>4、测试 @PostConstruct 内动态切换数据源</h4><p>项目启动后会进行一系列初始化，由于配置了@PostConstruct方法，所以会动态初始化数据源和数据表以及数据。</p>
<pre><code class="java">@PostConstruct
public void InitDataSource() &#123;
    log.info(&quot;===============初始化动态数据源===============&quot;);
    Map&lt;Object, Object&gt; dataSourceMap = dynamicDataSource.getTargetDataSources();
    Stream.of(1, 2, 3).forEach(i -&gt; &#123;
        DataSource dataSource = DataSourceBuilder.create()
            .username(&quot;sa&quot;)
            .password(&quot;&quot;)
            .url(&quot;jdbc:h2:mem:test&quot; + i)
            .build();
        dataSourceMap.put(&quot;test&quot; + i, dataSource);
    &#125;);
    dynamicDataSource.setTargetDataSources(dataSourceMap);
    log.info(&quot;===============动态数据源初始完毕===============&quot;);

    log.info(&quot;===============初始化每个数据源数据开始===============&quot;);
    dynamicDataSource.getTargetDataSources().forEach((k, y) -&gt; &#123;
        DynamicDataSourceContextHolder.setDataSource(k.toString());
        userInfoRepository.dropUserExistTable();
        userInfoRepository.createUserTable();
        userInfoRepository.initTableData(k.toString());
        userInfoRepository.findAll().forEach(System.out::println);
        DynamicDataSourceContextHolder.clearDataSource();
    &#125;);
    log.info(&quot;===============初始化动态数据源结束===============&quot;);
&#125;
</code></pre>
<pre><code class="shell">2024-09-03 22:50:08.666  INFO 80264 --- [main] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Starting...
2024-09-03 22:50:08.736  INFO 80264 --- [main] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Start completed.
2024-09-03 22:50:08.745  INFO 80264 --- [main] c.e.c.DynamicDataSourceContextHolder     : -----------当前数据源：master---------------
2024-09-03 22:50:08.745  INFO 80264 --- [main] o.s.b.a.h2.H2ConsoleAutoConfiguration    : H2 console available at &#39;/h2&#39;. Databases available at &#39;jdbc:h2:mem:master&#39;, &#39;jdbc:h2:mem:master&#39;
2024-09-03 22:50:08.854  INFO 80264 --- [main] o.hibernate.jpa.internal.util.LogHelper  : HHH000204: Processing PersistenceUnitInfo [name: masterPersistenceUnit]
2024-09-03 22:50:08.873  INFO 80264 --- [main] org.hibernate.Version                    : HHH000412: Hibernate ORM core version 5.6.15.Final
2024-09-03 22:50:08.947  INFO 80264 --- [main] o.hibernate.annotations.common.Version   : HCANN000001: Hibernate Commons Annotations &#123;5.1.2.Final&#125;
2024-09-03 22:50:08.989  INFO 80264 --- [main] c.e.c.DynamicDataSourceContextHolder     : -----------当前数据源：master---------------
2024-09-03 22:50:08.993  INFO 80264 --- [main] org.hibernate.dialect.Dialect            : HHH000400: Using dialect: org.hibernate.dialect.H2Dialect
2024-09-03 22:50:09.249  INFO 80264 --- [main] o.h.e.t.j.p.i.JtaPlatformInitiator       : HHH000490: Using JtaPlatform implementation: [org.hibernate.engine.transaction.jta.platform.internal.NoJtaPlatform]
2024-09-03 22:50:09.254  INFO 80264 --- [main] j.LocalContainerEntityManagerFactoryBean : Initialized JPA EntityManagerFactory for persistence unit &#39;masterPersistenceUnit&#39;
2024-09-03 22:50:09.535  INFO 80264 --- [main] c.example.config.DynamicDataSourceInit   : ===============初始化动态数据源===============
2024-09-03 22:50:09.538  INFO 80264 --- [main] c.example.config.DynamicDataSourceInit   : ===============动态数据源初始完毕===============
2024-09-03 22:50:09.539  INFO 80264 --- [main] c.example.config.DynamicDataSourceInit   : ===============初始化每个数据源数据开始===============
2024-09-03 22:50:09.539  INFO 80264 --- [main] c.e.c.DynamicDataSourceContextHolder     : -----------切换数据源：test2---------------
2024-09-03 22:50:09.574  INFO 80264 --- [main] c.e.c.DynamicDataSourceContextHolder     : -----------当前数据源：test2---------------
2024-09-03 22:50:09.574  INFO 80264 --- [main] com.zaxxer.hikari.HikariDataSource       : HikariPool-2 - Starting...
2024-09-03 22:50:09.577  INFO 80264 --- [main] com.zaxxer.hikari.HikariDataSource       : HikariPool-2 - Start completed.
Hibernate: drop table if exists USER_INFO;
2024-09-03 22:50:09.608  INFO 80264 --- [main] c.e.c.DynamicDataSourceContextHolder     : -----------当前数据源：test2---------------
Hibernate: create TABLE USER_INFO (id BIGINT NOT NULL AUTO_INCREMENT,name VARCHAR(50) DEFAULT NULL,type VARCHAR(50) DEFAULT NULL,PRIMARY KEY (id))
2024-09-03 22:50:09.616  INFO 80264 --- [main] c.e.c.DynamicDataSourceContextHolder     : -----------当前数据源：test2---------------
Hibernate: insert into USER_INFO (id, name, type) values (1, &#39;Jone&#39;, ?),(2, &#39;Kath&#39;, ?),(3, &#39;Tom&#39;, ?),(4, &#39;Sandy&#39;, ?),(5, &#39;Oliver&#39;, ?);
2024-09-03 22:50:09.623  INFO 80264 --- [main] c.e.c.DynamicDataSourceContextHolder     : -----------当前数据源：test2---------------
Hibernate: select userinfo0_.id as id1_1_, userinfo0_.name as name2_1_, userinfo0_.type as type3_1_ from user_info userinfo0_
UserInfo(Id=1, name=Jone, type=test2)
UserInfo(Id=2, name=Kath, type=test2)
UserInfo(Id=3, name=Tom, type=test2)
UserInfo(Id=4, name=Sandy, type=test2)
UserInfo(Id=5, name=Oliver, type=test2)
2024-09-03 22:50:09.774  INFO 80264 --- [main] c.e.c.DynamicDataSourceContextHolder     : -----------重置数据源：master---------------
2024-09-03 22:50:09.774  INFO 80264 --- [main] c.e.c.DynamicDataSourceContextHolder     : -----------切换数据源：test3---------------
2024-09-03 22:50:09.775  INFO 80264 --- [main] c.e.c.DynamicDataSourceContextHolder     : -----------当前数据源：test3---------------
2024-09-03 22:50:09.775  INFO 80264 --- [main] com.zaxxer.hikari.HikariDataSource       : HikariPool-3 - Starting...
2024-09-03 22:50:09.778  INFO 80264 --- [main] com.zaxxer.hikari.HikariDataSource       : HikariPool-3 - Start completed.
Hibernate: drop table if exists USER_INFO;
2024-09-03 22:50:09.783  INFO 80264 --- [main] c.e.c.DynamicDataSourceContextHolder     : -----------当前数据源：test3---------------
Hibernate: create TABLE USER_INFO (id BIGINT NOT NULL AUTO_INCREMENT,name VARCHAR(50) DEFAULT NULL,type VARCHAR(50) DEFAULT NULL,PRIMARY KEY (id))
2024-09-03 22:50:09.786  INFO 80264 --- [main] c.e.c.DynamicDataSourceContextHolder     : -----------当前数据源：test3---------------
Hibernate: insert into USER_INFO (id, name, type) values (1, &#39;Jone&#39;, ?),(2, &#39;Kath&#39;, ?),(3, &#39;Tom&#39;, ?),(4, &#39;Sandy&#39;, ?),(5, &#39;Oliver&#39;, ?);
2024-09-03 22:50:09.790  INFO 80264 --- [main] c.e.c.DynamicDataSourceContextHolder     : -----------当前数据源：test3---------------
Hibernate: select userinfo0_.id as id1_1_, userinfo0_.name as name2_1_, userinfo0_.type as type3_1_ from user_info userinfo0_
UserInfo(Id=1, name=Jone, type=test3)
UserInfo(Id=2, name=Kath, type=test3)
UserInfo(Id=3, name=Tom, type=test3)
UserInfo(Id=4, name=Sandy, type=test3)
UserInfo(Id=5, name=Oliver, type=test3)
2024-09-03 22:50:09.794  INFO 80264 --- [main] c.e.c.DynamicDataSourceContextHolder     : -----------重置数据源：master---------------
2024-09-03 22:50:09.794  INFO 80264 --- [main] c.e.c.DynamicDataSourceContextHolder     : -----------切换数据源：test1---------------
2024-09-03 22:50:09.794  INFO 80264 --- [main] c.e.c.DynamicDataSourceContextHolder     : -----------当前数据源：test1---------------
2024-09-03 22:50:09.794  INFO 80264 --- [main] com.zaxxer.hikari.HikariDataSource       : HikariPool-4 - Starting...
2024-09-03 22:50:09.799  INFO 80264 --- [main] com.zaxxer.hikari.HikariDataSource       : HikariPool-4 - Start completed.
Hibernate: drop table if exists USER_INFO;
2024-09-03 22:50:09.802  INFO 80264 --- [main] c.e.c.DynamicDataSourceContextHolder     : -----------当前数据源：test1---------------
Hibernate: create TABLE USER_INFO (id BIGINT NOT NULL AUTO_INCREMENT,name VARCHAR(50) DEFAULT NULL,type VARCHAR(50) DEFAULT NULL,PRIMARY KEY (id))
2024-09-03 22:50:09.806  INFO 80264 --- [main] c.e.c.DynamicDataSourceContextHolder     : -----------当前数据源：test1---------------
Hibernate: insert into USER_INFO (id, name, type) values (1, &#39;Jone&#39;, ?),(2, &#39;Kath&#39;, ?),(3, &#39;Tom&#39;, ?),(4, &#39;Sandy&#39;, ?),(5, &#39;Oliver&#39;, ?);
2024-09-03 22:50:09.807  INFO 80264 --- [main] c.e.c.DynamicDataSourceContextHolder     : -----------当前数据源：test1---------------
Hibernate: select userinfo0_.id as id1_1_, userinfo0_.name as name2_1_, userinfo0_.type as type3_1_ from user_info userinfo0_
UserInfo(Id=1, name=Jone, type=test1)
UserInfo(Id=2, name=Kath, type=test1)
UserInfo(Id=3, name=Tom, type=test1)
UserInfo(Id=4, name=Sandy, type=test1)
UserInfo(Id=5, name=Oliver, type=test1)
2024-09-03 22:50:09.809  INFO 80264 --- [main] c.e.c.DynamicDataSourceContextHolder     : -----------重置数据源：master---------------
2024-09-03 22:50:09.812  INFO 80264 --- [main] c.e.c.DynamicDataSourceContextHolder     : -----------切换数据源：master---------------
2024-09-03 22:50:09.812  INFO 80264 --- [main] c.e.c.DynamicDataSourceContextHolder     : -----------当前数据源：master---------------
Hibernate: drop table if exists USER_INFO;
2024-09-03 22:50:09.815  INFO 80264 --- [main] c.e.c.DynamicDataSourceContextHolder     : -----------当前数据源：master---------------
Hibernate: create TABLE USER_INFO (id BIGINT NOT NULL AUTO_INCREMENT,name VARCHAR(50) DEFAULT NULL,type VARCHAR(50) DEFAULT NULL,PRIMARY KEY (id))
2024-09-03 22:50:09.817  INFO 80264 --- [main] c.e.c.DynamicDataSourceContextHolder     : -----------当前数据源：master---------------
Hibernate: insert into USER_INFO (id, name, type) values (1, &#39;Jone&#39;, ?),(2, &#39;Kath&#39;, ?),(3, &#39;Tom&#39;, ?),(4, &#39;Sandy&#39;, ?),(5, &#39;Oliver&#39;, ?);
2024-09-03 22:50:09.818  INFO 80264 --- [main] c.e.c.DynamicDataSourceContextHolder     : -----------当前数据源：master---------------
Hibernate: select userinfo0_.id as id1_1_, userinfo0_.name as name2_1_, userinfo0_.type as type3_1_ from user_info userinfo0_
UserInfo(Id=1, name=Jone, type=master)
UserInfo(Id=2, name=Kath, type=master)
UserInfo(Id=3, name=Tom, type=master)
UserInfo(Id=4, name=Sandy, type=master)
UserInfo(Id=5, name=Oliver, type=master)
2024-09-03 22:50:09.820  INFO 80264 --- [main] c.e.c.DynamicDataSourceContextHolder     : -----------重置数据源：master---------------
2024-09-03 22:50:09.821  INFO 80264 --- [main] c.example.config.DynamicDataSourceInit   : ===============初始化动态数据源结束===============
2024-09-03 22:50:09.920  WARN 80264 --- [main] JpaBaseConfiguration$JpaWebConfiguration : spring.jpa.open-in-view is enabled by default. Therefore, database queries may be performed during view rendering. Explicitly configure spring.jpa.open-in-view to disable this warning
2024-09-03 22:50:10.221  INFO 80264 --- [main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port(s): 8090 (http) with context path &#39;&#39;
2024-09-03 22:50:10.251  INFO 80264 --- [main] e.H2JpaMultiDatasourceDynamicApplication : Started H2JpaMultiDatasourceDynamicApplication in 3.705 seconds (JVM running for 4.359)
</code></pre>
<ul>
<li>可以发现初始化数据源，动态新增了3个数据源</li>
<li>然后循环动态切换数据源初始化每个数据源的表和数据</li>
<li>最后打印了spring.jpa.open-in-view is enabled by default.可以发现默认是开启“Open Session in View” 模式的</li>
</ul>
<h4 id="5、调用初始化表和数据的接口-initData"><a href="#5、调用初始化表和数据的接口-initData" class="headerlink" title="5、调用初始化表和数据的接口 &#x2F;initData"></a>5、调用初始化表和数据的接口 &#x2F;initData</h4><pre><code class="java">/**
 * 给新增的数据源创建表和初始化数据
    */
@RequestMapping(&quot;/initData&quot;)
public String initData() &#123;
    dynamicDataSource.getTargetDataSources().forEach((k, y) -&gt; &#123;
        // 循环切换数据源, 因为手动多次切换数据源, 所以使用到entityManagerFactory+手动事务
        DynamicDataSourceContextHolder.setDataSource(k.toString());
        EntityManager manager = entityManagerFactory.createEntityManager();
        EntityTransaction transaction = manager.getTransaction();
        transaction.begin();
        UserInfoRepository repository = new JpaRepositoryFactory(manager).getRepository(UserInfoRepository.class);
        repository.dropUserExistTable();
        repository.createUserTable();
        repository.initTableData(k.toString());
        repository.findAll().forEach(System.out::println);
        transaction.commit();
        manager.close();
        DynamicDataSourceContextHolder.clearDataSource();
    &#125;);
    return &quot;init data success&quot;;
&#125;
</code></pre>
<pre><code class="shell">curl -X GET &quot;localhost:8090/initData&quot;
init data success

###### 控制台输出的内容 ######
2024-09-03 22:59:36.916  INFO 80264 --- [nio-8090-exec-4] c.e.c.DynamicDataSourceContextHolder     : -----------切换数据源：test2---------------
2024-09-03 22:59:36.919  INFO 80264 --- [nio-8090-exec-4] c.e.c.DynamicDataSourceContextHolder     : -----------当前数据源：test2---------------
Hibernate: drop table if exists USER_INFO;
Hibernate: create TABLE USER_INFO (id BIGINT NOT NULL AUTO_INCREMENT,name VARCHAR(50) DEFAULT NULL,type VARCHAR(50) DEFAULT NULL,PRIMARY KEY (id))
Hibernate: insert into USER_INFO (id, name, type) values (1, &#39;Jone&#39;, ?),(2, &#39;Kath&#39;, ?),(3, &#39;Tom&#39;, ?),(4, &#39;Sandy&#39;, ?),(5, &#39;Oliver&#39;, ?);
Hibernate: select userinfo0_.id as id1_1_, userinfo0_.name as name2_1_, userinfo0_.type as type3_1_ from user_info userinfo0_
UserInfo(Id=1, name=Jone, type=test2)
UserInfo(Id=2, name=Kath, type=test2)
UserInfo(Id=3, name=Tom, type=test2)
UserInfo(Id=4, name=Sandy, type=test2)
UserInfo(Id=5, name=Oliver, type=test2)
2024-09-03 22:59:36.967  INFO 80264 --- [nio-8090-exec-4] c.e.c.DynamicDataSourceContextHolder     : -----------重置数据源：master---------------
2024-09-03 22:59:36.967  INFO 80264 --- [nio-8090-exec-4] c.e.c.DynamicDataSourceContextHolder     : -----------切换数据源：test3---------------
2024-09-03 22:59:36.967  INFO 80264 --- [nio-8090-exec-4] c.e.c.DynamicDataSourceContextHolder     : -----------当前数据源：test3---------------
Hibernate: drop table if exists USER_INFO;
Hibernate: create TABLE USER_INFO (id BIGINT NOT NULL AUTO_INCREMENT,name VARCHAR(50) DEFAULT NULL,type VARCHAR(50) DEFAULT NULL,PRIMARY KEY (id))
Hibernate: insert into USER_INFO (id, name, type) values (1, &#39;Jone&#39;, ?),(2, &#39;Kath&#39;, ?),(3, &#39;Tom&#39;, ?),(4, &#39;Sandy&#39;, ?),(5, &#39;Oliver&#39;, ?);
Hibernate: select userinfo0_.id as id1_1_, userinfo0_.name as name2_1_, userinfo0_.type as type3_1_ from user_info userinfo0_
UserInfo(Id=1, name=Jone, type=test3)
UserInfo(Id=2, name=Kath, type=test3)
UserInfo(Id=3, name=Tom, type=test3)
UserInfo(Id=4, name=Sandy, type=test3)
UserInfo(Id=5, name=Oliver, type=test3)
2024-09-03 22:59:36.981  INFO 80264 --- [nio-8090-exec-4] c.e.c.DynamicDataSourceContextHolder     : -----------重置数据源：master---------------
2024-09-03 22:59:36.982  INFO 80264 --- [nio-8090-exec-4] c.e.c.DynamicDataSourceContextHolder     : -----------切换数据源：test1---------------
2024-09-03 22:59:36.982  INFO 80264 --- [nio-8090-exec-4] c.e.c.DynamicDataSourceContextHolder     : -----------当前数据源：test1---------------
Hibernate: drop table if exists USER_INFO;
Hibernate: create TABLE USER_INFO (id BIGINT NOT NULL AUTO_INCREMENT,name VARCHAR(50) DEFAULT NULL,type VARCHAR(50) DEFAULT NULL,PRIMARY KEY (id))
Hibernate: insert into USER_INFO (id, name, type) values (1, &#39;Jone&#39;, ?),(2, &#39;Kath&#39;, ?),(3, &#39;Tom&#39;, ?),(4, &#39;Sandy&#39;, ?),(5, &#39;Oliver&#39;, ?);
Hibernate: select userinfo0_.id as id1_1_, userinfo0_.name as name2_1_, userinfo0_.type as type3_1_ from user_info userinfo0_
UserInfo(Id=1, name=Jone, type=test1)
UserInfo(Id=2, name=Kath, type=test1)
UserInfo(Id=3, name=Tom, type=test1)
UserInfo(Id=4, name=Sandy, type=test1)
UserInfo(Id=5, name=Oliver, type=test1)
2024-09-03 22:59:36.995  INFO 80264 --- [nio-8090-exec-4] c.e.c.DynamicDataSourceContextHolder     : -----------重置数据源：master---------------
2024-09-03 22:59:36.995  INFO 80264 --- [nio-8090-exec-4] c.e.c.DynamicDataSourceContextHolder     : -----------切换数据源：master---------------
2024-09-03 22:59:36.995  INFO 80264 --- [nio-8090-exec-4] c.e.c.DynamicDataSourceContextHolder     : -----------当前数据源：master---------------
Hibernate: drop table if exists USER_INFO;
Hibernate: create TABLE USER_INFO (id BIGINT NOT NULL AUTO_INCREMENT,name VARCHAR(50) DEFAULT NULL,type VARCHAR(50) DEFAULT NULL,PRIMARY KEY (id))
Hibernate: insert into USER_INFO (id, name, type) values (1, &#39;Jone&#39;, ?),(2, &#39;Kath&#39;, ?),(3, &#39;Tom&#39;, ?),(4, &#39;Sandy&#39;, ?),(5, &#39;Oliver&#39;, ?);
Hibernate: select userinfo0_.id as id1_1_, userinfo0_.name as name2_1_, userinfo0_.type as type3_1_ from user_info userinfo0_
UserInfo(Id=1, name=Jone, type=master)
UserInfo(Id=2, name=Kath, type=master)
UserInfo(Id=3, name=Tom, type=master)
UserInfo(Id=4, name=Sandy, type=master)
UserInfo(Id=5, name=Oliver, type=master)
2024-09-03 22:59:37.010  INFO 80264 --- [nio-8090-exec-4] c.e.c.DynamicDataSourceContextHolder     : -----------重置数据源：master---------------
</code></pre>
<h4 id="6、调用-test1-数据源接口-test1"><a href="#6、调用-test1-数据源接口-test1" class="headerlink" title="6、调用 test1 数据源接口 &#x2F;test1"></a>6、调用 test1 数据源接口 &#x2F;test1</h4><p>这里使用的是 repository 接口查询的【<strong>注意</strong>：test1接口中切换了2次数据源，第1次切换到test1数据源，第2次切换到test2数据源并打印】，<strong>从下面的日志可以发现第2次查询已经差出了test1数据源的数据，这表示第2次切换数据源失败了。</strong></p>
<pre><code class="java">/**
 * 【失效】多数据源切换案例一: repository 接口失效
 * 可以发现使用 repository 接口时，多次切换数据源会失效。只有第一次切换是成功的
 * 【解决】
 * 方案一：参考test3(),直接使用entityManagerFactory来创建EntityManager
 * 方案二：配置 spring.jpa.open-in-view = false
 * 【注意】使用此方式需要手动事务处理，声明式事务会失效
 */
@RequestMapping(&quot;/test1&quot;)
public List&lt;UserInfo&gt; test1() &#123;
    DynamicDataSourceContextHolder.setDataSource(&quot;test1&quot;);
    List&lt;UserInfo&gt; userInfos1 = userInfoRepository.findAll();
    userInfos1.forEach(System.out::println);
    DynamicDataSourceContextHolder.clearDataSource();

    DynamicDataSourceContextHolder.setDataSource(&quot;test2&quot;);
    List&lt;UserInfo&gt; userInfos2 = userInfoRepository.findAll();
    userInfos2.forEach(System.out::println);
    DynamicDataSourceContextHolder.clearDataSource();
    return userInfos1;
&#125;
</code></pre>
<pre><code class="shell">curl -X GET &quot;localhost:8090/test1&quot;   
[&#123;&quot;name&quot;:&quot;Jone&quot;,&quot;type&quot;:&quot;test1&quot;,&quot;id&quot;:1&#125;,
&#123;&quot;name&quot;:&quot;Kath&quot;,&quot;type&quot;:&quot;test1&quot;,&quot;id&quot;:2&#125;,
&#123;&quot;name&quot;:&quot;Tom&quot;,&quot;type&quot;:&quot;test1&quot;,&quot;id&quot;:3&#125;,
&#123;&quot;name&quot;:&quot;Sandy&quot;,&quot;type&quot;:&quot;test1&quot;,&quot;id&quot;:4&#125;,
&#123;&quot;name&quot;:&quot;Oliver&quot;,&quot;type&quot;:&quot;test1&quot;,&quot;id&quot;:5&#125;]

###### 控制台输出的内容 ######
2024-09-03 23:01:13.017  INFO 80264 --- [nio-8090-exec-2] c.e.c.DynamicDataSourceContextHolder     : -----------切换数据源：test1---------------
2024-09-03 23:01:13.019  INFO 80264 --- [nio-8090-exec-2] c.e.c.DynamicDataSourceContextHolder     : -----------当前数据源：test1---------------
Hibernate: select userinfo0_.id as id1_1_, userinfo0_.name as name2_1_, userinfo0_.type as type3_1_ from user_info userinfo0_
UserInfo(Id=1, name=Jone, type=test1)
UserInfo(Id=2, name=Kath, type=test1)
UserInfo(Id=3, name=Tom, type=test1)
UserInfo(Id=4, name=Sandy, type=test1)
UserInfo(Id=5, name=Oliver, type=test1)
2024-09-03 23:01:13.036  INFO 80264 --- [nio-8090-exec-2] c.e.c.DynamicDataSourceContextHolder     : -----------重置数据源：master---------------
2024-09-03 23:01:13.037  INFO 80264 --- [nio-8090-exec-2] c.e.c.DynamicDataSourceContextHolder     : -----------切换数据源：test2---------------
Hibernate: select userinfo0_.id as id1_1_, userinfo0_.name as name2_1_, userinfo0_.type as type3_1_ from user_info userinfo0_
UserInfo(Id=1, name=Jone, type=test1)
UserInfo(Id=2, name=Kath, type=test1)
UserInfo(Id=3, name=Tom, type=test1)
UserInfo(Id=4, name=Sandy, type=test1)
UserInfo(Id=5, name=Oliver, type=test1)
2024-09-03 23:01:13.041  INFO 80264 --- [nio-8090-exec-2] c.e.c.DynamicDataSourceContextHolder     : -----------重置数据源：master---------------
</code></pre>
<h4 id="7、调用-test2-数据源接口-test2"><a href="#7、调用-test2-数据源接口-test2" class="headerlink" title="7、调用 test2 数据源接口 &#x2F;test2"></a>7、调用 test2 数据源接口 &#x2F;test2</h4><p>这里使用的是 EntityManager 接口查询的【注意：test2接口中切换了2次数据源，第1次切换到test1数据源，第2次切换到test2数据源并打印】，<strong>从下面的日志可以发现第2次查询已经差出了test1数据源的数据，这表示第2次切换数据源失败了。</strong>6、查询test1数据源中数据的接口&#x2F;test1【注意：test1接口中切换了2次数据源，第1次切换到test1数据源，第2次切换到test2数据源并打印】，<strong>从下面的日志可以发现第2次查询已经差出了test1数据源的数据，这表示第2次切换数据源失败了。</strong></p>
<pre><code class="java">/**
 * 【失效】多数据源切换案例二: 注入使用线程安全的 EntityManager 接口失效
 * 可以发现使用 EntityManager 接口时，多次切换数据源会失效。只有第一次切换是成功的
 * 【解决】
 * 方案一：参考test3(),直接使用entityManagerFactory来创建EntityManager
 * 方案二：配置 spring.jpa.open-in-view = false
 * 【注意】使用此方式需要手动事务处理，声明式事务会失效
 */
@RequestMapping(&quot;/test2&quot;)
public List&lt;UserInfo&gt; test2() &#123;
    DynamicDataSourceContextHolder.setDataSource(&quot;test1&quot;);
    List&lt;UserInfo&gt; userInfos1 = entityManager.createQuery(&quot;from UserInfo&quot;, UserInfo.class).getResultList();
    userInfos1.forEach(System.out::println);
    DynamicDataSourceContextHolder.clearDataSource();

    DynamicDataSourceContextHolder.setDataSource(&quot;test2&quot;);
    List&lt;UserInfo&gt; userInfos2 = entityManager.createQuery(&quot;from UserInfo&quot;, UserInfo.class).getResultList();
    userInfos2.forEach(System.out::println);
    DynamicDataSourceContextHolder.clearDataSource();
    return userInfos2;
&#125;
</code></pre>
<pre><code class="shell">curl -X GET &quot;localhost:8090/test2&quot;
[&#123;&quot;name&quot;:&quot;Jone&quot;,&quot;type&quot;:&quot;test1&quot;,&quot;id&quot;:1&#125;,
&#123;&quot;name&quot;:&quot;Kath&quot;,&quot;type&quot;:&quot;test1&quot;,&quot;id&quot;:2&#125;,
&#123;&quot;name&quot;:&quot;Tom&quot;,&quot;type&quot;:&quot;test1&quot;,&quot;id&quot;:3&#125;,
&#123;&quot;name&quot;:&quot;Sandy&quot;,&quot;type&quot;:&quot;test1&quot;,&quot;id&quot;:4&#125;,
&#123;&quot;name&quot;:&quot;Oliver&quot;,&quot;type&quot;:&quot;test1&quot;,&quot;id&quot;:5&#125;]

###### 控制台输出的内容 ######
2024-09-03 23:06:30.837  INFO 80264 --- [nio-8090-exec-6] c.e.c.DynamicDataSourceContextHolder     : -----------切换数据源：test1---------------
Hibernate: select userinfo0_.id as id1_1_, userinfo0_.name as name2_1_, userinfo0_.type as type3_1_ from user_info userinfo0_
2024-09-03 23:06:30.852  INFO 80264 --- [nio-8090-exec-6] c.e.c.DynamicDataSourceContextHolder     : -----------当前数据源：test1---------------
UserInfo(Id=1, name=Jone, type=test1)
UserInfo(Id=2, name=Kath, type=test1)
UserInfo(Id=3, name=Tom, type=test1)
UserInfo(Id=4, name=Sandy, type=test1)
UserInfo(Id=5, name=Oliver, type=test1)
2024-09-03 23:06:30.856  INFO 80264 --- [nio-8090-exec-6] c.e.c.DynamicDataSourceContextHolder     : -----------重置数据源：master---------------
2024-09-03 23:06:30.856  INFO 80264 --- [nio-8090-exec-6] c.e.c.DynamicDataSourceContextHolder     : -----------切换数据源：test2---------------
Hibernate: select userinfo0_.id as id1_1_, userinfo0_.name as name2_1_, userinfo0_.type as type3_1_ from user_info userinfo0_
UserInfo(Id=1, name=Jone, type=test1)
UserInfo(Id=2, name=Kath, type=test1)
UserInfo(Id=3, name=Tom, type=test1)
UserInfo(Id=4, name=Sandy, type=test1)
UserInfo(Id=5, name=Oliver, type=test1)
2024-09-03 23:06:30.858  INFO 80264 --- [nio-8090-exec-6] c.e.c.DynamicDataSourceContextHolder     : -----------重置数据源：master---------------
</code></pre>
<h4 id="8、调用-test3-数据源接口-test3"><a href="#8、调用-test3-数据源接口-test3" class="headerlink" title="8、调用 test3 数据源接口 &#x2F;test3"></a>8、调用 test3 数据源接口 &#x2F;test3</h4><p>这里使用的是 EntityManagerFactory 动态创建 Entitymanager&#x2F;Repository 接口查询的。【可以动态切换数据源】</p>
<pre><code class="java">/**
 * 【成功】多数据源切换案例三: 使用注入的 EntityManagerFactory，重新手动创建EntityManager/Session
 * 或者使用 JpaRepositoryFactory + EntityManagerFactory 创建 repository
 * 【结论】最后发现都能正确的切换数据源，并且查询数据正确。
 * 【注意】使用此方式需要手动事务处理，声明式事务会失效
 */
@RequestMapping(&quot;/test3&quot;)
public List&lt;UserInfo&gt; test3() &#123;
    DynamicDataSourceContextHolder.setDataSource(&quot;test1&quot;);
    EntityManager entityManager1 = entityManagerFactory.createEntityManager();
    entityManager1.createQuery(&quot;from UserInfo&quot;, UserInfo.class).getResultList().forEach(System.out::println);
    JpaRepositoryFactory jpaRepositoryFactory1 = new JpaRepositoryFactory(entityManager1);
    jpaRepositoryFactory1.getRepository(UserInfoRepository.class).findAll().forEach(System.out::println);
    entityManager1.close();
    DynamicDataSourceContextHolder.clearDataSource();

    DynamicDataSourceContextHolder.setDataSource(&quot;test2&quot;);
    EntityManager entityManager2 = entityManagerFactory.createEntityManager();
    entityManager2.createQuery(&quot;from UserInfo&quot;, UserInfo.class).getResultList().forEach(System.out::println);
    JpaRepositoryFactory jpaRepositoryFactory2 = new JpaRepositoryFactory(entityManager2);
    jpaRepositoryFactory2.getRepository(UserInfoRepository.class).findAll().forEach(System.out::println);
    entityManager1.close();
    DynamicDataSourceContextHolder.clearDataSource();

    DynamicDataSourceContextHolder.setDataSource(&quot;test3&quot;);
    EntityManager entityManager3 = entityManagerFactory.createEntityManager();
    entityManager3.createQuery(&quot;from UserInfo&quot;, UserInfo.class).getResultList().forEach(System.out::println);
    JpaRepositoryFactory jpaRepositoryFactory3 = new JpaRepositoryFactory(entityManager3);
    UserInfoRepository userInfoRepository3 = jpaRepositoryFactory3.getRepository(UserInfoRepository.class);
    List&lt;UserInfo&gt; userInfos3 = userInfoRepository3.findAll();
    userInfos3.forEach(System.out::println);
    entityManager3.close();
    DynamicDataSourceContextHolder.clearDataSource();

    return userInfos3;
&#125;
</code></pre>
<pre><code class="shell">curl -X GET &quot;localhost:8090/test3&quot;
[&#123;&quot;name&quot;:&quot;Jone&quot;,&quot;type&quot;:&quot;test3&quot;,&quot;id&quot;:1&#125;,
&#123;&quot;name&quot;:&quot;Kath&quot;,&quot;type&quot;:&quot;test3&quot;,&quot;id&quot;:2&#125;,
&#123;&quot;name&quot;:&quot;Tom&quot;,&quot;type&quot;:&quot;test3&quot;,&quot;id&quot;:3&#125;,
&#123;&quot;name&quot;:&quot;Sandy&quot;,&quot;type&quot;:&quot;test3&quot;,&quot;id&quot;:4&#125;,
&#123;&quot;name&quot;:&quot;Oliver&quot;,&quot;type&quot;:&quot;test3&quot;,&quot;id&quot;:5&#125;]

###### 控制台输出的内容 ######
2024-09-03 23:34:59.669  INFO 80264 --- [nio-8090-exec-7] c.e.c.DynamicDataSourceContextHolder     : -----------切换数据源：test1---------------
Hibernate: select userinfo0_.id as id1_1_, userinfo0_.name as name2_1_, userinfo0_.type as type3_1_ from user_info userinfo0_
2024-09-03 23:34:59.673  INFO 80264 --- [nio-8090-exec-7] c.e.c.DynamicDataSourceContextHolder     : -----------当前数据源：test1---------------
UserInfo(Id=1, name=Jone, type=test1)
UserInfo(Id=2, name=Kath, type=test1)
UserInfo(Id=3, name=Tom, type=test1)
UserInfo(Id=4, name=Sandy, type=test1)
UserInfo(Id=5, name=Oliver, type=test1)
Hibernate: select userinfo0_.id as id1_1_, userinfo0_.name as name2_1_, userinfo0_.type as type3_1_ from user_info userinfo0_
UserInfo(Id=1, name=Jone, type=test1)
UserInfo(Id=2, name=Kath, type=test1)
UserInfo(Id=3, name=Tom, type=test1)
UserInfo(Id=4, name=Sandy, type=test1)
UserInfo(Id=5, name=Oliver, type=test1)
2024-09-03 23:34:59.724  INFO 80264 --- [nio-8090-exec-7] c.e.c.DynamicDataSourceContextHolder     : -----------重置数据源：master---------------
2024-09-03 23:34:59.724  INFO 80264 --- [nio-8090-exec-7] c.e.c.DynamicDataSourceContextHolder     : -----------切换数据源：test2---------------
Hibernate: select userinfo0_.id as id1_1_, userinfo0_.name as name2_1_, userinfo0_.type as type3_1_ from user_info userinfo0_
2024-09-03 23:34:59.724  INFO 80264 --- [nio-8090-exec-7] c.e.c.DynamicDataSourceContextHolder     : -----------当前数据源：test2---------------
UserInfo(Id=1, name=Jone, type=test2)
UserInfo(Id=2, name=Kath, type=test2)
UserInfo(Id=3, name=Tom, type=test2)
UserInfo(Id=4, name=Sandy, type=test2)
UserInfo(Id=5, name=Oliver, type=test2)
Hibernate: select userinfo0_.id as id1_1_, userinfo0_.name as name2_1_, userinfo0_.type as type3_1_ from user_info userinfo0_
UserInfo(Id=1, name=Jone, type=test2)
UserInfo(Id=2, name=Kath, type=test2)
UserInfo(Id=3, name=Tom, type=test2)
UserInfo(Id=4, name=Sandy, type=test2)
UserInfo(Id=5, name=Oliver, type=test2)
2024-09-03 23:34:59.742  INFO 80264 --- [nio-8090-exec-7] c.e.c.DynamicDataSourceContextHolder     : -----------重置数据源：master---------------
2024-09-03 23:34:59.742  INFO 80264 --- [nio-8090-exec-7] c.e.c.DynamicDataSourceContextHolder     : -----------切换数据源：test3---------------
Hibernate: select userinfo0_.id as id1_1_, userinfo0_.name as name2_1_, userinfo0_.type as type3_1_ from user_info userinfo0_
2024-09-03 23:34:59.742  INFO 80264 --- [nio-8090-exec-7] c.e.c.DynamicDataSourceContextHolder     : -----------当前数据源：test3---------------
UserInfo(Id=1, name=Jone, type=test3)
UserInfo(Id=2, name=Kath, type=test3)
UserInfo(Id=3, name=Tom, type=test3)
UserInfo(Id=4, name=Sandy, type=test3)
UserInfo(Id=5, name=Oliver, type=test3)
Hibernate: select userinfo0_.id as id1_1_, userinfo0_.name as name2_1_, userinfo0_.type as type3_1_ from user_info userinfo0_
UserInfo(Id=1, name=Jone, type=test3)
UserInfo(Id=2, name=Kath, type=test3)
UserInfo(Id=3, name=Tom, type=test3)
UserInfo(Id=4, name=Sandy, type=test3)
UserInfo(Id=5, name=Oliver, type=test3)
2024-09-03 23:34:59.755  INFO 80264 --- [nio-8090-exec-7] c.e.c.DynamicDataSourceContextHolder     : -----------重置数据源：master---------------
</code></pre>
<h3 id="4、动态数据源使用【AOP切换】-2"><a href="#4、动态数据源使用【AOP切换】-2" class="headerlink" title="4、动态数据源使用【AOP切换】"></a>4、动态数据源使用【AOP切换】</h3><p>1、增加 AOP 依赖</p>
<pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<p>2、定义数据源注解</p>
<pre><code class="java">package com.example.annotation;

import java.lang.annotation.*;

/**
 * 数据源切换扫描注解
 */
@Documented
@Target(&#123;ElementType.METHOD&#125;)
@Retention(RetentionPolicy.RUNTIME)
public @interface DS &#123;
    String value() default &quot;master&quot;;
&#125;
</code></pre>
<p>3、定义数据源切面</p>
<pre><code class="java">package com.example.aop;

import com.example.annotation.DS;
import com.example.config.DynamicDataSourceContextHolder;
import lombok.extern.slf4j.Slf4j;
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Pointcut;
import org.aspectj.lang.reflect.MethodSignature;
import org.springframework.stereotype.Component;
import java.lang.reflect.Method;

@Slf4j
@Aspect
@Component
public class DataSourceAspect &#123;
    @Pointcut(&quot;@annotation(com.example.annotation.DS)&quot;)
    public void dataSourcePointCut() &#123;
    &#125;

    @Around(&quot;dataSourcePointCut()&quot;)
    public Object around(ProceedingJoinPoint point) throws Throwable &#123;
        MethodSignature signature = (MethodSignature) point.getSignature();
        Method method = signature.getMethod();
        DS DS = method.getAnnotation(DS.class);
        log.info(&quot;注解的拦截方法名注解内容前：&#123;&#125;&quot;, DS.value());
        DynamicDataSourceContextHolder.setDataSource(DS.value());
        try &#123;
            return point.proceed();
        &#125; finally &#123;
            DynamicDataSourceContextHolder.clearDataSource();
        &#125;
    &#125;
&#125;
</code></pre>
<p>4、使用 AOP 进行数据源切换</p>
<pre><code class="java">package com.example.controller;

import com.example.annotation.DS;
import com.example.model.UserInfo;
import com.example.repository.UserInfoRepository;
import lombok.extern.slf4j.Slf4j;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import javax.annotation.Resource;
import javax.persistence.EntityManagerFactory;
import javax.persistence.PersistenceUnit;
import java.util.List;

/**
 * 由于SpringMVC默认启用 “Open Session in View” 模式。
 * 这意味着在处理一个请求时，Hibernate 会在整个请求的生命周期内保持一个持久化的Session或EntityManager.
 * 虽然我们手动切换了数据源，但是在JPA事务中依旧是去获取当前请求线程中已经创建的EntityManager.
 * 所以会导致一个请求进来, 只有第一次数据源切换成功, 之后的切换都是无效的.
 * &lt;p&gt;
 * 详解可以参考：
 * 问题 1：SpringBoot整合JPA多数据源时，一个请求中无法无法多次切换数据源。可是使用@PostConstruct注释的方法却可以多次切换数据源，这是为什么？
 * 问题 2：SpringBoot整合JPA多数据源时，一个请求中无法无法多次切换数据源。可是整合Mybatis多数据源时，一个请求中却可以切换多次数据源，这是为什么？
 * 问题 3：spring.jpa.open-in-view = false 配置的解释
 */
@Slf4j
@RestController
public class MultiControllerAop &#123;
    /**
     * 如果想要多次切换数据源可以使用EntityManagerFactory创建 EntityManager/Repository
     */
    @PersistenceUnit
    EntityManagerFactory entityManagerFactory;
    @Resource
    UserInfoRepository userInfoRepository;

    @DS(&quot;test1&quot;)
    @RequestMapping(&quot;/test11&quot;)
    public List&lt;UserInfo&gt; slave11() &#123;
        return userInfoRepository.findAll();
    &#125;

    @DS(&quot;test2&quot;)
    @RequestMapping(&quot;/test22&quot;)
    public List&lt;UserInfo&gt; slave22() &#123;
        return userInfoRepository.findAll();
    &#125;

    @DS(&quot;test3&quot;)
    @RequestMapping(&quot;/test33&quot;)
    public List&lt;UserInfo&gt; slave33() &#123;
        return userInfoRepository.findAll();
    &#125;
&#125;
</code></pre>
<p>5、查询不同数据源中数据的接口【注意：AOP 注解这种方式只能切换一次数据源，也没办法多次切换数据源，如果想多次切换数据源，需要把方法分割到多个小方法中去，然后每个方法上加上切换数据源的注解，并且还需要改造Repository&#x2F;EntityManager使用方式，必须要使用 EntityManagerFactory】</p>
<pre><code class="shell">curl -X GET &quot;localhost:8090/test11&quot;
[&#123;&quot;name&quot;:&quot;Jone&quot;,&quot;type&quot;:&quot;test1&quot;,&quot;id&quot;:1&#125;,
&#123;&quot;name&quot;:&quot;Kath&quot;,&quot;type&quot;:&quot;test1&quot;,&quot;id&quot;:2&#125;,
&#123;&quot;name&quot;:&quot;Tom&quot;,&quot;type&quot;:&quot;test1&quot;,&quot;id&quot;:3&#125;,
&#123;&quot;name&quot;:&quot;Sandy&quot;,&quot;type&quot;:&quot;test1&quot;,&quot;id&quot;:4&#125;,
&#123;&quot;name&quot;:&quot;Oliver&quot;,&quot;type&quot;:&quot;test1&quot;,&quot;id&quot;:5&#125;]
###### test1接口 控制台输出的内容 ######
2024-09-03 23:57:14.037  INFO 80264 --- [nio-8090-exec-1] com.example.aop.DataSourceAspect         : 注解的拦截方法名注解内容前：test1
2024-09-03 23:57:14.038  INFO 80264 --- [nio-8090-exec-1] c.e.c.DynamicDataSourceContextHolder     : -----------切换数据源：test1---------------
2024-09-03 23:57:14.039  INFO 80264 --- [nio-8090-exec-1] c.e.c.DynamicDataSourceContextHolder     : -----------当前数据源：test1---------------
Hibernate: select userinfo0_.id as id1_1_, userinfo0_.name as name2_1_, userinfo0_.type as type3_1_ from user_info userinfo0_
2024-09-03 23:57:14.052  INFO 80264 --- [nio-8090-exec-1] c.e.c.DynamicDataSourceContextHolder     : -----------重置数据源：master---------------


curl -X GET &quot;localhost:8090/test22&quot;
[&#123;&quot;name&quot;:&quot;Jone&quot;,&quot;type&quot;:&quot;test2&quot;,&quot;id&quot;:1&#125;,
&#123;&quot;name&quot;:&quot;Kath&quot;,&quot;type&quot;:&quot;test2&quot;,&quot;id&quot;:2&#125;,
&#123;&quot;name&quot;:&quot;Tom&quot;,&quot;type&quot;:&quot;test2&quot;,&quot;id&quot;:3&#125;,
&#123;&quot;name&quot;:&quot;Sandy&quot;,&quot;type&quot;:&quot;test2&quot;,&quot;id&quot;:4&#125;,&#123;
&quot;name&quot;:&quot;Oliver&quot;,&quot;type&quot;:&quot;test2&quot;,&quot;id&quot;:5&#125;]
###### test2接口 控制台输出的内容 ######
2024-09-04 00:04:48.723  INFO 80264 --- [nio-8090-exec-4] com.example.aop.DataSourceAspect         : 注解的拦截方法名注解内容前：test2
2024-09-04 00:04:48.725  INFO 80264 --- [nio-8090-exec-4] c.e.c.DynamicDataSourceContextHolder     : -----------切换数据源：test2---------------
2024-09-04 00:04:48.727  INFO 80264 --- [nio-8090-exec-4] c.e.c.DynamicDataSourceContextHolder     : -----------当前数据源：test2---------------
Hibernate: select userinfo0_.id as id1_1_, userinfo0_.name as name2_1_, userinfo0_.type as type3_1_ from user_info userinfo0_
2024-09-04 00:04:48.741  INFO 80264 --- [nio-8090-exec-4] c.e.c.DynamicDataSourceContextHolder     : -----------重置数据源：master---------------


curl -X GET &quot;localhost:8090/test33&quot;
[&#123;&quot;name&quot;:&quot;Jone&quot;,&quot;type&quot;:&quot;test3&quot;,&quot;id&quot;:1&#125;,
&#123;&quot;name&quot;:&quot;Kath&quot;,&quot;type&quot;:&quot;test3&quot;,&quot;id&quot;:2&#125;,
&#123;&quot;name&quot;:&quot;Tom&quot;,&quot;type&quot;:&quot;test3&quot;,&quot;id&quot;:3&#125;,
&#123;&quot;name&quot;:&quot;Sandy&quot;,&quot;type&quot;:&quot;test3&quot;,&quot;id&quot;:4&#125;,
&#123;&quot;name&quot;:&quot;Oliver&quot;,&quot;type&quot;:&quot;test3&quot;,&quot;id&quot;:5&#125;]
###### test3接口 控制台输出的内容 ######
2024-09-04 00:05:47.451  INFO 80264 --- [nio-8090-exec-2] com.example.aop.DataSourceAspect         : 注解的拦截方法名注解内容前：test3
2024-09-04 00:05:47.451  INFO 80264 --- [nio-8090-exec-2] c.e.c.DynamicDataSourceContextHolder     : -----------切换数据源：test3---------------
2024-09-04 00:05:47.453  INFO 80264 --- [nio-8090-exec-2] c.e.c.DynamicDataSourceContextHolder     : -----------当前数据源：test3---------------
Hibernate: select userinfo0_.id as id1_1_, userinfo0_.name as name2_1_, userinfo0_.type as type3_1_ from user_info userinfo0_
2024-09-04 00:05:47.462  INFO 80264 --- [nio-8090-exec-2] c.e.c.DynamicDataSourceContextHolder     : -----------重置数据源：master---------------
</code></pre>
<h3 id="5、JPA-多次切换数据源失效原因分析及解决方案"><a href="#5、JPA-多次切换数据源失效原因分析及解决方案" class="headerlink" title="5、JPA 多次切换数据源失效原因分析及解决方案"></a>5、JPA 多次切换数据源失效原因分析及解决方案</h3><h4 id="1、两种解决方案"><a href="#1、两种解决方案" class="headerlink" title="1、两种解决方案"></a>1、两种解决方案</h4><p>问题：配置动态数据源之后，同一个请求，不同事务无法多次切换数据源【同一个事务中就更加不可能多次切换数据源了，这个自己分析理解】。</p>
<hr>
<p>解决方案一：spring.jpa.open-in-view&#x3D;false</p>
<p>原因：spring.jpa.open-in-view（默认为true），JPA 方法执行完成之后，并没有释放数据库连接（需要等到 Controlle r方法执行完成才会释放，具体源码可以查看拦截器 OpenEntityManagerInViewInterceptor，这个主要是整合 SpringMVC 默认配置的）</p>
<p>这里还有一点要注意数据源的切换是通过 AbstractRoutingDataSource 的 determineCurrentLookupKey() 实现，数据库建立连接时 getConnection 才会触发此方法，所以同一个事务中应该是触发不了多次的。</p>
<hr>
<p>解决方案二：默认 spring.jpa.open-in-view&#x3D;true 时，我们可以使用 EntityManagerFactory 创建 EntityManager&#x2F;Repository 接口来使用，需要手动管理事务。</p>
<pre><code class="java">// 先切换数据源
DynamicDataSourceContextHolder.setDataSource(&quot;test1&quot;);
// 使用entityManagerFactory创建EntityManager/Repository【如果update/save需要手动开启事务】
EntityManager em1 = entityManagerFactory.createEntityManager();
// 使用entityManagerFactory创建XxxRepository
JpaRepositoryFactory jrf1 = new JpaRepositoryFactory(em1);
XxxRepository repository1 = jrf1.getRepository(XxxRepository.class);
// 执行操作...

// 在此切换数据源
DynamicDataSourceContextHolder.setDataSource(&quot;test2&quot;);
// 使用entityManagerFactory创建EntityManager/Repository【如果update/save需要手动开启事务】
EntityManager em2 = entityManagerFactory.createEntityManager();
// 使用entityManagerFactory创建XxxRepository
JpaRepositoryFactory jrf2 = new JpaRepositoryFactory(em2);
XxxRepository repository2 = jrf2.getRepository(XxxRepository.class);
// 执行操作...
</code></pre>
<hr>
<p>【不推荐】解决方案三：手动使用TransactionSynchronizationManager清空EntityManager。关闭一个HTTP请求中的EntityManager。【拦截器再次解绑会报错】</p>
<pre><code class="java">import org.springframework.transaction.support.TransactionSynchronizationManager;
import javax.persistence.EntityManager;
import javax.persistence.EntityManagerFactory;

public void clearEntityManager(EntityManagerFactory entityManagerFactory) &#123;
    EntityManagerHolder emHolder = (EntityManagerHolder) TransactionSynchronizationManager.getResource(entityManagerFactory);
    
    if (emHolder != null) &#123;
        EntityManager entityManager = emHolder.getEntityManager();

        // 解除对 EntityManager 的绑定
        TransactionSynchronizationManager.unbindResource(entityManagerFactory);
        
        // 关闭 EntityManager
        if (entityManager.isOpen()) &#123;
            entityManager.close();
        &#125;
    &#125;
&#125;
</code></pre>
<blockquote>
<p>手动关闭EntityManagent后，请求最后会报错：</p>
<pre><code class="java">java.lang.IllegalStateException: No value for key [org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean@6dd2e453] bound to thread
</code></pre>
<p>这个错误是因为在手动关闭 EntityManager 后，Spring 仍然尝试在事务完成时访问和关闭 EntityManager，但由于你已经手动关闭并解除绑定，它在尝试获取 EntityManager 时找不到绑定的实例，导致抛出 IllegalStateException。</p>
</blockquote>
<p>问题根源：Spring 涉及事务的代码调用顺序:</p>
<pre><code>Service注解上@transactional--&gt;TransactionInterceptor.interpter()--&gt;TransactionAspectSupport.createTransactionIfNecessary()--&gt;AbstractPlatformTransactionManager.getTransaction()--&gt;DataSourceTransactionManager.doBegin()--&gt;AbstractRoutingDataSource.determineTargetDataSource()[lookupKey==null去拿默认的Datasource, 不为空则使用获取到的连接]--&gt;DataSourceTransactionManager.setTransactional()[将连接设置到TransactionUtils的threadLocal中]---&gt;Repository@Annotation--&gt;执行一般调用链, 问题在于SpringManagedTransaction.getConnection()--&gt;openConnection()--&gt;DataSourceUtils.getConnection()--&gt;TransactionSynchronizationManager.getResource(dataSource)不为空[从TransactionUtils的threadLocal中获取数据源], 所以不会再去调用DynamicDataSource去获取数据源
</code></pre>
<p>需要解决问题：在操作完数据库后把 threadLocal 中的数据源清除！【不推荐】</p>
<h4 id="2、JPA-数据源切换失效分析及扩展"><a href="#2、JPA-数据源切换失效分析及扩展" class="headerlink" title="2、JPA 数据源切换失效分析及扩展"></a>2、JPA 数据源切换失效分析及扩展</h4><h5 id="问题-1：SpringBoot整合JPA多数据源时，一个请求中无法多次切换数据源。可是使用-PostConstruct注释的方法却可以多次切换数据源，这是为什么？"><a href="#问题-1：SpringBoot整合JPA多数据源时，一个请求中无法多次切换数据源。可是使用-PostConstruct注释的方法却可以多次切换数据源，这是为什么？" class="headerlink" title="问题 1：SpringBoot整合JPA多数据源时，一个请求中无法多次切换数据源。可是使用@PostConstruct注释的方法却可以多次切换数据源，这是为什么？"></a>问题 1：SpringBoot整合JPA多数据源时，一个请求中无法多次切换数据源。可是使用@PostConstruct注释的方法却可以多次切换数据源，这是为什么？</h5><p>在 Spring Boot 中使用 JPA 多数据源时，通常一个请求中无法多次切换数据源，但如果在 @PostConstruct 注解的方法中，却可以多次切换数据源。这种现象与 Spring 的事务管理机制、EntityManager 的生命周期、@PostConstruct 方法的执行上下文有关。</p>
<p><strong>1、事务管理的影响</strong>:</p>
<ul>
<li>在一个 HTTP 请求中，Spring 会为该请求创建一个事务上下文，通常会绑定到一个特定的数据源上。在这个上下文中，切换数据源可能会导致事务不一致或异常。但是在 @PostConstruct 方法中，由于它是在请求上下文之外执行的，因此可以自由地切换数据源，而不会受到当前事务的限制。</li>
<li>在一个 HTTP 请求的生命周期中，Spring 通常会为请求内的操作开启事务（尤其是当使用 @Transactional 注解时）。一旦事务开始，Spring 的事务管理器会绑定当前线程的数据库连接，并且会一直使用这个连接，直到事务结束。这意味着在一个事务中，你无法切换数据源，因为事务管理器已经绑定了最初的数据源。多次切换数据源的尝试会被忽略，导致整个请求期间只使用最初绑定的数据源。</li>
</ul>
<p><strong>2、@PostConstruct</strong> <strong>方法的执行上下文</strong>:</p>
<ul>
<li>@PostConstruct 注解的方法在 Spring 容器初始化完成后会被调用，此时并没有开启事务，也没有 HTTP 请求上下文的约束。由于没有事务管理的干扰，数据源切换完全取决于你在方法内的逻辑。</li>
<li>在 @PostConstruct 方法中，切换数据源的逻辑直接影响每次数据库操作的实际数据源，因此可以多次切换数据源并成功执行。</li>
</ul>
<p><strong>3、EntityManager 生命周期的管理</strong></p>
<ul>
<li>在 JPA 中，EntityManager 通常与特定的数据源绑定，并且在一个请求中，Spring 会管理这个 EntityManager 的生命周期。如果在请求中尝试切换数据源，可能会导致 EntityManager 的状态不一致。</li>
<li>在 @PostConstruct 方法中，你可以手动创建和管理不同的数据源的 EntityManager，这使得你可以在这个方法中自由切换数据源。</li>
</ul>
<p><strong>4、为什么 @PostConstruct 可以多次切换数据源</strong></p>
<ul>
<li><strong>没有事务绑定</strong>: 在 @PostConstruct 方法中，Spring 并没有开启事务，也不会进行事务管理。由于没有事务的约束，数据源切换不会受到事务管理器的限制，每次切换都会生效。</li>
<li><strong>单线程执行</strong>: @PostConstruct 方法是在单线程中执行的，且不会与其他请求并发执行。数据源的上下文是通过 ThreadLocal 存储的，因此在方法内的每次切换都是独立的，不会受到其他线程的干扰。</li>
</ul>
<p><strong>5、结论：</strong></p>
<ul>
<li>在一个请求中无法多次切换数据源的根本原因是 Spring 的事务管理机制，它在事务开始时锁定了一个数据源。@PostConstruct 方法没有事务管理的限制，因此可以自由地在方法内部多次切换数据源，并且每次切换都会生效。</li>
<li>在 SpringBoot 中，@PostConstruct 方法的执行不受当前请求的事务上下文限制，因此可以在这个方法中自由切换数据源。而在一个请求中切换数据源时，由于事务管理和 EntityManager 的绑定，可能会导致不一致性和异常。因此，理解这两者之间的区别是关键。</li>
<li>如果你需要在一个请求中多次切换数据源，可能需要考虑手动管理事务、分离操作到不同的事务中，或者结合使用 MyBatis 等其他技术来绕过事务管理器的限制。</li>
</ul>
<hr>
<h5 id="问题-2：SpringBoot整合JPA多数据源时，一个请求中无法多次切换数据源。可整合Mybatis多数据源时，一个请求中却可以切换多次数据源，这是为什么？"><a href="#问题-2：SpringBoot整合JPA多数据源时，一个请求中无法多次切换数据源。可整合Mybatis多数据源时，一个请求中却可以切换多次数据源，这是为什么？" class="headerlink" title="问题 2：SpringBoot整合JPA多数据源时，一个请求中无法多次切换数据源。可整合Mybatis多数据源时，一个请求中却可以切换多次数据源，这是为什么？"></a>问题 2：SpringBoot整合JPA多数据源时，一个请求中无法多次切换数据源。可整合Mybatis多数据源时，一个请求中却可以切换多次数据源，这是为什么？</h5><blockquote>
<p>ChatGPT 解答：</p>
</blockquote>
<p>在 Spring Boot 中，当整合 JPA 和 MyBatis 时，虽然它们都可以实现多数据源的配置和切换，但由于两者的工作机制不同，导致在同一个请求中切换数据源时，表现也有所不同。具体来说，JPA 和 MyBatis 在处理事务和数据源上下文的方式上存在差异，这就解释了为什么在一个请求中，JPA 无法多次切换数据源，而 MyBatis 可以。</p>
<p>JPA 的事务与数据源处理机制</p>
<ol>
<li><p>事务管理绑定：</p>
<ul>
<li>Spring 的事务管理器（通常是 JpaTransactionManager）在事务开始时，会绑定当前线程的数据源（连接）到事务中。一旦事务开始，所有的数据库操作都会使用最初绑定的连接，事务管理器不会轻易切换数据源。</li>
<li>即使你在同一个请求中多次切换数据源，JPA 依赖的 Hibernate 仍会使用第一次绑定的数据库连接，导致无法多次切换数据源。</li>
</ul>
</li>
<li><p>Hibernate 的 Session 缓存：</p>
<ul>
<li>Hibernate 的 Session 会缓存实体和查询结果，并且这个缓存通常是绑定到当前事务的。这意味着在同一个事务中，即使你切换了数据源，Hibernate 可能仍然会使用缓存中的数据，而不是从新切换的数据源中获取。</li>
</ul>
</li>
<li><p>EntityManager 管理：</p>
<ul>
<li>EntityManager 是由 JPA 提供的接口，用来管理持久化上下文。EntityManager 在 Spring 中通常和事务一起管理。一个事务开始后，EntityManager 就绑定到当前线程，而这个绑定的数据源在整个事务生命周期中是不变的，除非开启新事务。</li>
</ul>
</li>
</ol>
<p>MyBatis 的事务与数据源处理机制</p>
<ol>
<li><p>MyBatis 与 Spring 的集成：</p>
<ul>
<li>MyBatis 是一个更轻量级的 ORM 框架，事务管理相对更灵活。MyBatis 在执行 SQL 语句时，通过 SqlSession 获取当前的数据源，执行 SQL 语句，并返回结果。</li>
<li>在 Spring 环境下，MyBatis 可以通过 Spring 的 DataSourceTransactionManager 来管理事务，但它并不会像 JPA 那样严格绑定数据源。每次 SqlSession 执行时，都会重新从当前的 ThreadLocal 获取数据源，因此 MyBatis 可以在同一个请求中多次切换数据源。</li>
</ul>
</li>
<li><p>数据源上下文的管理：</p>
<ul>
<li>MyBatis 在执行每个 SQL 语句时，都是临时获取当前的数据源。这意味着，如果你在同一个请求中切换数据源，MyBatis 会从当前的 <code>ThreadLocal</code> 获取最新的数据源，并且每次操作都会使用最新的连接。</li>
<li>这种机制使得 MyBatis 能够在一个请求中多次切换数据源，而不会受到事务绑定的影响。</li>
</ul>
</li>
</ol>
<p>总结</p>
<ul>
<li><strong>JPA</strong>：由于 JPA 的事务管理和 EntityManager 绑定在事务开始时就确定了数据源，并且在同一个事务中会一直使用这个数据源，这就导致了无法在一个请求中多次切换数据源。</li>
<li><strong>MyBatis</strong>：MyBatis 更灵活，每次执行 SQL 时都会获取最新的数据源，不会受事务绑定的限制，因此在一个请求中可以多次切换数据源。</li>
</ul>
<p>解决思路</p>
<p>如果你希望在 JPA 中实现类似于 MyBatis 的多次数据源切换，可以考虑以下几种方式：</p>
<ol>
<li><strong>手动管理事务</strong>：手动控制事务的开启和关闭，每次操作都切换数据源并开启新事务。</li>
<li><strong>分割业务逻辑</strong>：将不同的数据源操作分离到不同的方法或服务中，并使用 <code>@Transactional(propagation = Propagation.REQUIRES_NEW)</code> 来强制开启新事务，从而允许在一个请求中切换数据源。</li>
<li><strong>混合使用 MyBatis 和 JPA</strong>：如果业务逻辑允许，可以考虑在需要频繁切换数据源的场景下使用 MyBatis，而在需要强大的 ORM 支持时使用 JPA。这样可以结合两者的优点。</li>
</ol>
<p>通过理解 JPA 和 MyBatis 的事务和数据源管理机制，选择适合你应用的方式进行实现。</p>
<blockquote>
<p>DuckDuckGo AI Chat 解答：</p>
</blockquote>
<p>在Spring Boot中整合JPA和MyBatis时，处理多数据源的方式有所不同，这导致了在一个请求中切换数据源的能力差异。</p>
<p>JPA多数据源</p>
<ol>
<li><p><strong>事务管理</strong>：JPA通常与Spring的声明式事务管理紧密集成。每个事务通常会绑定到一个特定的数据源上，这意味着在一个事务中切换数据源会导致事务管理的复杂性和不一致性。因此，JPA在一个请求中切换数据源的支持较弱。</p>
</li>
<li><p><strong>EntityManager</strong>：JPA使用EntityManager来管理实体的生命周期和数据库操作。每个<code>EntityManager</code>通常与一个特定的数据源绑定，因此在同一个请求中频繁切换数据源可能会导致EntityManager的状态不一致。</p>
</li>
<li><p><strong>配置复杂性</strong>：JPA的多数据源配置相对复杂，通常需要为每个数据源配置不同的EntityManagerFactory和TransactionManager，这使得在同一请求中动态切换数据源变得更加困难。</p>
</li>
</ol>
<p>MyBatis多数据源</p>
<ol>
<li><p><strong>灵活性</strong>：MyBatis的设计更为灵活，允许在同一请求中通过<code>SqlSession</code>动态选择数据源。你可以在代码中直接指定使用哪个数据源的<code>SqlSessionFactory</code>，这使得在一个请求中切换数据源变得简单。</p>
</li>
<li><p><strong>事务管理</strong>：MyBatis的事务管理相对独立于Spring的事务管理，可以更容易地在不同的数据源之间切换，而不会影响到其他数据源的事务状态。</p>
</li>
<li><p><strong>配置简单</strong>：MyBatis的多数据源配置相对简单，通常只需要在<code>SqlSessionFactory</code>中指定不同的数据源即可，这使得在同一请求中切换数据源的实现更加直接。</p>
</li>
</ol>
<p>总结</p>
<p>因此，JPA在多数据源切换方面的限制主要是由于其与事务管理的紧密集成和<code>EntityManager</code>的绑定，而MyBatis则提供了更大的灵活性和简单的配置，使得在同一请求中切换数据源成为可能。如果需要在JPA中实现类似的功能，可能需要手动管理<code>EntityManager</code>的切换和事务的处理，这会增加代码的复杂性。</p>
<hr>
<h5 id="问题-3：spring-jpa-open-in-view-false-配置的解释"><a href="#问题-3：spring-jpa-open-in-view-false-配置的解释" class="headerlink" title="问题 3：spring.jpa.open-in-view &#x3D; false 配置的解释"></a>问题 3：spring.jpa.open-in-view &#x3D; false 配置的解释</h5><p>spring.jpa.open-in-view&#x3D;false 是 SpringBoot 中的一个配置项，主要与 JPA 的实体管理和事务处理有关。这个配置项控制了 “Open Session in View” 模式的启用与否。</p>
<p><strong>配置解释</strong></p>
<p><strong>1、spring.jpa.open-in-view&#x3D;true（默认值）</strong>：</p>
<ul>
<li><strong>作用</strong>：启用 “Open Session in View” 模式。这意味着在处理一个请求时，Hibernate 会在整个请求的生命周期内保持一个持久化的Session或EntityManager（即打开的数据库连接）。因此，即使在视图层（例如，模板引擎或@ResponseBody生成的JSON响应）访问延迟加载的实体属性时，Hibernate 仍然可以从数据库中加载数据。</li>
<li><strong>优点</strong>：允许在视图层或控制器返回响应时访问延迟加载的关联数据，而不抛出 LazyInitializationException。</li>
<li><strong>缺点</strong>：由于Session或EntityManager在整个请求过程中都保持打开状态，可能会导致数据库连接的长期占用，增加了内存泄漏和性能问题的风险。此外，使用这种模式可能掩盖了设计中的潜在问题，如在视图层进行数据库访问，而这是不推荐的实践。</li>
</ul>
<p><strong>2、spring.jpa.open-in-view&#x3D;false</strong>：</p>
<ul>
<li><strong>作用</strong>：禁用 “Open Session in View” 模式。在这种情况下，Session或EntityManager只在事务范围内打开，并在事务结束后立即关闭。这意味着在事务之外（通常在视图层）访问延迟加载的实体属性将抛出LazyInitializationException。</li>
<li><strong>优点</strong>：更符合事务的生命周期原则，有助于更清晰的架构设计，避免在视图层进行数据库访问，减少了内存泄漏的风险和数据库连接的长期占用问题。</li>
<li><strong>缺点</strong>：如果在视图层或控制器中访问未完全加载的实体，会导致LazyInitializationException。因此，开发者需要提前加载实体的关联数据，通常通过使用JOIN FETCH或设置合适的加载策略（如 Eager Fetching）。</li>
</ul>
<p><strong>3、什么时候使用 spring.jpa.open-in-view&#x3D;false？</strong></p>
<ol>
<li><strong>性能优化</strong>：如果你发现数据库连接过多，或内存占用过高，可以考虑禁用 “Open Session in View”，以减少数据库连接的时间和内存消耗。</li>
<li><strong>架构设计</strong>：在设计中，你希望确保所有数据库访问都发生在事务范围内，避免在视图层进行数据库操作。</li>
<li><strong>问题排查</strong>：当遇到LazyInitializationException时，可以通过禁用 “Open Session in View” 来强制在事务中加载所有需要的数据，从而找出问题所在。</li>
</ol>
<p><strong>4、总结</strong></p>
<ul>
<li>true（默认）：方便但可能有性能问题，适用于简单场景或开发阶段。</li>
<li>false：推荐用于生产环境，有助于更清晰的代码结构和更高的性能。</li>
<li>根据你的项目需求，可以选择启用或禁用这个配置。</li>
</ul>
<h1 id="参考文献-鸣谢"><a href="#参考文献-鸣谢" class="headerlink" title="参考文献 &amp; 鸣谢"></a>参考文献 &amp; 鸣谢</h1><ul>
<li>Mason技术记录：<a target="_blank" rel="noopener" href="https://github.com/mianshenglee/my-example/tree/master/multi-datasource">https://github.com/mianshenglee/my-example/tree/master/multi-datasource</a></li>
<li>YourBatman博客【JdbcTemplate】：<a target="_blank" rel="noopener" href="https://blog.csdn.net/f641385712/article/details/92404435">https://blog.csdn.net/f641385712/article/details/92404435</a></li>
<li>动态数据源配置&amp;运行时新增数据源：<a target="_blank" rel="noopener" href="https://blog.95id.com/dynamic-datasource-in-springboot.html">https://blog.95id.com/dynamic-datasource-in-springboot.html</a></li>
<li>Springboot 从数据库读取数据库配置信息，动态切换多数据源 最详细实战教程【Mybatis】：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_35387940/article/details/102699765">https://blog.csdn.net/qq_35387940/article/details/102699765</a></li>
<li>Springboot 整合druid+mybatis+jta分布式事务+多数据源aop注解动态切换 （一篇到位）：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_35387940/article/details/103474353">https://blog.csdn.net/qq_35387940/article/details/103474353</a></li>
</ul>
<hr>
<p>JPA 切换多数据失效参考：</p>
<ul>
<li>JPA动态数据源实现多数据源切换数据源失败：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_35167373/article/details/124042867">https://blog.csdn.net/qq_35167373/article/details/124042867</a></li>
<li>jpa+AbstractRoutingDataSource+Transactional数据源切换失效【解决方案无效】：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qichangleixin/article/details/117407676">https://blog.csdn.net/qichangleixin/article/details/117407676</a></li>
<li>JPA hibernate AbstractRoutingDataSource 在同一方法内使用不同数据源失败【解决方案无效】：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44987346/article/details/136829780">https://blog.csdn.net/weixin_44987346/article/details/136829780</a></li>
<li>SpringBoot 动态切换数据源，注意问题（JPA，Mybatis兼容）【解决方案无效】：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_39234317/article/details/90414873">https://blog.csdn.net/weixin_39234317/article/details/90414873</a></li>
</ul>

      
       <hr><span style="font-style: italic;color: gray;"> 转载请注明来源，欢迎对文章中的引用来源进行考证，欢迎指出任何有错误或不够清晰的表达。可以在下面评论区评论，也可以邮件至 8629303@qq.com </span>
    </div>
</article>


<p>
    <a  class="dashang" onclick="dashangToggle()">赏</a>
</p>






    




    </div>
    <div class="copyright">
        <p class="footer-entry">
    ©2017-2024 Sam
</p>
<p class="footer-entry">Built with <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/yelog/hexo-theme-3-hexo" target="_blank">3-hexo</a> theme</p>

    </div>
    <div class="full-toc">
        <button class="full" data-title="切换全屏 快捷键 s"><span class="min "></span></button>
<a class="" id="rocket" ></a>

    </div>
</div>

<div class="hide_box" onclick="dashangToggle()"></div>
<div class="shang_box">
    <a class="shang_close"  onclick="dashangToggle()">×</a>
    <div class="shang_tit">
        <p>喜欢就点赞,疼爱就打赏</p>
    </div>
    <div class="shang_payimg">
        <div class="pay_img">
            <img src="/img/alipay.jpg" class="alipay" title="扫码支持">
            <img src="/img/weixin.jpg" class="weixin" title="扫码支持">
        </div>
    </div>
    <div class="shang_payselect">
        <span><label><input type="radio" name="pay" checked value="alipay">支付宝</label></span><span><label><input type="radio" name="pay" value="weixin">微信</label></span>
    </div>
</div>


</body>
<script src="/js/jquery.pjax.js?v=1.1.0" ></script>

<script src="/js/script.js?v=1.1.0" ></script>
<script>
    var img_resize = 'default';
    function initArticle() {
        /*渲染对应的表格样式*/
        
            $("#post .pjax table").addClass("green_title");
        

        /*渲染打赏样式*/
        
        $("input[name=pay]").on("click", function () {
            if($("input[name=pay]:checked").val()=="weixin"){
                $(".shang_box .shang_payimg .pay_img").addClass("weixin_img");
            } else {
                $(".shang_box .shang_payimg .pay_img").removeClass("weixin_img");
            }
        })
        

        /*高亮代码块行号*/
        
        $('pre code').each(function(){
            var lines = $(this).text().trim().split('\n').length, widther='';
            if (lines>99) {
                widther = 'widther'
            }
            var $numbering = $('<ul/>').addClass('pre-numbering ' + widther).attr("unselectable","on");
            $(this).addClass('has-numbering ' + widther)
                    .parent()
                    .append($numbering);
            for(var i=1;i<=lines;i++){
                $numbering.append($('<li/>').text(i));
            }
        });
        

        /*访问数量*/
        
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js");
        

        /*代码高亮，行号对齐*/
        $('.pre-numbering').css('line-height',$('.has-numbering').css('line-height'));

        
        
    }

    /*打赏页面隐藏与展示*/
    
    function dashangToggle() {
        $(".shang_box").fadeToggle();
        $(".hide_box").fadeToggle();
    }
    

</script>

<!--加入行号的高亮代码块样式-->

<style>
    pre{
        position: relative;
        margin-bottom: 24px;
        border-radius: 10px;
        border: 1px solid #e2dede;
        background: #FFF;
        overflow: hidden;
    }
    code.has-numbering{
        margin-left: 30px;
    }
    code.has-numbering.widther{
        margin-left: 35px;
    }
    .pre-numbering{
        margin: 0;
        position: absolute;
        top: 0;
        left: 0;
        width: 20px;
        padding: 18px 3px 15px 5px;
        border-right: 1px solid #C3CCD0;
        text-align: right;
        color: #AAA;
        background-color: #fafafa;
    }
    .pre-numbering.widther {
        width: 35px;
    }
</style>

<!--自定义样式设置-->
<style>
    
    
    .nav {
        width: 582px;
    }
    .nav.fullscreen {
        margin-left: -582px;
    }
    .nav-left {
        width: 160px;
    }
    
    
    @media screen and (max-width: 1468px) {
        .nav {
            width: 492px;
        }
        .nav.fullscreen {
            margin-left: -492px;
        }
        .nav-left {
            width: 100px;
        }
    }
    
    
    @media screen and (max-width: 1024px) {
        .nav {
            width: 492px;
            margin-left: -492px
        }
        .nav.fullscreen {
            margin-left: 0;
        }
    }
    
    @media screen and (max-width: 426px) {
        .nav {
            width: 100%;
        }
        .nav-left {
            width: 100%;
        }
    }
    
    
    .nav-right .title-list nav a .post-title, .nav-right .title-list #local-search-result a .post-title {
        color: #383636;
    }
    
    
    .nav-right .title-list nav a .post-date, .nav-right .title-list #local-search-result a .post-date {
        color: #5e5e5f;
    }
    
    
    .nav-right nav a.hover, #local-search-result a.hover{
        background-color: #e2e0e0;
    }
    
    

    /*列表样式*/
    

    /* 背景图样式 */
    
    


    /*引用块样式*/
    

    /*文章列表背景图*/
    

    
</style>







</html>
