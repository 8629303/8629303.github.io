<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Spring JDBC - JdbcTemplate | Hexo</title>
  <meta name="keywords" content="">
  <meta name="description" content="Spring JDBC - JdbcTemplate | Hexo">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="description" content="请不要自己写，Spring Boot非常实用的内置功能：https:&#x2F;&#x2F;juejin.cn&#x2F;post&#x2F;7417630844100231206  在 SpringBoot 框架中，内置了许多实用的功能，这些功能可以帮助开发者高效地开发和维护应用程序。 一、请求数据记录器SpringBoot 提供了一个内置的日志记录解决方案，通过 AbstractRequestLoggingFilter 可以记录请">
<meta property="og:type" content="article">
<meta property="og:title" content="SpringBoot2.x 内置功能 - 内置过滤器和 AOP 工具类">
<meta property="og:url" content="http://example.com/2024/10/08/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot2.x%20%E5%86%85%E7%BD%AE%E5%8A%9F%E8%83%BD%20-%20%E5%86%85%E7%BD%AE%E8%BF%87%E6%BB%A4%E5%99%A8%E5%92%8C%20AOP%20%E5%B7%A5%E5%85%B7%E7%B1%BB/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="请不要自己写，Spring Boot非常实用的内置功能：https:&#x2F;&#x2F;juejin.cn&#x2F;post&#x2F;7417630844100231206  在 SpringBoot 框架中，内置了许多实用的功能，这些功能可以帮助开发者高效地开发和维护应用程序。 一、请求数据记录器SpringBoot 提供了一个内置的日志记录解决方案，通过 AbstractRequestLoggingFilter 可以记录请">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2024-10-08T08:44:19.743Z">
<meta property="article:modified_time" content="2024-10-19T16:49:11.489Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">


<link rel="icon" href="/img/avatar.jpg">

<link href="/css/style.css?v=1.1.0" rel="stylesheet">

<link href="/css/hl_theme/atom-light.css?v=1.1.0" rel="stylesheet">

<link href="//cdn.jsdelivr.net/npm/animate.css@4.1.0/animate.min.css" rel="stylesheet">

<script src="//cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
<script src="/js/titleTip.js?v=1.1.0" ></script>

<script src="//cdn.jsdelivr.net/npm/highlightjs@9.16.2/highlight.pack.min.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>

<script src="//cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script>



<script src="//cdn.jsdelivr.net/npm/jquery.cookie@1.4.1/jquery.cookie.min.js" ></script>

<script src="/js/iconfont.js?v=1.1.0" ></script>

<meta name="generator" content="Hexo 7.3.0"></head>
<div style="display: none">
  <input class="theme_disqus_on" value="false">
  <input class="theme_preload_comment" value="">
  <input class="theme_blog_path" value="">
  <input id="theme_shortcut" value="true" />
  <input id="theme_highlight_on" value="true" />
  <input id="theme_code_copy" value="true" />
</div>



<body>
<aside class="nav">
    <div class="nav-left">
        <a href="/"
   class="avatar_target">
    <img class="avatar"
         src="/img/avatar.jpg"/>
</a>
<div class="author">
    <span>John Doe</span>
</div>

<div class="icon">
    
        
            <a title="github"
               href="https://github.com/8629303"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-github"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="email"
               href="mailto:8629303@qq.com"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-email"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="qq"
               href="http://wpa.qq.com/msgrd?v=3&uin=8629303&site=qq&menu=yes"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-qq"></use>
                    </svg>
                
            </a>
        
    
</div>





<ul>
    <li>
        <div class="all active" data-rel="全部文章">全部文章
            
                <small>(172)</small>
            
        </div>
    </li>
    
        
            
                
    <li>
        <div data-rel="数据库">
            
            数据库
            <small>(5)</small>
        </div>
        
    </li>

            
        
    
        
            
        
    
        
            
        
    
        
            
                
    <li>
        <div data-rel="开发工具">
            <i class="fold iconfont icon-right"></i>
            开发工具
            <small>(16)</small>
        </div>
        
            <ul class="sub hide">
                
                    
    <li>
        <div data-rel="开发工具&lt;---&gt;Maven">
            
            Maven
            <small>(8)</small>
        </div>
        
    </li>

                
            </ul>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="面试篇">
            
            面试篇
            <small>(1)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="微服务开发">
            <i class="fold iconfont icon-right"></i>
            微服务开发
            <small>(61)</small>
        </div>
        
            <ul class="sub hide">
                
                    
    <li>
        <div data-rel="微服务开发&lt;---&gt;Shiro">
            
            Shiro
            <small>(2)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="微服务开发&lt;---&gt;Spring">
            
            Spring
            <small>(3)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="微服务开发&lt;---&gt;SpringBoot">
            
            SpringBoot
            <small>(44)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="微服务开发&lt;---&gt;SpringCloudAlibaba">
            
            SpringCloudAlibaba
            <small>(1)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="微服务开发&lt;---&gt;SpringDataJPA">
            
            SpringDataJPA
            <small>(4)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="微服务开发&lt;---&gt;SpringMVC">
            
            SpringMVC
            <small>(1)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="微服务开发&lt;---&gt;SpringSecurity">
            
            SpringSecurity
            <small>(1)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="微服务开发&lt;---&gt;SpringTransaction">
            
            SpringTransaction
            <small>(5)</small>
        </div>
        
    </li>

                
            </ul>
        
    </li>

            
        
    
        
            
        
    
        
            
                
    <li>
        <div data-rel="中间件">
            <i class="fold iconfont icon-right"></i>
            中间件
            <small>(8)</small>
        </div>
        
            <ul class="sub hide">
                
                    
    <li>
        <div data-rel="中间件&lt;---&gt;ElasticSearch">
            
            ElasticSearch
            <small>(1)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="中间件&lt;---&gt;MongoDB">
            
            MongoDB
            <small>(2)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="中间件&lt;---&gt;RabbitMQ">
            
            RabbitMQ
            <small>(3)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="中间件&lt;---&gt;Redis">
            
            Redis
            <small>(2)</small>
        </div>
        
    </li>

                
            </ul>
        
    </li>

            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
                
    <li>
        <div data-rel="Java基础篇">
            <i class="fold iconfont icon-right"></i>
            Java基础篇
            <small>(8)</small>
        </div>
        
            <ul class="sub hide">
                
                    
    <li>
        <div data-rel="Java基础篇&lt;---&gt;Java常用类库">
            
            Java常用类库
            <small>(1)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="Java基础篇&lt;---&gt;Java多线程">
            
            Java多线程
            <small>(2)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="Java基础篇&lt;---&gt;Java反射与注解">
            
            Java反射与注解
            <small>(1)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="Java基础篇&lt;---&gt;Java基础语法">
            
            Java基础语法
            <small>(1)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="Java基础篇&lt;---&gt;Java集合类">
            
            Java集合类
            <small>(1)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="Java基础篇&lt;---&gt;JavaIO流">
            
            JavaIO流
            <small>(1)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="Java基础篇&lt;---&gt;JavaNIO流">
            
            JavaNIO流
            <small>(1)</small>
        </div>
        
    </li>

                
            </ul>
        
    </li>

            
        
    
        
            
        
    
        
            
        
    
        
            
                
    <li>
        <div data-rel="Java进阶篇">
            <i class="fold iconfont icon-right"></i>
            Java进阶篇
            <small>(4)</small>
        </div>
        
            <ul class="sub hide">
                
                    
    <li>
        <div data-rel="Java进阶篇&lt;---&gt;Java设计模式">
            
            Java设计模式
            <small>(1)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="Java进阶篇&lt;---&gt;JVM虚拟机">
            
            JVM虚拟机
            <small>(3)</small>
        </div>
        
    </li>

                
            </ul>
        
    </li>

            
        
    
        
            
        
    
        
            
        
    
        
            
                
    <li>
        <div data-rel="Java新特性">
            <i class="fold iconfont icon-right"></i>
            Java新特性
            <small>(16)</small>
        </div>
        
            <ul class="sub hide">
                
                    
    <li>
        <div data-rel="Java新特性&lt;---&gt;Java10新特性">
            
            Java10新特性
            <small>(1)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="Java新特性&lt;---&gt;Java11新特性">
            
            Java11新特性
            <small>(1)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="Java新特性&lt;---&gt;Java12新特性">
            
            Java12新特性
            <small>(1)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="Java新特性&lt;---&gt;Java13新特性">
            
            Java13新特性
            <small>(1)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="Java新特性&lt;---&gt;Java14新特性">
            
            Java14新特性
            <small>(1)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="Java新特性&lt;---&gt;Java15新特性">
            
            Java15新特性
            <small>(1)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="Java新特性&lt;---&gt;Java16新特性">
            
            Java16新特性
            <small>(1)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="Java新特性&lt;---&gt;Java17新特性">
            
            Java17新特性
            <small>(1)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="Java新特性&lt;---&gt;Java18新特性">
            
            Java18新特性
            <small>(1)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="Java新特性&lt;---&gt;Java19新特性">
            
            Java19新特性
            <small>(1)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="Java新特性&lt;---&gt;Java20新特性">
            
            Java20新特性
            <small>(1)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="Java新特性&lt;---&gt;Java8新特性">
            
            Java8新特性
            <small>(4)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="Java新特性&lt;---&gt;Java9新特性">
            
            Java9新特性
            <small>(1)</small>
        </div>
        
    </li>

                
            </ul>
        
    </li>

            
        
    
        
            
        
    
        
            
                
    <li>
        <div data-rel="JavaEE">
            <i class="fold iconfont icon-right"></i>
            JavaEE
            <small>(6)</small>
        </div>
        
            <ul class="sub hide">
                
                    
    <li>
        <div data-rel="JavaEE&lt;---&gt;JavaWeb">
            
            JavaWeb
            <small>(2)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="JavaEE&lt;---&gt;SSM框架">
            
            SSM框架
            <small>(4)</small>
        </div>
        
    </li>

                
            </ul>
        
    </li>

            
        
    
        
            
        
    
        
            
        
    
        
            
                
    <li>
        <div data-rel="JavaSE">
            <i class="fold iconfont icon-right"></i>
            JavaSE
            <small>(34)</small>
        </div>
        
            <ul class="sub hide">
                
                    
    <li>
        <div data-rel="JavaSE&lt;---&gt;Java汇总篇">
            
            Java汇总篇
            <small>(28)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="JavaSE&lt;---&gt;Java新特性">
            
            Java新特性
            <small>(1)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="JavaSE&lt;---&gt;Java性能测试与安全">
            
            Java性能测试与安全
            <small>(5)</small>
        </div>
        
    </li>

                
            </ul>
        
    </li>

            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
                
    <li>
        <div data-rel="Linux">
            <i class="fold iconfont icon-right"></i>
            Linux
            <small>(7)</small>
        </div>
        
            <ul class="sub hide">
                
                    
    <li>
        <div data-rel="Linux&lt;---&gt;虚拟机工具">
            
            虚拟机工具
            <small>(2)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="Linux&lt;---&gt;Docker">
            
            Docker
            <small>(2)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="Linux&lt;---&gt;Kubernetes">
            
            Kubernetes
            <small>(2)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="Linux&lt;---&gt;Nginx">
            
            Nginx
            <small>(1)</small>
        </div>
        
    </li>

                
            </ul>
        
    </li>

            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
                
    <li>
        <div data-rel="Redis">
            <i class="fold iconfont icon-right"></i>
            Redis
            <small>(1)</small>
        </div>
        
            <ul class="sub hide">
                
                    
    <li>
        <div data-rel="Redis&lt;---&gt;backup">
            
            backup
            <small>(1)</small>
        </div>
        
    </li>

                
            </ul>
        
    </li>

            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
                
    <li>
        <div data-rel="SpringTransaction">
            <i class="fold iconfont icon-right"></i>
            SpringTransaction
            <small>(5)</small>
        </div>
        
            <ul class="sub hide">
                
                    
    <li>
        <div data-rel="SpringTransaction&lt;---&gt;多数据源事务处理">
            
            多数据源事务处理
            <small>(3)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="SpringTransaction&lt;---&gt;多线程下事务处理">
            
            多线程下事务处理
            <small>(2)</small>
        </div>
        
    </li>

                
            </ul>
        
    </li>

            
        
    
        
            
        
    
        
            
        
    
</ul>
<div class="left-bottom">
    <div class="menus">
        
            
            
            
    </div>
    <div>
        
            <a class="about  hasFriend  site_url"
               
               href="/about">关于</a>
        
        <a style="width: 50%"
                
                                           class="friends">友链</a>
        
    </div>
</div>
<input type="hidden" id="yelog_site_posts_number" value="172">

<div style="display: none">
    <span id="busuanzi_value_site_uv"></span>
    <span id="busuanzi_value_site_pv"></span>
</div>

    </div>
    <div class="nav-right">
        <div class="friends-area">
    <div class="friends-title">
        友情链接
        <i class="iconfont icon-left"></i>
    </div>
    <div class="friends-content">
        <ul>
            
            <li><a target="_blank" href="http://yelog.org/">叶落阁</a></li>
            
        </ul>
    </div>
</div>
        <div class="title-list">
    <div class="right-top">
        <div id="default-panel">
            <i class="iconfont icon-search" data-title="搜索 快捷键 i"></i>
            <div class="right-title">全部文章</div>
            <i class="iconfont icon-file-tree" data-title="切换到大纲视图 快捷键 w"></i>
        </div>
        <div id="search-panel">
            <i class="iconfont icon-left" data-title="返回"></i>
            <input id="local-search-input" autocomplete="off"/>
            <label class="border-line" for="input"></label>
            <i class="iconfont icon-case-sensitive" data-title="大小写敏感"></i>
            <i class="iconfont icon-tag" data-title="标签"></i>
        </div>
        <div id="outline-panel" style="display: none">
            <div class="right-title">大纲</div>
            <i class="iconfont icon-list" data-title="切换到文章列表"></i>
        </div>
    </div>

    <div class="tags-list">
    <input id="tag-search" />
    <div class="tag-wrapper">
        
    </div>

</div>

    
    <nav id="title-list-nav">
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2024/10/08/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot2.x%20%E5%86%85%E7%BD%AE%E5%8A%9F%E8%83%BD%20-%20%E5%86%85%E7%BD%AE%E8%BF%87%E6%BB%A4%E5%99%A8%E5%92%8C%20AOP%20%E5%B7%A5%E5%85%B7%E7%B1%BB/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot2.x 内置功能 - 内置过滤器和 AOP 工具类">SpringBoot2.x 内置功能 - 内置过滤器和 AOP 工具类</span>
            <span class="post-date" title="2024-10-08 16:44:19">2024/10/08</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2024/10/08/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%E7%B3%BB%E5%88%97-%E5%85%A8%E7%BD%91%E6%9C%80%E5%85%A8%E7%9A%84%E7%89%88%E6%9C%AC%E5%8F%98%E6%9B%B4%E5%8F%B2/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot系列-全网最全的版本变更史">SpringBoot系列-全网最全的版本变更史</span>
            <span class="post-date" title="2024-10-08 16:38:53">2024/10/08</span>
        </a>
        
        
        <a  class="全部文章 开发工具 Maven "
           href="/2024/10/08/6%E3%80%81%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Maven/Maven%20%E6%95%99%E7%A8%8B%E4%B9%8B%20%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE%20&%20%E9%B8%A3%E8%B0%A2/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Maven 教程之 参考文献 &amp; 鸣谢">Maven 教程之 参考文献 &amp; 鸣谢</span>
            <span class="post-date" title="2024-10-08 15:50:47">2024/10/08</span>
        </a>
        
        
        <a  class="全部文章 开发工具 "
           href="/2024/10/07/6%E3%80%81%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/GitHub%20%E5%AE%9E%E6%88%98%E6%8A%80%E5%B7%A7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="GitHub 实战技巧">GitHub 实战技巧</span>
            <span class="post-date" title="2024-10-07 15:55:34">2024/10/07</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2024/10/07/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot2.x%20%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AF%87%20-%20%E9%9B%86%E6%88%90%20HirakiCP%20%E4%B8%8E%20Druid%20%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot2.x 数据库篇 - 集成 HirakiCP 与 Druid 数据库连接池">SpringBoot2.x 数据库篇 - 集成 HirakiCP 与 Druid 数据库连接池</span>
            <span class="post-date" title="2024-10-07 14:19:43">2024/10/07</span>
        </a>
        
        
        <a  class="全部文章 开发工具 "
           href="/2024/09/30/6%E3%80%81%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/MacOS%20%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%8F%8A%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E5%8D%B8%E8%BD%BD/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="MacOS 开发环境搭建及软件安装卸载">MacOS 开发环境搭建及软件安装卸载</span>
            <span class="post-date" title="2024-09-30 23:56:52">2024/09/30</span>
        </a>
        
        
        <a  class="全部文章 开发工具 Maven "
           href="/2024/09/30/6%E3%80%81%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Maven/Maven%20%E6%95%99%E7%A8%8B%E4%B9%8B%20JDK%20%E7%89%88%E6%9C%AC%E9%BB%98%E8%AE%A4%E8%AE%BE%E7%BD%AE%20/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Maven 教程之 JDK 版本默认设置">Maven 教程之 JDK 版本默认设置</span>
            <span class="post-date" title="2024-09-30 16:37:08">2024/09/30</span>
        </a>
        
        
        <a  class="全部文章 开发工具 Maven "
           href="/2024/09/26/6%E3%80%81%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Maven/Maven%20%E6%95%99%E7%A8%8B%E4%B9%8B%20profiles%20%E5%A4%9A%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Maven 教程之 profiles 多环境配置">Maven 教程之 profiles 多环境配置</span>
            <span class="post-date" title="2024-09-26 17:40:34">2024/09/26</span>
        </a>
        
        
        <a  class="全部文章 开发工具 Maven "
           href="/2024/09/25/6%E3%80%81%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Maven/Maven%20%E6%95%99%E7%A8%8B%E4%B9%8B%20plugin%20%E8%AF%A6%E8%A7%A3/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Maven 教程之 plugin 详解">Maven 教程之 plugin 详解</span>
            <span class="post-date" title="2024-09-25 11:32:44">2024/09/25</span>
        </a>
        
        
        <a  class="全部文章 开发工具 Maven "
           href="/2024/09/21/6%E3%80%81%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Maven/Maven%20%E6%95%99%E7%A8%8B%E4%B9%8B%20pom.xml%20%E8%AF%A6%E8%A7%A3/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Maven 教程之 pom.xml 详解">Maven 教程之 pom.xml 详解</span>
            <span class="post-date" title="2024-09-21 16:14:13">2024/09/21</span>
        </a>
        
        
        <a  class="全部文章 开发工具 Maven "
           href="/2024/09/21/6%E3%80%81%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Maven/Maven%20%E6%95%99%E7%A8%8B%E4%B9%8B%20settings.xml%20%E8%AF%A6%E8%A7%A3/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Maven 教程之 settings.xml 详解">Maven 教程之 settings.xml 详解</span>
            <span class="post-date" title="2024-09-21 16:14:09">2024/09/21</span>
        </a>
        
        
        <a  class="全部文章 面试篇 "
           href="/2024/08/27/0%E3%80%81%E9%9D%A2%E8%AF%95%E7%AF%87/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8%E6%B1%87%E6%80%BB/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="面试宝典汇总">面试宝典汇总</span>
            <span class="post-date" title="2024-08-27 16:20:25">2024/08/27</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/2024/08/26/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E8%87%AA%E5%AE%9A%E4%B9%89%E9%9B%86%E5%90%88%E5%B8%B8%E9%87%8F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 自定义集合常量">Java 自定义集合常量</span>
            <span class="post-date" title="2024-08-26 12:11:54">2024/08/26</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringMVC "
           href="/2024/08/26/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20MVC/SpringMVC%E4%B9%8B@InitBinder%E6%B3%A8%E8%A7%A3%EF%BC%88%E6%97%A5%E6%9C%9F%E8%BD%AC%E6%8D%A2%EF%BC%89/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringMVC之@InitBinder注解（日期转换）">SpringMVC之@InitBinder注解（日期转换）</span>
            <span class="post-date" title="2024-08-26 11:10:28">2024/08/26</span>
        </a>
        
        
        <a  class="全部文章 SpringTransaction 多线程下事务处理 "
           href="/2024/08/21/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Transaction/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8B%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/Java%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BA%8B%E5%8A%A1%E6%8F%90%E4%BA%A4%E7%9A%84%E5%A4%84%E7%90%86/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 多线程事务提交的处理">Java 多线程事务提交的处理</span>
            <span class="post-date" title="2024-08-21 16:32:52">2024/08/21</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2024/08/20/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%20Cache%20%E6%95%B4%E5%90%88%20Redis%20%E7%BC%93%E5%AD%98%E6%A1%86%E6%9E%B6/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot Cache 整合 Redis 缓存框架">SpringBoot Cache 整合 Redis 缓存框架</span>
            <span class="post-date" title="2024-08-20 16:11:47">2024/08/20</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringTransaction "
           href="/2024/08/16/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Transaction/Spring%20%E4%BA%8B%E5%8A%A1%E5%BA%94%E7%94%A8%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Spring 事务应用及源码分析">Spring 事务应用及源码分析</span>
            <span class="post-date" title="2024-08-16 10:33:57">2024/08/16</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringTransaction "
           href="/2024/08/16/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Transaction/Spring%20JDBC%20-%20NamedParameterJdbcTemplate/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Spring JDBC - NamedParameterJdbcTemplate">Spring JDBC - NamedParameterJdbcTemplate</span>
            <span class="post-date" title="2024-08-16 00:18:18">2024/08/16</span>
        </a>
        
        
        <a  class="全部文章 开发工具 "
           href="/2024/07/18/6%E3%80%81%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Git%20&%20GitHub/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Git &amp; GitHub">Git &amp; GitHub</span>
            <span class="post-date" title="2024-07-18 10:34:58">2024/07/18</span>
        </a>
        
        
        <a  class="全部文章 开发工具 Maven "
           href="/2024/06/28/6%E3%80%81%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Maven/Maven%20%E5%AE%9E%E6%88%98/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Maven 实战">Maven 实战</span>
            <span class="post-date" title="2024-06-28 16:50:35">2024/06/28</span>
        </a>
        
        
        <a  class="全部文章 数据库 "
           href="/2024/06/26/3%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%9D%A2%E8%AF%95%E5%AE%98%EF%BC%9A%E4%B8%8D%E4%BC%9A%E7%9C%8B%20Explain%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%EF%BC%8C%E7%AE%80%E5%8E%86%E6%95%A2%E5%86%99%20SQL%20%E4%BC%98%E5%8C%96%EF%BC%9F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="面试官：不会看 Explain执行计划，简历敢写 SQL 优化？">面试官：不会看 Explain执行计划，简历敢写 SQL 优化？</span>
            <span class="post-date" title="2024-06-26 19:33:03">2024/06/26</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/2024/04/22/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%AF%87%E4%B9%8B%20IDEA%20-%20VM%20Options%E3%80%81Program%20Arguments%E3%80%81Environment%20Variable%20%E8%A7%A3%E6%9E%90/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 命令行篇之 IDEA - VM Options、Program Arguments、Environment Variable 解析">Java 命令行篇之 IDEA - VM Options、Program Arguments、Environment Variable 解析</span>
            <span class="post-date" title="2024-04-22 10:53:10">2024/04/22</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2024/04/19/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6-%E9%85%8D%E7%BD%AE%E5%A4%96%E9%83%A8%E5%8C%96/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 配置文件-配置外部化">SpringBoot 2.x 配置文件-配置外部化</span>
            <span class="post-date" title="2024-04-19 09:18:55">2024/04/19</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/2024/04/16/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E5%8E%9F%E7%90%86%E7%AF%87%E4%B9%8B%20SPI%20%E6%9C%BA%E5%88%B6/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 原理篇之 SPI 机制">Java 原理篇之 SPI 机制</span>
            <span class="post-date" title="2024-04-16 17:26:15">2024/04/16</span>
        </a>
        
        
        <a  class="全部文章 开发工具 Maven "
           href="/2024/01/14/6%E3%80%81%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Maven/Maven%20%E6%95%99%E7%A8%8B%E4%B9%8B%20mirror%20&%20repository%20%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Maven 教程之 mirror &amp; repository 配置详解">Maven 教程之 mirror &amp; repository 配置详解</span>
            <span class="post-date" title="2024-01-14 22:51:03">2024/01/14</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2023/12/07/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E4%B8%BA%E4%BB%80%E4%B9%88SpringBoot%20jar%20%E5%8F%AF%E4%BB%A5%E7%9B%B4%E6%8E%A5%E8%BF%90%E8%A1%8C/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 为什么SpringBoot jar 可以直接运行">SpringBoot 2.x 为什么SpringBoot jar 可以直接运行</span>
            <span class="post-date" title="2023-12-07 15:13:56">2023/12/07</span>
        </a>
        
        
        <a  class="全部文章 Java基础篇 Java多线程 "
           href="/2023/12/04/1%E3%80%81JavaSE/1.Java%20%E5%9F%BA%E7%A1%80%E7%AF%87/5%E3%80%81Java%20%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%BF%9B%E9%98%B6/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 多线程进阶">Java 多线程进阶</span>
            <span class="post-date" title="2023-12-04 16:37:09">2023/12/04</span>
        </a>
        
        
        <a  class="全部文章 数据库 "
           href="/2023/11/18/3%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BB%BA%E6%A8%A1%E5%B7%A5%E5%85%B7%E6%B1%87%E6%80%BB/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="数据库建模工具汇总">数据库建模工具汇总</span>
            <span class="post-date" title="2023-11-18 15:31:11">2023/11/18</span>
        </a>
        
        
        <a  class="全部文章 JavaEE SSM框架 "
           href="/2023/10/08/2%E3%80%81JavaEE/2%E3%80%81SSM%E6%A1%86%E6%9E%B6/Mybatis/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Mybatis">Mybatis</span>
            <span class="post-date" title="2023-10-08 19:45:47">2023/10/08</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java性能测试与安全 "
           href="/2023/08/28/1%E3%80%81JavaSE/5.Java%20%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E4%B8%8E%E5%AE%89%E5%85%A8/Java%20%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E7%AF%87%E4%B9%8B%20%E5%8E%8B%E6%B5%8B%E5%B7%A5%E5%85%B7%E6%B1%87%E6%80%BB/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 性能测试篇之 压测工具汇总">Java 性能测试篇之 压测工具汇总</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java性能测试与安全 "
           href="/2023/08/28/1%E3%80%81JavaSE/5.Java%20%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E4%B8%8E%E5%AE%89%E5%85%A8/Java%20%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E7%AF%87%E4%B9%8B%20%E9%AB%98%E5%B9%B6%E5%8F%91%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87%EF%BC%9AQPS%E3%80%81TPS%E3%80%81RT%E3%80%81%E5%B9%B6%E5%8F%91%E6%95%B0%E3%80%81%E5%90%9E%E5%90%90%E9%87%8F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 性能测试篇之 高并发性能指标：QPS、TPS、RT、并发数、吞吐量">Java 性能测试篇之 高并发性能指标：QPS、TPS、RT、并发数、吞吐量</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java性能测试与安全 "
           href="/2023/08/28/1%E3%80%81JavaSE/5.Java%20%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E4%B8%8E%E5%AE%89%E5%85%A8/Java%20%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E7%AF%87%E4%B9%8B%20JMH%20%E5%B7%A5%E5%85%B7%E7%B1%BB/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 性能测试篇之 JMH 工具类">Java 性能测试篇之 JMH 工具类</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java性能测试与安全 "
           href="/2023/08/28/1%E3%80%81JavaSE/5.Java%20%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E4%B8%8E%E5%AE%89%E5%85%A8/Java%20%E5%AE%89%E5%85%A8%E7%AF%87%E4%B9%8B%20API%20%E6%8E%A5%E5%8F%A3%E9%98%B2%E6%AD%A2%E5%8F%82%E6%95%B0%E7%AF%A1%E6%94%B9%E5%92%8C%E9%87%8D%E6%94%BE%E6%94%BB%E5%87%BB/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 安全篇之 API 接口防止参数篡改和重放攻击">Java 安全篇之 API 接口防止参数篡改和重放攻击</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java性能测试与安全 "
           href="/2023/08/28/1%E3%80%81JavaSE/5.Java%20%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E4%B8%8E%E5%AE%89%E5%85%A8/Java%20%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E7%AF%87%E4%B9%8B%2048%E5%BC%A0%E5%9B%BE%E5%AD%A6%E4%BC%9A%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E3%80%81%E5%8E%8B%E6%B5%8B%E5%92%8C%E8%B0%83%E4%BC%98/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 性能测试篇之 48张图学会性能监控、压测和调优">Java 性能测试篇之 48张图学会性能监控、压测和调优</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 开发工具 "
           href="/2023/08/28/6%E3%80%81%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/IDEA%20%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="IDEA 基本使用">IDEA 基本使用</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 开发工具 "
           href="/2023/08/28/6%E3%80%81%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/IDEA%20%E6%8F%92%E4%BB%B6%E5%AE%89%E8%A3%85/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="IDEA 插件安装">IDEA 插件安装</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 开发工具 "
           href="/2023/08/28/6%E3%80%81%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/IDEA%20%E5%BF%AB%E6%8D%B7%E9%94%AE/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="IDEA 快捷键">IDEA 快捷键</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 开发工具 "
           href="/2023/08/28/6%E3%80%81%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/PostMan%20%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="PostMan 工具的使用">PostMan 工具的使用</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 开发工具 "
           href="/2023/08/28/6%E3%80%81%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Git/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Git">Git</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E4%BC%98%E5%8C%96%E7%AF%87%E4%B9%8B%20%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3%20%E6%A0%A1%E9%AA%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 优化篇之 自定义注解 校验数据库表中的数据不可重复">Java 优化篇之 自定义注解 校验数据库表中的数据不可重复</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E5%B7%A5%E5%85%B7%E7%AF%87%E4%B9%8B%20API%20%E6%8E%A5%E5%8F%A3%E5%85%8D%E8%B4%B9%20JSONPlaceholder/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 工具篇之 API 接口免费 JSONPlaceholder">Java 工具篇之 API 接口免费 JSONPlaceholder</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E5%B7%A5%E5%85%B7%E7%AF%87%E4%B9%8B%20%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E7%BB%9F%E8%AE%A1%E4%BB%A3%E7%A0%81%E8%80%97%E6%97%B6/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 工具篇之 如何优雅的统计代码耗时">Java 工具篇之 如何优雅的统计代码耗时</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B9%8B%20%E4%B8%8D%E5%8F%AF%E4%B8%8D%E7%9F%A5%E7%9A%84%207%20%E4%B8%AA%20JDK%20%E5%91%BD%E4%BB%A4/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 命令行之 不可不知的 7 个 JDK 命令">Java 命令行之 不可不知的 7 个 JDK 命令</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%AF%87%E4%B9%8B%20Window%20%E5%90%8E%E5%8F%B0%E5%90%AF%E5%8A%A8%20JAR%20%E7%A8%8B%E5%BA%8F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 命令行篇之 Window 后台启动 JAR 程序">Java 命令行篇之 Window 后台启动 JAR 程序</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E5%B7%A5%E5%85%B7%E7%AF%87%E4%B9%8B%20API%20%E6%96%87%E6%A1%A3%E5%B7%A5%E5%85%B7%20Swagger3.x-2.x/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 工具篇之 API 文档工具 Swagger3.x-2.x">Java 工具篇之 API 文档工具 Swagger3.x-2.x</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E5%B7%A5%E5%85%B7%E7%AF%87%E4%B9%8B%20%E6%8E%8C%E6%8F%A114%E7%A7%8DUML%E5%9B%BE/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 工具篇之 掌握14种UML图">Java 工具篇之 掌握14种UML图</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E5%B7%A5%E5%85%B7%E7%AF%87%E4%B9%8B%20Lombok/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 工具篇之 Lombok">Java 工具篇之 Lombok</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E5%B7%A5%E5%85%B7%E7%B1%BB%E4%B9%8B%20%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B7%A5%E5%85%B7%E7%B1%BB/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 工具类之 自定义工具类">Java 工具类之 自定义工具类</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20Bean%20%E4%B9%8B%20DTO%E3%80%81VO%E3%80%81PO%E3%80%81DO%E3%80%81BO%20%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java Bean 之 DTO、VO、PO、DO、BO 类的区别">Java Bean 之 DTO、VO、PO、DO、BO 类的区别</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20JSON%20%E7%AF%87%E4%B9%8B%20Jackson/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java JSON 篇之 Jackson">Java JSON 篇之 Jackson</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20JSON%20%E7%AF%87%E4%B9%8B%20Gson/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java JSON 篇之 Gson">Java JSON 篇之 Gson</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Curl%20%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%91%BD%E4%BB%A4%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Curl 的使用及命令参数说明">Curl 的使用及命令参数说明</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20JSON%20%E7%AF%87%E4%B9%8B%20FastJson/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java JSON 篇之 FastJson">Java JSON 篇之 FastJson</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Redis backup "
           href="/2023/08/28/5%E3%80%81%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/backup/Redis6/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Redis6">Redis6</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 中间件 Redis "
           href="/2023/08/28/5%E3%80%81%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/Redis-%E6%9C%80%E5%85%A8%E5%AE%9E%E6%88%98/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Redis-最全实战">Redis-最全实战</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 中间件 Redis "
           href="/2023/08/28/5%E3%80%81%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/Redis-%E4%BB%A3%E7%A0%81%E5%AE%9E%E6%88%98/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Redis-代码实战">Redis-代码实战</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 中间件 RabbitMQ "
           href="/2023/08/28/5%E3%80%81%E4%B8%AD%E9%97%B4%E4%BB%B6/RabbitMQ/RabbitMQ-3.8.14/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="RabbitMQ-3.8.14">RabbitMQ-3.8.14</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 中间件 RabbitMQ "
           href="/2023/08/28/5%E3%80%81%E4%B8%AD%E9%97%B4%E4%BB%B6/RabbitMQ/RabbitMQ-3.7.x/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="RabbitMQ-3.7.x">RabbitMQ-3.7.x</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 中间件 RabbitMQ "
           href="/2023/08/28/5%E3%80%81%E4%B8%AD%E9%97%B4%E4%BB%B6/RabbitMQ/RabbitMQ-3.8.14-%E5%8D%9A%E5%AE%A2%E7%89%88/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="RabbitMQ-3.8.14-博客版">RabbitMQ-3.8.14-博客版</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 中间件 MongoDB "
           href="/2023/08/28/5%E3%80%81%E4%B8%AD%E9%97%B4%E4%BB%B6/MongoDB/MongDB-4.4.2-%E5%8D%9A%E5%AE%A2%E7%89%88/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="MongDB-4.4.2-博客版">MongDB-4.4.2-博客版</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 中间件 MongoDB "
           href="/2023/08/28/5%E3%80%81%E4%B8%AD%E9%97%B4%E4%BB%B6/MongoDB/MongDB-4.4.2/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="MongDB-4.4.2">MongDB-4.4.2</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 中间件 ElasticSearch "
           href="/2023/08/28/5%E3%80%81%E4%B8%AD%E9%97%B4%E4%BB%B6/ElasticSearch/ElasticSearch7.6.x%E5%AE%9E%E6%88%98/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="ElasticSearch7.6.x实战">ElasticSearch7.6.x实战</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Linux 虚拟机工具 "
           href="/2023/08/28/4%E3%80%81Linux/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%B7%A5%E5%85%B7/Virtualbox%E7%BD%91%E7%BB%9C%E8%AE%BE%E7%BD%AE%E6%88%96%E9%85%8D%E7%BD%AE/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Virtualbox网络设置或配置">Virtualbox网络设置或配置</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Linux 虚拟机工具 "
           href="/2023/08/28/4%E3%80%81Linux/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%B7%A5%E5%85%B7/Virtualbox%E5%AE%89%E8%A3%85Centos7%E5%AE%9E%E6%88%98/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Virtualbox安装Centos7实战">Virtualbox安装Centos7实战</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Linux Kubernetes "
           href="/2023/08/28/4%E3%80%81Linux/Kubernetes/Minikube-k8s/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Minikube-k8s">Minikube-k8s</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Linux Kubernetes "
           href="/2023/08/28/4%E3%80%81Linux/Kubernetes/k0s%20%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B%EF%BC%9A%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%20Kubernetes%20%E9%9B%86%E7%BE%A4/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="k0s 使用教程：如何快速搭建 Kubernetes 集群">k0s 使用教程：如何快速搭建 Kubernetes 集群</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Linux Nginx "
           href="/2023/08/28/4%E3%80%81Linux/Nginx/Nginx-1.8.0/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Nginx-1.8.0">Nginx-1.8.0</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Linux Docker "
           href="/2023/08/28/4%E3%80%81Linux/Docker/Docker%E5%88%9D%E7%BA%A7%E5%88%B0%E5%AE%9E%E6%88%98/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Docker初级到实战">Docker初级到实战</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Linux Docker "
           href="/2023/08/28/4%E3%80%81Linux/Docker/Docker&Docker-Compose%E5%AE%9E%E6%88%98-%E5%93%88%E5%96%BD%E6%B2%83%E5%BE%B7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Docker&amp;Docker-Compose实战-哈喽沃德">Docker&amp;Docker-Compose实战-哈喽沃德</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 Spring "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring/Spring%20Bean%20%E7%9A%84%E5%8A%A8%E6%80%81%E5%88%9B%E5%BB%BA%E8%8E%B7%E5%8F%96%E5%88%A0%E9%99%A4/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Spring Bean 的动态创建获取删除">Spring Bean 的动态创建获取删除</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 Spring "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring/Spring%20Bean%20%E7%9A%8412%E7%A7%8D%E5%AE%9A%E4%B9%89%E6%96%B9%E6%B3%95/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Spring Bean 的12种定义方法">Spring Bean 的12种定义方法</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 Spring "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring/Spring%20Bean%20%E6%B3%A8%E5%85%A5%E7%9A%843%E7%A7%8D%E6%96%B9%E5%BC%8F,%20%E4%B8%BA%E4%BD%95%E5%AE%98%E6%96%B9%E5%BB%BA%E8%AE%AE%E4%BD%BF%E7%94%A8%E6%9E%84%E9%80%A0%E5%99%A8%E6%B3%A8%E5%85%A5/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Spring Bean 注入的3种方式, 为何官方建议使用构造器注入">Spring Bean 注入的3种方式, 为何官方建议使用构造器注入</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 SpringTransaction 多数据源事务处理 "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Transaction/%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/Spring%20%E8%A7%A3%E5%86%B3%E5%8D%95%E6%9C%BA%E7%8E%AF%E5%A2%83%E4%B8%8B%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E7%9A%84%E4%BA%8B%E5%8A%A1%E9%97%AE%E9%A2%98/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Spring 解决单机环境下多数据源的事务问题">Spring 解决单机环境下多数据源的事务问题</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 SpringTransaction 多数据源事务处理 "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Transaction/%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/Spring%20%E5%AE%9E%E7%8E%B0%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E5%AE%9E%E6%88%98/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Spring 实现多数据源实战">Spring 实现多数据源实战</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 SpringTransaction 多数据源事务处理 "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Transaction/%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/Spring%20%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81%E6%95%B0%E6%8D%AE%E6%BA%90%E3%80%81%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E5%88%87%E6%8D%A2%E6%96%B9%E5%BC%8F%E3%80%81%E5%A4%9A%E6%95%B0%E6%8D%AE%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Spring 实现动态数据源、多数据源切换方式、多数据事务管理">Spring 实现动态数据源、多数据源切换方式、多数据事务管理</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringTransaction "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Transaction/Spring%20%E4%BA%8B%E5%8A%A1%E5%8E%9F%E7%90%86%E6%B7%B1%E5%85%A5%E4%B8%8E%E5%88%86%E6%9E%90/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Spring 事务原理深入与分析">Spring 事务原理深入与分析</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringTransaction "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Transaction/JDBC/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="JDBC">JDBC</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringSecurity "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Security/SpringSecurity/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringSecurity">SpringSecurity</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringTransaction "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Transaction/Spring%20JDBC%20-%20JdbcTemplate/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Spring JDBC - JdbcTemplate">Spring JDBC - JdbcTemplate</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 SpringTransaction 多线程下事务处理 "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Transaction/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8B%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/JDBC%E6%89%B9%E5%A4%84%E7%90%86%E5%AE%9E%E7%8E%B0%E6%89%8B%E5%8A%A8%E4%BA%8B%E5%8A%A1%E6%8F%92%E5%85%A51000%E4%B8%87%E6%95%B0%E6%8D%AE%EF%BC%88%E5%8D%95%E7%BA%BF%E7%A8%8B%20&%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%89/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="JDBC批处理实现手动事务插入1000万数据（单线程 &amp; 多线程）">JDBC批处理实现手动事务插入1000万数据（单线程 &amp; 多线程）</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringDataJPA "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Data%20JPA/SpringData%20JPA%20%E7%B1%BB%E5%9B%BE%E5%8F%8A%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringData JPA 类图及使用方法整理">SpringData JPA 类图及使用方法整理</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringDataJPA "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Data%20JPA/SpringData%20JPA/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringData JPA">SpringData JPA</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringDataJPA "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Data%20JPA/Spring%20Data%20JPA%20%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E6%88%98/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Spring Data JPA 原理与实战">Spring Data JPA 原理与实战</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringDataJPA "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Data%20JPA/Hibernata%20JPA/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Hibernata JPA">Hibernata JPA</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringCloudAlibaba "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Cloud%20Alibaba/SpringCloud%20Alibaba/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringCloud Alibaba">SpringCloud Alibaba</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot2.x%20%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AF%87%20-%20%E6%95%B4%E5%90%88H2%E6%95%B0%E6%8D%AE%E5%BA%93/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot2.x 数据库篇 - 整合H2数据库">SpringBoot2.x 数据库篇 - 整合H2数据库</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot2.x%20%E9%A1%B9%E7%9B%AE%E7%BB%9F%E4%B8%80%E6%9E%9A%E4%B8%BE%E8%BD%AC%E6%8D%A2%E5%AE%9E%E8%B7%B5/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot2.x 项目统一枚举转换实践">SpringBoot2.x 项目统一枚举转换实践</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%E9%85%8D%E7%BD%AE%E5%B1%9E%E6%80%A7%E4%B9%8BDataSource/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot配置属性之DataSource">SpringBoot配置属性之DataSource</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SprinigBoot%E6%96%87%E7%AB%A0%E6%91%98%E8%A6%81%E5%8F%8A%E8%BD%AC%E8%BD%BD/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SprinigBoot文章摘要及转载">SprinigBoot文章摘要及转载</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AD%A6/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot从零开始学">SpringBoot从零开始学</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/%E4%BB%A3%E7%A0%81%E5%AE%A1%E6%9F%A5%E7%9A%84%E5%BF%85%E8%A6%81%E6%80%A7%E5%92%8C%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="代码审查的必要性和最佳实践">代码审查的必要性和最佳实践</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6-%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%B9%8B@Value%E8%BF%9B%E9%98%B6/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 配置文件-读取配置文件之@Value进阶">SpringBoot 2.x 配置文件-读取配置文件之@Value进阶</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6-%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9A%84N%E7%A7%8D%E6%96%B9%E5%BC%8F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 配置文件-读取配置文件的N种方式">SpringBoot 2.x 配置文件-读取配置文件的N种方式</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6-%E8%AF%BB%E5%8F%96%20Resources%20%E6%96%87%E4%BB%B6%E4%B9%8B%E6%97%A0%E6%B3%95%E8%AF%BB%E5%8F%96Jar%E5%8C%85classpath%E4%B8%8B%E7%9A%84%E6%96%87%E4%BB%B6/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 配置文件-读取 Resources 文件之无法读取Jar包classpath下的文件">SpringBoot 2.x 配置文件-读取 Resources 文件之无法读取Jar包classpath下的文件</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E7%BB%9F%E4%B8%80%E6%8E%A5%E5%8F%A3%E8%BF%94%E5%9B%9E%E6%A0%BC%E5%BC%8F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 统一接口返回格式">SpringBoot 2.x 统一接口返回格式</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6-%E8%AF%BB%E5%8F%96%20Resources%20%E6%96%87%E4%BB%B6%E7%9A%84N%E7%A7%8D%E6%96%B9%E5%BC%8F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 配置文件-读取 Resources 文件的N种方式">SpringBoot 2.x 配置文件-读取 Resources 文件的N种方式</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B%E7%AF%87-%E6%8B%A6%E6%88%AA%E5%99%A8%E8%BF%87%E6%BB%A4%E5%99%A8%E4%B8%8E%E7%9B%91%E5%90%AC%E5%99%A8/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 切面编程篇-拦截器过滤器与监听器">SpringBoot 2.x 切面编程篇-拦截器过滤器与监听器</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3%E5%A4%A7%E5%85%A8/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 常用注解大全">SpringBoot 2.x 常用注解大全</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3%E8%AF%A6%E8%A7%A3/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 常用注解详解">SpringBoot 2.x 常用注解详解</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E5%AE%89%E5%85%A8%E5%AF%86%E7%A0%81%E5%AD%A6%E4%B9%8B%E5%8A%A0%E8%A7%A3%E5%AF%86%E7%AE%97%E6%B3%95/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 安全密码学之加解密算法">SpringBoot 2.x 安全密码学之加解密算法</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E5%90%AF%E5%8A%A8%E6%97%B6%E5%8A%A0%E8%BD%BD%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84N%E7%A7%8D%E6%96%B9%E5%BC%8F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 启动时加载初始化的N种方式">SpringBoot 2.x 启动时加载初始化的N种方式</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%8F%8A%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E8%BF%87%E7%A8%8B/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 启动流程及自动装配过程">SpringBoot 2.x 启动流程及自动装配过程</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E5%8A%A8%E6%80%81%E8%A3%85%E9%85%8DBean%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 动态装配Bean的三种方式">SpringBoot 2.x 动态装配Bean的三种方式</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E5%88%A9%E5%99%A8-1%20JUnit5/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 单元测试利器-1 JUnit5">SpringBoot 2.x 单元测试利器-1 JUnit5</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E5%88%A9%E5%99%A8-3%20MockMvc/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 单元测试利器-3 MockMvc">SpringBoot 2.x 单元测试利器-3 MockMvc</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E5%88%A9%E5%99%A8-2%20Mockito/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 单元测试利器-2 Mockito">SpringBoot 2.x 单元测试利器-2 Mockito</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E5%88%86%E7%89%87%E4%B8%8A%E4%BC%A0%E3%80%81%E6%96%AD%E7%82%B9%E7%BB%AD%E4%BC%A0%E3%80%81%E5%A4%A7%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E3%80%81%E7%A7%92%E4%BC%A0/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 分片上传、断点续传、大文件上传、秒传">SpringBoot 2.x 分片上传、断点续传、大文件上传、秒传</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20Validation%20%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C%EF%BC%88TODO%EF%BC%89/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x Validation 参数校验（TODO）">SpringBoot 2.x Validation 参数校验（TODO）</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20YML%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x YML配置文件详解">SpringBoot 2.x YML配置文件详解</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20WebMvcConfigurer%20%E8%AF%A6%E8%A7%A3%E3%80%90SpringMVC%E3%80%91/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x WebMvcConfigurer 详解【SpringMVC】">SpringBoot 2.x WebMvcConfigurer 详解【SpringMVC】</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E5%88%86%E5%B8%83%E5%BC%8F%E5%85%A8%E5%B1%80%E5%94%AF%E4%B8%80ID%E7%94%9F%E6%88%90%E6%96%B9%E6%A1%88/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 分布式全局唯一ID生成方案">SpringBoot 2.x 分布式全局唯一ID生成方案</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20Java%20%E5%AE%9E%E7%8E%B0%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E7%9A%848%E7%A7%8D%E6%96%B9%E5%BC%8F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x Java 实现异步编程的8种方式">SpringBoot 2.x Java 实现异步编程的8种方式</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20JWT%20%E6%A6%82%E5%BF%B5%E7%AF%87/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x JWT 概念篇">SpringBoot 2.x JWT 概念篇</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20Java%20%E7%A8%8B%E5%BA%8F%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0%E6%80%BB%E7%BB%93/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x Java 程序命令行参数总结">SpringBoot 2.x Java 程序命令行参数总结</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20Jar%20%E5%8C%85%E5%90%AF%E5%8A%A8%E3%80%81%E5%81%9C%E6%AD%A2%E3%80%81%E9%87%8D%E5%90%AF%E8%84%9A%E6%9C%AC/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x Jar 包启动、停止、重启脚本">SpringBoot 2.x Jar 包启动、停止、重启脚本</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20@ControllerAdvice%E4%B8%89%E7%A7%8D%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x @ControllerAdvice三种使用场景">SpringBoot 2.x @ControllerAdvice三种使用场景</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20HTTP%20Content-Type%20%E8%AF%A6%E8%A7%A3/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x HTTP Content-Type 详解">SpringBoot 2.x HTTP Content-Type 详解</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20HTTP%20Headers%20%E5%A4%B4%E4%BF%A1%E6%81%AF%E8%AF%BB%E5%8F%96/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x HTTP Headers 头信息读取">SpringBoot 2.x HTTP Headers 头信息读取</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20JWT%20%E5%AE%9E%E6%88%98%E7%AF%87/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x JWT 实战篇">SpringBoot 2.x JWT 实战篇</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20@ConfigurationProperties%E4%BB%A5%E5%8F%8A@NestedConfigurationProperty%E7%9A%84%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x @ConfigurationProperties以及@NestedConfigurationProperty的使用详解">SpringBoot 2.x @ConfigurationProperties以及@NestedConfigurationProperty的使用详解</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%20%E6%8E%A5%E5%8F%A3%E5%B9%82%E7%AD%89%E6%80%A7%E5%AE%9E%E7%8E%B0/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x  接口幂等性实现">SpringBoot 2.x  接口幂等性实现</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/Spring%20IO%20Platform%EF%BC%9A%E8%A7%A3%E5%86%B3%E4%BE%9D%E8%B5%96%E7%89%88%E6%9C%AC%E5%86%B2%E7%AA%81/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Spring IO Platform：解决依赖版本冲突">Spring IO Platform：解决依赖版本冲突</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B%E7%AF%87-AOP%20%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%8E%9F%E7%90%86/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 切面编程篇-AOP 的使用及原理">SpringBoot 2.x 切面编程篇-AOP 的使用及原理</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE SSM框架 "
           href="/2023/08/28/2%E3%80%81JavaEE/2%E3%80%81SSM%E6%A1%86%E6%9E%B6/SpringMVC/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringMVC">SpringMVC</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 Shiro "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Shiro/Shiro%E6%9D%83%E9%99%90%E5%AE%9E%E6%88%98/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Shiro权限实战">Shiro权限实战</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 Shiro "
           href="/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Shiro/Shiro%E6%9D%83%E9%99%90%E5%AE%9E%E6%88%98%E8%AF%BE%E7%A8%8B/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Shiro权限实战课程">Shiro权限实战课程</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE SSM框架 "
           href="/2023/08/28/2%E3%80%81JavaEE/2%E3%80%81SSM%E6%A1%86%E6%9E%B6/Spring/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Spring">Spring</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE SSM框架 "
           href="/2023/08/28/2%E3%80%81JavaEE/2%E3%80%81SSM%E6%A1%86%E6%9E%B6/MybatisPlus/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="MybatisPlus">MybatisPlus</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE JavaWeb "
           href="/2023/08/28/2%E3%80%81JavaEE/1%E3%80%81JavaWeb/%E4%BD%A0%E8%BF%98%E5%9C%A8%E4%B8%BA%20HTTP%20%E7%9A%84%E8%BF%99%E4%BA%9B%E6%A6%82%E5%BF%B5%E5%A4%B4%E7%96%BC%E5%90%97/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="你还在为 HTTP 的这些概念头疼吗">你还在为 HTTP 的这些概念头疼吗</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE JavaWeb "
           href="/2023/08/28/2%E3%80%81JavaEE/1%E3%80%81JavaWeb/Cookie%E3%80%81Session%E3%80%81Token%E3%80%81JWT%E7%BB%88%E4%BA%8E%E8%AE%B2%E6%B8%85%E6%A5%9A%E4%BA%86/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Cookie、Session、Token、JWT终于讲清楚了">Cookie、Session、Token、JWT终于讲清楚了</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 数据库 "
           href="/2023/08/28/3%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL-%E9%AB%98%E7%BA%A7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="MySQL-高级">MySQL-高级</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 数据库 "
           href="/2023/08/28/3%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL-%E5%88%9D%E7%BA%A7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="MySQL-初级">MySQL-初级</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 数据库 "
           href="/2023/08/28/3%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93/H2%20Database/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="H2 Database">H2 Database</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E4%BC%98%E5%8C%96%E7%AF%87%E4%B9%8B%20%E5%BB%B6%E6%97%B6%E9%98%9F%E5%88%97%20-%20%E8%AE%A2%E5%8D%95%E8%B6%85%E6%97%B6%E8%87%AA%E5%8A%A8%E5%8F%96%E6%B6%88%E7%9A%84N%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 优化篇之 延时队列 - 订单超时自动取消的N种实现方式">Java 优化篇之 延时队列 - 订单超时自动取消的N种实现方式</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E4%BC%98%E5%8C%96%E7%AF%87%E4%B9%8B%20%E6%B3%A8%E8%A7%A3%20+%20%E5%8F%8D%E5%B0%84%E6%B6%88%E9%99%A4%E9%87%8D%E5%A4%8D%E4%BB%A3%E7%A0%81/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 优化篇之 注解 + 反射消除重复代码">Java 优化篇之 注解 + 反射消除重复代码</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E9%9B%86%E5%90%88%E7%AF%87%E4%B9%8B%20%E8%8E%B7%E5%8F%96%E4%B8%A4%E4%B8%AA%E9%9B%86%E5%90%88List%E7%9A%84%E4%BA%A4%E9%9B%86%E3%80%81%E8%A1%A5%E9%9B%86%E3%80%81%E5%B9%B6%E9%9B%86%E3%80%81%E5%B7%AE%E9%9B%86%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 集合篇之 获取两个集合List的交集、补集、并集、差集的几种方式">Java 集合篇之 获取两个集合List的交集、补集、并集、差集的几种方式</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E4%BC%98%E5%8C%96%E7%AF%87%E4%B9%8B%20if-else%20%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 优化篇之 if-else 代码优化方案">Java 优化篇之 if-else 代码优化方案</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4%E5%90%84%E7%B1%BB%E5%9E%8B%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 日期时间各类型相互转换">Java 日期时间各类型相互转换</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E9%9B%86%E5%90%88%E7%AF%87%E4%B9%8B%20Lambda%20%E5%AE%9E%E7%8E%B0%E8%B6%85%E5%BC%BA%E6%8E%92%E5%BA%8F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 集合篇之 Lambda 实现超强排序">Java 集合篇之 Lambda 实现超强排序</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 动态代理">Java 动态代理</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E5%9F%BA%E6%9C%AC%E5%8A%9F%E7%AF%87%E4%B9%8B%20for%E3%80%81for-each%E3%80%81forEach()%20%E7%9A%84%20break%E3%80%81continue%E3%80%81return/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 基本功篇之 for、for-each、forEach() 的 break、continue、return">Java 基本功篇之 for、for-each、forEach() 的 break、continue、return</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6%E8%AF%A6%E8%A7%A3/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 日志框架详解">Java 日志框架详解</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java新特性 "
           href="/2023/08/28/1%E3%80%81JavaSE/3.Java%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%20%E6%96%B0%E7%89%B9%E6%80%A7%E6%A6%82%E8%BF%B0%E5%8F%8A%E7%89%88%E6%9C%AC%E5%8F%91%E8%A1%8C%E5%8F%B2/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 新特性概述及版本发行史">Java 新特性概述及版本发行史</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20Bean%20%E4%B9%8B%20Record%20%E7%B1%BB/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java Bean 之 Record 类">Java Bean 之 Record 类</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E4%BC%98%E5%8C%96%E7%AF%87%E4%B9%8B%20GZIP%E5%8E%8B%E7%BC%A9%E5%AD%97%E7%AC%A6%E4%B8%B2/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 优化篇之 GZIP压缩字符串">Java 优化篇之 GZIP压缩字符串</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java进阶篇 JVM虚拟机 "
           href="/2023/08/28/1%E3%80%81JavaSE/2.Java%20%E8%BF%9B%E9%98%B6%E7%AF%87/JVM%20%E8%99%9A%E6%8B%9F%E6%9C%BA/Java%20GC%20%E6%80%BB%E7%BB%93/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java GC 总结">Java GC 总结</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java新特性 Java9新特性 "
           href="/2023/08/28/1%E3%80%81JavaSE/3.Java%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%209%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%209%20%E6%96%B0%E7%89%B9%E6%80%A7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 9 新特性">Java 9 新特性</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java新特性 Java8新特性 "
           href="/2023/08/28/1%E3%80%81JavaSE/3.Java%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%208%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%208%20%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8B%20Stream%20%E6%B5%81/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 8 新特性之 Stream 流">Java 8 新特性之 Stream 流</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java新特性 Java8新特性 "
           href="/2023/08/28/1%E3%80%81JavaSE/3.Java%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%208%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%208%20%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8B%20Optional%20%E7%B1%BB/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 8 新特性之 Optional 类">Java 8 新特性之 Optional 类</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java新特性 Java8新特性 "
           href="/2023/08/28/1%E3%80%81JavaSE/3.Java%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%208%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%208%20%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8B%20DateTime%20API/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 8 新特性之 DateTime API">Java 8 新特性之 DateTime API</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java新特性 Java8新特性 "
           href="/2023/08/28/1%E3%80%81JavaSE/3.Java%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%208%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%208%20%E6%96%B0%E7%89%B9%E6%80%A7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 8 新特性">Java 8 新特性</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java新特性 Java18新特性 "
           href="/2023/08/28/1%E3%80%81JavaSE/3.Java%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2018%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2018%20%E6%96%B0%E7%89%B9%E6%80%A7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 18 新特性">Java 18 新特性</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java新特性 Java19新特性 "
           href="/2023/08/28/1%E3%80%81JavaSE/3.Java%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2019%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2019%20%E6%96%B0%E7%89%B9%E6%80%A7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 19 新特性">Java 19 新特性</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java新特性 Java20新特性 "
           href="/2023/08/28/1%E3%80%81JavaSE/3.Java%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2020%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2020%20%E6%96%B0%E7%89%B9%E6%80%A7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 20 新特性">Java 20 新特性</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java新特性 Java17新特性 "
           href="/2023/08/28/1%E3%80%81JavaSE/3.Java%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2017%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2017%20%E6%96%B0%E7%89%B9%E6%80%A7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 17 新特性">Java 17 新特性</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java新特性 Java16新特性 "
           href="/2023/08/28/1%E3%80%81JavaSE/3.Java%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2016%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2016%20%E6%96%B0%E7%89%B9%E6%80%A7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 16 新特性">Java 16 新特性</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java新特性 Java15新特性 "
           href="/2023/08/28/1%E3%80%81JavaSE/3.Java%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2015%E6%96%B0%E7%89%B9%E6%80%A7/Java%2015%20%E6%96%B0%E7%89%B9%E6%80%A7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 15 新特性">Java 15 新特性</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java新特性 Java13新特性 "
           href="/2023/08/28/1%E3%80%81JavaSE/3.Java%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2013%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2013%20%E6%96%B0%E7%89%B9%E6%80%A7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 13 新特性">Java 13 新特性</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java新特性 Java14新特性 "
           href="/2023/08/28/1%E3%80%81JavaSE/3.Java%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2014%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2014%20%E6%96%B0%E7%89%B9%E6%80%A7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 14 新特性">Java 14 新特性</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java新特性 Java10新特性 "
           href="/2023/08/28/1%E3%80%81JavaSE/3.Java%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2010%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2010%20%E6%96%B0%E7%89%B9%E6%80%A7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 10 新特性">Java 10 新特性</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java新特性 Java11新特性 "
           href="/2023/08/28/1%E3%80%81JavaSE/3.Java%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2011%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2011%20%E6%96%B0%E7%89%B9%E6%80%A7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 11 新特性">Java 11 新特性</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java新特性 Java12新特性 "
           href="/2023/08/28/1%E3%80%81JavaSE/3.Java%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2012%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2012%20%E6%96%B0%E7%89%B9%E6%80%A7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 12 新特性">Java 12 新特性</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java基础篇 Java基础语法 "
           href="/2023/08/28/1%E3%80%81JavaSE/1.Java%20%E5%9F%BA%E7%A1%80%E7%AF%87/1%E3%80%81Java%20%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/Java%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 面向对象编程">Java 面向对象编程</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java基础篇 Java集合类 "
           href="/2023/08/28/1%E3%80%81JavaSE/1.Java%20%E5%9F%BA%E7%A1%80%E7%AF%87/3%E3%80%81Java%20%E9%9B%86%E5%90%88%E7%B1%BB/Java%20%E7%B1%BB%E9%9B%86%E6%A1%86%E6%9E%B6/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 类集框架">Java 类集框架</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java基础篇 Java常用类库 "
           href="/2023/08/28/1%E3%80%81JavaSE/1.Java%20%E5%9F%BA%E7%A1%80%E7%AF%87/2%E3%80%81Java%20%E5%B8%B8%E7%94%A8%E7%B1%BB%E5%BA%93/Java%20%E5%B8%B8%E7%94%A8%E7%B1%BB%E5%BA%93/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 常用类库">Java 常用类库</span>
            <span class="post-date" title="2023-08-28 09:23:44">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java基础篇 Java多线程 "
           href="/2023/08/28/1%E3%80%81JavaSE/1.Java%20%E5%9F%BA%E7%A1%80%E7%AF%87/5%E3%80%81Java%20%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 多线程基础">Java 多线程基础</span>
            <span class="post-date" title="2023-08-28 09:23:44">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java基础篇 Java反射与注解 "
           href="/2023/08/28/1%E3%80%81JavaSE/1.Java%20%E5%9F%BA%E7%A1%80%E7%AF%87/4%E3%80%81Java%20%E5%8F%8D%E5%B0%84%E4%B8%8E%E6%B3%A8%E8%A7%A3/Java%20%E5%8F%8D%E5%B0%84%E4%B8%8E%E6%B3%A8%E8%A7%A3/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 反射与注解">Java 反射与注解</span>
            <span class="post-date" title="2023-08-28 09:23:44">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java基础篇 JavaNIO流 "
           href="/2023/08/28/1%E3%80%81JavaSE/1.Java%20%E5%9F%BA%E7%A1%80%E7%AF%87/7%E3%80%81Java%20NIO%20%E6%B5%81/Java%20NIO%20%E6%B5%81/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java NIO 流">Java NIO 流</span>
            <span class="post-date" title="2023-08-28 09:23:44">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java基础篇 JavaIO流 "
           href="/2023/08/28/1%E3%80%81JavaSE/1.Java%20%E5%9F%BA%E7%A1%80%E7%AF%87/6%E3%80%81Java%20IO%20%E6%B5%81/Java%20IO%20%E6%B5%81/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java IO 流">Java IO 流</span>
            <span class="post-date" title="2023-08-28 09:23:44">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java进阶篇 Java设计模式 "
           href="/2023/08/28/1%E3%80%81JavaSE/2.Java%20%E8%BF%9B%E9%98%B6%E7%AF%87/Java%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/Java%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 设计模式">Java 设计模式</span>
            <span class="post-date" title="2023-08-28 09:23:44">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java进阶篇 JVM虚拟机 "
           href="/2023/08/28/1%E3%80%81JavaSE/2.Java%20%E8%BF%9B%E9%98%B6%E7%AF%87/JVM%20%E8%99%9A%E6%8B%9F%E6%9C%BA/7%20%E6%AE%B5%E5%B0%8F%E4%BB%A3%E7%A0%81%EF%BC%8C%E7%8E%A9%E8%BD%ACJava%E7%A8%8B%E5%BA%8F%E5%B8%B8%E8%A7%81%E7%9A%84%E5%B4%A9%E6%BA%83%E5%9C%BA%E6%99%AF/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="7 段小代码，玩转Java程序常见的崩溃场景">7 段小代码，玩转Java程序常见的崩溃场景</span>
            <span class="post-date" title="2023-08-28 09:23:44">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java进阶篇 JVM虚拟机 "
           href="/2023/08/28/1%E3%80%81JavaSE/2.Java%20%E8%BF%9B%E9%98%B6%E7%AF%87/JVM%20%E8%99%9A%E6%8B%9F%E6%9C%BA/JVM%20%E8%99%9A%E6%8B%9F%E6%9C%BA/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="JVM 虚拟机">JVM 虚拟机</span>
            <span class="post-date" title="2023-08-28 09:23:44">2023/08/28</span>
        </a>
        
        <div id="no-item-tips">

        </div>
    </nav>
    <div id="outline-list">
    </div>
</div>

    </div>
    <div class="hide-list">
        <div class="semicircle" data-title="切换全屏 快捷键 s">
            <div class="brackets first"><</div>
            <div class="brackets">&gt;</div>
        </div>
    </div>
</aside>
<div id="post">
    <div class="pjax">
        <article id="post-2、JavaEE/3、微服务开发/Spring Transaction/Spring JDBC - JdbcTemplate" class="article article-type-post" itemscope itemprop="blogPost">
    
        <h1 class="article-title">Spring JDBC - JdbcTemplate</h1>
    
    <div class="article-meta">
        
        
        
        <span class="book">
            <i class="iconfont icon-category"></i>
            
            
            <a  data-rel="微服务开发">微服务开发</a> > 
            
            <a  data-rel="微服务开发&lt;---&gt;SpringTransaction">SpringTransaction</a>
            
        </span>
        
        
    </div>
    <div class="article-meta">
        
            发布时间 : <time class="date" title='最后更新: 2024-10-20 00:49:11'>2023-08-28 09:23</time>
        
    </div>
    <div class="article-meta">
        
        
        <span id="busuanzi_container_page_pv">
            阅读 :<span id="busuanzi_value_page_pv">
                <span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </span>
        </span>
        
        
    </div>
    
    <div class="toc-ref">
    
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81JdbcTemplate-%E7%B1%BB%E4%BB%8B%E7%BB%8D"><span class="toc-text">一、JdbcTemplate 类介绍</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81JdbcTemplate-%E6%96%B9%E6%B3%95%E4%BD%BF%E7%94%A8%E6%A6%82%E8%BF%B0"><span class="toc-text">二、JdbcTemplate 方法使用概述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81execute-%E7%B3%BB%E5%88%97"><span class="toc-text">1、execute 系列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81execute-final-String-sql"><span class="toc-text">1、execute(final String sql)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81execute-StatementCallback-T-action"><span class="toc-text">2、execute(StatementCallback&lt; T &gt; action)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81execute-ConnectionCallback-T-action"><span class="toc-text">3、execute(ConnectionCallback&lt; T &gt; action)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81execute-String-sql-PreparedStatementCallback-T-action"><span class="toc-text">4、execute(String sql, PreparedStatementCallback&lt; T &gt; action)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81execute-PreparedStatementCreator-psc-PreparedStatementCallback-T-action"><span class="toc-text">5、execute(PreparedStatementCreator psc, PreparedStatementCallback&lt; T &gt; action)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81execute-String-callString-CallableStatementCallback-T-action"><span class="toc-text">6、execute(String callString, CallableStatementCallback&lt; T &gt; action)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%E3%80%81execute-CallableStatementCreator-csc-CallableStatementCallback-T-action"><span class="toc-text">7、execute(CallableStatementCreator csc, CallableStatementCallback&lt; T &gt; action)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81update-%E7%B3%BB%E5%88%97"><span class="toc-text">2、update 系列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81update-final-String-sql"><span class="toc-text">1、update(final String sql)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81update-String-sql-Nullable-Object%E2%80%A6-args"><span class="toc-text">2、update(String sql, @Nullable Object… args)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81update-String-sql-Object-args-int-argTypes"><span class="toc-text">3、update(String sql, Object[] args, int[] argTypes)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81update-String-sql-Nullable-PreparedStatementSetter-pss"><span class="toc-text">4、update(String sql, @Nullable PreparedStatementSetter pss)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81update-PreparedStatementCreator-psc"><span class="toc-text">5、update(PreparedStatementCreator psc)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81update-final-PreparedStatementCreator-psc-final-KeyHolder-generatedKeyHolder"><span class="toc-text">6、update(final PreparedStatementCreator psc, final KeyHolder generatedKeyHolder)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81batchUpdate-%E7%B3%BB%E5%88%97"><span class="toc-text">3、batchUpdate 系列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81batchUpdate-final-String%E2%80%A6-sql"><span class="toc-text">1、batchUpdate(final String… sql)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81batchUpdate-String-sql-List-batchArgs"><span class="toc-text">2、batchUpdate(String sql, List&lt;Object[]&gt; batchArgs)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81batchUpdate-String-sql-List-batchArgs-final-int-argTypes"><span class="toc-text">3、batchUpdate(String sql, List&lt;Object[]&gt; batchArgs, final int[] argTypes)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81batchUpdate-String-sql-final-BatchPreparedStatementSetter-pss"><span class="toc-text">4、batchUpdate(String sql, final BatchPreparedStatementSetter pss)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81batchUpdate-String-sql-final-Collection-T-batchArgs-final-int-batchSize-final-ParameterizedPreparedStatementSetter-T-pss"><span class="toc-text">5、batchUpdate(String sql, final Collection&lt; T &gt; batchArgs, final int batchSize, final ParameterizedPreparedStatementSetter&lt; T &gt; pss)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81%E6%89%B9%E9%87%8F%E6%8F%92%E5%85%A5%E5%B9%B6%E8%BF%94%E5%9B%9E%E4%B8%BB%E9%94%AE-ID"><span class="toc-text">6、批量插入并返回主键 ID</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81call-%E7%B3%BB%E5%88%97"><span class="toc-text">4、call 系列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81call-CallableStatementCreator-csc-List-SqlParameter-declaredParameters"><span class="toc-text">1、call(CallableStatementCreator csc, List&lt; SqlParameter &gt; declaredParameters)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81queryForObject-%E7%B3%BB%E5%88%97"><span class="toc-text">5、queryForObject 系列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81queryForObject-String-sql-RowMapper-T-rowMapper"><span class="toc-text">1、queryForObject(String sql, RowMapper&lt; T &gt; rowMapper)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81queryForObject-String-sql-RowMapper-T-rowMapper-Nullable-Object%E2%80%A6-args"><span class="toc-text">2、queryForObject(String sql, RowMapper&lt; T &gt; rowMapper, @Nullable Object… args)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81queryForObject-String-sql-Object-args-int-argTypes-RowMapper-T-rowMapper"><span class="toc-text">3、queryForObject(String sql, Object[] args, int[] argTypes, RowMapper&lt; T &gt; rowMapper)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81queryForObject-String-sql-Class-T-requiredType"><span class="toc-text">4、queryForObject(String sql, Class&lt; T &gt; requiredType)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81queryForObject-String-sql-Class-T-requiredType-Nullable-Object%E2%80%A6-args"><span class="toc-text">5、queryForObject(String sql, Class&lt; T &gt; requiredType, @Nullable Object… args)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81queryForObject-String-sql-Object-args-int-argTypes-Class-T-requiredType"><span class="toc-text">6、queryForObject(String sql, Object[] args, int[] argTypes, Class&lt; T &gt; requiredType)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81queryForMap-%E7%B3%BB%E5%88%97"><span class="toc-text">6、queryForMap 系列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81queryForMap-String-sql"><span class="toc-text">1、queryForMap(String sql)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81queryForMap-String-sql-Nullable-Object%E2%80%A6-args"><span class="toc-text">2、queryForMap(String sql, @Nullable Object… args)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81queryForMap-String-sql-Object-args-int-argTypes"><span class="toc-text">3、queryForMap(String sql, Object[] args, int[] argTypes)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E3%80%81queryForRowSet-%E7%B3%BB%E5%88%97"><span class="toc-text">7、queryForRowSet 系列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81queryForRowSet-String-sql"><span class="toc-text">1、queryForRowSet(String sql)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81queryForRowSet-String-sql-Nullable-Object%E2%80%A6-args"><span class="toc-text">2、queryForRowSet(String sql, @Nullable Object… args)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81queryForRowSet-String-sql-Object-args-int-argTypes"><span class="toc-text">3、queryForRowSet(String sql, Object[] args, int[] argTypes)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8%E3%80%81queryForList-%E7%B3%BB%E5%88%97"><span class="toc-text">8、queryForList 系列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81queryForList-String-sql"><span class="toc-text">1、queryForList(String sql)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81queryForList-String-sql-Nullable-Object%E2%80%A6-args"><span class="toc-text">2、queryForList(String sql, @Nullable Object… args)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81queryForList-String-sql-Object-args-int-argTypes"><span class="toc-text">3、queryForList(String sql, Object[] args, int[] argTypes)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81queryForList-String-sql-Class-T-elementType"><span class="toc-text">4、queryForList(String sql, Class&lt; T &gt; elementType)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81queryForList-String-sql-Class-T-elementType-Nullable-Object%E2%80%A6-args"><span class="toc-text">5、queryForList(String sql, Class&lt; T &gt; elementType, @Nullable Object… args)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81queryForList-String-sql-Object-args-int-argTypes-Class-T-elementType"><span class="toc-text">6、queryForList(String sql, Object[] args, int[] argTypes, Class&lt; T &gt; elementType)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9%E3%80%81query-%E7%B3%BB%E5%88%97"><span class="toc-text">9、query 系列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81query-String-sql-RowCallbackHandler-rch"><span class="toc-text">1、query(String sql, RowCallbackHandler rch)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81query-String-sql-RowCallbackHandler-rch-Nullable-Object%E2%80%A6-args"><span class="toc-text">2、query(String sql, RowCallbackHandler rch, @Nullable Object… args)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81query-String-sql-Object-args-int-argTypes-RowCallbackHandler-rch"><span class="toc-text">3、query(String sql, Object[] args, int[] argTypes, RowCallbackHandler rch)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81query-String-sql-Nullable-PreparedStatementSetter-pss-RowCallbackHandler-rch"><span class="toc-text">4、query(String sql, @Nullable PreparedStatementSetter pss, RowCallbackHandler rch)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81query-PreparedStatementCreator-psc-RowCallbackHandler-rch"><span class="toc-text">5、query(PreparedStatementCreator psc, RowCallbackHandler rch)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81query-String-sql-ResultSetExtractor-rse"><span class="toc-text">6、query(String sql, ResultSetExtractor rse)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%E3%80%81query-String-sql-ResultSetExtractor-rse-Nullable-Object%E2%80%A6-args"><span class="toc-text">7、query(String sql, ResultSetExtractor rse, @Nullable Object… args)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8%E3%80%81query-String-sql-Object-args-int-argTypes-ResultSetExtractor-rse"><span class="toc-text">8、query(String sql, Object[] args, int[] argTypes, ResultSetExtractor rse)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9%E3%80%81query-String-sql-Nullable-PreparedStatementSetter-pss-ResultSetExtractor-T-rse"><span class="toc-text">9、query(String sql, @Nullable PreparedStatementSetter pss, ResultSetExtractor&lt; T &gt; rse)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10%E3%80%81query-PreparedStatementCreator-psc-Nullable-final-PreparedStatementSetter-pss-final-ResultSetExtractor-T-rse"><span class="toc-text">10、query(PreparedStatementCreator psc, @Nullable final PreparedStatementSetter pss, final ResultSetExtractor&lt; T &gt; rse)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11%E3%80%81query-PreparedStatementCreator-psc-final-ResultSetExtractor-T-rse"><span class="toc-text">11、query(PreparedStatementCreator psc, final ResultSetExtractor&lt; T &gt; rse)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12%E3%80%81query-String-sql-RowMapper-T-rowMapper"><span class="toc-text">12、query(String sql, RowMapper&lt; T &gt; rowMapper)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13%E3%80%81query-String-sql-RowMapper-T-rowMapper-Nullable-Object%E2%80%A6-args"><span class="toc-text">13、query(String sql, RowMapper&lt; T &gt; rowMapper, @Nullable Object… args)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14%E3%80%81query-String-sql-Object-args-int-argTypes-RowMapper-T-rowMapper"><span class="toc-text">14、query(String sql, Object[] args, int[] argTypes, RowMapper&lt; T &gt; rowMapper</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15%E3%80%81query-String-sql-Nullable-PreparedStatementSetter-pss-RowMapper-T-rowMapper"><span class="toc-text">15、query(String sql, @Nullable PreparedStatementSetter pss, RowMapper&lt; T &gt; rowMapper)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16%E3%80%81query-PreparedStatementCreator-psc-RowMapper-T-rowMapper"><span class="toc-text">16、query(PreparedStatementCreator psc, RowMapper&lt; T &gt; rowMapper)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81Junit-%E6%B5%8B%E8%AF%95-ResultSetExtractor-RowMapper"><span class="toc-text">三、Junit 测试 ResultSetExtractor&#x2F;RowMapper</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81RowMapper-Mockito-%E6%B5%8B%E8%AF%95"><span class="toc-text">1、RowMapper Mockito 测试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81ResultSetExtractor-Mockito-%E6%B5%8B%E8%AF%95"><span class="toc-text">2、ResultSetExtractor Mockito 测试</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E3%80%81Spring-JDBC-%E5%85%B6%E4%BB%96%E5%AF%B9%E8%B1%A1"><span class="toc-text">四、Spring JDBC 其他对象</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81NamedParameterJdbcTemplate"><span class="toc-text">1、NamedParameterJdbcTemplate</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81SimpleJdbcInsert"><span class="toc-text">2、SimpleJdbcInsert</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81SqlQuery"><span class="toc-text">3、SqlQuery</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81SqlUpdate"><span class="toc-text">4、SqlUpdate</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81SimpleJdbcCall"><span class="toc-text">5、SimpleJdbcCall</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81%E6%80%BB%E7%BB%93%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E8%BF%99%E4%BA%9B%E7%B1%BB%EF%BC%9F"><span class="toc-text">6、总结：为什么需要这些类？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94%E3%80%81JdbcTemplate-%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE-%E9%B8%A3%E8%B0%A2"><span class="toc-text">五、JdbcTemplate 参考文献 &amp; 鸣谢</span></a></li></ol>
    
<style>
    .left-col .switch-btn,
    .left-col .switch-area {
        display: none;
    }
    .toc-level-3 i,
    .toc-level-3 ol {
        display: none !important;
    }
</style>
</div>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="一、JdbcTemplate-类介绍"><a href="#一、JdbcTemplate-类介绍" class="headerlink" title="一、JdbcTemplate 类介绍"></a>一、JdbcTemplate 类介绍</h1><p>Spring 对数据库的操作在 JDBC 上面做了深层次的封装，使用 Spring 的注入功能，可以把 DataSource 注册到 JdbcTemplate 中。</p>
<p>JdbcTemplate 是 Spring 框架中提供的一个对象，是对原始繁琐的 Jdbc API 对象的简单封装。Spring 框架为我们提供了很多的操作模板类。例如：操作关系型数据的 JdbcTemplate 和 HibernateTemplate，操作 NoSQL 数据库的 RedisTemplate，操作消息队列的JmsTemplate等等。</p>
<p>JdbcTemplate 位于 spring-jdbc-x.x.x.jar 中，其全限定命名为 org.springframework.jdbc.core.JdbcTemplate。要使用 JdbcTemplate 还需要一个  spring-tx-x.x.x.jar 包，这个包含了事务和异常控制。</p>
<ul>
<li>spring-jdbc-x.x.x.jar</li>
<li>spring-tx-x.x.x.jar</li>
<li>spring-core-x.x.x.jar</li>
<li>spring-beans-x.x.x.jar</li>
</ul>
<blockquote>
<p>环境搭建：</p>
</blockquote>
<ul>
<li>需要导入Spring的 tx 和 jdbc 模块</li>
<li>需要相关数据库的驱动</li>
<li>数据库连接池（仅就本文非必需）</li>
<li>需要有相应的数据库进行操作</li>
</ul>
<p>1、导入依赖</p>
<pre><code class="xml">&lt;properties&gt;
    &lt;maven.compiler.source&gt;11&lt;/maven.compiler.source&gt;
    &lt;maven.compiler.target&gt;11&lt;/maven.compiler.target&gt;
    &lt;spring-version&gt;5.3.29&lt;/spring-version&gt;
    &lt;mysql-connector-version&gt;5.1.49&lt;/mysql-connector-version&gt;
&lt;/properties&gt;

&lt;dependencies&gt;
    &lt;!-- Spring的 context 和 jdbc 模块 --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
        &lt;version&gt;$&#123;spring-version&#125;&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;
        &lt;version&gt;$&#123;spring-version&#125;&lt;/version&gt;
    &lt;/dependency&gt;

    &lt;!-- H2数据库驱动 --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;com.h2database&lt;/groupId&gt;
        &lt;artifactId&gt;h2&lt;/artifactId&gt;
        &lt;version&gt;2.2.220&lt;/version&gt;
    &lt;/dependency&gt;

    &lt;!-- Mysql数据库驱动 --&gt;
    &lt;!--        &lt;dependency&gt;--&gt;
    &lt;!--            &lt;groupId&gt;mysql&lt;/groupId&gt;--&gt;
    &lt;!--            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;--&gt;
    &lt;!--            &lt;version&gt;$&#123;mysql-connector-version&#125;&lt;/version&gt;--&gt;
    &lt;!--        &lt;/dependency&gt;--&gt;
    &lt;!-- 阿里的德鲁伊连接池 --&gt;
    &lt;!--        &lt;dependency&gt;--&gt;
    &lt;!--            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;--&gt;
    &lt;!--            &lt;artifactId&gt;druid&lt;/artifactId&gt;--&gt;
    &lt;!--            &lt;version&gt;$&#123;druid-version&#125;&lt;/version&gt;--&gt;
    &lt;!--        &lt;/dependency&gt;--&gt;
&lt;/dependencies&gt;
&lt;repositories&gt;
    &lt;repository&gt;
        &lt;id&gt;nexus-aliyun&lt;/id&gt;
        &lt;name&gt;nexus-aliyun&lt;/name&gt;
        &lt;url&gt;https://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt;
        &lt;releases&gt;
            &lt;enabled&gt;true&lt;/enabled&gt;
        &lt;/releases&gt;
        &lt;snapshots&gt;
            &lt;enabled&gt;false&lt;/enabled&gt;
        &lt;/snapshots&gt;
    &lt;/repository&gt;
&lt;/repositories&gt;
</code></pre>
<p>2、简单使用</p>
<pre><code class="java">import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.datasource.DriverManagerDataSource;

public class Main &#123;
    public static void main(String[] args) &#123;
        // 获取数据源, 这里使用H数据库, 不知道为什么使用mem内存模式一直报错, 所以使用file文件模式
        DriverManagerDataSource dataSource = new DriverManagerDataSource();
        dataSource.setDriverClassName(&quot;org.h2.Driver&quot;); // 驱动
        dataSource.setUrl(&quot;jdbc:h2:file:~/test;;DATABASE_TO_UPPER=false&quot;); // 数据库连接
        dataSource.setUsername(&quot;sa&quot;); // 用户
        dataSource.setPassword(&quot;&quot;); // 密码
        // 如果要使用其他数据源只需要修改上面部分, 然后把dataSource注入JdbcTemplate即可

        // 获取 JdbcTemplate
        JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource);

        // 先初始化表和初始化数据
        jdbcTemplate.execute(&quot;drop table if exists user_info&quot;);
        jdbcTemplate.execute(&quot;create table user_info(user_id int primary key, user_name varchar(255))&quot;);
        jdbcTemplate.update(&quot;insert into user_info values(1, &#39;Java&#39;)&quot;);
        jdbcTemplate.update(&quot;insert into user_info values(2, &#39;Python&#39;)&quot;);
        jdbcTemplate.update(&quot;insert into user_info values(3, &#39;JavaScript&#39;)&quot;);

        // 查询数据
        System.out.println(jdbcTemplate.queryForList(&quot;select * from user_info&quot;));
    &#125;
&#125;
</code></pre>
<pre><code class="、">[&#123;user_id=1, user_name=Java&#125;, &#123;user_id=2, user_name=Python&#125;, &#123;user_id=3, user_name=JavaScript&#125;]
</code></pre>
<p>3、配置文件定义，将数据源连接池以及 jdbcTemplate 改为配置文件定义。或者直接@Bean定义也行。</p>
<pre><code class="xml">&lt;!-- 德鲁伊连接池 --&gt;
&lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt;
    &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt;
    &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/test?serverTimezone=Asia/Shanghai&quot;/&gt;
    &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;
    &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt;
&lt;/bean&gt;

&lt;!-- jdbcTemplate --&gt;
&lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;
    &lt;!-- 设置数据源 --&gt;
    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<h1 id="二、JdbcTemplate-方法使用概述"><a href="#二、JdbcTemplate-方法使用概述" class="headerlink" title="二、JdbcTemplate 方法使用概述"></a>二、JdbcTemplate 方法使用概述</h1><p>JdbcTemplate 主要提供以下五类或四类方法：</p>
<ul>
<li><p>execute 方法：可以用于执行任何SQL语句，一般用于执行DDL语句；</p>
</li>
<li><p>update 方法及 batchUpdate 方法：用于执行新增、修改、删除等DML语句；batchUpdate 方法用于执行批量处理相关语句。</p>
</li>
<li><p>query 方法及 queryForXXX 方法：用于执行查询相关DQL语句；</p>
</li>
<li><p>call 方法：用于执行存储过程、函数相关语句。</p>
</li>
</ul>
<p>注意：所有执行查询的语句，都要注意查询结果为空的情况，有些方法对于空的查询结果会报异常。</p>
<p>其中主要三类操作如下：</p>
<ul>
<li>execute：可以执行所有SQL语句，一般用于执行DDL语句。</li>
<li>update：用于执行INSERT、UPDATE、DELETE等DML语句。</li>
<li>queryXxx：用于DQL数据查询语句。</li>
</ul>
<p>query 方法及 queryForXXX 方法 重点概述：</p>
<ul>
<li>queryForObject：查询结果，将结果封装为对象，一般用于聚合函数的查询。一般用户单行单列或单行多列</li>
<li>queryForMap()：查询结果将结果集封装为map集合，列名作为key，值作为value。 该方法只能查一行数据。一般用于单行多列</li>
<li>queryForList()：查询结果将结果集封装为list集合。注意：每一条记录为一个Map集合，再将Map集合装载到List集合中。一般用于多行多列。</li>
<li>queryForRowSet：查询结果将结果集封装为SqlRowSet对象，该对象是一个集合，可以理解为ResultSet对象，一般用于多行多列。</li>
<li>queryForStream：查询结果将结果集封装为Stream对象，该对象可以转换成绩集合也可以是单个对象。一般用于多行多列。</li>
<li>query()：查询结果，将结果封装为JavaBean对象。<ol>
<li>query 的参数：RowCallbackHandler，这个回调方式，一条记录回调一次，不返回结果。</li>
<li>query 的参数：ResultSetExtractor，这个回调方式，接收的是批量的结果，一次对所有的结果进行转换。返回类型为泛型ResultSetExtractor&lt; T &gt;，T 可以是单个JavaBean也可以是一个List。</li>
<li>query 的参数：RowMapper，一般我们使用BeanPropertyRowMapper实现类。可以完成数据到JavaBean的自动封装new BeanPropertyRowMapper&lt;类型&gt;(类型.class)。RowMapper 返回结果是List。</li>
</ol>
</li>
</ul>
<p>JdbcTemplate 类支持的回调类：</p>
<ul>
<li>预编译语句及存储过程创建回调：用于根据JdbcTemplate提供的连接创建相应的语句；<ul>
<li>PreparedStatementCreator：通过回调获取JdbcTemplate提供的Connection，由用户使用该Conncetion创建相关的PreparedStatement；</li>
<li>CallableStatementCreator：通过回调获取JdbcTemplate提供的Connection，由用户使用该Conncetion创建相关的CallableStatement；</li>
</ul>
</li>
<li>预编译语句设值回调：用于给预编译语句相应参数设值；<ul>
<li>PreparedStatementSetter：通过回调获取JdbcTemplate提供的PreparedStatement，由用户来对相应的预编译语句相应参数设值；</li>
<li>BatchPreparedStatementSetter：类似于PreparedStatementSetter，但用于批处理，需要指定批处理大小；</li>
</ul>
</li>
<li>自定义功能回调：提供给用户一个扩展点，用户可以在指定类型的扩展点执行任何数量需要的操作；<ul>
<li>StatementCallback：通过回调获取JdbcTemplate提供的Statement，用户可以在该Statement执行任何数量的操作；</li>
<li>PreparedStatementCallback：通过回调获取JdbcTemplate提供的PreparedStatement，用户可以在该PreparedStatement执行任何数量的操作；</li>
<li>CallableStatementCallback：通过回调获取JdbcTemplate提供的CallableStatement，用户可以在该CallableStatement执行任何数量的操作；</li>
</ul>
</li>
<li>结果集处理回调：通过回调处理ResultSet或将ResultSet转换为需要的形式；<ul>
<li>RowMapper：用于将结果集每行数据转换为需要的类型，用户需实现方法mapRow(ResultSet rs, int rowNum)来完成将每行数据转换为相应的类型。</li>
<li>RowCallbackHandler：用于处理ResultSet的每一行结果，用户需实现方法processRow(ResultSet rs)来完成处理，在该回调方法中无需执行rs.next()，该操作由JdbcTemplate来执行，用户只需按行获取数据然后处理即可。</li>
<li>ResultSetExtractor：用于结果集数据提取，用户需实现方法extractData(ResultSet rs)来处理结果集，用户必须处理整个结果集；</li>
</ul>
</li>
</ul>
<h2 id="1、execute-系列"><a href="#1、execute-系列" class="headerlink" title="1、execute 系列"></a>1、execute 系列</h2><h3 id="1、execute-final-String-sql"><a href="#1、execute-final-String-sql" class="headerlink" title="1、execute(final String sql)"></a>1、execute(final String sql)</h3><pre><code class="java">public void execute(final String sql) throws DataAccessException &#123;&#125;
</code></pre>
<p>该方法可以执行任意SQL，参数是一个SQL，没有返回值。</p>
<pre><code class="java">@Autowired
JdbcTemplate jdbcTemplate;

@PostConstruct
public void execute1() &#123;
    jdbcTemplate.execute(&quot;drop table if exists user_info&quot;); // 删除表
    jdbcTemplate.execute(&quot;create table user_info(user_id int primary key, user_name varchar(255))&quot;); // 创建表
    jdbcTemplate.execute(&quot;insert into user_info values(1, &#39;Java&#39;)&quot;); // 插入数据
    jdbcTemplate.execute(&quot;update user_info set user_name = &#39;Python&#39; where user_id = 1&quot;); // 更新数据
    jdbcTemplate.execute(&quot;delete from user_info where user_id = 1&quot;); // 删除数据
    jdbcTemplate.execute(&quot;truncate table user_info&quot;); // 清空表数据
    jdbcTemplate.execute(&quot;begin add_data_to_account; end;&quot;); // 执行存储过程
&#125;
</code></pre>
<h3 id="2、execute-StatementCallback-T-action"><a href="#2、execute-StatementCallback-T-action" class="headerlink" title="2、execute(StatementCallback&lt; T &gt; action)"></a>2、execute(StatementCallback&lt; T &gt; action)</h3><pre><code class="JAVA">public &lt;T&gt; T execute(StatementCallback&lt;T&gt; action) throws DataAccessException &#123;&#125;
</code></pre>
<p>此方法是传入一个 StatementCallback 对象。StatementCallback 接口只有一个方法。</p>
<pre><code class="java">@FunctionalInterface
public interface StatementCallback&lt;T&gt; &#123;
    @Nullable
    T doInStatement(Statement stmt) throws SQLException, DataAccessException;
&#125;
</code></pre>
<p>通过回调获取 JdbcTemplate 提供的 Statement，用户可以在该 Statement 进行 SQL 操作。</p>
<p>其实 execute(final String sql) 该方法就是调用 execute(StatementCallback&lt; T&gt; action) 这个方法实现的。可以执行任意 SQL。</p>
<pre><code class="java">@Autowired
JdbcTemplate jdbcTemplate;

@PostConstruct
public void execute2() &#123;
    // 删除表、创建表、新增数据
    Integer num = jdbcTemplate.execute(new StatementCallback&lt;Integer&gt;() &#123;
        @Override
        public Integer doInStatement(Statement st) throws SQLException, DataAccessException &#123;
            st.execute(&quot;drop table if exists user_info&quot;); // 删除表
            st.execute(&quot;create table user_info(user_id int primary key, user_name varchar(255))&quot;); // 创建表
            return st.executeUpdate(&quot;insert into user_info values(1, &#39;Java&#39;)&quot;); // 插入数据
        &#125;
    &#125;);
    System.out.println(&quot;插入数据: &quot; + num + &quot; 条&quot;);

    // 更新数据、删除数据。采用Lambda表达式
    num = jdbcTemplate.execute((StatementCallback&lt;Integer&gt;) st -&gt; &#123;
        // 更新数据
        int numByUpdate = st.executeUpdate(&quot;update user_info set user_name = &#39;Python&#39; where user_id = 1&quot;);
        System.out.println(&quot;更新数据: &quot; + numByUpdate + &quot; 条&quot;);
        return st.executeUpdate(&quot;delete from user_info where user_id = 1&quot;); // 删除数据
    &#125;);
    System.out.println(&quot;删除数据: &quot; + num + &quot; 条&quot;);
&#125;
</code></pre>
<pre><code>插入数据: 1 条
更新数据: 1 条
删除数据: 1 条
</code></pre>
<p>实际上一些 query()、update()、batchUpdate() 内部都是调用这个方法。</p>
<h3 id="3、execute-ConnectionCallback-T-action"><a href="#3、execute-ConnectionCallback-T-action" class="headerlink" title="3、execute(ConnectionCallback&lt; T &gt; action)"></a>3、execute(ConnectionCallback&lt; T &gt; action)</h3><pre><code class="java">public &lt;T&gt; T execute(ConnectionCallback&lt;T&gt; action) throws DataAccessException &#123;&#125;
</code></pre>
<p>通过回调获取 JdbcTemplate 提供的 Connection，用户可在该 Connection 执行一些操作。例如：</p>
<pre><code class="java">@Autowired
JdbcTemplate jdbcTemplate;

@PostConstruct
public void execute3() &#123;
    // 删除表、创建表、新增数据
    Integer num = jdbcTemplate.execute(new ConnectionCallback&lt;Integer&gt;() &#123;
        @Override
        public Integer doInConnection(Connection con) throws SQLException, DataAccessException &#123;
            Statement st = con.createStatement();
            st.execute(&quot;drop table if exists user_info&quot;); // 删除表
            st.execute(&quot;create table user_info(user_id int primary key, user_name varchar(255))&quot;); // 创建表
            return st.executeUpdate(&quot;insert into user_info values(1, &#39;Java&#39;)&quot;); // 插入数据
        &#125;
    &#125;);
    System.out.println(&quot;插入数据: &quot; + num + &quot; 条&quot;);

    // 更新数据、删除数据。采用Lambda表达式
    num = jdbcTemplate.execute((ConnectionCallback&lt;Integer&gt;) con -&gt; &#123;
        Statement st = con.createStatement();
        // 更新数据
        int numByUpdate = st.executeUpdate(&quot;update user_info set user_name = &#39;Python&#39; where user_id = 1&quot;);
        System.out.println(&quot;更新数据: &quot; + numByUpdate + &quot; 条&quot;);
        return st.executeUpdate(&quot;delete from user_info where user_id = 1&quot;); // 删除数据
    &#125;);
    System.out.println(&quot;删除数据: &quot; + num + &quot; 条&quot;);
&#125;
</code></pre>
<pre><code>插入数据: 1 条
更新数据: 1 条
删除数据: 1 条
</code></pre>
<h3 id="4、execute-String-sql-PreparedStatementCallback-T-action"><a href="#4、execute-String-sql-PreparedStatementCallback-T-action" class="headerlink" title="4、execute(String sql, PreparedStatementCallback&lt; T &gt; action)"></a>4、execute(String sql, PreparedStatementCallback&lt; T &gt; action)</h3><pre><code class="java">public &lt;T&gt; T execute(String sql, PreparedStatementCallback&lt;T&gt; action) throws DataAccessException &#123;&#125;
</code></pre>
<p>由传入的 SQL 生成一个预编译语句，PreparedStatementCallback 回调传回，由用户决定如何执行该 PreparedStatement。</p>
<pre><code class="java">@Override
@Nullable
public &lt;T&gt; T execute(String sql, PreparedStatementCallback&lt;T&gt; action) throws DataAccessException &#123;
    return execute(new SimplePreparedStatementCreator(sql), action);
&#125;
</code></pre>
<p>execute(String sql, PreparedStatementCallback&lt; T &gt; action) 与 execute(PreparedStatementCreator psc, PreparedStatementCallback&lt; T &gt; action) 内部都是调用同一个方法。</p>
<p>操作示例：</p>
<pre><code class="java">@Autowired
JdbcTemplate jdbcTemplate;

@PostConstruct
public void execute4() &#123;
    // 先初始化表
    jdbcTemplate.execute(&quot;drop table if exists user_info&quot;); // 删除表
    jdbcTemplate.execute(&quot;create table user_info(user_id int primary key, user_name varchar(255))&quot;); // 创建表

    // 插入数据
    String insertSql = &quot;insert into user_info values(?, ?)&quot;;
    Integer num = jdbcTemplate.execute(insertSql, new PreparedStatementCallback&lt;Integer&gt;() &#123;
        @Override
        public Integer doInPreparedStatement(PreparedStatement ps)
            throws SQLException, DataAccessException &#123;
            ps.setInt(1, 1);
            ps.setString(2, &quot;Java&quot;);
            return ps.executeUpdate();
        &#125;
    &#125;);
    System.out.println(&quot;插入数据: &quot; + num + &quot; 条&quot;);

    // 查询数据, 采用Lambda表达式。返回对象为自定义的JavaBean
    String querySql = &quot;select * from user_info where user_id = ?&quot;;
    UserInfo userInfo = jdbcTemplate.execute(querySql, (PreparedStatementCallback&lt;UserInfo&gt;) ps -&gt; &#123;
        ps.setInt(1, 1);
        ResultSet rs = ps.executeQuery();
        rs.next();
        return new UserInfo(rs.getInt(1), rs.getString(2));
    &#125;);
    System.out.println(userInfo);
&#125;

@Data
@NoArgsConstructor
@AllArgsConstructor
public static class UserInfo &#123;
    private int userId;
    private String userName;
&#125;
</code></pre>
<pre><code>插入数据: 1 条
UserInfo(userId=1, userName=Java)
</code></pre>
<h3 id="5、execute-PreparedStatementCreator-psc-PreparedStatementCallback-T-action"><a href="#5、execute-PreparedStatementCreator-psc-PreparedStatementCallback-T-action" class="headerlink" title="5、execute(PreparedStatementCreator psc, PreparedStatementCallback&lt; T &gt; action)"></a>5、execute(PreparedStatementCreator psc, PreparedStatementCallback&lt; T &gt; action)</h3><pre><code class="java">public &lt;T&gt; T execute(PreparedStatementCreator psc, PreparedStatementCallback&lt;T&gt; action) throws DataAccessException &#123;&#125;
</code></pre>
<p>第一个参数是创建一个预编译语句，第二个是预编译的回调函数。由用户决定如何创建如何 PreparedStatementCreator，以及如何执行该 PreparedStatement。</p>
<pre><code class="java">@Override
@Nullable
public &lt;T&gt; T execute(String sql, PreparedStatementCallback&lt;T&gt; action) throws DataAccessException &#123;
    return execute(new SimplePreparedStatementCreator(sql), action);
&#125;
</code></pre>
<p>execute(String sql, PreparedStatementCallback&lt; T &gt; action) 与 execute(PreparedStatementCreator psc, PreparedStatementCallback&lt; T &gt; action) 内部都是调用同一个方法。</p>
<p>操作示例：</p>
<pre><code class="java">@Autowired
JdbcTemplate jdbcTemplate;

@PostConstruct
public void execute5() &#123;
    // 先初始化表
    jdbcTemplate.execute(&quot;drop table if exists user_info&quot;); // 删除表
    jdbcTemplate.execute(&quot;create table user_info(user_id int primary key, user_name varchar(255))&quot;); // 创建表

    // 插入数据
    Integer num = jdbcTemplate.execute(new PreparedStatementCreator()&#123;
        @Override
        public PreparedStatement createPreparedStatement(Connection con) throws SQLException &#123;
            return con.prepareStatement(&quot;insert into user_info values(?, ?)&quot;);
        &#125;
    &#125;, new PreparedStatementCallback&lt;Integer&gt;() &#123;
        @Override
        public Integer doInPreparedStatement(PreparedStatement ps)
                throws SQLException, DataAccessException &#123;
            ps.setInt(1, 1);
            ps.setString(2, &quot;Java&quot;);
            return ps.executeUpdate();
        &#125;
    &#125;);
    System.out.println(&quot;插入数据: &quot; + num + &quot; 条&quot;);

    // 查询数据, 采用Lambda表达式。返回对象为自定义的JavaBean
    String querySql = &quot;select * from user_info where user_id = ?&quot;;
    UserInfo userInfo = jdbcTemplate.execute(con -&gt; con.prepareStatement(querySql),
            (PreparedStatementCallback&lt;UserInfo&gt;) ps -&gt; &#123;
                ps.setInt(1, 1);
                ResultSet rs = ps.executeQuery();
                rs.next();
                return new UserInfo(rs.getInt(1), rs.getString(2));
            &#125;);
    System.out.println(userInfo);
&#125;

@Data
@NoArgsConstructor
@AllArgsConstructor
public static class UserInfo &#123;
    private int userId;
    private String userName;
&#125;
</code></pre>
<pre><code>插入数据: 1 条
UserInfo(userId=1, userName=Java)
</code></pre>
<h3 id="6、execute-String-callString-CallableStatementCallback-T-action"><a href="#6、execute-String-callString-CallableStatementCallback-T-action" class="headerlink" title="6、execute(String callString, CallableStatementCallback&lt; T &gt; action)"></a>6、execute(String callString, CallableStatementCallback&lt; T &gt; action)</h3><pre><code class="java">public &lt;T&gt; T execute(String callString, CallableStatementCallback&lt;T&gt; action) throws DataAccessException &#123;&#125;
</code></pre>
<p>此方法主要是处理存储过程和函数使用。由传入的 SQL 生成一个预编译语句，CallableStatementCallback 回调传回，由用户决定如何执行该 CallableStatement。</p>
<pre><code class="java">@Override
@Nullable
public &lt;T&gt; T execute(String callString, CallableStatementCallback&lt;T&gt; action) throws DataAccessException &#123;
    return execute(new SimpleCallableStatementCreator(callString), action);
&#125;
</code></pre>
<p>操作示例：</p>
<pre><code class="java">@Autowired
JdbcTemplate jdbcTemplate;

@PostConstruct
public void execute6() &#123;
    // 创建存储过程
    jdbcTemplate.execute(&quot;CREATE ALIAS getDate FOR \&quot;java.lang.System.currentTimeMillis\&quot;&quot;);
    jdbcTemplate.execute(&quot;CREATE ALIAS getProperty FOR \&quot;java.lang.System.getProperty\&quot;&quot;);

    // 调用存储过程
    String call = jdbcTemplate.execute(&quot;call getDate()&quot;, new CallableStatementCallback&lt;String&gt;() &#123;
        @Override
        public String doInCallableStatement(CallableStatement cs) throws SQLException, DataAccessException &#123;
            ResultSet resultSet = cs.executeQuery();
            resultSet.next();
            return String.valueOf(resultSet.getLong(1));
        &#125;
    &#125;);
    System.out.println(call);

    // 调用存储过程
    call = jdbcTemplate.execute(&quot;call getProperty(?)&quot;, (CallableStatementCallback&lt;String&gt;) cs -&gt; &#123;
        cs.setString(1, &quot;user.home&quot;);
        ResultSet resultSet = cs.executeQuery();
        resultSet.next();
        return resultSet.getString(1);
    &#125;);
    System.out.println(call);
&#125;
</code></pre>
<pre><code>1692181535524
C:\Users\lsx
</code></pre>
<h3 id="7、execute-CallableStatementCreator-csc-CallableStatementCallback-T-action"><a href="#7、execute-CallableStatementCreator-csc-CallableStatementCallback-T-action" class="headerlink" title="7、execute(CallableStatementCreator csc, CallableStatementCallback&lt; T &gt; action)"></a>7、execute(CallableStatementCreator csc, CallableStatementCallback&lt; T &gt; action)</h3><pre><code class="java">public &lt;T&gt; T execute(CallableStatementCreator csc, CallableStatementCallback&lt;T&gt; action) &#123;&#125;
</code></pre>
<p>通过 CallableStatementCreator 创建存储过程或者函数的预编译语句，然后由 CallableStatementCallback 回调函数执行，获取结果。</p>
<pre><code class="java">@Autowired
JdbcTemplate jdbcTemplate;

@PostConstruct
public void execute7() &#123;
    // 创建存储过程
    jdbcTemplate.execute(&quot;CREATE ALIAS getDate FOR \&quot;java.lang.System.currentTimeMillis\&quot;&quot;);
    jdbcTemplate.execute(&quot;CREATE ALIAS getProperty FOR \&quot;java.lang.System.getProperty\&quot;&quot;);

    // 调用存储过程
    String call = jdbcTemplate.execute(new CallableStatementCreator() &#123;
        @Override
        public CallableStatement createCallableStatement(Connection con) throws SQLException &#123;
            return con.prepareCall(&quot;call getDate()&quot;);
        &#125;
    &#125;, new CallableStatementCallback&lt;String&gt;() &#123;
        @Override
        public String doInCallableStatement(CallableStatement cs) throws SQLException, DataAccessException &#123;
            ResultSet resultSet = cs.executeQuery();
            resultSet.next();
            return resultSet.getString(1);
        &#125;
    &#125;);
    System.out.println(call);

    // 调用存储过程
    call = jdbcTemplate.execute(con -&gt; &#123;
        CallableStatement cs = con.prepareCall(&quot;call getProperty(?)&quot;);
        cs.setString(1, &quot;user.home&quot;);
        return cs;
    &#125;, (CallableStatementCallback&lt;String&gt;) cs -&gt; &#123;
        // cs.setString(1, &quot;user.home&quot;);
        ResultSet resultSet = cs.executeQuery();
        resultSet.next();
        return resultSet.getString(1);
    &#125;);
    System.out.println(call);
&#125;
</code></pre>
<pre><code>1692182057557
C:\Users\lsx
</code></pre>
<h2 id="2、update-系列"><a href="#2、update-系列" class="headerlink" title="2、update 系列"></a>2、update 系列</h2><p>update()方法可以执行所有execute()能执行的SQL，几乎涵盖了所有常用的SQL。</p>
<h3 id="1、update-final-String-sql"><a href="#1、update-final-String-sql" class="headerlink" title="1、update(final String sql)"></a>1、update(final String sql)</h3><pre><code class="java">public int update(final String sql) throws DataAccessException &#123;&#125;
</code></pre>
<p>可以自行查看源码，源码中可以看到这个方法其实就是调用execute(StatementCallback&lt; T &gt; action)他的。故此 update() 方法也能执行很多操作类的SQL，不过SQL中不能处理动态参数。</p>
<pre><code class="java">@Autowired
JdbcTemplate jdbcTemplate;

@PostConstruct
public void execute1() &#123;
    // 先初始化表
    jdbcTemplate.update(&quot;drop table if exists user_info&quot;);
    jdbcTemplate.update(&quot;create table user_info(user_id int primary key, user_name varchar(255))&quot;);
    // 创建存储过程
    jdbcTemplate.update(&quot;CREATE ALIAS getDate FOR \&quot;java.lang.System.currentTimeMillis\&quot;&quot;);

    // 插入、更新、删除数据
    int insert = jdbcTemplate.update(&quot;insert into user_info values(1, &#39;Java&#39;)&quot;);
    int update = jdbcTemplate.update(&quot;update user_info set user_name = &#39;Python&#39; where user_id = 1&quot;);
    int delete = jdbcTemplate.update(&quot;delete from user_info where user_id = 1&quot;);
    System.out.println(&quot;插入数据: &quot; + insert + &quot; 条&quot;);
    System.out.println(&quot;更新数据: &quot; + update + &quot; 条&quot;);
    System.out.println(&quot;删除数据: &quot; + delete + &quot; 条&quot;);
&#125;
</code></pre>
<pre><code>插入数据: 1 条
更新数据: 1 条
删除数据: 1 条
</code></pre>
<h3 id="2、update-String-sql-Nullable-Object…-args"><a href="#2、update-String-sql-Nullable-Object…-args" class="headerlink" title="2、update(String sql, @Nullable Object… args)"></a>2、update(String sql, @Nullable Object… args)</h3><pre><code class="java">public int update(String sql, @Nullable Object... args) throws DataAccessException &#123;&#125;
</code></pre>
<p>推荐使用。方法比较简单。其中第二个多参参数形式为SQL中动态参数的值数组。</p>
<pre><code class="java">@Autowired
JdbcTemplate jdbcTemplate;

@PostConstruct
public void execute2() &#123;
    // 先初始化表
    jdbcTemplate.update(&quot;drop table if exists user_info&quot;);
    jdbcTemplate.update(&quot;create table user_info(user_id int primary key, user_name varchar(255))&quot;);

    // 插入、更新、删除数据
    int insert = jdbcTemplate.update(&quot;insert into user_info values(?, ?)&quot;, 1, &quot;Java&quot;);
    int update = jdbcTemplate.update(&quot;update user_info set user_name = ? where user_id = ?&quot;, &quot;Python&quot;, 1);
    int delete = jdbcTemplate.update(&quot;delete from user_info where user_id = ?&quot;, 1);
    System.out.println(&quot;插入数据: &quot; + insert + &quot; 条&quot;);
    System.out.println(&quot;更新数据: &quot; + update + &quot; 条&quot;);
    System.out.println(&quot;删除数据: &quot; + delete + &quot; 条&quot;);
&#125;
</code></pre>
<pre><code>插入数据: 1 条
更新数据: 1 条
删除数据: 1 条
</code></pre>
<h3 id="3、update-String-sql-Object-args-int-argTypes"><a href="#3、update-String-sql-Object-args-int-argTypes" class="headerlink" title="3、update(String sql, Object[] args, int[] argTypes)"></a>3、update(String sql, Object[] args, int[] argTypes)</h3><pre><code class="java">public int update(String sql, Object[] args, int[] argTypes) throws DataAccessException &#123;&#125;
</code></pre>
<p>执行带有动态参数的sql，通过两个数组入参。对于此方法中：</p>
<ul>
<li>第一个参数：执行的SQL。</li>
<li>第二个参数：SQL中参数的值。</li>
<li>第三个数组：动态参数的各个类型。</li>
</ul>
<pre><code class="java">@Autowired
JdbcTemplate jdbcTemplate;

@PostConstruct
public void execute3() &#123;
    // 先初始化表
    jdbcTemplate.update(&quot;drop table if exists user_info&quot;);
    jdbcTemplate.update(&quot;create table user_info(user_id int primary key, user_name varchar(255))&quot;);

    // 插入、更新、删除数据
    Object[] param1 = &#123;1, &quot;Java&quot;&#125;;
    int[] index1 = &#123;Types.INTEGER, Types.VARCHAR&#125;;
    int insert = jdbcTemplate.update(&quot;insert into user_info values(?, ?)&quot;, param1, index1);
    Object[] param2 = &#123;&quot;Python&quot;, 1&#125;;
    int[] index2 = &#123;Types.VARCHAR, Types.INTEGER&#125;;
    int update = jdbcTemplate.update(&quot;update user_info set user_name = ? where user_id = ?&quot;, param2, index2);
    Object[] param3 = &#123;1&#125;;
    int[] index3 = &#123;Types.INTEGER&#125;;
    int delete = jdbcTemplate.update(&quot;delete from user_info where user_id = ?&quot;, param3, index3);
    System.out.println(&quot;插入数据: &quot; + insert + &quot; 条&quot;);
    System.out.println(&quot;更新数据: &quot; + update + &quot; 条&quot;);
    System.out.println(&quot;删除数据: &quot; + delete + &quot; 条&quot;);
&#125;
</code></pre>
<pre><code>插入数据: 1 条
更新数据: 1 条
删除数据: 1 条
</code></pre>
<h3 id="4、update-String-sql-Nullable-PreparedStatementSetter-pss"><a href="#4、update-String-sql-Nullable-PreparedStatementSetter-pss" class="headerlink" title="4、update(String sql, @Nullable PreparedStatementSetter pss)"></a>4、update(String sql, @Nullable PreparedStatementSetter pss)</h3><pre><code class="java">public int update(String sql, @Nullable PreparedStatementSetter pss) throws DataAccessException &#123;&#125;
</code></pre>
<p>此方法可执行带有动态参数的SQL，参数由PreparedStatement对象操作，无需ps.execute();方法，否则SQL会被执行两次。</p>
<pre><code class="java">@Autowired
JdbcTemplate jdbcTemplate;

@PostConstruct
public void execute4() &#123;
    // 先初始化表
    jdbcTemplate.update(&quot;drop table if exists user_info&quot;);
    jdbcTemplate.update(&quot;create table user_info(user_id int primary key, user_name varchar(255))&quot;);

    // 插入、更新、删除数据
    int insert = jdbcTemplate.update(&quot;insert into user_info values(?, ?)&quot;, new PreparedStatementSetter() &#123;
        @Override
        public void setValues(PreparedStatement pss) throws SQLException &#123;
            pss.setInt(1, 1);
            pss.setString(2, &quot;Java&quot;);
        &#125;
    &#125;);
    int update = jdbcTemplate.update(&quot;update user_info set user_name = ? where user_id = ?&quot;, pss -&gt; &#123;
        pss.setString(1, &quot;Python&quot;);
        pss.setInt(2, 1);
    &#125;);

    int delete = jdbcTemplate.update(&quot;delete from user_info where user_id = ?&quot;, pss -&gt; &#123;
        pss.setInt(1, 1);
    &#125;);
    System.out.println(&quot;插入数据: &quot; + insert + &quot; 条&quot;);
    System.out.println(&quot;更新数据: &quot; + update + &quot; 条&quot;);
    System.out.println(&quot;删除数据: &quot; + delete + &quot; 条&quot;);
&#125;
</code></pre>
<pre><code>插入数据: 1 条
更新数据: 1 条
删除数据: 1 条
</code></pre>
<h3 id="5、update-PreparedStatementCreator-psc"><a href="#5、update-PreparedStatementCreator-psc" class="headerlink" title="5、update(PreparedStatementCreator psc)"></a>5、update(PreparedStatementCreator psc)</h3><pre><code class="java">public int update(PreparedStatementCreator psc) throws DataAccessException &#123;&#125;
</code></pre>
<p>此方法执行SQL时可以传递动态的参数，使用 PreparedStatement 对象操作参数。</p>
<pre><code class="java">@Autowired
JdbcTemplate jdbcTemplate;

@PostConstruct
public void execute5() &#123;
    // 先初始化表
    jdbcTemplate.update(&quot;drop table if exists user_info&quot;);
    jdbcTemplate.update(&quot;create table user_info(user_id int primary key, user_name varchar(255))&quot;);

    // 插入、更新、删除数据
    int insert = jdbcTemplate.update(new PreparedStatementCreator() &#123;
        @Override
        public PreparedStatement createPreparedStatement(Connection con) throws SQLException &#123;
            PreparedStatement ps = con.prepareStatement(&quot;insert into user_info values(?, ?)&quot;);
            ps.setInt(1, 1);
            ps.setString(2, &quot;Java&quot;);
            return ps;
        &#125;
    &#125;);
    int update = jdbcTemplate.update((PreparedStatementCreator) con -&gt; &#123;
        PreparedStatement ps = con.prepareStatement(&quot;update user_info set user_name = ? where user_id = ?&quot;);
        ps.setString(1, &quot;Python&quot;);
        ps.setInt(2, 1);
        return ps;
    &#125;);
    int delete = jdbcTemplate.update(con -&gt; &#123;
        PreparedStatement ps = con.prepareStatement(&quot;delete from user_info where user_id = ?&quot;);
        ps.setInt(1, 1);
        return ps;
    &#125;);
    System.out.println(&quot;插入数据: &quot; + insert + &quot; 条&quot;);
    System.out.println(&quot;更新数据: &quot; + update + &quot; 条&quot;);
    System.out.println(&quot;删除数据: &quot; + delete + &quot; 条&quot;);
&#125;
</code></pre>
<pre><code>插入数据: 1 条
更新数据: 1 条
删除数据: 1 条
</code></pre>
<h3 id="6、update-final-PreparedStatementCreator-psc-final-KeyHolder-generatedKeyHolder"><a href="#6、update-final-PreparedStatementCreator-psc-final-KeyHolder-generatedKeyHolder" class="headerlink" title="6、update(final PreparedStatementCreator psc, final KeyHolder generatedKeyHolder)"></a>6、update(final PreparedStatementCreator psc, final KeyHolder generatedKeyHolder)</h3><pre><code class="java">public int update(final PreparedStatementCreator psc, final KeyHolder generatedKeyHolder) throws DataAccessException &#123;&#125;
</code></pre>
<p>此方法对于执行insert sql语句时，可查询执行的主键id的值。也就是最重要的一点根据KeyHolder获取插入记录的ID。</p>
<p>不过获取主键的时候需要注意数据库类别，Oracle和MySQL是不一样的。不过本人使用的是H2数据库，与MySQL类似。所以如果操作的是Mysql数据库插入动作，获取Id应该是：</p>
<pre><code class="java">Number key = keyHolder.getKey();
int intValue = key.intValue();
</code></pre>
<p>操作示例：获取主键ID</p>
<pre><code class="java">@Autowired
JdbcTemplate jdbcTemplate;

@PostConstruct
public void execute6() &#123;
    // 先初始化表
    jdbcTemplate.update(&quot;drop table if exists user_info&quot;);
    jdbcTemplate.update(&quot;create table user_info(user_id int primary key auto_increment, user_name varchar(255))&quot;);

    // 插入数据返回主键
    GeneratedKeyHolder keyHolder = new GeneratedKeyHolder();
    int insert1 = jdbcTemplate.update(con -&gt; &#123;
        // 直接设置返回自增主键值, Statement.RETURN_GENERATED_KEYS 属性是返回自增主键
        PreparedStatement ps = con.prepareStatement(&quot;insert into user_info(user_name) values(?)&quot;, Statement.RETURN_GENERATED_KEYS);
        ps.setString(1, &quot;Java&quot;);
        return ps;
    &#125;, keyHolder);
    System.out.println(&quot;插入数据: &quot; + insert1 + &quot; 条&quot;);
    System.out.println(keyHolder.getKeys());
    System.out.println(keyHolder.getKey());
    int insert2 = jdbcTemplate.update(con -&gt; &#123;
        // 指定需要返回的列名
        PreparedStatement ps = con.prepareStatement(&quot;insert into user_info(user_name) values(?)&quot;, new String[]&#123;&quot;user_id&quot;&#125;);
        ps.setString(1, &quot;Java&quot;);
        return ps;
    &#125;, keyHolder);
    System.out.println(&quot;插入数据: &quot; + insert2 + &quot; 条&quot;);
    System.out.println(keyHolder.getKeys());
    System.out.println(keyHolder.getKey());
&#125;
</code></pre>
<pre><code>插入数据: 1 条
&#123;user_id=1&#125;
1
插入数据: 1 条
&#123;user_id=2&#125;
2
</code></pre>
<h2 id="3、batchUpdate-系列"><a href="#3、batchUpdate-系列" class="headerlink" title="3、batchUpdate 系列"></a>3、batchUpdate 系列</h2><p>同 update() 方法一样，batchUpdate() 也能处理很多批量操作的sql，比如：insert、update、delete 语句等等。</p>
<h3 id="1、batchUpdate-final-String…-sql"><a href="#1、batchUpdate-final-String…-sql" class="headerlink" title="1、batchUpdate(final String… sql)"></a>1、batchUpdate(final String… sql)</h3><pre><code class="java">public int[] batchUpdate(final String... sql) throws DataAccessException &#123;&#125;
</code></pre>
<p>使用方法如下，对于执行的SQL不能带有动态参数。</p>
<pre><code class="java">@Autowired
JdbcTemplate jdbcTemplate;

@PostConstruct
public void execute1() &#123;
    // 先初始化表
    jdbcTemplate.update(&quot;drop table if exists user_info&quot;);
    jdbcTemplate.update(&quot;create table user_info(user_id int primary key, user_name varchar(255))&quot;);

    String sql1 = &quot;insert into user_info values(1, &#39;Java&#39;)&quot;;
    String sql2 = &quot;insert into user_info values(2, &#39;Python&#39;)&quot;;
    String sql3 = &quot;insert into user_info values(3, &#39;JavaScript&#39;)&quot;;
    int[] ints = jdbcTemplate.batchUpdate(sql1, sql2, sql3);
    System.out.println(Arrays.toString(ints));
&#125;
</code></pre>
<pre><code>[1, 1, 1]
</code></pre>
<h3 id="2、batchUpdate-String-sql-List-batchArgs"><a href="#2、batchUpdate-String-sql-List-batchArgs" class="headerlink" title="2、batchUpdate(String sql, List&lt;Object[]&gt; batchArgs)"></a>2、batchUpdate(String sql, List&lt;Object[]&gt; batchArgs)</h3><pre><code class="java">public int[] batchUpdate(String sql, List&lt;Object[]&gt; batchArgs) throws DataAccessException &#123;&#125;
</code></pre>
<p>对于第二个参数 List&lt;Object[]&gt; batchArgs用于存放sql中的动态参数对应的值，如下：</p>
<pre><code class="java">@Autowired
JdbcTemplate jdbcTemplate;

@PostConstruct
public void execute2() &#123;
    // 先初始化表
    jdbcTemplate.update(&quot;drop table if exists user_info&quot;);
    jdbcTemplate.update(&quot;create table user_info(user_id int primary key, user_name varchar(255))&quot;);

    String sql = &quot;insert into user_info values(?, ?)&quot;;
    Object[] objects1 = new Object[]&#123;1, &quot;Java&quot;&#125;;
    Object[] objects2 = new Object[]&#123;2, &quot;Python&quot;&#125;;
    Object[] objects3 = new Object[]&#123;3, &quot;JavaScript&quot;&#125;;
    List&lt;Object[]&gt; objects = List.of(objects1, objects2, objects3);
    int[] ints = jdbcTemplate.batchUpdate(sql, objects);
    System.out.println(Arrays.toString(ints));
&#125;
</code></pre>
<pre><code>[1, 1, 1]
</code></pre>
<h3 id="3、batchUpdate-String-sql-List-batchArgs-final-int-argTypes"><a href="#3、batchUpdate-String-sql-List-batchArgs-final-int-argTypes" class="headerlink" title="3、batchUpdate(String sql, List&lt;Object[]&gt; batchArgs, final int[] argTypes)"></a>3、batchUpdate(String sql, List&lt;Object[]&gt; batchArgs, final int[] argTypes)</h3><pre><code class="java">public int[] batchUpdate(String sql, List&lt;Object[]&gt; batchArgs, final int[] argTypes) throws DataAccessException &#123;&#125;
</code></pre>
<p>同上面的方法一样，采用数组泛型的List存放参数值，第三个参数为数据库中对应字段的属性。比如：</p>
<pre><code class="java">@Autowired
JdbcTemplate jdbcTemplate;

@PostConstruct
public void execute3() &#123;
    // 先初始化表
    jdbcTemplate.update(&quot;drop table if exists user_info&quot;);
    jdbcTemplate.update(&quot;create table user_info(user_id int primary key, user_name varchar(255))&quot;);

    String sql = &quot;insert into user_info values(?, ?)&quot;;
    Object[] objects1 = new Object[]&#123;1, &quot;Java&quot;&#125;;
    Object[] objects2 = new Object[]&#123;2, &quot;Python&quot;&#125;;
    Object[] objects3 = new Object[]&#123;3, &quot;JavaScript&quot;&#125;;
    int[] types = new int[]&#123;Types.INTEGER, Types.VARCHAR&#125;;
    List&lt;Object[]&gt; objects = List.of(objects1, objects2, objects3);
    int[] ints = jdbcTemplate.batchUpdate(sql, objects, types);
    System.out.println(Arrays.toString(ints));
&#125;
</code></pre>
<pre><code>[1, 1, 1]
</code></pre>
<h3 id="4、batchUpdate-String-sql-final-BatchPreparedStatementSetter-pss"><a href="#4、batchUpdate-String-sql-final-BatchPreparedStatementSetter-pss" class="headerlink" title="4、batchUpdate(String sql, final BatchPreparedStatementSetter pss)"></a>4、batchUpdate(String sql, final BatchPreparedStatementSetter pss)</h3><pre><code class="java">public int[] batchUpdate(String sql, final BatchPreparedStatementSetter pss) throws DataAccessException &#123;&#125;
</code></pre>
<p>动态参数通过BatchPreparedStatementSetter接口的匿名类实现。比如：</p>
<pre><code class="java">@Autowired
JdbcTemplate jdbcTemplate;

@PostConstruct
public void execute4() &#123;
    // 先初始化表
    jdbcTemplate.update(&quot;drop table if exists user_info&quot;);
    jdbcTemplate.update(&quot;create table user_info(user_id int primary key, user_name varchar(255))&quot;);

    String sql = &quot;insert into user_info values(?, ?)&quot;;
    Object[] objects1 = new Object[]&#123;1, &quot;Java&quot;&#125;;
    Object[] objects2 = new Object[]&#123;2, &quot;Python&quot;&#125;;
    Object[] objects3 = new Object[]&#123;3, &quot;JavaScript&quot;&#125;;
    List&lt;Object[]&gt; objects = List.of(objects1, objects2, objects3);
    int[] ints = jdbcTemplate.batchUpdate(sql, new BatchPreparedStatementSetter() &#123;
        @Override
        public void setValues(PreparedStatement ps, int i) throws SQLException &#123;
            ps.setInt(1, (Integer) objects.get(i)[0]);
            ps.setString(2, (String) objects.get(i)[1]);
        &#125;

        @Override
        public int getBatchSize() &#123;
            return objects.size();
        &#125;
    &#125;);
    System.out.println(Arrays.toString(ints));
&#125;
</code></pre>
<h3 id="5、batchUpdate-String-sql-final-Collection-T-batchArgs-final-int-batchSize-final-ParameterizedPreparedStatementSetter-T-pss"><a href="#5、batchUpdate-String-sql-final-Collection-T-batchArgs-final-int-batchSize-final-ParameterizedPreparedStatementSetter-T-pss" class="headerlink" title="5、batchUpdate(String sql, final Collection&lt; T &gt; batchArgs, final int batchSize, final ParameterizedPreparedStatementSetter&lt; T &gt; pss)"></a>5、batchUpdate(String sql, final Collection&lt; T &gt; batchArgs, final int batchSize, final ParameterizedPreparedStatementSetter&lt; T &gt; pss)</h3><pre><code class="java">public &lt;T&gt; int[][] batchUpdate(String sql, final Collection&lt;T&gt; batchArgs, final int batchSize,
            final ParameterizedPreparedStatementSetter&lt;T&gt; pss) throws DataAccessException &#123;&#125;
</code></pre>
<p>推荐使用。这个批量操作的方法比较好用。</p>
<ul>
<li>第一个参数：要执行的SQL。</li>
<li>第二个参数：SQL参数的对象集合。</li>
<li>第三个参数：需要处理数据的数量。</li>
<li>第四个参数：根据第二个参数泛型取对应的值赋值给PreparedStatement对象，用于执行SQL。</li>
</ul>
<pre><code class="java">@Autowired
JdbcTemplate jdbcTemplate;

@PostConstruct
public void execute5() &#123;
    // 先初始化表
    jdbcTemplate.update(&quot;drop table if exists user_info&quot;);
    jdbcTemplate.update(&quot;create table user_info(user_id int primary key, user_name varchar(255))&quot;);

    String sql = &quot;insert into user_info values(?, ?)&quot;;
    List&lt;UserInfo&gt; datas = List.of(
            new UserInfo(1, &quot;Java&quot;),
            new UserInfo(2, &quot;Python&quot;),
            new UserInfo(3, &quot;JavaScript&quot;));
    int[][] ints = jdbcTemplate.batchUpdate(sql, datas, datas.size(), new ParameterizedPreparedStatementSetter&lt;UserInfo&gt;() &#123;
        @Override
        public void setValues(PreparedStatement ps, UserInfo userInfo) throws SQLException &#123;
            ps.setInt(1, userInfo.getUserId());
            ps.setString(2, userInfo.getUserName());
        &#125;
    &#125;);
    System.out.println(Arrays.toString(ints[0]));
&#125;

@Data
@NoArgsConstructor
@AllArgsConstructor
public static class UserInfo &#123;
    private int userId;
    private String userName;
&#125;
</code></pre>
<pre><code>[&#123;user_id=1&#125;, &#123;user_id=2&#125;, &#123;user_id=3&#125;]
</code></pre>
<h3 id="6、批量插入并返回主键-ID"><a href="#6、批量插入并返回主键-ID" class="headerlink" title="6、批量插入并返回主键 ID"></a>6、批量插入并返回主键 ID</h3><p>上面还漏了一个批量插入时，也需要返回主键ID，改怎么办？</p>
<p>直接看JdbcTemplate的接口，并没有发现类似单个插入获取主键的方式，是不是意味着没法实现呢？</p>
<p>当然不是了，既然没有提供，我们完全可以依葫芦画瓢，自己实现一个 ExtendJdbcTemplate， 首先看先单个插入返回ID的实现如下：</p>
<pre><code class="java">@Override
public int update(final PreparedStatementCreator psc, final KeyHolder generatedKeyHolder)
    throws DataAccessException &#123;

    Assert.notNull(generatedKeyHolder, &quot;KeyHolder must not be null&quot;);
    logger.debug(&quot;Executing SQL update and returning generated keys&quot;);

    return updateCount(execute(psc, ps -&gt; &#123;
        int rows = ps.executeUpdate();
        List&lt;Map&lt;String, Object&gt;&gt; generatedKeys = generatedKeyHolder.getKeyList();
        generatedKeys.clear();
        ResultSet keys = ps.getGeneratedKeys();
        if (keys != null) &#123;
            try &#123;
                RowMapperResultSetExtractor&lt;Map&lt;String, Object&gt;&gt; rse =
                    new RowMapperResultSetExtractor&lt;&gt;(getColumnMapRowMapper(), 1);
                generatedKeys.addAll(result(rse.extractData(keys)));
            &#125;
            finally &#123;
                JdbcUtils.closeResultSet(keys);
            &#125;
        &#125;
        if (logger.isTraceEnabled()) &#123;
            logger.trace(&quot;SQL update affected &quot; + rows + &quot; rows and returned &quot; + generatedKeys.size() + &quot; keys&quot;);
        &#125;
        return rows;
    &#125;, true));
&#125;
</code></pre>
<p>接下来，我们自己的实现可以如下：</p>
<pre><code class="java">import org.springframework.dao.DataAccessException;
import org.springframework.jdbc.core.*;
import org.springframework.jdbc.support.JdbcUtils;
import org.springframework.jdbc.support.KeyHolder;
import org.springframework.stereotype.Component;

import javax.sql.DataSource;
import java.sql.*;
import java.util.*;

@Component
public class ExtendJdbcTemplate extends JdbcTemplate &#123;
    public ExtendJdbcTemplate(DataSource dataSource) &#123;
        super(dataSource);
    &#125;

    public int[] batchUpdate(final PreparedStatementCreator psc, final BatchPreparedStatementSetter pss,
                             final KeyHolder generatedKeyHolder) throws DataAccessException &#123;
        return execute(psc, ps -&gt; &#123;
            try &#123;
                int batchSize = pss.getBatchSize();
                int totalRowsAffected = 0;
                int[] rowsAffected = new int[batchSize];
                List&lt;Map&lt;String, Object&gt;&gt; generatedKeys = generatedKeyHolder.getKeyList();
                generatedKeys.clear();
                ResultSet keys = null;
                for (int i = 0; i &lt; batchSize; i++) &#123;
                    pss.setValues(ps, i);
                    rowsAffected[i] = ps.executeUpdate();
                    totalRowsAffected += rowsAffected[i];
                    try &#123;
                        keys = ps.getGeneratedKeys();
                        if (keys != null) &#123;
                            RowMapper&lt;Map&lt;String, Object&gt;&gt; rowMapper = new ColumnMapRowMapper();
                            RowMapperResultSetExtractor&lt;Map&lt;String, Object&gt;&gt; rse =
                                    new RowMapperResultSetExtractor&lt;&gt;(rowMapper, 1);
                            generatedKeys.addAll(Objects.requireNonNull(rse.extractData(keys)));
                        &#125;
                    &#125; finally &#123;
                        JdbcUtils.closeResultSet(keys);
                    &#125;
                &#125;
                if (logger.isDebugEnabled()) &#123;
                    logger.debug(&quot;SQL batch update affected &quot; + totalRowsAffected +
                            &quot; rows and returned &quot; + generatedKeys.size() + &quot; keys&quot;);
                &#125;
                return rowsAffected;
            &#125; finally &#123;
                if (pss instanceof ParameterDisposer) &#123;
                    ((ParameterDisposer) pss).cleanupParameters();
                &#125;
            &#125;
        &#125;);
    &#125;
&#125;
</code></pre>
<pre><code class="java">@Autowired
private ExtendJdbcTemplate extendJdbcTemplate;

@PostConstruct
public void execute6() &#123;
    // 先初始化表
    jdbcTemplate.update(&quot;drop table if exists user_info&quot;);
    jdbcTemplate.update(&quot;create table user_info(user_id int primary key, user_name varchar(255))&quot;);

    String sql = &quot;insert into user_info values(?, ?)&quot;;
    List&lt;UserInfo&gt; userInfos = List.of(
            new UserInfo(1, &quot;Java&quot;),
            new UserInfo(2, &quot;Python&quot;),
            new UserInfo(3, &quot;JavaScript&quot;));

    GeneratedKeyHolder generatedKeyHolder = new GeneratedKeyHolder();
    extendJdbcTemplate.batchUpdate(new PreparedStatementCreator() &#123;
        @Override
        public PreparedStatement createPreparedStatement(Connection conn) throws SQLException &#123;
            return conn.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);
        &#125;
    &#125;, new BatchPreparedStatementSetter() &#123;
        @Override
        public void setValues(PreparedStatement ps, int i) throws SQLException &#123;
            ps.setInt(1, userInfos.get(i).getUserId());
            ps.setString(2, userInfos.get(i).getUserName());
        &#125;

        @Override
        public int getBatchSize() &#123;
            return userInfos.size();
        &#125;
    &#125;, generatedKeyHolder);
    System.out.println(generatedKeyHolder.getKeyList());
&#125;
</code></pre>
<h2 id="4、call-系列"><a href="#4、call-系列" class="headerlink" title="4、call 系列"></a>4、call 系列</h2><h3 id="1、call-CallableStatementCreator-csc-List-SqlParameter-declaredParameters"><a href="#1、call-CallableStatementCreator-csc-List-SqlParameter-declaredParameters" class="headerlink" title="1、call(CallableStatementCreator csc, List&lt; SqlParameter &gt; declaredParameters)"></a>1、call(CallableStatementCreator csc, List&lt; SqlParameter &gt; declaredParameters)</h3><pre><code class="java">public Map&lt;String, Object&gt; call(CallableStatementCreator csc, List&lt;SqlParameter&gt; declaredParameters)
            throws DataAccessException &#123;&#125;
</code></pre>
<pre><code class="java">@Autowired
JdbcTemplate jdbcTemplate;

@PostConstruct
public void execute() &#123;
    // 创建存储过程
    jdbcTemplate.execute(&quot;CREATE ALIAS getDate FOR \&quot;java.lang.System.currentTimeMillis\&quot;&quot;);
    jdbcTemplate.execute(&quot;CREATE ALIAS getProperty FOR \&quot;java.lang.System.getProperty\&quot;&quot;);

    // H2调用存储过程实际上也可以不用给SqlParameter,如果有Out参数就必须要要使用
    SqlParameter parameter = new SqlParameter(Types.VARCHAR);
    Map&lt;String, Object&gt; call = jdbcTemplate.call(new CallableStatementCreator() &#123;
        @Override
        public CallableStatement createCallableStatement(Connection con) throws SQLException &#123;
            CallableStatement cs = con.prepareCall(&quot;call getProperty(?)&quot;);
            cs.setString(1, &quot;user.home&quot;);
            return cs;
        &#125;
    &#125;, Collections.singletonList(parameter));
    System.out.println(call);

    // Lambda 方式调用
    call = jdbcTemplate.call(con -&gt; con.prepareCall(&quot;call getDate()&quot;), Collections.emptyList());
    System.out.println(call);
&#125;
</code></pre>
<pre><code>&#123;#result-set-1=[&#123;PUBLIC.getProperty(?1)=C:\Users\lsx&#125;]&#125;
&#123;#result-set-1=[&#123;PUBLIC.getDate()=1692331016474&#125;]&#125;
</code></pre>
<h2 id="5、queryForObject-系列"><a href="#5、queryForObject-系列" class="headerlink" title="5、queryForObject 系列"></a>5、queryForObject 系列</h2><p>queryForObject() 方法只能查询单个列且结果只有一行。否则报错。这一点尤其注意。</p>
<p>如果查询结果为空也会报错：</p>
<pre><code class="java">org.springframework.dao.EmptyResultDataAccessException: Incorrect result size: expected 1, actual 0 。
</code></pre>
<p>如果查询结果是多行，则报错：</p>
<pre><code class="java">org.springframework.dao.IncorrectResultSizeDataAccessException: Incorrect result size: expected 1, actual 12
</code></pre>
<p>注意：可以在网上看到很人多：查询的结果必须有且只有一行一列的值。这种说法也不完全对，如果查询结果映射为 RowMapper&lt; T &gt; ，泛型中可以是 Java 对象，这样就可以使一行多列了。</p>
<p>queryForObject：查询结果，将结果封装为对象，一般用于聚合函数的查询。</p>
<h3 id="1、queryForObject-String-sql-RowMapper-T-rowMapper"><a href="#1、queryForObject-String-sql-RowMapper-T-rowMapper" class="headerlink" title="1、queryForObject(String sql, RowMapper&lt; T &gt; rowMapper)"></a>1、queryForObject(String sql, RowMapper&lt; T &gt; rowMapper)</h3><pre><code class="java">public &lt;T&gt; T queryForObject(String sql, RowMapper&lt;T&gt; rowMapper) throws DataAccessException &#123;&#125;
</code></pre>
<p>返回一个泛型对象。且查询SQL不能动态传参，除非将参数在查询之前动态的拼接好，RowMapper 用于处理查询的结果。此种方式既可以返回单行单列，也可以返回单行多列。主要看 RowMapper 接口中泛型的设置。</p>
<pre><code class="java">@Autowired
JdbcTemplate jdbcTemplate;

@PostConstruct
public void execute() &#123;
    // 先初始化表和初始化数据
    jdbcTemplate.execute(&quot;drop table if exists user_info&quot;);
    jdbcTemplate.execute(&quot;create table user_info(user_id int primary key, user_name varchar(255))&quot;);
    jdbcTemplate.update(&quot;insert into user_info values(1, &#39;Java&#39;)&quot;);
    jdbcTemplate.update(&quot;insert into user_info values(2, &#39;Python&#39;)&quot;);
    jdbcTemplate.update(&quot;insert into user_info values(3, &#39;JavaScript&#39;)&quot;);

    // 查询单行单列
    String sql = &quot;select user_name from user_info where user_id = 1&quot;;
    String str = jdbcTemplate.queryForObject(sql, new RowMapper&lt;String&gt;() &#123;
        @Override
        public String mapRow(ResultSet rs, int rowNum) throws SQLException &#123;
            return rs.getString(1);
        &#125;
    &#125;);
    System.out.println(str);

    // 查询单行多列
    sql = &quot;select user_id,user_name from user_info where user_id = 1&quot;;
    UserInfo userInfo = jdbcTemplate.queryForObject(sql, (rs, rowNum) -&gt;
                                                    new UserInfo(rs.getInt(1), rs.getString(2)));
    System.out.println(userInfo);

    // 注意这里Spring自身提供了一个RowMapper接口实现类:ColumnMapRowMapper
    Map&lt;String, Object&gt; map = jdbcTemplate.queryForObject(sql, new ColumnMapRowMapper());
    System.out.println(map);
&#125;

@Data
@NoArgsConstructor
@AllArgsConstructor
public static class UserInfo &#123;
    private int userId;
    private String userName;
&#125;
</code></pre>
<pre><code>Java
UserInfo(userId=1, userName=Java)
&#123;user_id=1, user_name=Java&#125;
</code></pre>
<h3 id="2、queryForObject-String-sql-RowMapper-T-rowMapper-Nullable-Object…-args"><a href="#2、queryForObject-String-sql-RowMapper-T-rowMapper-Nullable-Object…-args" class="headerlink" title="2、queryForObject(String sql, RowMapper&lt; T &gt; rowMapper, @Nullable Object… args)"></a>2、queryForObject(String sql, RowMapper&lt; T &gt; rowMapper, @Nullable Object… args)</h3><pre><code class="java">public &lt;T&gt; T queryForObject(String sql, RowMapper&lt;T&gt; rowMapper, @Nullable Object... args) throws DataAccessException &#123;&#125;
</code></pre>
<p>和上面的方法一样，区别在于查询SQL能动态传参。</p>
<pre><code class="java">@Autowired
JdbcTemplate jdbcTemplate;

@PostConstruct
public void execute() &#123;
    // 先初始化表和初始化数据
    jdbcTemplate.execute(&quot;drop table if exists user_info&quot;);
    jdbcTemplate.execute(&quot;create table user_info(user_id int primary key, user_name varchar(255))&quot;);
    jdbcTemplate.update(&quot;insert into user_info values(1, &#39;Java&#39;)&quot;);
    jdbcTemplate.update(&quot;insert into user_info values(2, &#39;Python&#39;)&quot;);
    jdbcTemplate.update(&quot;insert into user_info values(3, &#39;JavaScript&#39;)&quot;);

    // 查询单行单列
    String sql = &quot;select user_name from user_info where user_id = ?&quot;;
    String str = jdbcTemplate.queryForObject(sql, new RowMapper&lt;String&gt;() &#123;
        @Override
        public String mapRow(ResultSet rs, int rowNum) throws SQLException &#123;
            return rs.getString(1);
        &#125;
    &#125;, 1);
    System.out.println(str);

    // 查询单行多列
    sql = &quot;select user_id,user_name from user_info where user_id = ?&quot;;
    UserInfo userInfo = jdbcTemplate.queryForObject(sql,
            (rs, rowNum) -&gt; new UserInfo(rs.getInt(1), rs.getString(2)),
            1);
    System.out.println(userInfo);

    // 注意这里Spring自身提供了一个RowMapper接口实现类:ColumnMapRowMapper
    Map&lt;String, Object&gt; map = jdbcTemplate.queryForObject(sql, new ColumnMapRowMapper(), 1);
    System.out.println(map);
&#125;

@Data
@NoArgsConstructor
@AllArgsConstructor
public static class UserInfo &#123;
    private int userId;
    private String userName;
&#125;
</code></pre>
<pre><code>Java
UserInfo(userId=1, userName=Java)
&#123;user_id=1, user_name=Java&#125;
</code></pre>
<h3 id="3、queryForObject-String-sql-Object-args-int-argTypes-RowMapper-T-rowMapper"><a href="#3、queryForObject-String-sql-Object-args-int-argTypes-RowMapper-T-rowMapper" class="headerlink" title="3、queryForObject(String sql, Object[] args, int[] argTypes, RowMapper&lt; T &gt; rowMapper)"></a>3、queryForObject(String sql, Object[] args, int[] argTypes, RowMapper&lt; T &gt; rowMapper)</h3><pre><code class="java">public &lt;T&gt; T queryForObject(String sql, Object[] args, int[] argTypes, RowMapper&lt;T&gt; rowMapper) throws DataAccessException &#123;&#125;
</code></pre>
<p>查询带有参数的 SQL，并且指定参数在数据库中的类型，如果SQL中没有参数，则为null。</p>
<ul>
<li><p>第一个参数：查询SQL。</p>
</li>
<li><p>第二个参数：如果SQL中有动态参数，则此为SQL中占位符参数的数组，注意顺序保持一致。如果没有则为null。</p>
</li>
<li><p>第三个参数：如果SQL有占位符需要处理参数，则此为参数在数据库中的类型，如果SQL中没有参数，则为null。</p>
</li>
<li><p>第四个参数：手动处理结果集。</p>
</li>
</ul>
<pre><code class="java">@Autowired
JdbcTemplate jdbcTemplate;

@PostConstruct
public void execute() &#123;
    // 先初始化表和初始化数据
    jdbcTemplate.execute(&quot;drop table if exists user_info&quot;);
    jdbcTemplate.execute(&quot;create table user_info(user_id int primary key, user_name varchar(255))&quot;);
    jdbcTemplate.update(&quot;insert into user_info values(1, &#39;Java&#39;)&quot;);
    jdbcTemplate.update(&quot;insert into user_info values(2, &#39;Python&#39;)&quot;);
    jdbcTemplate.update(&quot;insert into user_info values(3, &#39;JavaScript&#39;)&quot;);

    // 查询单行单列
    String sql = &quot;select user_name from user_info where user_id = ?&quot;;
    Object[] param = &#123;1&#125;;
    int[] index = &#123;Types.INTEGER&#125;;
    String str = jdbcTemplate.queryForObject(sql, param, index, new RowMapper&lt;String&gt;() &#123;
        @Override
        public String mapRow(ResultSet rs, int rowNum) throws SQLException &#123;
            return rs.getString(1);
        &#125;
    &#125;);
    System.out.println(str);

    // 查询单行多列
    sql = &quot;select user_id,user_name from user_info where user_id = ?&quot;;
    UserInfo userInfo = jdbcTemplate.queryForObject(sql, param, index,
            (rs, rowNum) -&gt; new UserInfo(rs.getInt(1), rs.getString(2)));
    System.out.println(userInfo);

    // 注意这里Spring自身提供了一个RowMapper接口实现类:ColumnMapRowMapper
    Map&lt;String, Object&gt; map = jdbcTemplate.queryForObject(sql, param, index, new ColumnMapRowMapper());
    System.out.println(map);
&#125;

@Data
@NoArgsConstructor
@AllArgsConstructor
public static class UserInfo &#123;
    private int userId;
    private String userName;
&#125;
</code></pre>
<pre><code>Java
UserInfo(userId=1, userName=Java)
&#123;user_id=1, user_name=Java&#125;
</code></pre>
<h3 id="4、queryForObject-String-sql-Class-T-requiredType"><a href="#4、queryForObject-String-sql-Class-T-requiredType" class="headerlink" title="4、queryForObject(String sql, Class&lt; T &gt; requiredType)"></a>4、queryForObject(String sql, Class&lt; T &gt; requiredType)</h3><pre><code class="java">public &lt;T&gt; T queryForObject(String sql, Class&lt;T&gt; requiredType) throws DataAccessException &#123;&#125;
</code></pre>
<p>这个方法就是用上面的**queryForObject(String sql, RowMapper&lt; T &gt; rowMapper)**方法，只不过把第二个参数封装了。requiredType 必须是常用的8个基本类型，否则报错。且查询SQL不能动态传参。</p>
<pre><code class="java">@Override
@Nullable
public &lt;T&gt; T queryForObject(String sql, Class&lt;T&gt; requiredType) throws DataAccessException &#123;
    return queryForObject(sql, getSingleColumnRowMapper(requiredType));
&#125;
</code></pre>
<p>如果只是查询单个字段时，或者聚合查询时，推荐使用此方法。</p>
<pre><code class="java">@Autowired
JdbcTemplate jdbcTemplate;

@PostConstruct
public void execute() &#123;
    // 先初始化表和初始化数据
    jdbcTemplate.execute(&quot;drop table if exists user_info&quot;);
    jdbcTemplate.execute(&quot;create table user_info(user_id int primary key, user_name varchar(255))&quot;);
    jdbcTemplate.update(&quot;insert into user_info values(1, &#39;Java&#39;)&quot;);
    jdbcTemplate.update(&quot;insert into user_info values(2, &#39;Python&#39;)&quot;);
    jdbcTemplate.update(&quot;insert into user_info values(3, &#39;JavaScript&#39;)&quot;);

    String userName = jdbcTemplate.queryForObject(&quot;select user_name from user_info where user_id = 1&quot;, String.class);
    System.out.println(&quot;userName: &quot; + userName);

    Integer count = jdbcTemplate.queryForObject(&quot;select count(*) from user_info&quot;, Integer.class);
    System.out.println(&quot;count: &quot; + count);

    // 下面这个会报错：
    //  org.springframework.dao.TypeMismatchDataAccessException: Type mismatch affecting row number 0 and column type &#39;CHARACTER VARYING&#39;:
    //  Value [Java] is of type [java.lang.String] and cannot be converted to required type [UserInfo]
    // UserInfo userInfo = jdbcTemplate.queryForObject(&quot;select user_name from user_info where user_id = 1&quot;, UserInfo.class);
&#125;
</code></pre>
<pre><code>userName: Java
count: 3
</code></pre>
<h3 id="5、queryForObject-String-sql-Class-T-requiredType-Nullable-Object…-args"><a href="#5、queryForObject-String-sql-Class-T-requiredType-Nullable-Object…-args" class="headerlink" title="5、queryForObject(String sql, Class&lt; T &gt; requiredType, @Nullable Object… args)"></a>5、queryForObject(String sql, Class&lt; T &gt; requiredType, @Nullable Object… args)</h3><pre><code class="java">public &lt;T&gt; T queryForObject(String sql, Class&lt;T&gt; requiredType, @Nullable Object... args) throws DataAccessException &#123;&#125;
</code></pre>
<p>在上面的方法的基础上，增加了查询SQL可以动态传参。需要注意：requiredType 必须是常用的8个基本类型，否则报错。</p>
<pre><code class="java">@Autowired
JdbcTemplate jdbcTemplate;

@PostConstruct
public void execute() &#123;
    // 先初始化表和初始化数据
    jdbcTemplate.execute(&quot;drop table if exists user_info&quot;);
    jdbcTemplate.execute(&quot;create table user_info(user_id int primary key, user_name varchar(255))&quot;);
    jdbcTemplate.update(&quot;insert into user_info values(1, &#39;Java&#39;)&quot;);
    jdbcTemplate.update(&quot;insert into user_info values(2, &#39;Python&#39;)&quot;);
    jdbcTemplate.update(&quot;insert into user_info values(3, &#39;JavaScript&#39;)&quot;);

    String sql = &quot;select user_name from user_info where user_id = ? and user_name = ?&quot;;
    String userName = jdbcTemplate.queryForObject(sql, String.class, 1, &quot;Java&quot;);
    System.out.println(&quot;userName: &quot; + userName);
&#125;
</code></pre>
<pre><code>userName: Java
</code></pre>
<h3 id="6、queryForObject-String-sql-Object-args-int-argTypes-Class-T-requiredType"><a href="#6、queryForObject-String-sql-Object-args-int-argTypes-Class-T-requiredType" class="headerlink" title="6、queryForObject(String sql, Object[] args, int[] argTypes, Class&lt; T &gt; requiredType)"></a>6、queryForObject(String sql, Object[] args, int[] argTypes, Class&lt; T &gt; requiredType)</h3><pre><code class="java">public &lt;T&gt; T queryForObject(String sql, Object[] args, int[] argTypes, Class&lt;T&gt; requiredType) throws DataAccessException &#123;&#125;
</code></pre>
<p>查询带有参数的 SQL，并且指定参数在数据库中的类型，如果SQL中没有参数，则为null。需要注意：requiredType 必须是常用的8个基本类型，否则报错。</p>
<ul>
<li>第一个参数：查询SQL。</li>
<li>第二个参数：如果SQL中有动态参数，则此为SQL中占位符参数的数组，注意顺序保持一致。如果没有则为null。</li>
<li>第三个参数：如果SQL有占位符需要处理参数，则此为参数在数据库中的类型，如果SQL中没有参数，则为null。</li>
<li>第四个参数：手动处理结果集。结果集只能为常用的8个基本类型，否则报错。</li>
</ul>
<pre><code class="java">@Autowired
JdbcTemplate jdbcTemplate;

@PostConstruct
public void execute() &#123;
    // 先初始化表和初始化数据
    jdbcTemplate.execute(&quot;drop table if exists user_info&quot;);
    jdbcTemplate.execute(&quot;create table user_info(user_id int primary key, user_name varchar(255))&quot;);
    jdbcTemplate.update(&quot;insert into user_info values(1, &#39;Java&#39;)&quot;);
    jdbcTemplate.update(&quot;insert into user_info values(2, &#39;Python&#39;)&quot;);
    jdbcTemplate.update(&quot;insert into user_info values(3, &#39;JavaScript&#39;)&quot;);

    String sql = &quot;select user_name from user_info where user_id = ? and user_name = ?&quot;;
    Object[] param = &#123;1, &quot;Java&quot;&#125;;
    int[] index = &#123;Types.INTEGER, Types.VARCHAR&#125;;
    String userName = jdbcTemplate.queryForObject(sql, param, index, String.class);
    System.out.println(&quot;userName: &quot; + userName);
&#125;
</code></pre>
<pre><code>userName: Java
</code></pre>
<h2 id="6、queryForMap-系列"><a href="#6、queryForMap-系列" class="headerlink" title="6、queryForMap 系列"></a>6、queryForMap 系列</h2><p>queryForMap() 方法是 JdbcOperations 接口的方法，由 JdbcTemplate 子类进行了重写。queryForMap 方法查询结果将结果集封装为 Map 集合，将列名作为 key，将值作为 value 将这条记录封装为一个 Map 集合。 注意：这个方法查询的结果集长度只能是1，也就是一行。</p>
<h3 id="1、queryForMap-String-sql"><a href="#1、queryForMap-String-sql" class="headerlink" title="1、queryForMap(String sql)"></a>1、queryForMap(String sql)</h3><pre><code class="java">public Map&lt;String, Object&gt; queryForMap(String sql) throws DataAccessException &#123;&#125;
</code></pre>
<p>返回一个Map对象。且查询SQL不能动态传参。</p>
<p>操作案例请参考：queryForMap(String sql, Object[] args, int[] argTypes)</p>
<h3 id="2、queryForMap-String-sql-Nullable-Object…-args"><a href="#2、queryForMap-String-sql-Nullable-Object…-args" class="headerlink" title="2、queryForMap(String sql, @Nullable Object… args)"></a>2、queryForMap(String sql, @Nullable Object… args)</h3><pre><code class="java">public Map&lt;String, Object&gt; queryForMap(String sql, @Nullable Object... args) throws DataAccessException &#123;&#125;
</code></pre>
<p>与上面方法唯一的区别是：查询SQL能动态传参。</p>
<p>操作案例请参考：queryForMap(String sql, Object[] args, int[] argTypes)</p>
<h3 id="3、queryForMap-String-sql-Object-args-int-argTypes"><a href="#3、queryForMap-String-sql-Object-args-int-argTypes" class="headerlink" title="3、queryForMap(String sql, Object[] args, int[] argTypes)"></a>3、queryForMap(String sql, Object[] args, int[] argTypes)</h3><pre><code class="java">public Map&lt;String, Object&gt; queryForMap(String sql, Object[] args, int[] argTypes) throws DataAccessException &#123;&#125;
</code></pre>
<p>查询带有参数的 SQL，并且指定参数在数据库中的类型，如果SQL中没有参数，则为null。</p>
<pre><code class="java">@Autowired
JdbcTemplate jdbcTemplate;

@PostConstruct
public void execute() &#123;
    // 先初始化表和初始化数据
    jdbcTemplate.execute(&quot;drop table if exists user_info&quot;);
    jdbcTemplate.execute(&quot;create table user_info(user_id int primary key, user_name varchar(255))&quot;);
    jdbcTemplate.update(&quot;insert into user_info values(1, &#39;Java&#39;)&quot;);
    jdbcTemplate.update(&quot;insert into user_info values(2, &#39;Python&#39;)&quot;);
    jdbcTemplate.update(&quot;insert into user_info values(3, &#39;JavaScript&#39;)&quot;);

    Map&lt;String, Object&gt; map = jdbcTemplate.queryForMap(&quot;select * from user_info where user_id = 1&quot;);
    System.out.println(map);

    map = jdbcTemplate.queryForMap(&quot;select * from user_info where user_id = ?&quot;, 1);
    System.out.println(map);

    Object[] param = &#123;1&#125;;
    int[] index = &#123;Types.INTEGER&#125;;
    map = jdbcTemplate.queryForMap(&quot;select * from user_info where user_id = ?&quot;, param, index);
    System.out.println(map);

    // 如下会报错: Invocation of init method failed;
    // nested exception is org.springframework.dao.IncorrectResultSizeDataAccessException: 
    // Incorrect result size: expected 1, actual 3
    // System.out.println(jdbcTemplate.queryForMap(&quot;select * from user_info&quot;));
&#125;
</code></pre>
<pre><code>&#123;user_id=1, user_name=Java&#125;
&#123;user_id=1, user_name=Java&#125;
&#123;user_id=1, user_name=Java&#125;
</code></pre>
<h2 id="7、queryForRowSet-系列"><a href="#7、queryForRowSet-系列" class="headerlink" title="7、queryForRowSet 系列"></a>7、queryForRowSet 系列</h2><p>queryForRowSet 方法也是 JdbcOperations 接口的方法，由 JdbcTemplate 子类进行了重写。queryForRowSet 方法返回是 SqlRowSet 对象，这是一个集合，也就是说，可以查询多条记录。【与 queryForMap 的区别：queryForMap 返回 Map 集合，并且只能放回一行数据。而 queryForRowSet 返回的是一个SqlRowSet对象，这是个集合对象，所以可以查询多条记录】</p>
<h3 id="1、queryForRowSet-String-sql"><a href="#1、queryForRowSet-String-sql" class="headerlink" title="1、queryForRowSet(String sql)"></a>1、queryForRowSet(String sql)</h3><pre><code class="java">public SqlRowSet queryForRowSet(String sql) throws DataAccessException &#123;&#125;
</code></pre>
<p>返回一个SqlRowSet 对象。且查询SQL不能动态传参。</p>
<p>操作案例请参考：queryForRowSet(String sql, Object[] args, int[] argTypes)</p>
<h3 id="2、queryForRowSet-String-sql-Nullable-Object…-args"><a href="#2、queryForRowSet-String-sql-Nullable-Object…-args" class="headerlink" title="2、queryForRowSet(String sql, @Nullable Object… args)"></a>2、queryForRowSet(String sql, @Nullable Object… args)</h3><pre><code class="java">public SqlRowSet queryForRowSet(String sql, @Nullable Object... args) throws DataAccessException &#123;&#125;
</code></pre>
<p>与上面方法唯一的区别是：查询SQL能动态传参。</p>
<p>操作案例请参考：queryForRowSet(String sql, Object[] args, int[] argTypes)</p>
<h3 id="3、queryForRowSet-String-sql-Object-args-int-argTypes"><a href="#3、queryForRowSet-String-sql-Object-args-int-argTypes" class="headerlink" title="3、queryForRowSet(String sql, Object[] args, int[] argTypes)"></a>3、queryForRowSet(String sql, Object[] args, int[] argTypes)</h3><pre><code class="java">public SqlRowSet queryForRowSet(String sql, Object[] args, int[] argTypes) throws DataAccessException &#123;&#125;
</code></pre>
<p>查询带有参数的 SQL，并且指定参数在数据库中的类型，如果SQL中没有参数，则为null。</p>
<pre><code class="java">@Autowired
JdbcTemplate jdbcTemplate;

@PostConstruct
public void execute() &#123;
    // 先初始化表和初始化数据
    jdbcTemplate.execute(&quot;drop table if exists user_info&quot;);
    jdbcTemplate.execute(&quot;create table user_info(user_id int primary key, user_name varchar(255))&quot;);
    jdbcTemplate.update(&quot;insert into user_info values(1, &#39;Java&#39;)&quot;);
    jdbcTemplate.update(&quot;insert into user_info values(2, &#39;Python&#39;)&quot;);
    jdbcTemplate.update(&quot;insert into user_info values(3, &#39;JavaScript&#39;)&quot;);

    String sql = &quot;select * from user_info&quot;;
    SqlRowSet rowSet = jdbcTemplate.queryForRowSet(sql);
    List&lt;UserInfo&gt; userInfos = new ArrayList&lt;&gt;();
    while (rowSet.next()) &#123;
        userInfos.add(new UserInfo(rowSet.getInt(1), rowSet.getString(2)));
    &#125;
    System.out.println(userInfos);
    userInfos.clear();

    sql = &quot;select * from user_info where user_id = ?&quot;;
    rowSet = jdbcTemplate.queryForRowSet(sql, 1);
    while (rowSet.next()) &#123;
        userInfos.add(new UserInfo(rowSet.getInt(1), rowSet.getString(2)));
    &#125;
    System.out.println(userInfos);
    userInfos.clear();

    Object[] param = &#123;1&#125;;
    int[] index = &#123;Types.INTEGER&#125;;
    rowSet = jdbcTemplate.queryForRowSet(sql, param, index);
    while (rowSet.next()) &#123;
        userInfos.add(new UserInfo(rowSet.getInt(1), rowSet.getString(2)));
    &#125;
    System.out.println(userInfos);
    userInfos.clear();
&#125;

@Data
@NoArgsConstructor
@AllArgsConstructor
public static class UserInfo &#123;
    private int userId;
    private String userName;
&#125;
</code></pre>
<pre><code>[UserInfo(userId=1, userName=Java), UserInfo(userId=2, userName=Python), UserInfo(userId=3, userName=JavaScript)]
[UserInfo(userId=1, userName=Java)]
[UserInfo(userId=1, userName=Java)]
</code></pre>
<h2 id="8、queryForList-系列"><a href="#8、queryForList-系列" class="headerlink" title="8、queryForList 系列"></a>8、queryForList 系列</h2><p>queryForList() 方法查询有两种形式：</p>
<ol>
<li>查询结果将结果集封装为List集合。注意：将每一条记录封装为一个Map集合，再将Map集合装载到List集合中。</li>
<li>查询结果将结果集封装为List集合，如果指定elementType类型，则只能查询单列。再将单列这个类型装载到List集合中。</li>
</ol>
<p>查询多行多列，以List的形式返回结果，如果指定elementType类型，则只能查询单列，否则报错：</p>
<pre><code class="java">org.springframework.jdbc.IncorrectResultSetColumnCountException: Incorrect column count: expected 1, actual 4 
</code></pre>
<p>如果指定elementType类型，则只能查询单列，且类型只能时8中基本数据类型，否则报错：</p>
<pre><code class="java">org.springframework.dao.TypeMismatchDataAccessException:

Type mismatch affecting row number 0 and column type &#39;xxxxxx&#39;:

Value [xxxxxx] is of type [java.lang.String] and cannot be converted to required type [xxx.xxx.xxx.xxx]
</code></pre>
<p>如果经常查询一些数据，建议使用queryForList()。需要注意的是：如果查询结果为空则返回空集合，也就是如下，不会报错。</p>
<pre><code class="java">list.isEmpty() == true
</code></pre>
<h3 id="1、queryForList-String-sql"><a href="#1、queryForList-String-sql" class="headerlink" title="1、queryForList(String sql)"></a>1、queryForList(String sql)</h3><pre><code class="java">public List&lt;Map&lt;String, Object&gt;&gt; queryForList(String sql) throws DataAccessException &#123;&#125;
</code></pre>
<p>可以查询多行多列，返回一个List集合，List元素是Map，也就是查询结果中每一行的数据，只不过以Map的形式返回。 如果SQL中没有动态参数，<strong>推荐使用。</strong></p>
<pre><code class="java">@Autowired
JdbcTemplate jdbcTemplate;

@PostConstruct
public void execute() &#123;
    // 先初始化表和初始化数据
    jdbcTemplate.execute(&quot;drop table if exists user_info&quot;);
    jdbcTemplate.execute(&quot;create table user_info(user_id int primary key, user_name varchar(255))&quot;);
    jdbcTemplate.update(&quot;insert into user_info values(1, &#39;Java&#39;)&quot;);
    jdbcTemplate.update(&quot;insert into user_info values(2, &#39;Python&#39;)&quot;);
    jdbcTemplate.update(&quot;insert into user_info values(3, &#39;JavaScript&#39;)&quot;);

    List&lt;Map&lt;String, Object&gt;&gt; maps = jdbcTemplate.queryForList(&quot;select * from user_info&quot;);
    System.out.println(maps);
&#125;
</code></pre>
<pre><code>[&#123;user_id=1, user_name=Java&#125;, &#123;user_id=2, user_name=Python&#125;, &#123;user_id=3, user_name=JavaScript&#125;]
</code></pre>
<h3 id="2、queryForList-String-sql-Nullable-Object…-args"><a href="#2、queryForList-String-sql-Nullable-Object…-args" class="headerlink" title="2、queryForList(String sql, @Nullable Object… args)"></a>2、queryForList(String sql, @Nullable Object… args)</h3><pre><code class="java">public List&lt;Map&lt;String, Object&gt;&gt; queryForList(String sql, @Nullable Object... args) throws DataAccessException &#123;&#125;
</code></pre>
<p>与上面方法一样，如果SQL中有动态参数，推荐使用这个，比较方便。例如：</p>
<pre><code class="java">@Autowired
JdbcTemplate jdbcTemplate;

@PostConstruct
public void execute() &#123;
    // 先初始化表和初始化数据
    jdbcTemplate.execute(&quot;drop table if exists user_info&quot;);
    jdbcTemplate.execute(&quot;create table user_info(user_id int primary key, user_name varchar(255))&quot;);
    jdbcTemplate.update(&quot;insert into user_info values(1, &#39;Java&#39;)&quot;);
    jdbcTemplate.update(&quot;insert into user_info values(2, &#39;Python&#39;)&quot;);
    jdbcTemplate.update(&quot;insert into user_info values(3, &#39;JavaScript&#39;)&quot;);

    List&lt;Map&lt;String, Object&gt;&gt; maps = jdbcTemplate.queryForList(&quot;select * from user_info where user_id &lt; ?&quot;, 4);
    System.out.println(maps);
&#125;
</code></pre>
<pre><code>[&#123;user_id=1, user_name=Java&#125;, &#123;user_id=2, user_name=Python&#125;, &#123;user_id=3, user_name=JavaScript&#125;]
</code></pre>
<h3 id="3、queryForList-String-sql-Object-args-int-argTypes"><a href="#3、queryForList-String-sql-Object-args-int-argTypes" class="headerlink" title="3、queryForList(String sql, Object[] args, int[] argTypes)"></a>3、queryForList(String sql, Object[] args, int[] argTypes)</h3><pre><code class="java">public List&lt;Map&lt;String, Object&gt;&gt; queryForList(String sql, Object[] args, int[] argTypes) throws DataAccessException &#123;&#125;
</code></pre>
<p>查询多行多列，SQL中可以传多个动态参数，并且指定参数在数据库中的类型，该参数可有可无，如：</p>
<pre><code class="java">@Autowired
JdbcTemplate jdbcTemplate;

@PostConstruct
public void execute() &#123;
    // 先初始化表和初始化数据
    jdbcTemplate.execute(&quot;drop table if exists user_info&quot;);
    jdbcTemplate.execute(&quot;create table user_info(user_id int primary key, user_name varchar(255))&quot;);
    jdbcTemplate.update(&quot;insert into user_info values(1, &#39;Java&#39;)&quot;);
    jdbcTemplate.update(&quot;insert into user_info values(2, &#39;Python&#39;)&quot;);
    jdbcTemplate.update(&quot;insert into user_info values(3, &#39;JavaScript&#39;)&quot;);

    Object[] param = &#123;4&#125;;
    int[] index = &#123;Types.INTEGER&#125;;
    List&lt;Map&lt;String, Object&gt;&gt; maps = jdbcTemplate.queryForList(&quot;select * from user_info where user_id &lt; ?&quot;, param, index);
    System.out.println(maps);
&#125;
</code></pre>
<pre><code>[&#123;user_id=1, user_name=Java&#125;, &#123;user_id=2, user_name=Python&#125;, &#123;user_id=3, user_name=JavaScript&#125;]
</code></pre>
<h3 id="4、queryForList-String-sql-Class-T-elementType"><a href="#4、queryForList-String-sql-Class-T-elementType" class="headerlink" title="4、queryForList(String sql, Class&lt; T &gt; elementType)"></a>4、queryForList(String sql, Class&lt; T &gt; elementType)</h3><pre><code class="java">public &lt;T&gt; List&lt;T&gt; queryForList(String sql, Class&lt;T&gt; elementType) throws DataAccessException &#123;&#125;
</code></pre>
<p>此方法用于SQL中没有动态参数，且查询结果为单列多行，返回一个指定类型的List集合，指定的类型只能是8个基本数据类型。</p>
<pre><code class="java">@Autowired
JdbcTemplate jdbcTemplate;

@PostConstruct
public void execute() &#123;
    // 先初始化表和初始化数据
    jdbcTemplate.execute(&quot;drop table if exists user_info&quot;);
    jdbcTemplate.execute(&quot;create table user_info(user_id int primary key, user_name varchar(255))&quot;);
    jdbcTemplate.update(&quot;insert into user_info values(1, &#39;Java&#39;)&quot;);
    jdbcTemplate.update(&quot;insert into user_info values(2, &#39;Python&#39;)&quot;);
    jdbcTemplate.update(&quot;insert into user_info values(3, &#39;JavaScript&#39;)&quot;);

    List&lt;String&gt; userNames = jdbcTemplate.queryForList(&quot;select user_name from user_info&quot;, String.class);
    System.out.println(userNames);
&#125;
</code></pre>
<pre><code>[Java, Python, JavaScript]
</code></pre>
<h3 id="5、queryForList-String-sql-Class-T-elementType-Nullable-Object…-args"><a href="#5、queryForList-String-sql-Class-T-elementType-Nullable-Object…-args" class="headerlink" title="5、queryForList(String sql, Class&lt; T &gt; elementType, @Nullable Object… args)"></a>5、queryForList(String sql, Class&lt; T &gt; elementType, @Nullable Object… args)</h3><pre><code class="java">public &lt;T&gt; List&lt;T&gt; queryForList(String sql, Class&lt;T&gt; elementType, @Nullable Object... args) throws DataAccessException &#123;&#125;
</code></pre>
<p>查询多行单列，第二个参数的类型必须是八个基本数据类型之一，动态占位符参数采用多个参数传参的方式。如：</p>
<pre><code class="java">@Autowired
JdbcTemplate jdbcTemplate;

@PostConstruct
public void execute() &#123;
    // 先初始化表和初始化数据
    jdbcTemplate.execute(&quot;drop table if exists user_info&quot;);
    jdbcTemplate.execute(&quot;create table user_info(user_id int primary key, user_name varchar(255))&quot;);
    jdbcTemplate.update(&quot;insert into user_info values(1, &#39;Java&#39;)&quot;);
    jdbcTemplate.update(&quot;insert into user_info values(2, &#39;Python&#39;)&quot;);
    jdbcTemplate.update(&quot;insert into user_info values(3, &#39;JavaScript&#39;)&quot;);

    String sql = &quot;select user_name from user_info where user_id &lt; ?&quot;;
    List&lt;String&gt; userNames = jdbcTemplate.queryForList(sql, String.class, 4);
    System.out.println(userNames);
&#125;
</code></pre>
<pre><code>[Java, Python, JavaScript]
</code></pre>
<h3 id="6、queryForList-String-sql-Object-args-int-argTypes-Class-T-elementType"><a href="#6、queryForList-String-sql-Object-args-int-argTypes-Class-T-elementType" class="headerlink" title="6、queryForList(String sql, Object[] args, int[] argTypes, Class&lt; T &gt; elementType)"></a>6、queryForList(String sql, Object[] args, int[] argTypes, Class&lt; T &gt; elementType)</h3><pre><code class="java">public &lt;T&gt; List&lt;T&gt; queryForList(String sql, Object[] args, int[] argTypes, Class&lt;T&gt; elementType) throws DataAccessException &#123;&#125;
</code></pre>
<p>查询多行单列，SQL中可以有动态参数。</p>
<ul>
<li><p>第一个参数：SQL语句。</p>
</li>
<li><p>第二个参数：如果SQL中有动态参数，则此为SQL中占位符参数的数组，注意顺序保持一致。如果没有则为null。</p>
</li>
<li><p>第三个参数：如果SQL有占位符需要处理参数，则此为参数的数据库类型，如果SQL中没有参数，则为null。该参数其实可有可无</p>
</li>
<li><p>第四个参数：必须是8个基本数据类型其一。</p>
</li>
</ul>
<pre><code class="java">@Autowired
JdbcTemplate jdbcTemplate;

@PostConstruct
public void execute() &#123;
    // 先初始化表和初始化数据
    jdbcTemplate.execute(&quot;drop table if exists user_info&quot;);
    jdbcTemplate.execute(&quot;create table user_info(user_id int primary key, user_name varchar(255))&quot;);
    jdbcTemplate.update(&quot;insert into user_info values(1, &#39;Java&#39;)&quot;);
    jdbcTemplate.update(&quot;insert into user_info values(2, &#39;Python&#39;)&quot;);
    jdbcTemplate.update(&quot;insert into user_info values(3, &#39;JavaScript&#39;)&quot;);

    Object[] param = &#123;4&#125;;
    int[] index = &#123;Types.INTEGER&#125;;
    String sql = &quot;select user_name from user_info where user_id &lt; ?&quot;;
    List&lt;String&gt; userNames = jdbcTemplate.queryForList(sql, param, index, String.class);
    System.out.println(userNames);
&#125;
</code></pre>
<pre><code>[Java, Python, JavaScript]
</code></pre>
<h2 id="9、query-系列"><a href="#9、query-系列" class="headerlink" title="9、query 系列"></a>9、query 系列</h2><h3 id="1、query-String-sql-RowCallbackHandler-rch"><a href="#1、query-String-sql-RowCallbackHandler-rch" class="headerlink" title="1、query(String sql, RowCallbackHandler rch)"></a>1、query(String sql, RowCallbackHandler rch)</h3><pre><code class="java">public void query(String sql, RowCallbackHandler rch) throws DataAccessException &#123;&#125;
</code></pre>
<p>其实这个方式就是调用query(String sql, @Nullable PreparedStatementSetter pss, RowCallbackHandler rch)方法，需要用户自己取处理结果集，不过不需要判断ResultSet.next()，交由ResultSetExtractor的实现类的extractData(ResultSet rs)完成。用户只需要处理ResultSet的每一行数据。不支持SQL动态传入参数。</p>
<pre><code class="java">@Autowired
JdbcTemplate jdbcTemplate;

@PostConstruct
public void execute() &#123;
    // 先初始化表和初始化数据
    jdbcTemplate.execute(&quot;drop table if exists user_info&quot;);
    jdbcTemplate.execute(&quot;create table user_info(user_id int primary key, user_name varchar(255))&quot;);
    jdbcTemplate.update(&quot;insert into user_info values(1, &#39;Java&#39;)&quot;);
    jdbcTemplate.update(&quot;insert into user_info values(2, &#39;Python&#39;)&quot;);
    jdbcTemplate.update(&quot;insert into user_info values(3, &#39;JavaScript&#39;)&quot;);

    // 查询单个对象, 这个回调方式, 一条记录回调一次, 不返回结果
    UserInfo userInfo = new UserInfo();
    jdbcTemplate.query(&quot;select * from user_info where user_id = 1&quot;, new RowCallbackHandler() &#123;
        @Override
        public void processRow(ResultSet rs) throws SQLException &#123;
            userInfo.setUserId(rs.getInt(1));
            userInfo.setUserName(rs.getString(2));
        &#125;
    &#125;);
    System.out.println(userInfo);

    // 查询多个对象, 这个回调方式, 一条记录回调一次, 不返回结果, 我们可以用List去一条一条的接收数据
    List&lt;UserInfo&gt; userInfos = new ArrayList&lt;&gt;();
    jdbcTemplate.query(&quot;select * from user_info&quot;, rs -&gt; &#123;
        userInfos.add(new UserInfo(rs.getInt(1), rs.getString(2)));
    &#125;);
    System.out.println(userInfos);
&#125;

@Data
@NoArgsConstructor
@AllArgsConstructor
public static class UserInfo &#123;
    private int userId;
    private String userName;
&#125;
</code></pre>
<pre><code>UserInfo(userId=1, userName=Java)
[UserInfo(userId=1, userName=Java), UserInfo(userId=2, userName=Python), UserInfo(userId=3, userName=JavaScript)]
</code></pre>
<h3 id="2、query-String-sql-RowCallbackHandler-rch-Nullable-Object…-args"><a href="#2、query-String-sql-RowCallbackHandler-rch-Nullable-Object…-args" class="headerlink" title="2、query(String sql, RowCallbackHandler rch, @Nullable Object… args)"></a>2、query(String sql, RowCallbackHandler rch, @Nullable Object… args)</h3><pre><code class="java">public &lt;T&gt; T query(String sql, ResultSetExtractor&lt;T&gt; rse, @Nullable Object... args) throws DataAccessException &#123;&#125;
</code></pre>
<p>和上面的方法类似，只不过把参数改为动态可传参数的形式。如果没有参数就传个空的数组。主要是针对有可变参数的SQL。</p>
<pre><code class="java">@Autowired
JdbcTemplate jdbcTemplate;

@PostConstruct
public void execute() &#123;
    // 先初始化表和初始化数据
    jdbcTemplate.execute(&quot;drop table if exists user_info&quot;);
    jdbcTemplate.execute(&quot;create table user_info(user_id int primary key, user_name varchar(255))&quot;);
    jdbcTemplate.update(&quot;insert into user_info values(1, &#39;Java&#39;)&quot;);
    jdbcTemplate.update(&quot;insert into user_info values(2, &#39;Python&#39;)&quot;);
    jdbcTemplate.update(&quot;insert into user_info values(3, &#39;JavaScript&#39;)&quot;);

    // 查询单个对象, 这个回调方式, 一条记录回调一次, 不返回结果
    UserInfo userInfo = new UserInfo();
    jdbcTemplate.query(&quot;select * from user_info where user_id = ?&quot;, new RowCallbackHandler() &#123;
        @Override
        public void processRow(ResultSet rs) throws SQLException &#123;
            userInfo.setUserId(rs.getInt(1));
            userInfo.setUserName(rs.getString(2));
        &#125;
    &#125;, 1);
    System.out.println(userInfo);

    // 查询多个对象, 这个回调方式, 一条记录回调一次, 不返回结果, 我们可以用List去一条一条的接收数据
    List&lt;UserInfo&gt; userInfos = new ArrayList&lt;&gt;();
    jdbcTemplate.query(&quot;select * from user_info where user_id &lt; ?&quot;, rs -&gt; &#123;
        userInfos.add(new UserInfo(rs.getInt(1), rs.getString(2)));
    &#125;, 4);
    System.out.println(userInfos);
&#125;

@Data
@NoArgsConstructor
@AllArgsConstructor
public static class UserInfo &#123;
    private int userId;
    private String userName;
&#125;
</code></pre>
<pre><code>UserInfo(userId=1, userName=Java)
[UserInfo(userId=1, userName=Java), UserInfo(userId=2, userName=Python), UserInfo(userId=3, userName=JavaScript)]
</code></pre>
<h3 id="3、query-String-sql-Object-args-int-argTypes-RowCallbackHandler-rch"><a href="#3、query-String-sql-Object-args-int-argTypes-RowCallbackHandler-rch" class="headerlink" title="3、query(String sql, Object[] args, int[] argTypes, RowCallbackHandler rch)"></a>3、query(String sql, Object[] args, int[] argTypes, RowCallbackHandler rch)</h3><pre><code class="java">public void query(String sql, Object[] args, int[] argTypes, RowCallbackHandler rch) throws DataAccessException &#123;&#125;
</code></pre>
<p>在上面方法得基础多多了一个SQL参数类型，该参数可有可无。</p>
<ul>
<li><p>第一个参数：要查询的SQL。</p>
</li>
<li><p>第二个参数：如果SQL中有动态参数，则此为sql中占位符参数的数组，注意顺序保持一致。如果没有则为null。</p>
</li>
<li><p>第三个参数：如果SQL有占位符需要处理参数，则此为参数的数据类型，如果sql中没有参数，则为null。该参数可有可无。</p>
</li>
<li><p>第四个参数：对结果集的每一行进行处理，转换成想要的对象。不需要做ResultSet.next()判断。</p>
</li>
</ul>
<pre><code class="java">@Autowired
JdbcTemplate jdbcTemplate;

@PostConstruct
public void execute() &#123;
    // 先初始化表和初始化数据
    jdbcTemplate.execute(&quot;drop table if exists user_info&quot;);
    jdbcTemplate.execute(&quot;create table user_info(user_id int primary key, user_name varchar(255))&quot;);
    jdbcTemplate.update(&quot;insert into user_info values(1, &#39;Java&#39;)&quot;);
    jdbcTemplate.update(&quot;insert into user_info values(2, &#39;Python&#39;)&quot;);
    jdbcTemplate.update(&quot;insert into user_info values(3, &#39;JavaScript&#39;)&quot;);

    // 查询单个对象, 这个回调方式, 一条记录回调一次, 不返回结果
    Object[] param1 = &#123;1&#125;;
    int[] index1 = &#123;Types.INTEGER&#125;;
    String sql = &quot;select * from user_info where user_id = ?&quot;;
    UserInfo userInfo = new UserInfo();
    jdbcTemplate.query(sql, param1, index1, new RowCallbackHandler() &#123;
        @Override
        public void processRow(ResultSet rs) throws SQLException &#123;
            userInfo.setUserId(rs.getInt(1));
            userInfo.setUserName(rs.getString(2));
        &#125;
    &#125;);
    System.out.println(userInfo);

    // 查询多个对象, 这个回调方式, 一条记录回调一次, 不返回结果, 我们可以用List去一条一条的接收数据
    Object[] param2 = &#123;4&#125;;
    int[] index2 = &#123;Types.INTEGER&#125;;
    sql = &quot;select * from user_info where user_id &lt; ?&quot;;
    List&lt;UserInfo&gt; userInfos = new ArrayList&lt;&gt;();
    jdbcTemplate.query(sql, param2, index2, rs -&gt; &#123;
        userInfos.add(new UserInfo(rs.getInt(1), rs.getString(2)));
    &#125;);
    System.out.println(userInfos);
&#125;

@Data
@NoArgsConstructor
@AllArgsConstructor
public static class UserInfo &#123;
    private int userId;
    private String userName;
&#125;
</code></pre>
<pre><code>UserInfo(userId=1, userName=Java)
[UserInfo(userId=1, userName=Java), UserInfo(userId=2, userName=Python), UserInfo(userId=3, userName=JavaScript)]
</code></pre>
<h3 id="4、query-String-sql-Nullable-PreparedStatementSetter-pss-RowCallbackHandler-rch"><a href="#4、query-String-sql-Nullable-PreparedStatementSetter-pss-RowCallbackHandler-rch" class="headerlink" title="4、query(String sql, @Nullable PreparedStatementSetter pss, RowCallbackHandler rch)"></a>4、query(String sql, @Nullable PreparedStatementSetter pss, RowCallbackHandler rch)</h3><pre><code class="java">public void query(String sql, @Nullable PreparedStatementSetter pss, RowCallbackHandler rch) throws DataAccessException &#123;&#125;
</code></pre>
<ul>
<li>第一个参数：需要查询的SQL。</li>
<li>第二个参数：对SQL中的参数处理，如果没有则不处理。</li>
<li>第三个参数：对结果集的每一行进行处理，转换成想要的对象。不需要做ResultSet.next()判断。</li>
</ul>
<pre><code class="java">@Autowired
JdbcTemplate jdbcTemplate;

@PostConstruct
public void execute() &#123;
    // 先初始化表和初始化数据
    jdbcTemplate.execute(&quot;drop table if exists user_info&quot;);
    jdbcTemplate.execute(&quot;create table user_info(user_id int primary key, user_name varchar(255))&quot;);
    jdbcTemplate.update(&quot;insert into user_info values(1, &#39;Java&#39;)&quot;);
    jdbcTemplate.update(&quot;insert into user_info values(2, &#39;Python&#39;)&quot;);
    jdbcTemplate.update(&quot;insert into user_info values(3, &#39;JavaScript&#39;)&quot;);

    // 查询单个对象, 这个回调方式, 一条记录回调一次, 不返回结果
    UserInfo userInfo = new UserInfo();
    String sql = &quot;select * from user_info where user_id = ?&quot;;
    jdbcTemplate.query(sql, new PreparedStatementSetter() &#123;
        @Override
        public void setValues(PreparedStatement ps) throws SQLException &#123;
            ps.setInt(1, 1);
        &#125;
    &#125;, new RowCallbackHandler() &#123;
        @Override
        public void processRow(ResultSet rs) throws SQLException &#123;
            userInfo.setUserId(rs.getInt(1));
            userInfo.setUserName(rs.getString(2));
        &#125;
    &#125;);
    System.out.println(userInfo);

    // 查询多个对象, 这个回调方式, 一条记录回调一次, 不返回结果, 我们可以用List去一条一条的接收数据
    List&lt;UserInfo&gt; userInfos = new ArrayList&lt;&gt;();
    sql = &quot;select * from user_info where user_id &lt; ?&quot;;
    jdbcTemplate.query(sql, ps -&gt; ps.setInt(1, 4), rs -&gt; &#123;
        userInfos.add(new UserInfo(rs.getInt(1), rs.getString(2)));
    &#125;);
    System.out.println(userInfos);
&#125;

@Data
@NoArgsConstructor
@AllArgsConstructor
public static class UserInfo &#123;
    private int userId;
    private String userName;
&#125;
</code></pre>
<pre><code>UserInfo(userId=1, userName=Java)
[UserInfo(userId=1, userName=Java), UserInfo(userId=2, userName=Python), UserInfo(userId=3, userName=JavaScript)]
</code></pre>
<h3 id="5、query-PreparedStatementCreator-psc-RowCallbackHandler-rch"><a href="#5、query-PreparedStatementCreator-psc-RowCallbackHandler-rch" class="headerlink" title="5、query(PreparedStatementCreator psc, RowCallbackHandler rch)"></a>5、query(PreparedStatementCreator psc, RowCallbackHandler rch)</h3><pre><code class="java">public void query(PreparedStatementCreator psc, RowCallbackHandler rch) throws DataAccessException &#123;&#125;
</code></pre>
<ul>
<li>参数一：构建一个预编译的SQL语句，如果有可变参数，给其赋值。</li>
<li>参数二：用户处理每一行的结果集，不需要判断ResultSet.next()。</li>
<li>注意：这是个没有返回值的方法。</li>
</ul>
<pre><code class="java">@Autowired
JdbcTemplate jdbcTemplate;

@PostConstruct
public void execute() &#123;
    // 先初始化表和初始化数据
    jdbcTemplate.execute(&quot;drop table if exists user_info&quot;);
    jdbcTemplate.execute(&quot;create table user_info(user_id int primary key, user_name varchar(255))&quot;);
    jdbcTemplate.update(&quot;insert into user_info values(1, &#39;Java&#39;)&quot;);
    jdbcTemplate.update(&quot;insert into user_info values(2, &#39;Python&#39;)&quot;);
    jdbcTemplate.update(&quot;insert into user_info values(3, &#39;JavaScript&#39;)&quot;);

    // 查询单个对象, 这个回调方式, 一条记录回调一次, 不返回结果
    UserInfo userInfo = new UserInfo();
    jdbcTemplate.query(new PreparedStatementCreator() &#123;
        @Override
        public PreparedStatement createPreparedStatement(Connection con) throws SQLException &#123;
            String sql = &quot;select * from user_info where user_id = ?&quot;;
            PreparedStatement ps = con.prepareStatement(sql);
            ps.setInt(1, 1);
            return ps;
        &#125;
    &#125;, new RowCallbackHandler() &#123;
        @Override
        public void processRow(ResultSet rs) throws SQLException &#123;
            userInfo.setUserId(rs.getInt(1));
            userInfo.setUserName(rs.getString(2));
        &#125;
    &#125;);
    System.out.println(userInfo);

    // 查询多个对象, 这个回调方式, 一条记录回调一次, 不返回结果, 我们可以用List去一条一条的接收数据
    List&lt;UserInfo&gt; userInfos = new ArrayList&lt;&gt;();
    jdbcTemplate.query(con -&gt; &#123;
        String sql = &quot;select * from user_info where user_id &lt; ?&quot;;
        PreparedStatement ps = con.prepareStatement(sql);
        ps.setInt(1, 4);
        return ps;
    &#125;, rs -&gt; &#123;
        userInfos.add(new UserInfo(rs.getInt(1), rs.getString(2)));
    &#125;);
    System.out.println(userInfos);
&#125;

@Data
@NoArgsConstructor
@AllArgsConstructor
public static class UserInfo &#123;
    private int userId;
    private String userName;
&#125;
</code></pre>
<h3 id="6、query-String-sql-ResultSetExtractor-rse"><a href="#6、query-String-sql-ResultSetExtractor-rse" class="headerlink" title="6、query(String sql, ResultSetExtractor rse)"></a>6、query(String sql, ResultSetExtractor rse)</h3><pre><code class="java">public &lt;T&gt; T query(final String sql, final ResultSetExtractor&lt;T&gt; rse) throws DataAccessException &#123;&#125;
</code></pre>
<p>该方法返回一个泛型对象。SQL为查询的SQL语句，ResultSetExtractor是结果集数据提取用的，通过extractData(ResultSet rs)处理整个结果集。不支持传入参数。可以根据自己想要的类型返回结果，需要手工处理结果集。这种查询处理既可以查询单条数据，也可以查询多条数据。</p>
<pre><code class="java">@Autowired
JdbcTemplate jdbcTemplate;

@PostConstruct
public void execute() &#123;
    // 先初始化表和初始化数据
    jdbcTemplate.execute(&quot;drop table if exists user_info&quot;);
    jdbcTemplate.execute(&quot;create table user_info(user_id int primary key, user_name varchar(255))&quot;);
    jdbcTemplate.update(&quot;insert into user_info values(1, &#39;Java&#39;)&quot;);
    jdbcTemplate.update(&quot;insert into user_info values(2, &#39;Python&#39;)&quot;);
    jdbcTemplate.update(&quot;insert into user_info values(3, &#39;JavaScript&#39;)&quot;);

    // 查询单个对象, 这个回调方式, 接收的是批量的结果，一次对所有的结果进行转换, 返回泛型&lt;T&gt;
    String sql = &quot;select * from user_info where user_id = 1&quot;;
    UserInfo userInfo = jdbcTemplate.query(sql, new ResultSetExtractor&lt;UserInfo&gt;() &#123;
        @Override
        public UserInfo extractData(ResultSet rs) throws SQLException, DataAccessException &#123;
            rs.next();
            return new UserInfo(rs.getInt(1), rs.getString(2));
        &#125;
    &#125;);
    System.out.println(userInfo);

    // 查询多个对象, 这个回调方式, 接收的是批量的结果，一次对所有的结果进行转换, 返回List&lt;T&gt;
    List&lt;UserInfo&gt; userInfos = jdbcTemplate.query(&quot;select * from user_info&quot;, rs -&gt; &#123;
        List&lt;UserInfo&gt; list = new ArrayList&lt;&gt;();
        while (rs.next()) &#123;
            list.add(new UserInfo(rs.getInt(1), rs.getString(2)));
        &#125;
        return list;
    &#125;);
    System.out.println(userInfos);
&#125;

@Data
@NoArgsConstructor
@AllArgsConstructor
public static class UserInfo &#123;
    private int userId;
    private String userName;
&#125;
</code></pre>
<pre><code>UserInfo(userId=1, userName=Java)
[UserInfo(userId=1, userName=Java), UserInfo(userId=2, userName=Python), UserInfo(userId=3, userName=JavaScript)]
</code></pre>
<h3 id="7、query-String-sql-ResultSetExtractor-rse-Nullable-Object…-args"><a href="#7、query-String-sql-ResultSetExtractor-rse-Nullable-Object…-args" class="headerlink" title="7、query(String sql, ResultSetExtractor rse, @Nullable Object… args)"></a>7、query(String sql, ResultSetExtractor rse, @Nullable Object… args)</h3><pre><code class="java">public &lt;T&gt; T query(String sql, ResultSetExtractor&lt;T&gt; rse, @Nullable Object... args) throws DataAccessException &#123;&#125;
</code></pre>
<p>和上面的方法类似，只不过把参数改为动态可传参数的形式。如果没有参数就传个空的数组。主要是针对有可变参数的SQL。</p>
<pre><code class="java">@Autowired
JdbcTemplate jdbcTemplate;

@PostConstruct
public void execute() &#123;
    // 先初始化表和初始化数据
    jdbcTemplate.execute(&quot;drop table if exists user_info&quot;);
    jdbcTemplate.execute(&quot;create table user_info(user_id int primary key, user_name varchar(255))&quot;);
    jdbcTemplate.update(&quot;insert into user_info values(1, &#39;Java&#39;)&quot;);
    jdbcTemplate.update(&quot;insert into user_info values(2, &#39;Python&#39;)&quot;);
    jdbcTemplate.update(&quot;insert into user_info values(3, &#39;JavaScript&#39;)&quot;);

    // 查询单个对象, 这个回调方式, 接收的是批量的结果，一次对所有的结果进行转换, 返回泛型&lt;T&gt;
    String sql = &quot;select * from user_info where user_id = ?&quot;;
    UserInfo userInfo = jdbcTemplate.query(sql, new ResultSetExtractor&lt;UserInfo&gt;() &#123;
        @Override
        public UserInfo extractData(ResultSet rs) throws SQLException, DataAccessException &#123;
            rs.next();
            return new UserInfo(rs.getInt(1), rs.getString(2));
        &#125;
    &#125;, 1);
    System.out.println(userInfo);

    // 查询多个对象, 这个回调方式, 接收的是批量的结果，一次对所有的结果进行转换, 返回List&lt;T&gt;
    sql = &quot;select * from user_info where user_id &lt; ?&quot;;
    List&lt;UserInfo&gt; userInfos = jdbcTemplate.query(sql, rs -&gt; &#123;
        List&lt;UserInfo&gt; list = new ArrayList&lt;&gt;();
        while (rs.next()) &#123;
            list.add(new UserInfo(rs.getInt(1), rs.getString(2)));
        &#125;
        return list;
    &#125;, 4);
    System.out.println(userInfos);
&#125;

@Data
@NoArgsConstructor
@AllArgsConstructor
public static class UserInfo &#123;
    private int userId;
    private String userName;
&#125;
</code></pre>
<pre><code>UserInfo(userId=1, userName=Java)
[UserInfo(userId=1, userName=Java), UserInfo(userId=2, userName=Python), UserInfo(userId=3, userName=JavaScript)]
</code></pre>
<h3 id="8、query-String-sql-Object-args-int-argTypes-ResultSetExtractor-rse"><a href="#8、query-String-sql-Object-args-int-argTypes-ResultSetExtractor-rse" class="headerlink" title="8、query(String sql, Object[] args, int[] argTypes, ResultSetExtractor rse)"></a>8、query(String sql, Object[] args, int[] argTypes, ResultSetExtractor rse)</h3><pre><code class="java">public &lt;T&gt; T query(String sql, Object[] args, int[] argTypes, ResultSetExtractor&lt;T&gt; rse) throws DataAccessException &#123;&#125;
</code></pre>
<p>这个方式和上面的几个没有什么差别，看一下方法内部的调用就知道了，也是调用的query(PreparedStatementCreator psc, @Nullable final PreparedStatementSetter pss, final ResultSetExtractor&lt; T &gt; rse)，只不过把Object[] args, int[] argTypes这两个参数分开了。主要是针对有可变参数的sql。这两个参数的意思是：</p>
<ul>
<li>Object[] args：占位符对应的参数值。</li>
<li>int[] argTypes：占位符参数值的类型。</li>
</ul>
<pre><code class="java">@Autowired
JdbcTemplate jdbcTemplate;

@PostConstruct
public void execute() &#123;
    // 先初始化表和初始化数据
    jdbcTemplate.execute(&quot;drop table if exists user_info&quot;);
    jdbcTemplate.execute(&quot;create table user_info(user_id int primary key, user_name varchar(255))&quot;);
    jdbcTemplate.update(&quot;insert into user_info values(1, &#39;Java&#39;)&quot;);
    jdbcTemplate.update(&quot;insert into user_info values(2, &#39;Python&#39;)&quot;);
    jdbcTemplate.update(&quot;insert into user_info values(3, &#39;JavaScript&#39;)&quot;);

    // 查询单个对象, 这个回调方式, 接收的是批量的结果，一次对所有的结果进行转换, 返回泛型&lt;T&gt;
    Object[] param1 = &#123;1&#125;;
    int[] index1 = &#123;Types.INTEGER&#125;;
    String sql = &quot;select * from user_info where user_id = ?&quot;;
    UserInfo userInfo = jdbcTemplate.query(sql, param1, index1, new ResultSetExtractor&lt;UserInfo&gt;() &#123;
        @Override
        public UserInfo extractData(ResultSet rs) throws SQLException, DataAccessException &#123;
            rs.next();
            return new UserInfo(rs.getInt(1), rs.getString(2));
        &#125;
    &#125;);
    System.out.println(userInfo);

    // 查询多个对象, 这个回调方式, 接收的是批量的结果，一次对所有的结果进行转换, 返回List&lt;T&gt;
    Object[] param2 = &#123;4&#125;;
    int[] index2 = &#123;Types.INTEGER&#125;;
    sql = &quot;select * from user_info where user_id &lt; ?&quot;;
    List&lt;UserInfo&gt; userInfos = jdbcTemplate.query(sql, param2, index2, rs -&gt; &#123;
        List&lt;UserInfo&gt; list = new ArrayList&lt;&gt;();
        while (rs.next()) &#123;
            list.add(new UserInfo(rs.getInt(1), rs.getString(2)));
        &#125;
        return list;
    &#125;);
    System.out.println(userInfos);
&#125;

@Data
@NoArgsConstructor
@AllArgsConstructor
public static class UserInfo &#123;
    private int userId;
    private String userName;
&#125;
</code></pre>
<pre><code>UserInfo(userId=1, userName=Java)
[UserInfo(userId=1, userName=Java), UserInfo(userId=2, userName=Python), UserInfo(userId=3, userName=JavaScript)]
</code></pre>
<h3 id="9、query-String-sql-Nullable-PreparedStatementSetter-pss-ResultSetExtractor-T-rse"><a href="#9、query-String-sql-Nullable-PreparedStatementSetter-pss-ResultSetExtractor-T-rse" class="headerlink" title="9、query(String sql, @Nullable PreparedStatementSetter pss, ResultSetExtractor&lt; T &gt; rse)"></a>9、query(String sql, @Nullable PreparedStatementSetter pss, ResultSetExtractor&lt; T &gt; rse)</h3><pre><code class="java">public &lt;T&gt; T query(String sql, @Nullable PreparedStatementSetter pss, ResultSetExtractor&lt;T&gt; rse) throws DataAccessException &#123;&#125;
</code></pre>
<p>和上面的方法一样，使用的是PreparedStatementSetter来支持动态的参数，需要处理SQL中的占位符。具体的处理方式都一样。</p>
<pre><code class="java">@Autowired
JdbcTemplate jdbcTemplate;

@PostConstruct
public void execute() &#123;
    // 先初始化表和初始化数据
    jdbcTemplate.execute(&quot;drop table if exists user_info&quot;);
    jdbcTemplate.execute(&quot;create table user_info(user_id int primary key, user_name varchar(255))&quot;);
    jdbcTemplate.update(&quot;insert into user_info values(1, &#39;Java&#39;)&quot;);
    jdbcTemplate.update(&quot;insert into user_info values(2, &#39;Python&#39;)&quot;);
    jdbcTemplate.update(&quot;insert into user_info values(3, &#39;JavaScript&#39;)&quot;);

    // 查询单个对象, 这个回调方式, 接收的是批量的结果，一次对所有的结果进行转换, 返回泛型&lt;T&gt;
    String sql = &quot;select * from user_info where user_id = ?&quot;;
    UserInfo userInfo = jdbcTemplate.query(sql, new PreparedStatementSetter() &#123;
        @Override
        public void setValues(PreparedStatement ps) throws SQLException &#123;
            ps.setInt(1, 1);
        &#125;
    &#125;, new ResultSetExtractor&lt;UserInfo&gt;() &#123;
        @Override
        public UserInfo extractData(ResultSet rs) throws SQLException, DataAccessException &#123;
            rs.next();
            return new UserInfo(rs.getInt(1), rs.getString(2));
        &#125;
    &#125;);
    System.out.println(userInfo);

    // 查询多个对象, 这个回调方式, 接收的是批量的结果，一次对所有的结果进行转换, 返回List&lt;T&gt;
    sql = &quot;select * from user_info where user_id &lt; ?&quot;;
    List&lt;UserInfo&gt; userInfos = jdbcTemplate.query(sql, ps -&gt; ps.setInt(1, 4), rs -&gt; &#123;
        List&lt;UserInfo&gt; list = new ArrayList&lt;&gt;();
        while (rs.next()) &#123;
            list.add(new UserInfo(rs.getInt(1), rs.getString(2)));
        &#125;
        return list;
    &#125;);
    System.out.println(userInfos);
&#125;

@Data
@NoArgsConstructor
@AllArgsConstructor
public static class UserInfo &#123;
    private int userId;
    private String userName;
&#125;
</code></pre>
<pre><code>UserInfo(userId=1, userName=Java)
[UserInfo(userId=1, userName=Java), UserInfo(userId=2, userName=Python), UserInfo(userId=3, userName=JavaScript)]
</code></pre>
<h3 id="10、query-PreparedStatementCreator-psc-Nullable-final-PreparedStatementSetter-pss-final-ResultSetExtractor-T-rse"><a href="#10、query-PreparedStatementCreator-psc-Nullable-final-PreparedStatementSetter-pss-final-ResultSetExtractor-T-rse" class="headerlink" title="10、query(PreparedStatementCreator psc, @Nullable final PreparedStatementSetter pss, final ResultSetExtractor&lt; T &gt; rse)"></a>10、query(PreparedStatementCreator psc, @Nullable final PreparedStatementSetter pss, final ResultSetExtractor&lt; T &gt; rse)</h3><pre><code class="java">public &lt;T&gt; T query(PreparedStatementCreator psc, 
                   @Nullable final PreparedStatementSetter pss, 
                   final ResultSetExtractor&lt;T&gt; rse) throws DataAccessException &#123;&#125;
</code></pre>
<p><em><strong>这是个很重要的方法，其它很多query()方法底层都是调用这个方法实现的。</strong></em>该方法有三个参数：</p>
<ul>
<li><p>PreparedStatementCreator：创建一个预编译的SQL语句。</p>
</li>
<li><p>PreparedStatementSetter：如果SQL中有动态的参数占位符，则给占位符赋值参数值。</p>
</li>
<li><p>ResultSetExtractor：处理SQL执行的结果，将结果集中每一行转换为需要对象，需要先调用ResultSet.next()。</p>
</li>
</ul>
<pre><code class="java">@Autowired
JdbcTemplate jdbcTemplate;

@PostConstruct
public void execute() &#123;
    // 先初始化表和初始化数据
    jdbcTemplate.execute(&quot;drop table if exists user_info&quot;);
    jdbcTemplate.execute(&quot;create table user_info(user_id int primary key, user_name varchar(255))&quot;);
    jdbcTemplate.update(&quot;insert into user_info values(1, &#39;Java&#39;)&quot;);
    jdbcTemplate.update(&quot;insert into user_info values(2, &#39;Python&#39;)&quot;);
    jdbcTemplate.update(&quot;insert into user_info values(3, &#39;JavaScript&#39;)&quot;);

    // 查询单个对象, 这个回调方式, 接收的是批量的结果，一次对所有的结果进行转换, 返回泛型&lt;T&gt;
    UserInfo userInfo = jdbcTemplate.query(new PreparedStatementCreator() &#123;
        @Override
        public PreparedStatement createPreparedStatement(Connection con) throws SQLException &#123;
            String sql = &quot;select * from user_info where user_id = ?&quot;;
            return con.prepareStatement(sql);
        &#125;
    &#125;, new PreparedStatementSetter() &#123;
        @Override
        public void setValues(PreparedStatement ps) throws SQLException &#123;
            ps.setInt(1, 1);
        &#125;
    &#125;, new ResultSetExtractor&lt;UserInfo&gt;() &#123;
        @Override
        public UserInfo extractData(ResultSet rs) throws SQLException, DataAccessException &#123;
            rs.next();
            return new UserInfo(rs.getInt(1), rs.getString(2));
        &#125;
    &#125;);
    System.out.println(userInfo);

    // 查询多个对象, 这个回调方式, 接收的是批量的结果，一次对所有的结果进行转换, 返回List&lt;T&gt;
    List&lt;UserInfo&gt; userInfos = jdbcTemplate.query(con -&gt; &#123;
        String sql = &quot;select * from user_info where user_id &lt; ?&quot;;
        return con.prepareStatement(sql);
    &#125;, ps -&gt; ps.setInt(1, 4), rs -&gt; &#123;
        List&lt;UserInfo&gt; list = new ArrayList&lt;&gt;();
        while (rs.next()) &#123;
            list.add(new UserInfo(rs.getInt(1), rs.getString(2)));
        &#125;
        return list;
    &#125;);
    System.out.println(userInfos);
&#125;

@Data
@NoArgsConstructor
@AllArgsConstructor
public static class UserInfo &#123;
    private int userId;
    private String userName;
&#125;
</code></pre>
<pre><code>UserInfo(userId=1, userName=Java)
[UserInfo(userId=1, userName=Java), UserInfo(userId=2, userName=Python), UserInfo(userId=3, userName=JavaScript)]
</code></pre>
<h3 id="11、query-PreparedStatementCreator-psc-final-ResultSetExtractor-T-rse"><a href="#11、query-PreparedStatementCreator-psc-final-ResultSetExtractor-T-rse" class="headerlink" title="11、query(PreparedStatementCreator psc, final ResultSetExtractor&lt; T &gt; rse)"></a>11、query(PreparedStatementCreator psc, final ResultSetExtractor&lt; T &gt; rse)</h3><pre><code class="java">public &lt;T&gt; T query(PreparedStatementCreator psc, ResultSetExtractor&lt;T&gt; rse) throws DataAccessException &#123;&#125;
</code></pre>
<p>该方法其实和上面的一样，从其方法内部的实现可以看出就是调用上面的方法（query(PreparedStatementCreator psc, @Nullable final PreparedStatementSetter pss, final ResultSetExtractor&lt; T &gt; rse)）。只是不支持传入动态的参数了，使用方式和上面类似：</p>
<pre><code class="java">@Autowired
JdbcTemplate jdbcTemplate;

@PostConstruct
public void execute() &#123;
    // 先初始化表和初始化数据
    jdbcTemplate.execute(&quot;drop table if exists user_info&quot;);
    jdbcTemplate.execute(&quot;create table user_info(user_id int primary key, user_name varchar(255))&quot;);
    jdbcTemplate.update(&quot;insert into user_info values(1, &#39;Java&#39;)&quot;);
    jdbcTemplate.update(&quot;insert into user_info values(2, &#39;Python&#39;)&quot;);
    jdbcTemplate.update(&quot;insert into user_info values(3, &#39;JavaScript&#39;)&quot;);

    // 查询单个对象, 这个回调方式, 接收的是批量的结果，一次对所有的结果进行转换, 返回泛型&lt;T&gt;
    UserInfo userInfo = jdbcTemplate.query(new PreparedStatementCreator() &#123;
        @Override
        public PreparedStatement createPreparedStatement(Connection con) throws SQLException &#123;
            String sql = &quot;select * from user_info where user_id = ?&quot;;
            PreparedStatement ps = con.prepareStatement(sql);
            ps.setInt(1, 1); // 实际上这种方式不算是动态传参
            return ps;
        &#125;
    &#125;, new ResultSetExtractor&lt;UserInfo&gt;() &#123;
        @Override
        public UserInfo extractData(ResultSet rs) throws SQLException, DataAccessException &#123;
            rs.next();
            return new UserInfo(rs.getInt(1), rs.getString(2));
        &#125;
    &#125;);
    System.out.println(userInfo);

    // 查询多个对象, 这个回调方式, 接收的是批量的结果，一次对所有的结果进行转换, 返回List&lt;T&gt;
    List&lt;UserInfo&gt; userInfos = jdbcTemplate.query(con -&gt; &#123;
        String sql = &quot;select * from user_info where user_id &lt; ?&quot;;
        PreparedStatement ps = con.prepareStatement(sql);
        ps.setInt(1, 4); // 实际上这种方式不算是动态传参
        return ps;
    &#125;, rs -&gt; &#123;
        List&lt;UserInfo&gt; list = new ArrayList&lt;&gt;();
        while (rs.next()) &#123;
            list.add(new UserInfo(rs.getInt(1), rs.getString(2)));
        &#125;
        return list;
    &#125;);
    System.out.println(userInfos);
&#125;

@Data
@NoArgsConstructor
@AllArgsConstructor
public static class UserInfo &#123;
    private int userId;
    private String userName;
&#125;
</code></pre>
<pre><code>UserInfo(userId=1, userName=Java)
[UserInfo(userId=1, userName=Java), UserInfo(userId=2, userName=Python), UserInfo(userId=3, userName=JavaScript)]
</code></pre>
<h3 id="12、query-String-sql-RowMapper-T-rowMapper"><a href="#12、query-String-sql-RowMapper-T-rowMapper" class="headerlink" title="12、query(String sql, RowMapper&lt; T &gt; rowMapper)"></a>12、query(String sql, RowMapper&lt; T &gt; rowMapper)</h3><pre><code class="java">public &lt;T&gt; List&lt;T&gt; query(String sql, RowMapper&lt;T&gt; rowMapper) throws DataAccessException &#123;&#125;
</code></pre>
<p>该方法返回一个RowMapper指定泛型对象的List集合，用户需要通过mapRow(ResultSet rs, int rowNum)实现方法手动将每一行转换为需要的类型，可以是Map也可以是自定义的对象。不支持动态传入参数。</p>
<pre><code class="java">@Autowired
JdbcTemplate jdbcTemplate;

@PostConstruct
public void execute() &#123;
    // 先初始化表和初始化数据
    jdbcTemplate.execute(&quot;drop table if exists user_info&quot;);
    jdbcTemplate.execute(&quot;create table user_info(user_id int primary key, user_name varchar(255))&quot;);
    jdbcTemplate.update(&quot;insert into user_info values(1, &#39;Java&#39;)&quot;);
    jdbcTemplate.update(&quot;insert into user_info values(2, &#39;Python&#39;)&quot;);
    jdbcTemplate.update(&quot;insert into user_info values(3, &#39;JavaScript&#39;)&quot;);

    // 这个回调方式, 一行数据回调一次, 结果自动封装到List中, 可理解为 RowCallbackHandler + ResultSetExtractor
    String sql = &quot;select * from user_info where user_id = 1&quot;;
    jdbcTemplate.query(sql, new RowMapper&lt;UserInfo&gt;() &#123;
        @Override
        public UserInfo mapRow(ResultSet rs, int rowNum) throws SQLException &#123;
            return new UserInfo(rs.getInt(1), rs.getString(2));
        &#125;
    &#125;);

    // BeanPropertyRowMapper 为 RowMapper的子类, 可以直接转换为 Java Bean, 是 Spring 封装的.
    sql = &quot;select * from user_info&quot;;
    userInfos = jdbcTemplate.query(sql, new BeanPropertyRowMapper&lt;&gt;(UserInfo.class));
    System.out.println(userInfos);

    // ColumnMapRowMapper 为 RowMapper的子类, 可以直接转换为 Map, 是 Spring 封装的.
    List&lt;Map&lt;String, Object&gt;&gt; userNames = jdbcTemplate.query(sql, new ColumnMapRowMapper());
    System.out.println(userNames);

    // 查询多行单列
    List&lt;Integer&gt; ids = jdbcTemplate.query(sql, (rs, rowNum) -&gt; rs.getInt(1));
    System.out.println(ids);
&#125;

@Data
@NoArgsConstructor
@AllArgsConstructor
public static class UserInfo &#123;
    private int userId;
    private String userName;
&#125;
</code></pre>
<pre><code>[UserInfo(userId=1, userName=Java)]
[UserInfo(userId=1, userName=Java), UserInfo(userId=2, userName=Python), UserInfo(userId=3, userName=JavaScript)]
[&#123;user_id=1, user_name=Java&#125;, &#123;user_id=2, user_name=Python&#125;, &#123;user_id=3, user_name=JavaScript&#125;]
[1, 2, 3]
</code></pre>
<h3 id="13、query-String-sql-RowMapper-T-rowMapper-Nullable-Object…-args"><a href="#13、query-String-sql-RowMapper-T-rowMapper-Nullable-Object…-args" class="headerlink" title="13、query(String sql, RowMapper&lt; T &gt; rowMapper, @Nullable Object… args)"></a>13、query(String sql, RowMapper&lt; T &gt; rowMapper, @Nullable Object… args)</h3><pre><code class="java">public &lt;T&gt; List&lt;T&gt; query(String sql, RowMapper&lt;T&gt; rowMapper, @Nullable Object... args) throws DataAccessException &#123;&#125;
</code></pre>
<ul>
<li>第一个参数：需要执行的查询SQL。</li>
<li>第二个参数：查询结果的每一行结果集。</li>
<li>第三个参数：采用多参数组的形式，指SQL中占位符的参数值，没有则不写。</li>
</ul>
<pre><code class="java">@Autowired
JdbcTemplate jdbcTemplate;

@PostConstruct
public void execute() &#123;
    // 先初始化表和初始化数据
    jdbcTemplate.execute(&quot;drop table if exists user_info&quot;);
    jdbcTemplate.execute(&quot;create table user_info(user_id int primary key, user_name varchar(255))&quot;);
    jdbcTemplate.update(&quot;insert into user_info values(1, &#39;Java&#39;)&quot;);
    jdbcTemplate.update(&quot;insert into user_info values(2, &#39;Python&#39;)&quot;);
    jdbcTemplate.update(&quot;insert into user_info values(3, &#39;JavaScript&#39;)&quot;);

    // 这个回调方式, 一行数据回调一次, 结果自动封装到List中, 可理解为 RowCallbackHandler + ResultSetExtractor
    String sql = &quot;select * from user_info where user_id = ?&quot;;
    List&lt;UserInfo&gt; userInfos = jdbcTemplate.query(sql, new RowMapper&lt;UserInfo&gt;() &#123;
        @Override
        public UserInfo mapRow(ResultSet rs, int rowNum) throws SQLException &#123;
            return new UserInfo(rs.getInt(1), rs.getString(2));
        &#125;
    &#125;, 1);
    System.out.println(userInfos);

    // BeanPropertyRowMapper 为 RowMapper的子类, 可以直接转换为 Java Bean, 是 Spring 封装的.
    sql = &quot;select * from user_info where user_id &lt; ?&quot;;
    userInfos = jdbcTemplate.query(sql, new BeanPropertyRowMapper&lt;&gt;(UserInfo.class), 4);
    System.out.println(userInfos);

    // ColumnMapRowMapper 为 RowMapper的子类, 可以直接转换为 Map, 是 Spring 封装的.
    List&lt;Map&lt;String, Object&gt;&gt; userNames = jdbcTemplate.query(sql, new ColumnMapRowMapper(), 4);
    System.out.println(userNames);

    // 查询多行单列
    List&lt;Integer&gt; ids = jdbcTemplate.query(sql, (rs, rowNum) -&gt; rs.getInt(1), 4);
    System.out.println(ids);
&#125;

@Data
@NoArgsConstructor
@AllArgsConstructor
public static class UserInfo &#123;
    private int userId;
    private String userName;
&#125;
</code></pre>
<pre><code>[UserInfo(userId=1, userName=Java)]
[UserInfo(userId=1, userName=Java), UserInfo(userId=2, userName=Python), UserInfo(userId=3, userName=JavaScript)]
[&#123;user_id=1, user_name=Java&#125;, &#123;user_id=2, user_name=Python&#125;, &#123;user_id=3, user_name=JavaScript&#125;]
[1, 2, 3]
</code></pre>
<h3 id="14、query-String-sql-Object-args-int-argTypes-RowMapper-T-rowMapper"><a href="#14、query-String-sql-Object-args-int-argTypes-RowMapper-T-rowMapper" class="headerlink" title="14、query(String sql, Object[] args, int[] argTypes, RowMapper&lt; T &gt; rowMapper"></a>14、query(String sql, Object[] args, int[] argTypes, RowMapper&lt; T &gt; rowMapper</h3><pre><code class="java">public &lt;T&gt; List&lt;T&gt; query(String sql, Object[] args, int[] argTypes, RowMapper&lt;T&gt; rowMapper) throws DataAccessException &#123;&#125;
</code></pre>
<ul>
<li>第一个参数：需要执行的查询SQL。</li>
<li>第二个参数：有SQL中占位符参数构成的数组。如果没有则为传null。注意顺序保持一致。</li>
<li>第三个参数：参数值的数据库类型。如果没有则为传null。该参数可有可无。</li>
<li>第四个参数：查询结果的每一行结果集。</li>
</ul>
<pre><code class="java">@Autowired
JdbcTemplate jdbcTemplate;

@PostConstruct
public void execute() &#123;
    // 先初始化表和初始化数据
    jdbcTemplate.execute(&quot;drop table if exists user_info&quot;);
    jdbcTemplate.execute(&quot;create table user_info(user_id int primary key, user_name varchar(255))&quot;);
    jdbcTemplate.update(&quot;insert into user_info values(1, &#39;Java&#39;)&quot;);
    jdbcTemplate.update(&quot;insert into user_info values(2, &#39;Python&#39;)&quot;);
    jdbcTemplate.update(&quot;insert into user_info values(3, &#39;JavaScript&#39;)&quot;);

        // 这个回调方式, 一行数据回调一次, 结果自动封装到List中, 可理解为 RowCallbackHandler + ResultSetExtractor
        Object[] param = &#123;1&#125;;
        int[] index = &#123;Types.INTEGER&#125;;
        String sql = &quot;select * from user_info where user_id = ?&quot;;
        List&lt;UserInfo&gt; userInfos = jdbcTemplate.query(sql, param, index, new RowMapper&lt;UserInfo&gt;() &#123;
            @Override
            public UserInfo mapRow(ResultSet rs, int rowNum) throws SQLException &#123;
                return new UserInfo(rs.getInt(1), rs.getString(2));
            &#125;
        &#125;);
        System.out.println(userInfos);

        // BeanPropertyRowMapper 为 RowMapper的子类, 可以直接转换为 Java Bean, 是 Spring 封装的.
        param[0] = 4;
        sql = &quot;select * from user_info where user_id &lt; ?&quot;;
        userInfos = jdbcTemplate.query(sql, param, index, new BeanPropertyRowMapper&lt;&gt;(UserInfo.class));
        System.out.println(userInfos);

        // ColumnMapRowMapper 为 RowMapper的子类, 可以直接转换为 Map, 是 Spring 封装的.
        List&lt;Map&lt;String, Object&gt;&gt; userNames = jdbcTemplate.query(sql, param, index, new ColumnMapRowMapper());
        System.out.println(userNames);

        // 查询多行单列
        List&lt;Integer&gt; ids = jdbcTemplate.query(sql, param, index, (rs, rowNum) -&gt; rs.getInt(1));
        System.out.println(ids);
&#125;

@Data
@NoArgsConstructor
@AllArgsConstructor
public static class UserInfo &#123;
    private int userId;
    private String userName;
&#125;
</code></pre>
<pre><code>[UserInfo(userId=1, userName=Java)]
[UserInfo(userId=1, userName=Java), UserInfo(userId=2, userName=Python), UserInfo(userId=3, userName=JavaScript)]
[&#123;user_id=1, user_name=Java&#125;, &#123;user_id=2, user_name=Python&#125;, &#123;user_id=3, user_name=JavaScript&#125;]
[1, 2, 3]
</code></pre>
<h3 id="15、query-String-sql-Nullable-PreparedStatementSetter-pss-RowMapper-T-rowMapper"><a href="#15、query-String-sql-Nullable-PreparedStatementSetter-pss-RowMapper-T-rowMapper" class="headerlink" title="15、query(String sql, @Nullable PreparedStatementSetter pss, RowMapper&lt; T &gt; rowMapper)"></a>15、query(String sql, @Nullable PreparedStatementSetter pss, RowMapper&lt; T &gt; rowMapper)</h3><pre><code class="java">public &lt;T&gt; List&lt;T&gt; query(String sql, @Nullable PreparedStatementSetter pss, RowMapper&lt;T&gt; rowMapper) throws DataAccessException &#123;&#125;
</code></pre>
<p>使用的是PreparedStatementSetter来支持动态的参数，需要处理SQL中的占位符。具体的处理方式都一样。</p>
<pre><code class="java">@Autowired
JdbcTemplate jdbcTemplate;

@PostConstruct
public void execute() &#123;
    // 先初始化表和初始化数据
    jdbcTemplate.execute(&quot;drop table if exists user_info&quot;);
    jdbcTemplate.execute(&quot;create table user_info(user_id int primary key, user_name varchar(255))&quot;);
    jdbcTemplate.update(&quot;insert into user_info values(1, &#39;Java&#39;)&quot;);
    jdbcTemplate.update(&quot;insert into user_info values(2, &#39;Python&#39;)&quot;);
    jdbcTemplate.update(&quot;insert into user_info values(3, &#39;JavaScript&#39;)&quot;);

    // 这个回调方式, 一行数据回调一次, 结果自动封装到List中, 可理解为 RowCallbackHandler + ResultSetExtractor
    String sql = &quot;select * from user_info where user_id = ?&quot;;
    List&lt;UserInfo&gt; userInfos = jdbcTemplate.query(sql, new PreparedStatementSetter() &#123;
        @Override
        public void setValues(PreparedStatement ps) throws SQLException &#123;
            ps.setInt(1, 1);
        &#125;
    &#125;, new RowMapper&lt;UserInfo&gt;() &#123;
        @Override
        public UserInfo mapRow(ResultSet rs, int rowNum) throws SQLException &#123;
            return new UserInfo(rs.getInt(1), rs.getString(2));
        &#125;
    &#125;);
    System.out.println(userInfos);

    // BeanPropertyRowMapper 为 RowMapper的子类, 可以直接转换为 Java Bean, 是 Spring 封装的.
    sql = &quot;select * from user_info where user_id &lt; ?&quot;;
    userInfos = jdbcTemplate.query(sql,  ps -&gt; ps.setInt(1, 4), new BeanPropertyRowMapper&lt;&gt;(UserInfo.class));
    System.out.println(userInfos);

    // ColumnMapRowMapper 为 RowMapper的子类, 可以直接转换为 Map, 是 Spring 封装的.
    List&lt;Map&lt;String, Object&gt;&gt; userNames = jdbcTemplate.query(sql, ps -&gt; ps.setInt(1, 4), new ColumnMapRowMapper());
    System.out.println(userNames);

    // 查询多行单列
    List&lt;Integer&gt; ids = jdbcTemplate.query(sql, ps -&gt; ps.setInt(1, 4), (rs, rowNum) -&gt; rs.getInt(1));
    System.out.println(ids);
&#125;

@Data
@NoArgsConstructor
@AllArgsConstructor
public static class UserInfo &#123;
    private int userId;
    private String userName;
&#125;
</code></pre>
<pre><code>[UserInfo(userId=1, userName=Java)]
[UserInfo(userId=1, userName=Java), UserInfo(userId=2, userName=Python), UserInfo(userId=3, userName=JavaScript)]
[&#123;user_id=1, user_name=Java&#125;, &#123;user_id=2, user_name=Python&#125;, &#123;user_id=3, user_name=JavaScript&#125;]
[1, 2, 3]
</code></pre>
<h3 id="16、query-PreparedStatementCreator-psc-RowMapper-T-rowMapper"><a href="#16、query-PreparedStatementCreator-psc-RowMapper-T-rowMapper" class="headerlink" title="16、query(PreparedStatementCreator psc, RowMapper&lt; T &gt; rowMapper)"></a>16、query(PreparedStatementCreator psc, RowMapper&lt; T &gt; rowMapper)</h3><pre><code class="java">public &lt;T&gt; List&lt;T&gt; query(PreparedStatementCreator psc, RowMapper&lt;T&gt; rowMapper) throws DataAccessException &#123;&#125;
</code></pre>
<ul>
<li>第一个参数：创建一个预编译的SQL，如果SQL中有占位符，则需要进行处理。</li>
<li>第二个参数：查询的每一行结果集，需要手动进行转换为想要的对象。</li>
<li>注意：这个方法和上面的几个query(rowMapper)方法返回的是List&lt; T &gt;对象。无论查询时单条记录还是多条记录，返回的都是List。</li>
</ul>
<pre><code class="java">@Autowired
JdbcTemplate jdbcTemplate;

@PostConstruct
public void execute() &#123;
    // 先初始化表和初始化数据
    jdbcTemplate.execute(&quot;drop table if exists user_info&quot;);
    jdbcTemplate.execute(&quot;create table user_info(user_id int primary key, user_name varchar(255))&quot;);
    jdbcTemplate.update(&quot;insert into user_info values(1, &#39;Java&#39;)&quot;);
    jdbcTemplate.update(&quot;insert into user_info values(2, &#39;Python&#39;)&quot;);
    jdbcTemplate.update(&quot;insert into user_info values(3, &#39;JavaScript&#39;)&quot;);

    // 这个回调方式, 一行数据回调一次, 结果自动封装到List中, 可理解为 RowCallbackHandler + ResultSetExtractor
    List&lt;UserInfo&gt; userInfos = jdbcTemplate.query(new PreparedStatementCreator() &#123;
        @Override
        public PreparedStatement createPreparedStatement(Connection con) throws SQLException &#123;
            String sql = &quot;select * from user_info where user_id = ?&quot;;
            PreparedStatement ps = con.prepareStatement(sql);
            ps.setInt(1, 1);
            return ps;
        &#125;
    &#125;, new RowMapper&lt;UserInfo&gt;() &#123;
        @Override
        public UserInfo mapRow(ResultSet rs, int rowNum) throws SQLException &#123;
            return new UserInfo(rs.getInt(1), rs.getString(2));
        &#125;
    &#125;);
    System.out.println(userInfos);

    // BeanPropertyRowMapper 为 RowMapper的子类, 可以直接转换为 Java Bean, 是 Spring 封装的.
    userInfos = jdbcTemplate.query(con -&gt; &#123;
        String sql = &quot;select * from user_info where user_id &lt; ?&quot;;
        PreparedStatement ps = con.prepareStatement(sql);
        ps.setInt(1, 4);
        return ps;
    &#125;, new BeanPropertyRowMapper&lt;&gt;(UserInfo.class));
    System.out.println(userInfos);

    // ColumnMapRowMapper 为 RowMapper的子类, 可以直接转换为 Map, 是 Spring 封装的.
    List&lt;Map&lt;String, Object&gt;&gt; userNames = jdbcTemplate.query(con -&gt; &#123;
        String sql = &quot;select * from user_info where user_id &lt; ?&quot;;
        PreparedStatement ps = con.prepareStatement(sql);
        ps.setInt(1, 4);
        return ps;
    &#125;, new ColumnMapRowMapper());
    System.out.println(userNames);

    // 查询多行单列
    List&lt;Integer&gt; ids = jdbcTemplate.query(con -&gt; &#123;
        String sql = &quot;select * from user_info where user_id &lt; ?&quot;;
        PreparedStatement ps = con.prepareStatement(sql);
        ps.setInt(1, 4);
        return ps;
    &#125;, (rs, rowNum) -&gt; rs.getInt(1));
    System.out.println(ids);
&#125;

@Data
@NoArgsConstructor
@AllArgsConstructor
public static class UserInfo &#123;
    private int userId;
    private String userName;
&#125;
</code></pre>
<pre><code>[UserInfo(userId=1, userName=Java)]
[UserInfo(userId=1, userName=Java), UserInfo(userId=2, userName=Python), UserInfo(userId=3, userName=JavaScript)]
[&#123;user_id=1, user_name=Java&#125;, &#123;user_id=2, user_name=Python&#125;, &#123;user_id=3, user_name=JavaScript&#125;]
[1, 2, 3]
</code></pre>
<h1 id="三、Junit-测试-ResultSetExtractor-RowMapper"><a href="#三、Junit-测试-ResultSetExtractor-RowMapper" class="headerlink" title="三、Junit 测试 ResultSetExtractor&#x2F;RowMapper"></a>三、Junit 测试 ResultSetExtractor&#x2F;RowMapper</h1><blockquote>
<p>作者：<a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_58680865">YD_1989</a>、来源：Spring JdbcTemplate Junit 测试 - ResultSetExtractor&#x2F;RowMapper：<a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_58680865/article/details/134429114">https://blog.csdn.net/m0_58680865/article/details/134429114</a></p>
</blockquote>
<p>Spring JdbcTemplate Junit 测试覆盖率 - 以 ResultSetExtractor &#x2F; RowMapper 为例</p>
<h2 id="1、RowMapper-Mockito-测试"><a href="#1、RowMapper-Mockito-测试" class="headerlink" title="1、RowMapper Mockito 测试"></a>1、RowMapper Mockito 测试</h2><p>1、创建实体类 User</p>
<pre><code class="java">@Data
public class User &#123;
    private Integer id;
    private String name;
    private String applicant;
    private String address;
    private Boolean flag;
&#125;
</code></pre>
<p>2、JdbcTemplate 业务代码</p>
<pre><code class="java">import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.stereotype.Repository;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.List;

@Repository
public class InsertGroup &#123;

    @Autowired
    JdbcTemplate jdbcTemplate;

    public List&lt;User&gt; getUsers(String sql, String name, String address) &#123;

        return jdbcTemplate.query(sql, new RowMapper&lt;User&gt;() &#123;
            @Override
            public User mapRow(ResultSet rs, int rowNum) throws SQLException &#123;

                User user = new User();
                user.setId(rs.getInt(&quot;ID&quot;));
                user.setName(rs.getString(&quot;Name&quot;));
                user.setApplicant(rs.getString(&quot;Applicant&quot;));
                user.setAddress(rs.getString(&quot;Address&quot;));
                user.setFlag(rs.getBoolean(&quot;Flag&quot;));
                return user;
            &#125;
        &#125;, name, address);
    &#125;
&#125;
</code></pre>
<p>3、Junit Mockito 测试</p>
<pre><code class="java">import org.junit.Assert;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.*;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;

import java.sql.ResultSet;
import java.util.ArrayList;
import java.util.List;

@RunWith(SpringJUnit4ClassRunner.class)
public class InsertGroupTest &#123;

    @Mock
    JdbcTemplate jdbcTemplate;

    @InjectMocks
    InsertGroup insertGroup;

    @Before
    public void init() &#123;
        MockitoAnnotations.openMocks(this);
    &#125;


    @Test
    public void test() &#123;

        /**
         * 需要注意的是：invocation.getArgument(1)
         * jdbcTemplate.query() 中 Mock 的参数索引是以0开始的，RowMapper 是第二个元素，因此索引是 1，如果是第三个位置，那么索引是 2，即 invocation.getArgument(2)
         * 同时需要注意的是，jdbcTemplate 中 query 的方法有很多，但是传的参数是不同的，因此 Mock 的参数数量要根据自己实际用到的 query 参数为准
         */
        Mockito.when(jdbcTemplate.query(ArgumentMatchers.anyString(), 
                                        ArgumentMatchers.any(RowMapper.class), 
                                        ArgumentMatchers.any()))
            .thenAnswer((invocation) -&gt; &#123;

                RowMapper&lt;User&gt; rowMapper = (RowMapper&lt;User&gt;) invocation.getArgument(1);
                ResultSet rs = Mockito.mock(ResultSet.class);

                // Mock ResultSet to return one rows.
                // Mockito.when(rs.getInt(ArgumentMatchers.eq(&quot;ID&quot;))).thenReturn(506);

                // Mock ResultSet to return two rows.
                Mockito.when(rs.getInt(ArgumentMatchers.eq(&quot;ID&quot;))).thenReturn(412, 300);
                Mockito.when(rs.getString(ArgumentMatchers.eq(&quot;Name&quot;))).thenReturn(&quot;刘亦菲&quot;, &quot;刘诗诗&quot;);
                Mockito.when(rs.getBoolean(ArgumentMatchers.eq(&quot;Flag&quot;))).thenReturn(true, false);

                List&lt;User&gt; users = new ArrayList&lt;&gt;();
                users.add(rowMapper.mapRow(rs, 0));
                users.add(rowMapper.mapRow(rs, 1));

                return users;
            &#125;);

        List&lt;User&gt; userList = insertGroup.getUsers(&quot;sql&quot;, &quot;1&quot;, &quot;2&quot;);

        // Assert First Row
        assertFirstUser(userList.get(0));

        // Assert Second Row
        assertSecondUser(userList.get(1));
    &#125;

    public void assertFirstUser(User user) &#123;
        Assert.assertEquals(Integer.valueOf(412), user.getId());
        Assert.assertEquals(&quot;刘亦菲&quot;, user.getName());
        Assert.assertTrue(user.getFlag());
    &#125;

    public void assertSecondUser(User user) &#123;
        Assert.assertEquals(Integer.valueOf(300), user.getId());
        Assert.assertEquals(&quot;刘诗诗&quot;, user.getName());
        Assert.assertFalse(user.getFlag());
    &#125;
&#125;
</code></pre>
<h2 id="2、ResultSetExtractor-Mockito-测试"><a href="#2、ResultSetExtractor-Mockito-测试" class="headerlink" title="2、ResultSetExtractor Mockito 测试"></a>2、ResultSetExtractor Mockito 测试</h2><p>1、创建 User 实体</p>
<pre><code class="java">@Data
public class User &#123;
    private Integer id;
    private String name;
    private String applicant;
    private String address;
    private Boolean flag;
&#125;
</code></pre>
<p>2、JdbcTemplate 业务代码</p>
<pre><code class="java">public List&lt;User&gt; getUsers2(String sql, String name, String address) &#123;

    return jdbcTemplate.query(sql, new ResultSetExtractor&lt;List&lt;User&gt;&gt;() &#123;
        @Override
        public List&lt;User&gt; extractData(ResultSet rs) throws SQLException, DataAccessException &#123;
            List&lt;User&gt; userList = new ArrayList&lt;&gt;();
            while (rs.next()) &#123;
                User user = new User();
                user.setId(rs.getInt(&quot;ID&quot;));
                user.setName(rs.getString(&quot;Name&quot;));
                user.setApplicant(rs.getString(&quot;Applicant&quot;));
                user.setAddress(rs.getString(&quot;Address&quot;));
                user.setFlag(rs.getBoolean(&quot;Flag&quot;));
                userList.add(user);
            &#125;
            return userList;
        &#125;
    &#125;, name, address);
&#125;
</code></pre>
<p>3、Junit Mockito 测试</p>
<pre><code class="java">@Test
public void test2() &#123;
    Mockito.when(jdbcTemplate.query(ArgumentMatchers.anyString(), 
                                    ArgumentMatchers.any(ResultSetExtractor.class), 
                                    ArgumentMatchers.any()))
        .thenAnswer((invocation) -&gt; &#123;
            ResultSetExtractor&lt;List&lt;User&gt;&gt; resultSetExtractor =
                (ResultSetExtractor&lt;List&lt;User&gt;&gt;) invocation.getArgument(1);

            ResultSet rs = Mockito.mock(ResultSet.class);

            // two times it returns true and third time returns false.
            Mockito.when(rs.next()).thenReturn(true, true, false);

            // Mock ResultSet to return two rows.
            Mockito.when(rs.getInt(ArgumentMatchers.eq(&quot;ID&quot;))).thenReturn(412, 300);
            Mockito.when(rs.getString(ArgumentMatchers.eq(&quot;Name&quot;))) .thenReturn(&quot;刘亦菲&quot;, &quot;刘诗诗&quot;);
            Mockito.when(rs.getBoolean(ArgumentMatchers.eq(&quot;Flag&quot;))).thenReturn(true, false);

            return resultSetExtractor.extractData(rs);
        &#125;);

    List&lt;User&gt; users = insertGroup.getUsers2(&quot;sql&quot;, &quot;1&quot;, &quot;2&quot;);

    Assert.assertEquals(Integer.valueOf(412), users.get(0).getId());
    Assert.assertEquals(&quot;刘亦菲&quot;, users.get(0).getName());
    Assert.assertTrue(users.get(0).getFlag());
&#125;
</code></pre>
<h1 id="四、Spring-JDBC-其他对象"><a href="#四、Spring-JDBC-其他对象" class="headerlink" title="四、Spring JDBC 其他对象"></a>四、Spring JDBC 其他对象</h1><blockquote>
<p>Spring JDBC 其他对象：<a target="_blank" rel="noopener" href="http://m.weizhi.cc/tutorial/detail-7428.html">http://m.weizhi.cc/tutorial/detail-7428.html</a></p>
</blockquote>
<h2 id="1、NamedParameterJdbcTemplate"><a href="#1、NamedParameterJdbcTemplate" class="headerlink" title="1、NamedParameterJdbcTemplate"></a>1、NamedParameterJdbcTemplate</h2><p>NamedParameterJdbcTemplate 类拓展了 JdbcTemplate 类，对 JdbcTemplate 类进行了封装从而支持<strong>具名参数特性</strong>。</p>
<h2 id="2、SimpleJdbcInsert"><a href="#2、SimpleJdbcInsert" class="headerlink" title="2、SimpleJdbcInsert"></a>2、SimpleJdbcInsert</h2><p>SimpleJdbcInsert 是一个简化插入操作的类，它帮助你自动生成插入 SQL 语句，而不需要手动编写。</p>
<p>优势：</p>
<ul>
<li>自动生成 SQL 插入语句：你只需要提供表名和列名，SimpleJdbcInsert 会生成插入语句。</li>
<li>支持自动生成主键（如果数据库支持自动生成主键）。</li>
<li>提供便捷的 API 来插入单行或多行数据。</li>
</ul>
<p><strong>适用场景</strong>：当你想避免写手动的 SQL 插入语句时，SimpleJdbcInsert 提供了更简洁的方式，尤其是表结构比较固定的情况下。</p>
<h2 id="3、SqlQuery"><a href="#3、SqlQuery" class="headerlink" title="3、SqlQuery"></a>3、SqlQuery</h2><p>SqlQuery：是一个抽象类，专门用于执行静态 SQL 查询。它的优势是可以：</p>
<ul>
<li>让查询的结构更加清晰：通过将查询封装在类中，你可以将 SQL 查询和其参数声明、结果映射等封装在一个地方，方便维护。</li>
<li>提供参数声明和查询编译功能：你可以提前声明查询的参数，避免在每次执行查询时重复设置。</li>
<li>让代码更加结构化：每个查询作为一个类，使得代码更具可读性和复用性。</li>
</ul>
<p><strong>适用场景</strong>：如果你有很多类似的查询操作，可以使用 SqlQuery 来简化代码，使其更加模块化、易于管理。</p>
<h2 id="4、SqlUpdate"><a href="#4、SqlUpdate" class="headerlink" title="4、SqlUpdate"></a>4、SqlUpdate</h2><p>SqlUpdate 类类似于 SqlQuery，但是用于执行更新、删除或插入操作，而不是查询。它封装了常见的更新操作，并且可以提前声明 SQL 和参数。</p>
<p>优势：</p>
<ul>
<li>像 SqlQuery 一样，它简化了参数声明和 SQL 语句的封装。</li>
<li>支持批量更新操作。</li>
<li>可以自动处理返回的更新行数。</li>
</ul>
<p><strong>适用场景</strong>：当需要进行多次相似的更新操作（如批量更新、插入或删除）时，SqlUpdate 可以减少样板代码，简化操作。</p>
<h2 id="5、SimpleJdbcCall"><a href="#5、SimpleJdbcCall" class="headerlink" title="5、SimpleJdbcCall"></a>5、SimpleJdbcCall</h2><p>SimpleJdbcCall 用于简化调用存储过程或函数的操作。</p>
<p>优势：</p>
<ul>
<li>自动生成存储过程的调用语句。</li>
<li>自动推断存储过程的输入和输出参数。</li>
<li>简化存储过程调用时的输入、输出和结果映射。</li>
</ul>
<p><strong>适用场景</strong>：如果你需要频繁调用存储过程或数据库函数，SimpleJdbcCall 可以减少代码的复杂性，简化参数声明和结果处理。</p>
<h2 id="6、总结：为什么需要这些类？"><a href="#6、总结：为什么需要这些类？" class="headerlink" title="6、总结：为什么需要这些类？"></a>6、总结：为什么需要这些类？</h2><ol>
<li>减少样板代码：虽然 JdbcTemplate 很强大，但有些重复操作如参数声明、SQL 编写、结果映射等会产生很多样板代码。这些类简化了这些操作，使代码更加简洁。</li>
<li>增强代码可读性和可维护性：通过封装 SQL 语句和操作逻辑在类中，代码结构变得更加清晰，易于维护，尤其是在需要大量重复查询或更新的场景下。</li>
<li>自动化一些常见的操作：例如 SimpleJdbcInsert 和 SimpleJdbcCall 自动生成 SQL 语句，使开发者不需要手动编写复杂的 SQL，减少出错的机会。</li>
<li>增强复用性：这些类提供了更加模块化的设计，可以在不同地方复用同样的 SQL 逻辑，从而提升代码的复用性。</li>
</ol>
<p>因此，虽然 JdbcTemplate 已经简化了 JDBC 操作，但这些类进一步提升了开发效率，减少了重复代码，适用于特定场景下的高效开发。</p>
<h1 id="五、JdbcTemplate-参考文献-鸣谢"><a href="#五、JdbcTemplate-参考文献-鸣谢" class="headerlink" title="五、JdbcTemplate 参考文献 &amp; 鸣谢"></a>五、JdbcTemplate 参考文献 &amp; 鸣谢</h1><ol>
<li>Spring中JdbcTemplate各个方法的使用介绍（持续更新中….）：<a target="_blank" rel="noopener" href="https://blog.csdn.net/whxjason/article/details/108949343">https://blog.csdn.net/whxjason/article/details/108949343</a></li>
<li>SpringBoot高级篇JdbcTemplate之数据查询上篇：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/SeN5q4g92LfHYOAVlQxytA">https://mp.weixin.qq.com/s/SeN5q4g92LfHYOAVlQxytA</a></li>
<li>SpringBoot高级篇JdbcTemplate之数据查询下篇：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/laab3OyzTKL8mfR80Wy_QA">https://mp.weixin.qq.com/s/laab3OyzTKL8mfR80Wy_QA</a></li>
<li>【JavaWeb】73：JdbcTemplate竟然只能算是江南七怪级别的：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/qsVKW3wwbAYYi4zrrReL5A">https://mp.weixin.qq.com/s/qsVKW3wwbAYYi4zrrReL5A</a></li>
<li>Spring之JdbcTemplate使用：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/antLaddie/p/12859647.html">https://www.cnblogs.com/antLaddie/p/12859647.html</a></li>
<li>Spring JdbcTemplate Junit 测试 - ResultSetExtractor&#x2F;RowMapper：<a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_58680865/article/details/134429114">https://blog.csdn.net/m0_58680865/article/details/134429114</a></li>
</ol>

      
       <hr><span style="font-style: italic;color: gray;"> 转载请注明来源，欢迎对文章中的引用来源进行考证，欢迎指出任何有错误或不够清晰的表达。可以在下面评论区评论，也可以邮件至 8629303@qq.com </span>
    </div>
</article>


<p>
    <a  class="dashang" onclick="dashangToggle()">赏</a>
</p>






    




    </div>
    <div class="copyright">
        <p class="footer-entry">
    ©2017-2024 Sam
</p>
<p class="footer-entry">Built with <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/yelog/hexo-theme-3-hexo" target="_blank">3-hexo</a> theme</p>

    </div>
    <div class="full-toc">
        <button class="full" data-title="切换全屏 快捷键 s"><span class="min "></span></button>
<a class="" id="rocket" ></a>

    </div>
</div>

<div class="hide_box" onclick="dashangToggle()"></div>
<div class="shang_box">
    <a class="shang_close"  onclick="dashangToggle()">×</a>
    <div class="shang_tit">
        <p>喜欢就点赞,疼爱就打赏</p>
    </div>
    <div class="shang_payimg">
        <div class="pay_img">
            <img src="/img/alipay.jpg" class="alipay" title="扫码支持">
            <img src="/img/weixin.jpg" class="weixin" title="扫码支持">
        </div>
    </div>
    <div class="shang_payselect">
        <span><label><input type="radio" name="pay" checked value="alipay">支付宝</label></span><span><label><input type="radio" name="pay" value="weixin">微信</label></span>
    </div>
</div>


</body>
<script src="/js/jquery.pjax.js?v=1.1.0" ></script>

<script src="/js/script.js?v=1.1.0" ></script>
<script>
    var img_resize = 'default';
    function initArticle() {
        /*渲染对应的表格样式*/
        
            $("#post .pjax table").addClass("green_title");
        

        /*渲染打赏样式*/
        
        $("input[name=pay]").on("click", function () {
            if($("input[name=pay]:checked").val()=="weixin"){
                $(".shang_box .shang_payimg .pay_img").addClass("weixin_img");
            } else {
                $(".shang_box .shang_payimg .pay_img").removeClass("weixin_img");
            }
        })
        

        /*高亮代码块行号*/
        
        $('pre code').each(function(){
            var lines = $(this).text().trim().split('\n').length, widther='';
            if (lines>99) {
                widther = 'widther'
            }
            var $numbering = $('<ul/>').addClass('pre-numbering ' + widther).attr("unselectable","on");
            $(this).addClass('has-numbering ' + widther)
                    .parent()
                    .append($numbering);
            for(var i=1;i<=lines;i++){
                $numbering.append($('<li/>').text(i));
            }
        });
        

        /*访问数量*/
        
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js");
        

        /*代码高亮，行号对齐*/
        $('.pre-numbering').css('line-height',$('.has-numbering').css('line-height'));

        
        
    }

    /*打赏页面隐藏与展示*/
    
    function dashangToggle() {
        $(".shang_box").fadeToggle();
        $(".hide_box").fadeToggle();
    }
    

</script>

<!--加入行号的高亮代码块样式-->

<style>
    pre{
        position: relative;
        margin-bottom: 24px;
        border-radius: 10px;
        border: 1px solid #e2dede;
        background: #FFF;
        overflow: hidden;
    }
    code.has-numbering{
        margin-left: 30px;
    }
    code.has-numbering.widther{
        margin-left: 35px;
    }
    .pre-numbering{
        margin: 0;
        position: absolute;
        top: 0;
        left: 0;
        width: 20px;
        padding: 18px 3px 15px 5px;
        border-right: 1px solid #C3CCD0;
        text-align: right;
        color: #AAA;
        background-color: #fafafa;
    }
    .pre-numbering.widther {
        width: 35px;
    }
</style>

<!--自定义样式设置-->
<style>
    
    
    .nav {
        width: 582px;
    }
    .nav.fullscreen {
        margin-left: -582px;
    }
    .nav-left {
        width: 160px;
    }
    
    
    @media screen and (max-width: 1468px) {
        .nav {
            width: 492px;
        }
        .nav.fullscreen {
            margin-left: -492px;
        }
        .nav-left {
            width: 100px;
        }
    }
    
    
    @media screen and (max-width: 1024px) {
        .nav {
            width: 492px;
            margin-left: -492px
        }
        .nav.fullscreen {
            margin-left: 0;
        }
    }
    
    @media screen and (max-width: 426px) {
        .nav {
            width: 100%;
        }
        .nav-left {
            width: 100%;
        }
    }
    
    
    .nav-right .title-list nav a .post-title, .nav-right .title-list #local-search-result a .post-title {
        color: #383636;
    }
    
    
    .nav-right .title-list nav a .post-date, .nav-right .title-list #local-search-result a .post-date {
        color: #5e5e5f;
    }
    
    
    .nav-right nav a.hover, #local-search-result a.hover{
        background-color: #e2e0e0;
    }
    
    

    /*列表样式*/
    

    /* 背景图样式 */
    
    


    /*引用块样式*/
    

    /*文章列表背景图*/
    

    
</style>







</html>
