<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Hibernata JPA | Hexo</title>
  <meta name="keywords" content="">
  <meta name="description" content="Hibernata JPA | Hexo">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="description" content="请不要自己写，Spring Boot非常实用的内置功能：https:&#x2F;&#x2F;juejin.cn&#x2F;post&#x2F;7417630844100231206  在 SpringBoot 框架中，内置了许多实用的功能，这些功能可以帮助开发者高效地开发和维护应用程序。 一、请求数据记录器SpringBoot 提供了一个内置的日志记录解决方案，通过 AbstractRequestLoggingFilter 可以记录请">
<meta property="og:type" content="article">
<meta property="og:title" content="SpringBoot2.x 内置功能 - 内置过滤器和 AOP 工具类">
<meta property="og:url" content="http://example.com/2024/10/08/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot2.x%20%E5%86%85%E7%BD%AE%E5%8A%9F%E8%83%BD%20-%20%E5%86%85%E7%BD%AE%E8%BF%87%E6%BB%A4%E5%99%A8%E5%92%8C%20AOP%20%E5%B7%A5%E5%85%B7%E7%B1%BB/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="请不要自己写，Spring Boot非常实用的内置功能：https:&#x2F;&#x2F;juejin.cn&#x2F;post&#x2F;7417630844100231206  在 SpringBoot 框架中，内置了许多实用的功能，这些功能可以帮助开发者高效地开发和维护应用程序。 一、请求数据记录器SpringBoot 提供了一个内置的日志记录解决方案，通过 AbstractRequestLoggingFilter 可以记录请">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2024-10-08T08:44:19.743Z">
<meta property="article:modified_time" content="2024-10-20T16:22:32.002Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">


<link rel="icon" href="/img/avatar.jpg">

<link href="/css/style.css?v=1.1.0" rel="stylesheet">

<link href="/css/hl_theme/atom-light.css?v=1.1.0" rel="stylesheet">

<link href="//cdn.jsdelivr.net/npm/animate.css@4.1.0/animate.min.css" rel="stylesheet">

<script src="//cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
<script src="/js/titleTip.js?v=1.1.0" ></script>

<script src="//cdn.jsdelivr.net/npm/highlightjs@9.16.2/highlight.pack.min.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>

<script src="//cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script>



<script src="//cdn.jsdelivr.net/npm/jquery.cookie@1.4.1/jquery.cookie.min.js" ></script>

<script src="/js/iconfont.js?v=1.1.0" ></script>

<meta name="generator" content="Hexo 7.3.0"></head>
<div style="display: none">
  <input class="theme_disqus_on" value="false">
  <input class="theme_preload_comment" value="">
  <input class="theme_blog_path" value="">
  <input id="theme_shortcut" value="true" />
  <input id="theme_highlight_on" value="true" />
  <input id="theme_code_copy" value="true" />
</div>



<body>
<aside class="nav">
    <div class="nav-left">
        <a href="/"
   class="avatar_target">
    <img class="avatar"
         src="/img/avatar.jpg"/>
</a>
<div class="author">
    <span>John Doe</span>
</div>

<div class="icon">
    
        
            <a title="github"
               href="https://github.com/8629303"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-github"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="email"
               href="mailto:8629303@qq.com"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-email"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="qq"
               href="http://wpa.qq.com/msgrd?v=3&uin=8629303&site=qq&menu=yes"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-qq"></use>
                    </svg>
                
            </a>
        
    
</div>





<ul>
    <li>
        <div class="all active" data-rel="全部文章">全部文章
            
                <small>(172)</small>
            
        </div>
    </li>
    
        
            
                
    <li>
        <div data-rel="数据库">
            
            数据库
            <small>(5)</small>
        </div>
        
    </li>

            
        
    
        
            
        
    
        
            
        
    
        
            
                
    <li>
        <div data-rel="开发工具">
            <i class="fold iconfont icon-right"></i>
            开发工具
            <small>(16)</small>
        </div>
        
            <ul class="sub hide">
                
                    
    <li>
        <div data-rel="开发工具&lt;---&gt;Maven">
            
            Maven
            <small>(8)</small>
        </div>
        
    </li>

                
            </ul>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="面试篇">
            
            面试篇
            <small>(1)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="微服务开发">
            <i class="fold iconfont icon-right"></i>
            微服务开发
            <small>(61)</small>
        </div>
        
            <ul class="sub hide">
                
                    
    <li>
        <div data-rel="微服务开发&lt;---&gt;Shiro">
            
            Shiro
            <small>(2)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="微服务开发&lt;---&gt;Spring">
            
            Spring
            <small>(3)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="微服务开发&lt;---&gt;SpringBoot">
            
            SpringBoot
            <small>(44)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="微服务开发&lt;---&gt;SpringCloudAlibaba">
            
            SpringCloudAlibaba
            <small>(1)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="微服务开发&lt;---&gt;SpringDataJPA">
            
            SpringDataJPA
            <small>(4)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="微服务开发&lt;---&gt;SpringMVC">
            
            SpringMVC
            <small>(1)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="微服务开发&lt;---&gt;SpringSecurity">
            
            SpringSecurity
            <small>(1)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="微服务开发&lt;---&gt;SpringTransaction">
            
            SpringTransaction
            <small>(5)</small>
        </div>
        
    </li>

                
            </ul>
        
    </li>

            
        
    
        
            
        
    
        
            
                
    <li>
        <div data-rel="中间件">
            <i class="fold iconfont icon-right"></i>
            中间件
            <small>(8)</small>
        </div>
        
            <ul class="sub hide">
                
                    
    <li>
        <div data-rel="中间件&lt;---&gt;ElasticSearch">
            
            ElasticSearch
            <small>(1)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="中间件&lt;---&gt;MongoDB">
            
            MongoDB
            <small>(2)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="中间件&lt;---&gt;RabbitMQ">
            
            RabbitMQ
            <small>(3)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="中间件&lt;---&gt;Redis">
            
            Redis
            <small>(2)</small>
        </div>
        
    </li>

                
            </ul>
        
    </li>

            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
                
    <li>
        <div data-rel="Java基础篇">
            <i class="fold iconfont icon-right"></i>
            Java基础篇
            <small>(8)</small>
        </div>
        
            <ul class="sub hide">
                
                    
    <li>
        <div data-rel="Java基础篇&lt;---&gt;Java常用类库">
            
            Java常用类库
            <small>(1)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="Java基础篇&lt;---&gt;Java多线程">
            
            Java多线程
            <small>(2)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="Java基础篇&lt;---&gt;Java反射与注解">
            
            Java反射与注解
            <small>(1)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="Java基础篇&lt;---&gt;Java基础语法">
            
            Java基础语法
            <small>(1)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="Java基础篇&lt;---&gt;Java集合类">
            
            Java集合类
            <small>(1)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="Java基础篇&lt;---&gt;JavaIO流">
            
            JavaIO流
            <small>(1)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="Java基础篇&lt;---&gt;JavaNIO流">
            
            JavaNIO流
            <small>(1)</small>
        </div>
        
    </li>

                
            </ul>
        
    </li>

            
        
    
        
            
        
    
        
            
        
    
        
            
                
    <li>
        <div data-rel="Java进阶篇">
            <i class="fold iconfont icon-right"></i>
            Java进阶篇
            <small>(4)</small>
        </div>
        
            <ul class="sub hide">
                
                    
    <li>
        <div data-rel="Java进阶篇&lt;---&gt;Java设计模式">
            
            Java设计模式
            <small>(1)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="Java进阶篇&lt;---&gt;JVM虚拟机">
            
            JVM虚拟机
            <small>(3)</small>
        </div>
        
    </li>

                
            </ul>
        
    </li>

            
        
    
        
            
        
    
        
            
        
    
        
            
                
    <li>
        <div data-rel="Java新特性">
            <i class="fold iconfont icon-right"></i>
            Java新特性
            <small>(16)</small>
        </div>
        
            <ul class="sub hide">
                
                    
    <li>
        <div data-rel="Java新特性&lt;---&gt;Java10新特性">
            
            Java10新特性
            <small>(1)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="Java新特性&lt;---&gt;Java11新特性">
            
            Java11新特性
            <small>(1)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="Java新特性&lt;---&gt;Java12新特性">
            
            Java12新特性
            <small>(1)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="Java新特性&lt;---&gt;Java13新特性">
            
            Java13新特性
            <small>(1)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="Java新特性&lt;---&gt;Java14新特性">
            
            Java14新特性
            <small>(1)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="Java新特性&lt;---&gt;Java15新特性">
            
            Java15新特性
            <small>(1)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="Java新特性&lt;---&gt;Java16新特性">
            
            Java16新特性
            <small>(1)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="Java新特性&lt;---&gt;Java17新特性">
            
            Java17新特性
            <small>(1)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="Java新特性&lt;---&gt;Java18新特性">
            
            Java18新特性
            <small>(1)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="Java新特性&lt;---&gt;Java19新特性">
            
            Java19新特性
            <small>(1)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="Java新特性&lt;---&gt;Java20新特性">
            
            Java20新特性
            <small>(1)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="Java新特性&lt;---&gt;Java8新特性">
            
            Java8新特性
            <small>(4)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="Java新特性&lt;---&gt;Java9新特性">
            
            Java9新特性
            <small>(1)</small>
        </div>
        
    </li>

                
            </ul>
        
    </li>

            
        
    
        
            
        
    
        
            
                
    <li>
        <div data-rel="JavaEE">
            <i class="fold iconfont icon-right"></i>
            JavaEE
            <small>(6)</small>
        </div>
        
            <ul class="sub hide">
                
                    
    <li>
        <div data-rel="JavaEE&lt;---&gt;JavaWeb">
            
            JavaWeb
            <small>(2)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="JavaEE&lt;---&gt;SSM框架">
            
            SSM框架
            <small>(4)</small>
        </div>
        
    </li>

                
            </ul>
        
    </li>

            
        
    
        
            
        
    
        
            
        
    
        
            
                
    <li>
        <div data-rel="JavaSE">
            <i class="fold iconfont icon-right"></i>
            JavaSE
            <small>(34)</small>
        </div>
        
            <ul class="sub hide">
                
                    
    <li>
        <div data-rel="JavaSE&lt;---&gt;Java汇总篇">
            
            Java汇总篇
            <small>(28)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="JavaSE&lt;---&gt;Java新特性">
            
            Java新特性
            <small>(1)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="JavaSE&lt;---&gt;Java性能测试与安全">
            
            Java性能测试与安全
            <small>(5)</small>
        </div>
        
    </li>

                
            </ul>
        
    </li>

            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
                
    <li>
        <div data-rel="Linux">
            <i class="fold iconfont icon-right"></i>
            Linux
            <small>(7)</small>
        </div>
        
            <ul class="sub hide">
                
                    
    <li>
        <div data-rel="Linux&lt;---&gt;虚拟机工具">
            
            虚拟机工具
            <small>(2)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="Linux&lt;---&gt;Docker">
            
            Docker
            <small>(2)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="Linux&lt;---&gt;Kubernetes">
            
            Kubernetes
            <small>(2)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="Linux&lt;---&gt;Nginx">
            
            Nginx
            <small>(1)</small>
        </div>
        
    </li>

                
            </ul>
        
    </li>

            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
                
    <li>
        <div data-rel="Redis">
            <i class="fold iconfont icon-right"></i>
            Redis
            <small>(1)</small>
        </div>
        
            <ul class="sub hide">
                
                    
    <li>
        <div data-rel="Redis&lt;---&gt;backup">
            
            backup
            <small>(1)</small>
        </div>
        
    </li>

                
            </ul>
        
    </li>

            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
                
    <li>
        <div data-rel="SpringTransaction">
            <i class="fold iconfont icon-right"></i>
            SpringTransaction
            <small>(5)</small>
        </div>
        
            <ul class="sub hide">
                
                    
    <li>
        <div data-rel="SpringTransaction&lt;---&gt;多数据源事务处理">
            
            多数据源事务处理
            <small>(3)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="SpringTransaction&lt;---&gt;多线程下事务处理">
            
            多线程下事务处理
            <small>(2)</small>
        </div>
        
    </li>

                
            </ul>
        
    </li>

            
        
    
        
            
        
    
</ul>
<div class="left-bottom">
    <div class="menus">
        
            
            
            
    </div>
    <div>
        
            <a class="about  hasFriend  site_url"
               
               href="/about">关于</a>
        
        <a style="width: 50%"
                
                                           class="friends">友链</a>
        
    </div>
</div>
<input type="hidden" id="yelog_site_posts_number" value="172">

<div style="display: none">
    <span id="busuanzi_value_site_uv"></span>
    <span id="busuanzi_value_site_pv"></span>
</div>

    </div>
    <div class="nav-right">
        <div class="friends-area">
    <div class="friends-title">
        友情链接
        <i class="iconfont icon-left"></i>
    </div>
    <div class="friends-content">
        <ul>
            
            <li><a target="_blank" href="http://yelog.org/">叶落阁</a></li>
            
        </ul>
    </div>
</div>
        <div class="title-list">
    <div class="right-top">
        <div id="default-panel">
            <i class="iconfont icon-search" data-title="搜索 快捷键 i"></i>
            <div class="right-title">全部文章</div>
            <i class="iconfont icon-file-tree" data-title="切换到大纲视图 快捷键 w"></i>
        </div>
        <div id="search-panel">
            <i class="iconfont icon-left" data-title="返回"></i>
            <input id="local-search-input" autocomplete="off"/>
            <label class="border-line" for="input"></label>
            <i class="iconfont icon-case-sensitive" data-title="大小写敏感"></i>
            <i class="iconfont icon-tag" data-title="标签"></i>
        </div>
        <div id="outline-panel" style="display: none">
            <div class="right-title">大纲</div>
            <i class="iconfont icon-list" data-title="切换到文章列表"></i>
        </div>
    </div>

    <div class="tags-list">
    <input id="tag-search" />
    <div class="tag-wrapper">
        
    </div>

</div>

    
    <nav id="title-list-nav">
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/blog/2024/10/08/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot2.x%20%E5%86%85%E7%BD%AE%E5%8A%9F%E8%83%BD%20-%20%E5%86%85%E7%BD%AE%E8%BF%87%E6%BB%A4%E5%99%A8%E5%92%8C%20AOP%20%E5%B7%A5%E5%85%B7%E7%B1%BB/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot2.x 内置功能 - 内置过滤器和 AOP 工具类">SpringBoot2.x 内置功能 - 内置过滤器和 AOP 工具类</span>
            <span class="post-date" title="2024-10-08 16:44:19">2024/10/08</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/blog/2024/10/08/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%E7%B3%BB%E5%88%97-%E5%85%A8%E7%BD%91%E6%9C%80%E5%85%A8%E7%9A%84%E7%89%88%E6%9C%AC%E5%8F%98%E6%9B%B4%E5%8F%B2/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot系列-全网最全的版本变更史">SpringBoot系列-全网最全的版本变更史</span>
            <span class="post-date" title="2024-10-08 16:38:53">2024/10/08</span>
        </a>
        
        
        <a  class="全部文章 开发工具 Maven "
           href="/blog/2024/10/08/6%E3%80%81%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Maven/Maven%20%E6%95%99%E7%A8%8B%E4%B9%8B%20%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE%20&%20%E9%B8%A3%E8%B0%A2/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Maven 教程之 参考文献 &amp; 鸣谢">Maven 教程之 参考文献 &amp; 鸣谢</span>
            <span class="post-date" title="2024-10-08 15:50:47">2024/10/08</span>
        </a>
        
        
        <a  class="全部文章 开发工具 "
           href="/blog/2024/10/07/6%E3%80%81%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/GitHub%20%E5%AE%9E%E6%88%98%E6%8A%80%E5%B7%A7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="GitHub 实战技巧">GitHub 实战技巧</span>
            <span class="post-date" title="2024-10-07 15:55:34">2024/10/07</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/blog/2024/10/07/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot2.x%20%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AF%87%20-%20%E9%9B%86%E6%88%90%20HirakiCP%20%E4%B8%8E%20Druid%20%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot2.x 数据库篇 - 集成 HirakiCP 与 Druid 数据库连接池">SpringBoot2.x 数据库篇 - 集成 HirakiCP 与 Druid 数据库连接池</span>
            <span class="post-date" title="2024-10-07 14:19:43">2024/10/07</span>
        </a>
        
        
        <a  class="全部文章 开发工具 "
           href="/blog/2024/09/30/6%E3%80%81%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/MacOS%20%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%8F%8A%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E5%8D%B8%E8%BD%BD/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="MacOS 开发环境搭建及软件安装卸载">MacOS 开发环境搭建及软件安装卸载</span>
            <span class="post-date" title="2024-09-30 23:56:52">2024/09/30</span>
        </a>
        
        
        <a  class="全部文章 开发工具 Maven "
           href="/blog/2024/09/30/6%E3%80%81%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Maven/Maven%20%E6%95%99%E7%A8%8B%E4%B9%8B%20JDK%20%E7%89%88%E6%9C%AC%E9%BB%98%E8%AE%A4%E8%AE%BE%E7%BD%AE%20/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Maven 教程之 JDK 版本默认设置">Maven 教程之 JDK 版本默认设置</span>
            <span class="post-date" title="2024-09-30 16:37:08">2024/09/30</span>
        </a>
        
        
        <a  class="全部文章 开发工具 Maven "
           href="/blog/2024/09/26/6%E3%80%81%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Maven/Maven%20%E6%95%99%E7%A8%8B%E4%B9%8B%20profiles%20%E5%A4%9A%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Maven 教程之 profiles 多环境配置">Maven 教程之 profiles 多环境配置</span>
            <span class="post-date" title="2024-09-26 17:40:34">2024/09/26</span>
        </a>
        
        
        <a  class="全部文章 开发工具 Maven "
           href="/blog/2024/09/25/6%E3%80%81%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Maven/Maven%20%E6%95%99%E7%A8%8B%E4%B9%8B%20plugin%20%E8%AF%A6%E8%A7%A3/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Maven 教程之 plugin 详解">Maven 教程之 plugin 详解</span>
            <span class="post-date" title="2024-09-25 11:32:44">2024/09/25</span>
        </a>
        
        
        <a  class="全部文章 开发工具 Maven "
           href="/blog/2024/09/21/6%E3%80%81%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Maven/Maven%20%E6%95%99%E7%A8%8B%E4%B9%8B%20pom.xml%20%E8%AF%A6%E8%A7%A3/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Maven 教程之 pom.xml 详解">Maven 教程之 pom.xml 详解</span>
            <span class="post-date" title="2024-09-21 16:14:13">2024/09/21</span>
        </a>
        
        
        <a  class="全部文章 开发工具 Maven "
           href="/blog/2024/09/21/6%E3%80%81%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Maven/Maven%20%E6%95%99%E7%A8%8B%E4%B9%8B%20settings.xml%20%E8%AF%A6%E8%A7%A3/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Maven 教程之 settings.xml 详解">Maven 教程之 settings.xml 详解</span>
            <span class="post-date" title="2024-09-21 16:14:09">2024/09/21</span>
        </a>
        
        
        <a  class="全部文章 面试篇 "
           href="/blog/2024/08/27/0%E3%80%81%E9%9D%A2%E8%AF%95%E7%AF%87/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8%E6%B1%87%E6%80%BB/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="面试宝典汇总">面试宝典汇总</span>
            <span class="post-date" title="2024-08-27 16:20:25">2024/08/27</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/blog/2024/08/26/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E8%87%AA%E5%AE%9A%E4%B9%89%E9%9B%86%E5%90%88%E5%B8%B8%E9%87%8F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 自定义集合常量">Java 自定义集合常量</span>
            <span class="post-date" title="2024-08-26 12:11:54">2024/08/26</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringMVC "
           href="/blog/2024/08/26/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20MVC/SpringMVC%E4%B9%8B@InitBinder%E6%B3%A8%E8%A7%A3%EF%BC%88%E6%97%A5%E6%9C%9F%E8%BD%AC%E6%8D%A2%EF%BC%89/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringMVC之@InitBinder注解（日期转换）">SpringMVC之@InitBinder注解（日期转换）</span>
            <span class="post-date" title="2024-08-26 11:10:28">2024/08/26</span>
        </a>
        
        
        <a  class="全部文章 SpringTransaction 多线程下事务处理 "
           href="/blog/2024/08/21/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Transaction/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8B%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/Java%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BA%8B%E5%8A%A1%E6%8F%90%E4%BA%A4%E7%9A%84%E5%A4%84%E7%90%86/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 多线程事务提交的处理">Java 多线程事务提交的处理</span>
            <span class="post-date" title="2024-08-21 16:32:52">2024/08/21</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/blog/2024/08/20/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%20Cache%20%E6%95%B4%E5%90%88%20Redis%20%E7%BC%93%E5%AD%98%E6%A1%86%E6%9E%B6/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot Cache 整合 Redis 缓存框架">SpringBoot Cache 整合 Redis 缓存框架</span>
            <span class="post-date" title="2024-08-20 16:11:47">2024/08/20</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringTransaction "
           href="/blog/2024/08/16/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Transaction/Spring%20%E4%BA%8B%E5%8A%A1%E5%BA%94%E7%94%A8%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Spring 事务应用及源码分析">Spring 事务应用及源码分析</span>
            <span class="post-date" title="2024-08-16 10:33:57">2024/08/16</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringTransaction "
           href="/blog/2024/08/16/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Transaction/Spring%20JDBC%20-%20NamedParameterJdbcTemplate/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Spring JDBC - NamedParameterJdbcTemplate">Spring JDBC - NamedParameterJdbcTemplate</span>
            <span class="post-date" title="2024-08-16 00:18:18">2024/08/16</span>
        </a>
        
        
        <a  class="全部文章 开发工具 "
           href="/blog/2024/07/18/6%E3%80%81%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Git%20&%20GitHub/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Git &amp; GitHub">Git &amp; GitHub</span>
            <span class="post-date" title="2024-07-18 10:34:58">2024/07/18</span>
        </a>
        
        
        <a  class="全部文章 开发工具 Maven "
           href="/blog/2024/06/28/6%E3%80%81%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Maven/Maven%20%E5%AE%9E%E6%88%98/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Maven 实战">Maven 实战</span>
            <span class="post-date" title="2024-06-28 16:50:35">2024/06/28</span>
        </a>
        
        
        <a  class="全部文章 数据库 "
           href="/blog/2024/06/26/3%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%9D%A2%E8%AF%95%E5%AE%98%EF%BC%9A%E4%B8%8D%E4%BC%9A%E7%9C%8B%20Explain%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%EF%BC%8C%E7%AE%80%E5%8E%86%E6%95%A2%E5%86%99%20SQL%20%E4%BC%98%E5%8C%96%EF%BC%9F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="面试官：不会看 Explain执行计划，简历敢写 SQL 优化？">面试官：不会看 Explain执行计划，简历敢写 SQL 优化？</span>
            <span class="post-date" title="2024-06-26 19:33:03">2024/06/26</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/blog/2024/04/22/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%AF%87%E4%B9%8B%20IDEA%20-%20VM%20Options%E3%80%81Program%20Arguments%E3%80%81Environment%20Variable%20%E8%A7%A3%E6%9E%90/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 命令行篇之 IDEA - VM Options、Program Arguments、Environment Variable 解析">Java 命令行篇之 IDEA - VM Options、Program Arguments、Environment Variable 解析</span>
            <span class="post-date" title="2024-04-22 10:53:10">2024/04/22</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/blog/2024/04/19/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6-%E9%85%8D%E7%BD%AE%E5%A4%96%E9%83%A8%E5%8C%96/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 配置文件-配置外部化">SpringBoot 2.x 配置文件-配置外部化</span>
            <span class="post-date" title="2024-04-19 09:18:55">2024/04/19</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/blog/2024/04/16/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E5%8E%9F%E7%90%86%E7%AF%87%E4%B9%8B%20SPI%20%E6%9C%BA%E5%88%B6/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 原理篇之 SPI 机制">Java 原理篇之 SPI 机制</span>
            <span class="post-date" title="2024-04-16 17:26:15">2024/04/16</span>
        </a>
        
        
        <a  class="全部文章 开发工具 Maven "
           href="/blog/2024/01/14/6%E3%80%81%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Maven/Maven%20%E6%95%99%E7%A8%8B%E4%B9%8B%20mirror%20&%20repository%20%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Maven 教程之 mirror &amp; repository 配置详解">Maven 教程之 mirror &amp; repository 配置详解</span>
            <span class="post-date" title="2024-01-14 22:51:03">2024/01/14</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/blog/2023/12/07/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E4%B8%BA%E4%BB%80%E4%B9%88SpringBoot%20jar%20%E5%8F%AF%E4%BB%A5%E7%9B%B4%E6%8E%A5%E8%BF%90%E8%A1%8C/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 为什么SpringBoot jar 可以直接运行">SpringBoot 2.x 为什么SpringBoot jar 可以直接运行</span>
            <span class="post-date" title="2023-12-07 15:13:56">2023/12/07</span>
        </a>
        
        
        <a  class="全部文章 Java基础篇 Java多线程 "
           href="/blog/2023/12/04/1%E3%80%81JavaSE/1.Java%20%E5%9F%BA%E7%A1%80%E7%AF%87/5%E3%80%81Java%20%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%BF%9B%E9%98%B6/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 多线程进阶">Java 多线程进阶</span>
            <span class="post-date" title="2023-12-04 16:37:09">2023/12/04</span>
        </a>
        
        
        <a  class="全部文章 数据库 "
           href="/blog/2023/11/18/3%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BB%BA%E6%A8%A1%E5%B7%A5%E5%85%B7%E6%B1%87%E6%80%BB/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="数据库建模工具汇总">数据库建模工具汇总</span>
            <span class="post-date" title="2023-11-18 15:31:11">2023/11/18</span>
        </a>
        
        
        <a  class="全部文章 JavaEE SSM框架 "
           href="/blog/2023/10/08/2%E3%80%81JavaEE/2%E3%80%81SSM%E6%A1%86%E6%9E%B6/Mybatis/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Mybatis">Mybatis</span>
            <span class="post-date" title="2023-10-08 19:45:47">2023/10/08</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java性能测试与安全 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/5.Java%20%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E4%B8%8E%E5%AE%89%E5%85%A8/Java%20%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E7%AF%87%E4%B9%8B%20%E5%8E%8B%E6%B5%8B%E5%B7%A5%E5%85%B7%E6%B1%87%E6%80%BB/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 性能测试篇之 压测工具汇总">Java 性能测试篇之 压测工具汇总</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java性能测试与安全 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/5.Java%20%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E4%B8%8E%E5%AE%89%E5%85%A8/Java%20%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E7%AF%87%E4%B9%8B%20%E9%AB%98%E5%B9%B6%E5%8F%91%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87%EF%BC%9AQPS%E3%80%81TPS%E3%80%81RT%E3%80%81%E5%B9%B6%E5%8F%91%E6%95%B0%E3%80%81%E5%90%9E%E5%90%90%E9%87%8F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 性能测试篇之 高并发性能指标：QPS、TPS、RT、并发数、吞吐量">Java 性能测试篇之 高并发性能指标：QPS、TPS、RT、并发数、吞吐量</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java性能测试与安全 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/5.Java%20%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E4%B8%8E%E5%AE%89%E5%85%A8/Java%20%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E7%AF%87%E4%B9%8B%20JMH%20%E5%B7%A5%E5%85%B7%E7%B1%BB/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 性能测试篇之 JMH 工具类">Java 性能测试篇之 JMH 工具类</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java性能测试与安全 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/5.Java%20%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E4%B8%8E%E5%AE%89%E5%85%A8/Java%20%E5%AE%89%E5%85%A8%E7%AF%87%E4%B9%8B%20API%20%E6%8E%A5%E5%8F%A3%E9%98%B2%E6%AD%A2%E5%8F%82%E6%95%B0%E7%AF%A1%E6%94%B9%E5%92%8C%E9%87%8D%E6%94%BE%E6%94%BB%E5%87%BB/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 安全篇之 API 接口防止参数篡改和重放攻击">Java 安全篇之 API 接口防止参数篡改和重放攻击</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java性能测试与安全 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/5.Java%20%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E4%B8%8E%E5%AE%89%E5%85%A8/Java%20%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E7%AF%87%E4%B9%8B%2048%E5%BC%A0%E5%9B%BE%E5%AD%A6%E4%BC%9A%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E3%80%81%E5%8E%8B%E6%B5%8B%E5%92%8C%E8%B0%83%E4%BC%98/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 性能测试篇之 48张图学会性能监控、压测和调优">Java 性能测试篇之 48张图学会性能监控、压测和调优</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 开发工具 "
           href="/blog/2023/08/28/6%E3%80%81%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/IDEA%20%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="IDEA 基本使用">IDEA 基本使用</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 开发工具 "
           href="/blog/2023/08/28/6%E3%80%81%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/IDEA%20%E5%BF%AB%E6%8D%B7%E9%94%AE/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="IDEA 快捷键">IDEA 快捷键</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 开发工具 "
           href="/blog/2023/08/28/6%E3%80%81%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/IDEA%20%E6%8F%92%E4%BB%B6%E5%AE%89%E8%A3%85/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="IDEA 插件安装">IDEA 插件安装</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 开发工具 "
           href="/blog/2023/08/28/6%E3%80%81%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/PostMan%20%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="PostMan 工具的使用">PostMan 工具的使用</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 开发工具 "
           href="/blog/2023/08/28/6%E3%80%81%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Git/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Git">Git</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E4%BC%98%E5%8C%96%E7%AF%87%E4%B9%8B%20%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3%20%E6%A0%A1%E9%AA%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 优化篇之 自定义注解 校验数据库表中的数据不可重复">Java 优化篇之 自定义注解 校验数据库表中的数据不可重复</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E5%B7%A5%E5%85%B7%E7%AF%87%E4%B9%8B%20API%20%E6%8E%A5%E5%8F%A3%E5%85%8D%E8%B4%B9%20JSONPlaceholder/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 工具篇之 API 接口免费 JSONPlaceholder">Java 工具篇之 API 接口免费 JSONPlaceholder</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E5%B7%A5%E5%85%B7%E7%AF%87%E4%B9%8B%20%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E7%BB%9F%E8%AE%A1%E4%BB%A3%E7%A0%81%E8%80%97%E6%97%B6/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 工具篇之 如何优雅的统计代码耗时">Java 工具篇之 如何优雅的统计代码耗时</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B9%8B%20%E4%B8%8D%E5%8F%AF%E4%B8%8D%E7%9F%A5%E7%9A%84%207%20%E4%B8%AA%20JDK%20%E5%91%BD%E4%BB%A4/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 命令行之 不可不知的 7 个 JDK 命令">Java 命令行之 不可不知的 7 个 JDK 命令</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%AF%87%E4%B9%8B%20Window%20%E5%90%8E%E5%8F%B0%E5%90%AF%E5%8A%A8%20JAR%20%E7%A8%8B%E5%BA%8F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 命令行篇之 Window 后台启动 JAR 程序">Java 命令行篇之 Window 后台启动 JAR 程序</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E5%B7%A5%E5%85%B7%E7%AF%87%E4%B9%8B%20Lombok/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 工具篇之 Lombok">Java 工具篇之 Lombok</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E5%B7%A5%E5%85%B7%E7%AF%87%E4%B9%8B%20API%20%E6%96%87%E6%A1%A3%E5%B7%A5%E5%85%B7%20Swagger3.x-2.x/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 工具篇之 API 文档工具 Swagger3.x-2.x">Java 工具篇之 API 文档工具 Swagger3.x-2.x</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E5%B7%A5%E5%85%B7%E7%AF%87%E4%B9%8B%20%E6%8E%8C%E6%8F%A114%E7%A7%8DUML%E5%9B%BE/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 工具篇之 掌握14种UML图">Java 工具篇之 掌握14种UML图</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E5%B7%A5%E5%85%B7%E7%B1%BB%E4%B9%8B%20%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B7%A5%E5%85%B7%E7%B1%BB/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 工具类之 自定义工具类">Java 工具类之 自定义工具类</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20Bean%20%E4%B9%8B%20DTO%E3%80%81VO%E3%80%81PO%E3%80%81DO%E3%80%81BO%20%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java Bean 之 DTO、VO、PO、DO、BO 类的区别">Java Bean 之 DTO、VO、PO、DO、BO 类的区别</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20JSON%20%E7%AF%87%E4%B9%8B%20Jackson/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java JSON 篇之 Jackson">Java JSON 篇之 Jackson</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20JSON%20%E7%AF%87%E4%B9%8B%20Gson/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java JSON 篇之 Gson">Java JSON 篇之 Gson</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Curl%20%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%91%BD%E4%BB%A4%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Curl 的使用及命令参数说明">Curl 的使用及命令参数说明</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20JSON%20%E7%AF%87%E4%B9%8B%20FastJson/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java JSON 篇之 FastJson">Java JSON 篇之 FastJson</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Redis backup "
           href="/blog/2023/08/28/5%E3%80%81%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/backup/Redis6/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Redis6">Redis6</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 中间件 Redis "
           href="/blog/2023/08/28/5%E3%80%81%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/Redis-%E6%9C%80%E5%85%A8%E5%AE%9E%E6%88%98/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Redis-最全实战">Redis-最全实战</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 中间件 Redis "
           href="/blog/2023/08/28/5%E3%80%81%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/Redis-%E4%BB%A3%E7%A0%81%E5%AE%9E%E6%88%98/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Redis-代码实战">Redis-代码实战</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 中间件 RabbitMQ "
           href="/blog/2023/08/28/5%E3%80%81%E4%B8%AD%E9%97%B4%E4%BB%B6/RabbitMQ/RabbitMQ-3.8.14/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="RabbitMQ-3.8.14">RabbitMQ-3.8.14</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 中间件 RabbitMQ "
           href="/blog/2023/08/28/5%E3%80%81%E4%B8%AD%E9%97%B4%E4%BB%B6/RabbitMQ/RabbitMQ-3.7.x/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="RabbitMQ-3.7.x">RabbitMQ-3.7.x</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 中间件 RabbitMQ "
           href="/blog/2023/08/28/5%E3%80%81%E4%B8%AD%E9%97%B4%E4%BB%B6/RabbitMQ/RabbitMQ-3.8.14-%E5%8D%9A%E5%AE%A2%E7%89%88/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="RabbitMQ-3.8.14-博客版">RabbitMQ-3.8.14-博客版</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 中间件 MongoDB "
           href="/blog/2023/08/28/5%E3%80%81%E4%B8%AD%E9%97%B4%E4%BB%B6/MongoDB/MongDB-4.4.2/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="MongDB-4.4.2">MongDB-4.4.2</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 中间件 MongoDB "
           href="/blog/2023/08/28/5%E3%80%81%E4%B8%AD%E9%97%B4%E4%BB%B6/MongoDB/MongDB-4.4.2-%E5%8D%9A%E5%AE%A2%E7%89%88/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="MongDB-4.4.2-博客版">MongDB-4.4.2-博客版</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 中间件 ElasticSearch "
           href="/blog/2023/08/28/5%E3%80%81%E4%B8%AD%E9%97%B4%E4%BB%B6/ElasticSearch/ElasticSearch7.6.x%E5%AE%9E%E6%88%98/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="ElasticSearch7.6.x实战">ElasticSearch7.6.x实战</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Linux 虚拟机工具 "
           href="/blog/2023/08/28/4%E3%80%81Linux/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%B7%A5%E5%85%B7/Virtualbox%E7%BD%91%E7%BB%9C%E8%AE%BE%E7%BD%AE%E6%88%96%E9%85%8D%E7%BD%AE/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Virtualbox网络设置或配置">Virtualbox网络设置或配置</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Linux 虚拟机工具 "
           href="/blog/2023/08/28/4%E3%80%81Linux/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%B7%A5%E5%85%B7/Virtualbox%E5%AE%89%E8%A3%85Centos7%E5%AE%9E%E6%88%98/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Virtualbox安装Centos7实战">Virtualbox安装Centos7实战</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Linux Nginx "
           href="/blog/2023/08/28/4%E3%80%81Linux/Nginx/Nginx-1.8.0/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Nginx-1.8.0">Nginx-1.8.0</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Linux Kubernetes "
           href="/blog/2023/08/28/4%E3%80%81Linux/Kubernetes/Minikube-k8s/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Minikube-k8s">Minikube-k8s</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Linux Kubernetes "
           href="/blog/2023/08/28/4%E3%80%81Linux/Kubernetes/k0s%20%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B%EF%BC%9A%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%20Kubernetes%20%E9%9B%86%E7%BE%A4/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="k0s 使用教程：如何快速搭建 Kubernetes 集群">k0s 使用教程：如何快速搭建 Kubernetes 集群</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Linux Docker "
           href="/blog/2023/08/28/4%E3%80%81Linux/Docker/Docker%E5%88%9D%E7%BA%A7%E5%88%B0%E5%AE%9E%E6%88%98/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Docker初级到实战">Docker初级到实战</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Linux Docker "
           href="/blog/2023/08/28/4%E3%80%81Linux/Docker/Docker&Docker-Compose%E5%AE%9E%E6%88%98-%E5%93%88%E5%96%BD%E6%B2%83%E5%BE%B7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Docker&amp;Docker-Compose实战-哈喽沃德">Docker&amp;Docker-Compose实战-哈喽沃德</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 Spring "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring/Spring%20Bean%20%E7%9A%8412%E7%A7%8D%E5%AE%9A%E4%B9%89%E6%96%B9%E6%B3%95/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Spring Bean 的12种定义方法">Spring Bean 的12种定义方法</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 Spring "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring/Spring%20Bean%20%E7%9A%84%E5%8A%A8%E6%80%81%E5%88%9B%E5%BB%BA%E8%8E%B7%E5%8F%96%E5%88%A0%E9%99%A4/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Spring Bean 的动态创建获取删除">Spring Bean 的动态创建获取删除</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 Spring "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring/Spring%20Bean%20%E6%B3%A8%E5%85%A5%E7%9A%843%E7%A7%8D%E6%96%B9%E5%BC%8F,%20%E4%B8%BA%E4%BD%95%E5%AE%98%E6%96%B9%E5%BB%BA%E8%AE%AE%E4%BD%BF%E7%94%A8%E6%9E%84%E9%80%A0%E5%99%A8%E6%B3%A8%E5%85%A5/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Spring Bean 注入的3种方式, 为何官方建议使用构造器注入">Spring Bean 注入的3种方式, 为何官方建议使用构造器注入</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 SpringTransaction 多数据源事务处理 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Transaction/%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/Spring%20%E8%A7%A3%E5%86%B3%E5%8D%95%E6%9C%BA%E7%8E%AF%E5%A2%83%E4%B8%8B%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E7%9A%84%E4%BA%8B%E5%8A%A1%E9%97%AE%E9%A2%98/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Spring 解决单机环境下多数据源的事务问题">Spring 解决单机环境下多数据源的事务问题</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 SpringTransaction 多数据源事务处理 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Transaction/%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/Spring%20%E5%AE%9E%E7%8E%B0%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E5%AE%9E%E6%88%98/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Spring 实现多数据源实战">Spring 实现多数据源实战</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 SpringTransaction 多数据源事务处理 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Transaction/%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/Spring%20%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81%E6%95%B0%E6%8D%AE%E6%BA%90%E3%80%81%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E5%88%87%E6%8D%A2%E6%96%B9%E5%BC%8F%E3%80%81%E5%A4%9A%E6%95%B0%E6%8D%AE%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Spring 实现动态数据源、多数据源切换方式、多数据事务管理">Spring 实现动态数据源、多数据源切换方式、多数据事务管理</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringTransaction "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Transaction/Spring%20%E4%BA%8B%E5%8A%A1%E5%8E%9F%E7%90%86%E6%B7%B1%E5%85%A5%E4%B8%8E%E5%88%86%E6%9E%90/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Spring 事务原理深入与分析">Spring 事务原理深入与分析</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringSecurity "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Security/SpringSecurity/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringSecurity">SpringSecurity</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringTransaction "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Transaction/JDBC/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="JDBC">JDBC</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringTransaction "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Transaction/Spring%20JDBC%20-%20JdbcTemplate/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Spring JDBC - JdbcTemplate">Spring JDBC - JdbcTemplate</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 SpringTransaction 多线程下事务处理 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Transaction/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8B%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/JDBC%E6%89%B9%E5%A4%84%E7%90%86%E5%AE%9E%E7%8E%B0%E6%89%8B%E5%8A%A8%E4%BA%8B%E5%8A%A1%E6%8F%92%E5%85%A51000%E4%B8%87%E6%95%B0%E6%8D%AE%EF%BC%88%E5%8D%95%E7%BA%BF%E7%A8%8B%20&%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%89/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="JDBC批处理实现手动事务插入1000万数据（单线程 &amp; 多线程）">JDBC批处理实现手动事务插入1000万数据（单线程 &amp; 多线程）</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringDataJPA "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Data%20JPA/SpringData%20JPA%20%E7%B1%BB%E5%9B%BE%E5%8F%8A%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringData JPA 类图及使用方法整理">SpringData JPA 类图及使用方法整理</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringDataJPA "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Data%20JPA/SpringData%20JPA/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringData JPA">SpringData JPA</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringDataJPA "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Data%20JPA/Spring%20Data%20JPA%20%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E6%88%98/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Spring Data JPA 原理与实战">Spring Data JPA 原理与实战</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringDataJPA "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Data%20JPA/Hibernata%20JPA/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Hibernata JPA">Hibernata JPA</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringCloudAlibaba "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Cloud%20Alibaba/SpringCloud%20Alibaba/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringCloud Alibaba">SpringCloud Alibaba</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot2.x%20%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AF%87%20-%20%E6%95%B4%E5%90%88H2%E6%95%B0%E6%8D%AE%E5%BA%93/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot2.x 数据库篇 - 整合H2数据库">SpringBoot2.x 数据库篇 - 整合H2数据库</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AD%A6/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot从零开始学">SpringBoot从零开始学</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%E9%85%8D%E7%BD%AE%E5%B1%9E%E6%80%A7%E4%B9%8BDataSource/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot配置属性之DataSource">SpringBoot配置属性之DataSource</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SprinigBoot%E6%96%87%E7%AB%A0%E6%91%98%E8%A6%81%E5%8F%8A%E8%BD%AC%E8%BD%BD/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SprinigBoot文章摘要及转载">SprinigBoot文章摘要及转载</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot2.x%20%E9%A1%B9%E7%9B%AE%E7%BB%9F%E4%B8%80%E6%9E%9A%E4%B8%BE%E8%BD%AC%E6%8D%A2%E5%AE%9E%E8%B7%B5/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot2.x 项目统一枚举转换实践">SpringBoot2.x 项目统一枚举转换实践</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/%E4%BB%A3%E7%A0%81%E5%AE%A1%E6%9F%A5%E7%9A%84%E5%BF%85%E8%A6%81%E6%80%A7%E5%92%8C%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="代码审查的必要性和最佳实践">代码审查的必要性和最佳实践</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6-%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%B9%8B@Value%E8%BF%9B%E9%98%B6/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 配置文件-读取配置文件之@Value进阶">SpringBoot 2.x 配置文件-读取配置文件之@Value进阶</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6-%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9A%84N%E7%A7%8D%E6%96%B9%E5%BC%8F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 配置文件-读取配置文件的N种方式">SpringBoot 2.x 配置文件-读取配置文件的N种方式</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E7%BB%9F%E4%B8%80%E6%8E%A5%E5%8F%A3%E8%BF%94%E5%9B%9E%E6%A0%BC%E5%BC%8F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 统一接口返回格式">SpringBoot 2.x 统一接口返回格式</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6-%E8%AF%BB%E5%8F%96%20Resources%20%E6%96%87%E4%BB%B6%E4%B9%8B%E6%97%A0%E6%B3%95%E8%AF%BB%E5%8F%96Jar%E5%8C%85classpath%E4%B8%8B%E7%9A%84%E6%96%87%E4%BB%B6/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 配置文件-读取 Resources 文件之无法读取Jar包classpath下的文件">SpringBoot 2.x 配置文件-读取 Resources 文件之无法读取Jar包classpath下的文件</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6-%E8%AF%BB%E5%8F%96%20Resources%20%E6%96%87%E4%BB%B6%E7%9A%84N%E7%A7%8D%E6%96%B9%E5%BC%8F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 配置文件-读取 Resources 文件的N种方式">SpringBoot 2.x 配置文件-读取 Resources 文件的N种方式</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B%E7%AF%87-%E6%8B%A6%E6%88%AA%E5%99%A8%E8%BF%87%E6%BB%A4%E5%99%A8%E4%B8%8E%E7%9B%91%E5%90%AC%E5%99%A8/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 切面编程篇-拦截器过滤器与监听器">SpringBoot 2.x 切面编程篇-拦截器过滤器与监听器</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3%E8%AF%A6%E8%A7%A3/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 常用注解详解">SpringBoot 2.x 常用注解详解</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E5%AE%89%E5%85%A8%E5%AF%86%E7%A0%81%E5%AD%A6%E4%B9%8B%E5%8A%A0%E8%A7%A3%E5%AF%86%E7%AE%97%E6%B3%95/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 安全密码学之加解密算法">SpringBoot 2.x 安全密码学之加解密算法</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3%E5%A4%A7%E5%85%A8/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 常用注解大全">SpringBoot 2.x 常用注解大全</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E5%90%AF%E5%8A%A8%E6%97%B6%E5%8A%A0%E8%BD%BD%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84N%E7%A7%8D%E6%96%B9%E5%BC%8F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 启动时加载初始化的N种方式">SpringBoot 2.x 启动时加载初始化的N种方式</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%8F%8A%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E8%BF%87%E7%A8%8B/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 启动流程及自动装配过程">SpringBoot 2.x 启动流程及自动装配过程</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E5%8A%A8%E6%80%81%E8%A3%85%E9%85%8DBean%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 动态装配Bean的三种方式">SpringBoot 2.x 动态装配Bean的三种方式</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E5%88%A9%E5%99%A8-1%20JUnit5/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 单元测试利器-1 JUnit5">SpringBoot 2.x 单元测试利器-1 JUnit5</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E5%88%A9%E5%99%A8-3%20MockMvc/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 单元测试利器-3 MockMvc">SpringBoot 2.x 单元测试利器-3 MockMvc</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E5%88%A9%E5%99%A8-2%20Mockito/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 单元测试利器-2 Mockito">SpringBoot 2.x 单元测试利器-2 Mockito</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E5%88%86%E7%89%87%E4%B8%8A%E4%BC%A0%E3%80%81%E6%96%AD%E7%82%B9%E7%BB%AD%E4%BC%A0%E3%80%81%E5%A4%A7%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E3%80%81%E7%A7%92%E4%BC%A0/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 分片上传、断点续传、大文件上传、秒传">SpringBoot 2.x 分片上传、断点续传、大文件上传、秒传</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20Validation%20%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C%EF%BC%88TODO%EF%BC%89/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x Validation 参数校验（TODO）">SpringBoot 2.x Validation 参数校验（TODO）</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20WebMvcConfigurer%20%E8%AF%A6%E8%A7%A3%E3%80%90SpringMVC%E3%80%91/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x WebMvcConfigurer 详解【SpringMVC】">SpringBoot 2.x WebMvcConfigurer 详解【SpringMVC】</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20YML%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x YML配置文件详解">SpringBoot 2.x YML配置文件详解</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E5%88%86%E5%B8%83%E5%BC%8F%E5%85%A8%E5%B1%80%E5%94%AF%E4%B8%80ID%E7%94%9F%E6%88%90%E6%96%B9%E6%A1%88/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 分布式全局唯一ID生成方案">SpringBoot 2.x 分布式全局唯一ID生成方案</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20JWT%20%E6%A6%82%E5%BF%B5%E7%AF%87/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x JWT 概念篇">SpringBoot 2.x JWT 概念篇</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20Jar%20%E5%8C%85%E5%90%AF%E5%8A%A8%E3%80%81%E5%81%9C%E6%AD%A2%E3%80%81%E9%87%8D%E5%90%AF%E8%84%9A%E6%9C%AC/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x Jar 包启动、停止、重启脚本">SpringBoot 2.x Jar 包启动、停止、重启脚本</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20Java%20%E7%A8%8B%E5%BA%8F%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0%E6%80%BB%E7%BB%93/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x Java 程序命令行参数总结">SpringBoot 2.x Java 程序命令行参数总结</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20Java%20%E5%AE%9E%E7%8E%B0%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E7%9A%848%E7%A7%8D%E6%96%B9%E5%BC%8F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x Java 实现异步编程的8种方式">SpringBoot 2.x Java 实现异步编程的8种方式</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20@ConfigurationProperties%E4%BB%A5%E5%8F%8A@NestedConfigurationProperty%E7%9A%84%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x @ConfigurationProperties以及@NestedConfigurationProperty的使用详解">SpringBoot 2.x @ConfigurationProperties以及@NestedConfigurationProperty的使用详解</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20HTTP%20Content-Type%20%E8%AF%A6%E8%A7%A3/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x HTTP Content-Type 详解">SpringBoot 2.x HTTP Content-Type 详解</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20@ControllerAdvice%E4%B8%89%E7%A7%8D%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x @ControllerAdvice三种使用场景">SpringBoot 2.x @ControllerAdvice三种使用场景</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20JWT%20%E5%AE%9E%E6%88%98%E7%AF%87/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x JWT 实战篇">SpringBoot 2.x JWT 实战篇</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20HTTP%20Headers%20%E5%A4%B4%E4%BF%A1%E6%81%AF%E8%AF%BB%E5%8F%96/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x HTTP Headers 头信息读取">SpringBoot 2.x HTTP Headers 头信息读取</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%20%E6%8E%A5%E5%8F%A3%E5%B9%82%E7%AD%89%E6%80%A7%E5%AE%9E%E7%8E%B0/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x  接口幂等性实现">SpringBoot 2.x  接口幂等性实现</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/Spring%20IO%20Platform%EF%BC%9A%E8%A7%A3%E5%86%B3%E4%BE%9D%E8%B5%96%E7%89%88%E6%9C%AC%E5%86%B2%E7%AA%81/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Spring IO Platform：解决依赖版本冲突">Spring IO Platform：解决依赖版本冲突</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 SpringBoot "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B%E7%AF%87-AOP%20%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%8E%9F%E7%90%86/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 切面编程篇-AOP 的使用及原理">SpringBoot 2.x 切面编程篇-AOP 的使用及原理</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE SSM框架 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/2%E3%80%81SSM%E6%A1%86%E6%9E%B6/SpringMVC/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringMVC">SpringMVC</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 Shiro "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Shiro/Shiro%E6%9D%83%E9%99%90%E5%AE%9E%E6%88%98/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Shiro权限实战">Shiro权限实战</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 微服务开发 Shiro "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Shiro/Shiro%E6%9D%83%E9%99%90%E5%AE%9E%E6%88%98%E8%AF%BE%E7%A8%8B/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Shiro权限实战课程">Shiro权限实战课程</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE SSM框架 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/2%E3%80%81SSM%E6%A1%86%E6%9E%B6/Spring/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Spring">Spring</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE SSM框架 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/2%E3%80%81SSM%E6%A1%86%E6%9E%B6/MybatisPlus/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="MybatisPlus">MybatisPlus</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE JavaWeb "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/1%E3%80%81JavaWeb/%E4%BD%A0%E8%BF%98%E5%9C%A8%E4%B8%BA%20HTTP%20%E7%9A%84%E8%BF%99%E4%BA%9B%E6%A6%82%E5%BF%B5%E5%A4%B4%E7%96%BC%E5%90%97/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="你还在为 HTTP 的这些概念头疼吗">你还在为 HTTP 的这些概念头疼吗</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE JavaWeb "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/1%E3%80%81JavaWeb/Cookie%E3%80%81Session%E3%80%81Token%E3%80%81JWT%E7%BB%88%E4%BA%8E%E8%AE%B2%E6%B8%85%E6%A5%9A%E4%BA%86/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Cookie、Session、Token、JWT终于讲清楚了">Cookie、Session、Token、JWT终于讲清楚了</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 数据库 "
           href="/blog/2023/08/28/3%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL-%E9%AB%98%E7%BA%A7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="MySQL-高级">MySQL-高级</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 数据库 "
           href="/blog/2023/08/28/3%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL-%E5%88%9D%E7%BA%A7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="MySQL-初级">MySQL-初级</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 数据库 "
           href="/blog/2023/08/28/3%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93/H2%20Database/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="H2 Database">H2 Database</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E4%BC%98%E5%8C%96%E7%AF%87%E4%B9%8B%20%E5%BB%B6%E6%97%B6%E9%98%9F%E5%88%97%20-%20%E8%AE%A2%E5%8D%95%E8%B6%85%E6%97%B6%E8%87%AA%E5%8A%A8%E5%8F%96%E6%B6%88%E7%9A%84N%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 优化篇之 延时队列 - 订单超时自动取消的N种实现方式">Java 优化篇之 延时队列 - 订单超时自动取消的N种实现方式</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E4%BC%98%E5%8C%96%E7%AF%87%E4%B9%8B%20%E6%B3%A8%E8%A7%A3%20+%20%E5%8F%8D%E5%B0%84%E6%B6%88%E9%99%A4%E9%87%8D%E5%A4%8D%E4%BB%A3%E7%A0%81/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 优化篇之 注解 + 反射消除重复代码">Java 优化篇之 注解 + 反射消除重复代码</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E9%9B%86%E5%90%88%E7%AF%87%E4%B9%8B%20%E8%8E%B7%E5%8F%96%E4%B8%A4%E4%B8%AA%E9%9B%86%E5%90%88List%E7%9A%84%E4%BA%A4%E9%9B%86%E3%80%81%E8%A1%A5%E9%9B%86%E3%80%81%E5%B9%B6%E9%9B%86%E3%80%81%E5%B7%AE%E9%9B%86%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 集合篇之 获取两个集合List的交集、补集、并集、差集的几种方式">Java 集合篇之 获取两个集合List的交集、补集、并集、差集的几种方式</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E4%BC%98%E5%8C%96%E7%AF%87%E4%B9%8B%20if-else%20%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 优化篇之 if-else 代码优化方案">Java 优化篇之 if-else 代码优化方案</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4%E5%90%84%E7%B1%BB%E5%9E%8B%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 日期时间各类型相互转换">Java 日期时间各类型相互转换</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E9%9B%86%E5%90%88%E7%AF%87%E4%B9%8B%20Lambda%20%E5%AE%9E%E7%8E%B0%E8%B6%85%E5%BC%BA%E6%8E%92%E5%BA%8F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 集合篇之 Lambda 实现超强排序">Java 集合篇之 Lambda 实现超强排序</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 动态代理">Java 动态代理</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E5%9F%BA%E6%9C%AC%E5%8A%9F%E7%AF%87%E4%B9%8B%20for%E3%80%81for-each%E3%80%81forEach()%20%E7%9A%84%20break%E3%80%81continue%E3%80%81return/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 基本功篇之 for、for-each、forEach() 的 break、continue、return">Java 基本功篇之 for、for-each、forEach() 的 break、continue、return</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6%E8%AF%A6%E8%A7%A3/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 日志框架详解">Java 日志框架详解</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java新特性 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/3.Java%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%20%E6%96%B0%E7%89%B9%E6%80%A7%E6%A6%82%E8%BF%B0%E5%8F%8A%E7%89%88%E6%9C%AC%E5%8F%91%E8%A1%8C%E5%8F%B2/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 新特性概述及版本发行史">Java 新特性概述及版本发行史</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20Bean%20%E4%B9%8B%20Record%20%E7%B1%BB/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java Bean 之 Record 类">Java Bean 之 Record 类</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E4%BC%98%E5%8C%96%E7%AF%87%E4%B9%8B%20GZIP%E5%8E%8B%E7%BC%A9%E5%AD%97%E7%AC%A6%E4%B8%B2/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 优化篇之 GZIP压缩字符串">Java 优化篇之 GZIP压缩字符串</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java进阶篇 JVM虚拟机 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/2.Java%20%E8%BF%9B%E9%98%B6%E7%AF%87/JVM%20%E8%99%9A%E6%8B%9F%E6%9C%BA/Java%20GC%20%E6%80%BB%E7%BB%93/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java GC 总结">Java GC 总结</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java新特性 Java9新特性 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/3.Java%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%209%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%209%20%E6%96%B0%E7%89%B9%E6%80%A7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 9 新特性">Java 9 新特性</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java新特性 Java8新特性 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/3.Java%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%208%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%208%20%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8B%20Stream%20%E6%B5%81/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 8 新特性之 Stream 流">Java 8 新特性之 Stream 流</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java新特性 Java8新特性 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/3.Java%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%208%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%208%20%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8B%20Optional%20%E7%B1%BB/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 8 新特性之 Optional 类">Java 8 新特性之 Optional 类</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java新特性 Java8新特性 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/3.Java%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%208%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%208%20%E6%96%B0%E7%89%B9%E6%80%A7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 8 新特性">Java 8 新特性</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java新特性 Java8新特性 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/3.Java%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%208%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%208%20%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8B%20DateTime%20API/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 8 新特性之 DateTime API">Java 8 新特性之 DateTime API</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java新特性 Java18新特性 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/3.Java%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2018%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2018%20%E6%96%B0%E7%89%B9%E6%80%A7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 18 新特性">Java 18 新特性</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java新特性 Java20新特性 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/3.Java%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2020%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2020%20%E6%96%B0%E7%89%B9%E6%80%A7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 20 新特性">Java 20 新特性</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java新特性 Java19新特性 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/3.Java%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2019%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2019%20%E6%96%B0%E7%89%B9%E6%80%A7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 19 新特性">Java 19 新特性</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java新特性 Java17新特性 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/3.Java%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2017%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2017%20%E6%96%B0%E7%89%B9%E6%80%A7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 17 新特性">Java 17 新特性</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java新特性 Java15新特性 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/3.Java%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2015%E6%96%B0%E7%89%B9%E6%80%A7/Java%2015%20%E6%96%B0%E7%89%B9%E6%80%A7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 15 新特性">Java 15 新特性</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java新特性 Java16新特性 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/3.Java%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2016%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2016%20%E6%96%B0%E7%89%B9%E6%80%A7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 16 新特性">Java 16 新特性</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java新特性 Java13新特性 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/3.Java%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2013%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2013%20%E6%96%B0%E7%89%B9%E6%80%A7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 13 新特性">Java 13 新特性</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java新特性 Java14新特性 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/3.Java%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2014%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2014%20%E6%96%B0%E7%89%B9%E6%80%A7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 14 新特性">Java 14 新特性</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java新特性 Java10新特性 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/3.Java%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2010%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2010%20%E6%96%B0%E7%89%B9%E6%80%A7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 10 新特性">Java 10 新特性</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java新特性 Java11新特性 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/3.Java%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2011%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2011%20%E6%96%B0%E7%89%B9%E6%80%A7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 11 新特性">Java 11 新特性</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java新特性 Java12新特性 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/3.Java%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2012%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2012%20%E6%96%B0%E7%89%B9%E6%80%A7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 12 新特性">Java 12 新特性</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java基础篇 Java基础语法 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/1.Java%20%E5%9F%BA%E7%A1%80%E7%AF%87/1%E3%80%81Java%20%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/Java%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 面向对象编程">Java 面向对象编程</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java基础篇 Java集合类 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/1.Java%20%E5%9F%BA%E7%A1%80%E7%AF%87/3%E3%80%81Java%20%E9%9B%86%E5%90%88%E7%B1%BB/Java%20%E7%B1%BB%E9%9B%86%E6%A1%86%E6%9E%B6/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 类集框架">Java 类集框架</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java基础篇 Java常用类库 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/1.Java%20%E5%9F%BA%E7%A1%80%E7%AF%87/2%E3%80%81Java%20%E5%B8%B8%E7%94%A8%E7%B1%BB%E5%BA%93/Java%20%E5%B8%B8%E7%94%A8%E7%B1%BB%E5%BA%93/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 常用类库">Java 常用类库</span>
            <span class="post-date" title="2023-08-28 09:23:44">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java基础篇 Java多线程 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/1.Java%20%E5%9F%BA%E7%A1%80%E7%AF%87/5%E3%80%81Java%20%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 多线程基础">Java 多线程基础</span>
            <span class="post-date" title="2023-08-28 09:23:44">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java基础篇 Java反射与注解 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/1.Java%20%E5%9F%BA%E7%A1%80%E7%AF%87/4%E3%80%81Java%20%E5%8F%8D%E5%B0%84%E4%B8%8E%E6%B3%A8%E8%A7%A3/Java%20%E5%8F%8D%E5%B0%84%E4%B8%8E%E6%B3%A8%E8%A7%A3/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 反射与注解">Java 反射与注解</span>
            <span class="post-date" title="2023-08-28 09:23:44">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java基础篇 JavaNIO流 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/1.Java%20%E5%9F%BA%E7%A1%80%E7%AF%87/7%E3%80%81Java%20NIO%20%E6%B5%81/Java%20NIO%20%E6%B5%81/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java NIO 流">Java NIO 流</span>
            <span class="post-date" title="2023-08-28 09:23:44">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java基础篇 JavaIO流 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/1.Java%20%E5%9F%BA%E7%A1%80%E7%AF%87/6%E3%80%81Java%20IO%20%E6%B5%81/Java%20IO%20%E6%B5%81/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java IO 流">Java IO 流</span>
            <span class="post-date" title="2023-08-28 09:23:44">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java进阶篇 Java设计模式 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/2.Java%20%E8%BF%9B%E9%98%B6%E7%AF%87/Java%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/Java%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 设计模式">Java 设计模式</span>
            <span class="post-date" title="2023-08-28 09:23:44">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java进阶篇 JVM虚拟机 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/2.Java%20%E8%BF%9B%E9%98%B6%E7%AF%87/JVM%20%E8%99%9A%E6%8B%9F%E6%9C%BA/7%20%E6%AE%B5%E5%B0%8F%E4%BB%A3%E7%A0%81%EF%BC%8C%E7%8E%A9%E8%BD%ACJava%E7%A8%8B%E5%BA%8F%E5%B8%B8%E8%A7%81%E7%9A%84%E5%B4%A9%E6%BA%83%E5%9C%BA%E6%99%AF/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="7 段小代码，玩转Java程序常见的崩溃场景">7 段小代码，玩转Java程序常见的崩溃场景</span>
            <span class="post-date" title="2023-08-28 09:23:44">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Java进阶篇 JVM虚拟机 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/2.Java%20%E8%BF%9B%E9%98%B6%E7%AF%87/JVM%20%E8%99%9A%E6%8B%9F%E6%9C%BA/JVM%20%E8%99%9A%E6%8B%9F%E6%9C%BA/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="JVM 虚拟机">JVM 虚拟机</span>
            <span class="post-date" title="2023-08-28 09:23:44">2023/08/28</span>
        </a>
        
        <div id="no-item-tips">

        </div>
    </nav>
    <div id="outline-list">
    </div>
</div>

    </div>
    <div class="hide-list">
        <div class="semicircle" data-title="切换全屏 快捷键 s">
            <div class="brackets first"><</div>
            <div class="brackets">&gt;</div>
        </div>
    </div>
</aside>
<div id="post">
    <div class="pjax">
        <article id="post-2、JavaEE/3、微服务开发/Spring Data JPA/Hibernata JPA" class="article article-type-post" itemscope itemprop="blogPost">
    
        <h1 class="article-title">Hibernata JPA</h1>
    
    <div class="article-meta">
        
        
        
        <span class="book">
            <i class="iconfont icon-category"></i>
            
            
            <a  data-rel="微服务开发">微服务开发</a> > 
            
            <a  data-rel="微服务开发&lt;---&gt;SpringDataJPA">SpringDataJPA</a>
            
        </span>
        
        
    </div>
    <div class="article-meta">
        
            发布时间 : <time class="date" title='最后更新: 2024-10-21 00:22:31'>2023-08-28 09:23</time>
        
    </div>
    <div class="article-meta">
        
        
        <span id="busuanzi_container_page_pv">
            阅读 :<span id="busuanzi_value_page_pv">
                <span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </span>
        </span>
        
        
    </div>
    
    <div class="toc-ref">
    
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Hibernate-JPA-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8"><span class="toc-text">Hibernate JPA 快速入门</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81ORM-%E7%9A%84%E4%BB%8B%E7%BB%8D"><span class="toc-text">1、ORM 的介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF-ORM%EF%BC%9F"><span class="toc-text">1、什么是 ORM？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8-ORM%EF%BC%9F"><span class="toc-text">2、为什么要使用 ORM？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81ORM-%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">3、ORM 的优缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E5%B8%B8%E8%A7%81ORM%E6%80%9D%E6%83%B3%E7%9A%84%E6%A1%86%E6%9E%B6"><span class="toc-text">4、常见ORM思想的框架</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81%E5%B8%B8%E8%A7%81ORM%E6%A1%86%E6%9E%B6%E6%80%BB%E7%BB%93"><span class="toc-text">5、常见ORM框架总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81Hibernate-JPA%E7%AE%80%E4%BB%8B"><span class="toc-text">2、Hibernate JPA简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%EF%BC%88IDEA%EF%BC%89"><span class="toc-text">3、搭建开发环境（IDEA）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81JPA-%E5%AE%8C%E6%95%B4%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-text">4、JPA 完整配置文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81JPA-%E6%A0%B8%E5%BF%83API%E5%AF%B9%E8%B1%A1"><span class="toc-text">5、JPA 核心API对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81JPA-%E5%AE%9E%E7%8E%B0CRUD%E6%93%8D%E4%BD%9C"><span class="toc-text">6、JPA 实现CRUD操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E4%BF%9D%E5%AD%98%E6%93%8D%E4%BD%9C%EF%BC%9Apersist"><span class="toc-text">1、保存操作：persist</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E6%9F%A5%E8%AF%A2%E6%93%8D%E4%BD%9C%EF%BC%9Afind-getReference"><span class="toc-text">2、查询操作：find&#x2F;getReference</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E6%9B%B4%E6%96%B0%E6%93%8D%E4%BD%9C%EF%BC%9Amerge"><span class="toc-text">3、更新操作：merge</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C%EF%BC%9Aremove"><span class="toc-text">4、删除操作：remove</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E3%80%81JPA-%E8%BF%9E%E6%8E%A5%E5%B7%A5%E5%8E%82%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-text">7、JPA 连接工厂工具类</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Hibernate-JPA-%E5%A4%8D%E6%9D%82%E6%9F%A5%E8%AF%A2"><span class="toc-text">Hibernate JPA 复杂查询</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81JPQL-%E6%9F%A5%E8%AF%A2%E4%B8%8E%E6%9B%B4%E6%96%B0"><span class="toc-text">1、JPQL 查询与更新</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1%E3%80%81%E7%AE%80%E5%8D%95%E6%9F%A5%E8%AF%A2"><span class="toc-text">1.1、简单查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2%E3%80%81%E5%88%AB%E5%90%8D%E6%9F%A5%E8%AF%A2"><span class="toc-text">1.2、别名查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3%E3%80%81%E6%8E%92%E5%BA%8F%E6%9F%A5%E8%AF%A2"><span class="toc-text">1.3、排序查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4%E3%80%81%E6%9D%A1%E4%BB%B6%E6%9F%A5%E8%AF%A2"><span class="toc-text">1.4、条件查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5%E3%80%81%E6%8A%95%E5%BD%B1%E6%9F%A5%E8%AF%A2"><span class="toc-text">1.5、投影查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-6%E3%80%81%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2"><span class="toc-text">1.6、分页查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-7%E3%80%81%E5%88%86%E7%BB%84%E6%9F%A5%E8%AF%A2"><span class="toc-text">1.7、分组查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-8%E3%80%81%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2"><span class="toc-text">1.8、多表查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-9%E3%80%81%E6%9B%B4%E6%96%B0%E5%88%A0%E9%99%A4"><span class="toc-text">1.9、更新删除</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81SQL-%E6%9F%A5%E8%AF%A2%E4%B8%8E%E6%9B%B4%E6%96%B0"><span class="toc-text">2、SQL 查询与更新</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81Criteria-%E5%A4%8D%E6%9D%82%E6%9F%A5%E8%AF%A2"><span class="toc-text">3、Criteria 复杂查询</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1%E3%80%81%E6%9F%A5%E8%AF%A2%E5%85%A8%E9%83%A8"><span class="toc-text">3.1、查询全部</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2%E3%80%81%E6%8A%95%E5%BD%B1%E6%9F%A5%E8%AF%A2"><span class="toc-text">3.2、投影查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3%E3%80%81%E6%9D%A1%E4%BB%B6%E6%9F%A5%E8%AF%A2"><span class="toc-text">3.3、条件查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4%E3%80%81%E6%8E%92%E5%BA%8F%E6%9F%A5%E8%AF%A2"><span class="toc-text">3.4、排序查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5%E3%80%81%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2"><span class="toc-text">3.5、分页查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6%E3%80%81%E5%88%86%E7%BB%84%E6%9F%A5%E8%AF%A2"><span class="toc-text">3.6、分组查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-7%E3%80%81%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2"><span class="toc-text">3.7、多表查询</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81Query-%E6%8E%A5%E5%8F%A3%E6%96%B9%E6%B3%95%E4%BB%8B%E7%BB%8D"><span class="toc-text">4、Query 接口方法介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81NamedQuery-NamedNativeQuery-%E5%88%AB%E5%90%8D%E6%9F%A5%E8%AF%A2"><span class="toc-text">5、NamedQuery&#x2F;@NamedNativeQuery 别名查询</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81JPA-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AF%B9%E8%B1%A1%E6%8E%A5%E6%94%B6%E6%9F%A5%E8%AF%A2%E7%BB%93%E6%9E%9C%E9%9B%86"><span class="toc-text">6、JPA 自定义对象接收查询结果集</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Hibernate-JPA-%E6%B3%A8%E8%A7%A3%E5%88%86%E6%9E%90"><span class="toc-text">Hibernate JPA 注解分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3"><span class="toc-text">1、常用注解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Entity"><span class="toc-text">Entity</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Table"><span class="toc-text">Table</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Entity-%E4%B8%8E-Table-%E5%AF%B9%E6%AF%94"><span class="toc-text">Entity 与 Table 对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Column"><span class="toc-text">Column</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Basic"><span class="toc-text">Basic</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Transient"><span class="toc-text">Transient</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Temporal"><span class="toc-text">Temporal</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CreationTimestamp"><span class="toc-text">CreationTimestamp</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#UpdateTimestamp"><span class="toc-text">UpdateTimestamp</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E9%BB%98%E8%AE%A4%E5%80%BC%E6%B3%A8%E8%A7%A3%EF%BC%88%E7%B1%BB%E4%BC%BC%E5%AE%A1%E8%AE%A1%E5%8A%9F%E8%83%BD%EF%BC%89"><span class="toc-text">自定义默认值注解（类似审计功能）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E4%B8%BB%E9%94%AE%E6%B3%A8%E8%A7%A3"><span class="toc-text">2、主键注解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Id"><span class="toc-text">Id</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IdClass"><span class="toc-text">IdClass</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#EmbeddedId"><span class="toc-text">EmbeddedId</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GeneratedValue"><span class="toc-text">GeneratedValue</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SequenceGenerator"><span class="toc-text">SequenceGenerator</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GenericGenerator"><span class="toc-text">GenericGenerator</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TableGenerator"><span class="toc-text">TableGenerator</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E5%B5%8C%E5%85%A5%E6%B3%A8%E8%A7%A3"><span class="toc-text">3、嵌入注解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Embeddable"><span class="toc-text">Embeddable</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Embedded"><span class="toc-text">Embedded</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MappedSuperclass"><span class="toc-text">MappedSuperclass</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AttributeOverride"><span class="toc-text">AttributeOverride</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AttributeOverrides"><span class="toc-text">AttributeOverrides</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AssociationOverride"><span class="toc-text">AssociationOverride</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AssociationOverrides"><span class="toc-text">AssociationOverrides</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E6%AC%A1%E7%94%A8%E6%B3%A8%E8%A7%A3"><span class="toc-text">4、次用注解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#SecondaryTable"><span class="toc-text">SecondaryTable</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SecondaryTables"><span class="toc-text">SecondaryTables</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PrimaryKeyJoinColumn"><span class="toc-text">PrimaryKeyJoinColumn</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PrimaryKeyJoinColumns"><span class="toc-text">PrimaryKeyJoinColumns</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#UniqueConstraint"><span class="toc-text">UniqueConstraint</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#OrderBy"><span class="toc-text">OrderBy</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Version"><span class="toc-text">Version</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lob"><span class="toc-text">Lob</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Enumerated"><span class="toc-text">Enumerated</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ElementCollection"><span class="toc-text">ElementCollection</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NoRepositoryBean"><span class="toc-text">NoRepositoryBean</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#EntityGraph%EF%BC%88%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%B3%A8%E8%A7%A3%EF%BC%89"><span class="toc-text">EntityGraph（性能优化注解）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81%E5%AE%A1%E8%AE%A1%E5%8A%9F%E8%83%BD%EF%BC%88Spring-Data%EF%BC%89"><span class="toc-text">5、审计功能（Spring Data）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81%E5%85%B3%E8%81%94%E5%85%B3%E7%B3%BB%E6%B3%A8%E8%A7%A3"><span class="toc-text">6、关联关系注解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E3%80%81%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%9E%E8%B0%83%E6%96%B9%E6%B3%95"><span class="toc-text">7、生命周期回调方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8%E3%80%81Convert-%E8%BD%AC%E6%8D%A2%E5%99%A8%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89"><span class="toc-text">8、Convert 转换器（重点）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9%E3%80%81Hibernate-Validation-%E6%A0%A1%E9%AA%8C%E6%B3%A8%E8%A7%A3"><span class="toc-text">9、Hibernate-Validation 校验注解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Hibernate-JPA-%E4%B8%BB%E9%94%AE%E7%AD%96%E7%95%A5"><span class="toc-text">Hibernate JPA 主键策略</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81AUTO-%E7%AD%96%E7%95%A5"><span class="toc-text">1、AUTO 策略</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81IDENTITY-%E7%AD%96%E7%95%A5"><span class="toc-text">2、IDENTITY 策略</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81SEQUENCE-%E7%AD%96%E7%95%A5"><span class="toc-text">3、SEQUENCE 策略</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81TABLE-%E7%AD%96%E7%95%A5"><span class="toc-text">4、TABLE 策略</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%BB%E9%94%AE%E7%94%9F%E6%88%90%E5%99%A8"><span class="toc-text">5、自定义主键生成器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81%E4%B8%BB%E9%94%AE%E5%AF%B9%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E6%94%AF%E6%8C%81"><span class="toc-text">6、主键对数据库的支持</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E3%80%81%E4%B8%BB%E9%94%AEUUID%E4%B8%8E%E6%95%B0%E5%AD%97%E5%AF%B9%E6%AF%94"><span class="toc-text">7、主键UUID与数字对比</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8%E3%80%81%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE-%E9%B8%A3%E8%B0%A2"><span class="toc-text">8、参考文献 &amp; 鸣谢</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Hibernate-JPA-%E7%BC%93%E5%AD%98%E9%85%8D%E7%BD%AE"><span class="toc-text">Hibernate JPA 缓存配置</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98"><span class="toc-text">1、一级缓存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E5%AF%B9%E8%B1%A1%E7%8A%B6%E6%80%81%EF%BC%88%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%89"><span class="toc-text">2、对象状态（生命周期）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98"><span class="toc-text">3、二级缓存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E6%9F%A5%E8%AF%A2%E7%BC%93%E5%AD%98"><span class="toc-text">3、查询缓存</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Hibernate-JPA-%E9%94%81%E7%9A%84%E6%9C%BA%E5%88%B6"><span class="toc-text">Hibernate JPA 锁的机制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E6%82%B2%E8%A7%82%E9%94%81%EF%BC%9APessimistic"><span class="toc-text">1、悲观锁：Pessimistic</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E4%B9%90%E8%A7%82%E9%94%81%EF%BC%9AOptimistic"><span class="toc-text">2、乐观锁：Optimistic</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Hibernate-JPA-%E5%85%B3%E8%81%94%E5%85%B3%E7%B3%BB"><span class="toc-text">Hibernate JPA 关联关系</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E4%B8%80%E5%AF%B9%E4%B8%80%E5%85%B3%E8%81%94%E6%98%A0%E5%B0%84"><span class="toc-text">1、一对一关联映射</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1%E3%80%81%E5%8D%95%E5%90%91%E4%B8%80%E5%AF%B9%E4%B8%80"><span class="toc-text">1.1、单向一对一</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2%E3%80%81%E5%8F%8C%E5%90%91%E4%B8%80%E5%AF%B9%E4%B8%80"><span class="toc-text">1.2、双向一对一</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E4%B8%80%E5%AF%B9%E5%A4%9A%E5%85%B3%E8%81%94%E6%98%A0%E5%B0%84"><span class="toc-text">2、一对多关联映射</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1%E3%80%81%E5%8D%95%E5%90%91%E4%B8%80%E5%AF%B9%E5%A4%9A"><span class="toc-text">2.1、单向一对多</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2%E3%80%81%E5%8D%95%E5%90%91%E5%A4%9A%E5%AF%B9%E4%B8%80"><span class="toc-text">2.2、单向多对一</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3%E3%80%81%E5%8F%8C%E5%90%91%E4%B8%80%E5%AF%B9%E5%A4%9A"><span class="toc-text">2.3、双向一对多</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E5%A4%9A%E5%AF%B9%E5%A4%9A%E5%85%B3%E8%81%94%E6%98%A0%E5%B0%84"><span class="toc-text">3、多对多关联映射</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1%E3%80%81%E5%8D%95%E5%90%91%E5%A4%9A%E5%AF%B9%E5%A4%9A"><span class="toc-text">3.1、单向多对多</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2%E3%80%81%E5%8F%8C%E5%90%91%E5%A4%9A%E5%AF%B9%E5%A4%9A"><span class="toc-text">3.2、双向多对多</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Hibernate-JPA-%E9%80%BB%E8%BE%91%E5%88%A0%E9%99%A4"><span class="toc-text">Hibernate JPA 逻辑删除</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E9%80%BB%E8%BE%91%E5%88%A0%E9%99%A4"><span class="toc-text">1、什么是逻辑删除</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E9%80%BB%E8%BE%91%E5%88%A0%E9%99%A4"><span class="toc-text">2、为什么需要逻辑删除</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81JPA-%E5%AE%9E%E7%8E%B0%E9%80%BB%E8%BE%91%E5%88%A0%E9%99%A4"><span class="toc-text">3、JPA 实现逻辑删除</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E6%9B%B4%E6%96%B0%E5%BD%93%E5%89%8D-session-%E4%B8%AD%E7%9A%84%E5%88%A0%E9%99%A4%E7%8A%B6%E6%80%81"><span class="toc-text">4、更新当前 session 中的删除状态</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE-%E9%B8%A3%E8%B0%A2"><span class="toc-text">参考文献 &amp; 鸣谢</span></a></li></ol>
    
<style>
    .left-col .switch-btn,
    .left-col .switch-area {
        display: none;
    }
    .toc-level-3 i,
    .toc-level-3 ol {
        display: none !important;
    }
</style>
</div>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Hibernate-JPA-快速入门"><a href="#Hibernate-JPA-快速入门" class="headerlink" title="Hibernate JPA 快速入门"></a>Hibernate JPA 快速入门</h1><h2 id="1、ORM-的介绍"><a href="#1、ORM-的介绍" class="headerlink" title="1、ORM 的介绍"></a>1、ORM 的介绍</h2><h3 id="1、什么是-ORM？"><a href="#1、什么是-ORM？" class="headerlink" title="1、什么是 ORM？"></a>1、什么是 ORM？</h3><p>ORM（Object-Relational Mapping） 表示对象关系映射。在面向对象的软件开发中，通过ORM，就可以把对象映射到关系型数据库中。只要有一套程序能够做到建立对象与数据库的关联，操作对象就可以直接操作数据库数据，就可以说这套程序实现了ORM对象关系映射。简单的说：ORM 就是建立实体类和数据库表之间的关系，从而达到操作实体类就相当于操作数据库表的目的（就是说ORM会把数据表映射成一个Java对象，使开发人员可以关注Java程序）</p>
<h3 id="2、为什么要使用-ORM？"><a href="#2、为什么要使用-ORM？" class="headerlink" title="2、为什么要使用 ORM？"></a>2、为什么要使用 ORM？</h3><p>当实现一个应用程序时（不使用O&#x2F;R Mapping），我们可能会写特别多数据访问层的代码（各种各样的DAO类），从数据库增删改查等操作，而这些代码都是重复的。但使用ORM框架则会大大减少重复性代码。对象关系映射（Object Relational Mapping，简称ORM），主要实现程序对象到关系数据库数据的映射。</p>
<h3 id="3、ORM-的优缺点"><a href="#3、ORM-的优缺点" class="headerlink" title="3、ORM 的优缺点"></a>3、ORM 的优缺点</h3><p>优点：</p>
<ol>
<li>提高开发效率，降低开发成本  （减少了DAO类的操作）</li>
<li>使开发更加对象化 （直接在实体类domain中来映射关系）</li>
<li>可移植</li>
<li>可以很方便地引入数据缓存之类的附加功能</li>
</ol>
<p>缺点： </p>
<ol>
<li>自动化进行关系数据库的映射需要消耗系统性能（消耗的性能可以忽略不记）</li>
<li>在处理多表联查、where条件复杂之类的查询时，ORM的语法会变得复杂（这才是最致命的缺点）</li>
</ol>
<h3 id="4、常见ORM思想的框架"><a href="#4、常见ORM思想的框架" class="headerlink" title="4、常见ORM思想的框架"></a>4、常见ORM思想的框架</h3><p>常见ORM思想的框架：JDBC、Hibernate、MyBatis、TopLink、JPA（JPA对ORM框架的再一次封装，这里是一套规范）</p>
<ol>
<li>JDBC：其实JDBC是最原生的API，支持连接并操作各种关系型数据库，也就是说可以用JDBC完成ORM思想的程序编写，如一些有ORM思想的框架底层都调用JDBC，所有这个JDBC我对其理解为ORM思想</li>
<li>Hibernate：这个框架就不用多说了，完全使用ORM思想，不过现在直接使用Hibernate的少了，大多都是在JPA的封装上调用此框架</li>
<li>MyBatis：这个框架可以手动写SQL语句，也可以完成对象关系映射，其实严格上说Mybatis不完全是一个ORM框架（JPA的供应商就不支持Mybatis）</li>
</ol>
<h3 id="5、常见ORM框架总结"><a href="#5、常见ORM框架总结" class="headerlink" title="5、常见ORM框架总结"></a>5、常见ORM框架总结</h3><ol>
<li>JDBC：快，代码冗余、频繁的开关连接消耗性能、SQL不够灵活</li>
<li>Mybatis：小巧、方便、高效、简单、直接、半自动</li>
<li>Hibernate：强大、方便、高效、复杂、绕弯子、全自动</li>
</ol>
<h2 id="2、Hibernate-JPA简介"><a href="#2、Hibernate-JPA简介" class="headerlink" title="2、Hibernate JPA简介"></a>2、Hibernate JPA简介</h2><p>1、认识 hibernate</p>
<p>Hibernate是一个开放源代码的对象关系映射框架，它对JDBC进行了非常轻量级的对象封装，它将 POJO与数据库表建立映射关系，是一个全自动的 orm 框架，hibernate 可以自动生成 SQL 语句，自动执行，使得 Java 程序员可以随心所欲的使用对象编程思维来操纵数据库。</p>
<p>2、认识 JPA</p>
<p>JPA（Java Persistence API）即Java 持久化API，是SUN公司推出的一套基于ORM的规范，内部是由一系列的接口和抽象类构成。JPA 通过JDK 5.0注解描述 对象－关系表 的映射关系，并将运行期的实体对象持久化到数据库中。</p>
<p>3、JPA 的优势：</p>
<ul>
<li>标准化：<br>JPA 是 JCP 组织发布的 Java EE 标准之一，因此任何声称符合 JPA 标准的框架都遵循同样的架构，提供相同的访问API，这保证了基于JPA开发的企业应用能够经过少量的修改就能够在不同的JPA框架下运行。</li>
<li>容器级特性的支持：<br>JPA框架中支持大数据集、事务、并发等容器级事务，这使得 JPA 超越了简单持久化框架的局限，在企业应用发挥更大的作用。</li>
<li>简单方便：<br>JPA的主要目标之一就是提供更加简单的编程模型：在JPA框架下创建实体和创建Java 类一样简单，没有任何的约束和限制，只需要使用 javax.persistence.Entity 进行注释，JPA的框架和接口也都非常简单，没有太多特别的规则和设计模式的要求，开发者可以很容易的掌握。JPA基于非侵入式原则设计，因此可以很容易的和其它框架或者容器集成</li>
<li>查询能力：<br>JPA的查询语言是面向对象而非面向数据库的，它以面向对象的自然语法构造查询语句，可以看成是Hibernate HQL的等价物。JPA定义了独特的JPQL（Java Persistence Query Language），JPQL是EJB QL的一种扩展，它是针对实体的一种查询语言，操作对象是实体，而不是关系数据库的表，而且能够支持批量更新和修改、JOIN、GROUP BY、HAVING 等通常只有 SQL 才能够提供的高级查询特性，甚至还能够支持子查询。</li>
<li>高级特性：<br>JPA 中能够支持面向对象的高级特性，如类之间的继承、多态和类之间的复杂关系，这样的支持能够让开发者最大限度的使用面向对象的模型设计企业应用，而不需要自行处理这些特性在关系数据库的持久化。</li>
</ul>
<p>4、JPA 与 Hibernate 的关系</p>
<p>JPA 规范本质上就是<strong>一种ORM规范，注意不是ORM框架</strong>，因为JPA并未提供ORM实现，它只是定义了一些规范，提供了一些编程的API接口，但具体实现则由服务厂商来提供实现。JPA示意图：</p>
<pre><code>                                               Java代码
                                                  ⬇
                        JPA规范（SUM公司定义的，Java持久化规范，内部由一系列接口和抽象类组成）
                                                  ⬇
                             Hibernate/TopLink...其他ORM框架（它们都是实现了JPA规范）
                                                  ⬇
                                           JDBC规范（SUM公司制定）
                                                  ⬇
                                           MySQL/Oracle驱动
                                                  ⬇
                                           MySQL/Oracle数据库
</code></pre>
<p>JPA 和 Hibernate 的关系就像 JDBC 和 JDBC 驱动的关系，JPA是规范，Hibernate 除了作为ORM框架之外，它也是一种JPA实现。</p>
<p>PS：JPA 能取代 Hibernate 吗？正如同问 JDBC 规范可以驱动底层数据库吗？<br>答案是否定的，如果使用JPA规范进行数据库操作，底层需要 Hibernate 作为其实现类完成数据持久化工作。</p>
<h2 id="3、搭建开发环境（IDEA）"><a href="#3、搭建开发环境（IDEA）" class="headerlink" title="3、搭建开发环境（IDEA）"></a>3、搭建开发环境（IDEA）</h2><blockquote>
<p>直接使用IDEA创建JPA项目（使用Maven方式创建）：<a target="_blank" rel="noopener" href="https://blog.csdn.net/jellily12/article/details/89304345">https://blog.csdn.net/jellily12/article/details/89304345</a></p>
</blockquote>
<p>1、使用 IDEA 创建 maven 工程（如果缺少src&#x2F;test&#x2F;resources目录，手动创建和设置即可）</p>
<pre><code class="cmd">├─JPA
  │  JPA.iml
  │  pom.xml
  └─src
      ├─main
      │  ├─java
      │  └─resources
      └─test
          ├─java
          └─resources
</code></pre>
<p>2、导入pom依赖</p>
<pre><code class="xml">    &lt;properties&gt;
        &lt;!--锁定 jdk 版本为 1.8--&gt;
        &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;
        &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;
    &lt;/properties&gt;

    &lt;dependencies&gt;
        &lt;!-- hibernate对jpa的支持包 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.hibernate&lt;/groupId&gt;
            &lt;artifactId&gt;hibernate-entitymanager&lt;/artifactId&gt;
            &lt;version&gt;5.4.1.Final&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!-- Mysql驱动 --&gt;
        &lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;mysql&lt;/groupId&gt;
            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
            &lt;version&gt;5.1.38&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!-- junit4单元测试 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;junit&lt;/groupId&gt;
            &lt;artifactId&gt;junit&lt;/artifactId&gt;
            &lt;version&gt;4.13&lt;/version&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
        &lt;!-- https://mvnrepository.com/artifact/org.projectlombok/lombok --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
            &lt;artifactId&gt;lombok&lt;/artifactId&gt;
            &lt;version&gt;1.18.16&lt;/version&gt;
            &lt;scope&gt;provided&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
</code></pre>
<p>3、建立配置文件：&#x2F;resources&#x2F;META-INF&#x2F;persistence.xml</p>
<ul>
<li><p>路径：配置到类路径（resources）下的 META-INF 的文件夹下，文件名：persistence.xml</p>
</li>
<li><p>PS：由于主要在 src&#x2F;test&#x2F; 下测试，所以建议在 src&#x2F;test&#x2F;resources&#x2F; 也建立 META-INF&#x2F;persistence.xml</p>
</li>
<li><p>IDEA创建 persistence 模板：<code>setting=》Editor=》file and code Template=》JPA==》Deployment descriptors=》persistenceXX.xml</code></p>
</li>
</ul>
<p>persistence.xml 文件内容：</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;persistence xmlns=&quot;http://java.sun.com/xml/ns/persistence&quot; version=&quot;2.0&quot;&gt;
 
    &lt;!-- name：持久化单元名称，transaction-type：持久化单元事务类型(JTA:分布式事务管理,RESOURCE_LOCAL:本地事务管理) --&gt;
    &lt;persistence-unit name=&quot;myJpa&quot; transaction-type=&quot;RESOURCE_LOCAL&quot;&gt;
        &lt;!--jpa的实现方式,配置JPA服务提供商 --&gt;
        &lt;provider&gt;org.hibernate.jpa.HibernatePersistenceProvider&lt;/provider&gt;
        &lt;!-- 可配可不配，如果配置了顺序不能错，必须在provider之后--&gt;
        &lt;!--&lt;class&gt;com.caochenlei.hibernate.jpa.Customer&lt;/class&gt;--&gt;

        &lt;!--可选配置：配置jpa实现方的配置信息--&gt;
        &lt;properties&gt;
            &lt;!-- 数据库信息配置：数据库驱动、数据库地址、数据库账户、数据库密码 --&gt;
            &lt;property name=&quot;hibernate.connection.driver_class&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;
            &lt;property name=&quot;hibernate.connection.url&quot; value=&quot;jdbc:mysql://127.0.0.1:3306/hibernate_jpa&quot;/&gt;
            &lt;property name=&quot;hibernate.connection.username&quot; value=&quot;root&quot;/&gt;
            &lt;property name=&quot;hibernate.connection.password&quot; value=&quot;password&quot;/&gt;

            &lt;!-- 配置JPA服务提供商可选参数 --&gt;
            &lt;property name=&quot;hibernate.show_sql&quot; value=&quot;true&quot; /&gt;&lt;!-- 自动显示sql --&gt;
            &lt;property name=&quot;hibernate.format_sql&quot; value=&quot;true&quot;/&gt;&lt;!-- 格式化sql --&gt;
            &lt;!-- 自动创建数据库表：
                none        ：不会创建表
                create      : 程序运行时创建数据库表（如果有表，先删除表再创建）
                update      ：程序运行时创建表（如果有表，不会创建表）
                create-drop : 每次加载hibernate时根据model类生成表，但是sessionFactory一关闭,表就自动删除。
                validate    : 每次加载hibernate时，验证创建数据库表结构，只会和数据库中的表进行比较，不会创建新表，但是会插入新值。
            --&gt;
            &lt;property name=&quot;hibernate.hbm2ddl.auto&quot; value=&quot;update&quot; /&gt;
        &lt;/properties&gt;
    &lt;/persistence-unit&gt;
&lt;/persistence&gt;
</code></pre>
<p>4、编写实体类和数据库表的映射配置（目的是达到操作实体类，就相当于操作数据库表）</p>
<pre><code class="java">/**
 * 客户的实体类
 * 配置映射关系
 *   1.实体类和表的映射关系
 *      @Entity：声明实体类
 *      @Table：配置实体类和表的映射关系
 *          name : 配置数据库表的名称
 *   2.实体类中属性和表中字段的映射关系
 */
@Data
@Entity
@Table(name = &quot;tb_customer&quot;)
public class Customer &#123;

    /**
     * @Id：声明主键的配置
     * @GeneratedValue:配置主键的生成策略
     *      strategy:
     *          GenerationType.IDENTITY ：自增，mysql。底层数据库必须支持自动增长（底层数据库支持的自动增长方式，对id自增）
     *          GenerationType.SEQUENCE ：序列，oracle（底层数据库必须支持序列）
     *          GenerationType.TABLE    ：jpa提供的一种机制，通过一张数据库表的形式帮助我们完成主键自增
     *          GenerationType.AUTO     ：由程序自动的帮助我们选择主键生成策略
     * @Column：配置属性和字段的映射关系
     *      name：数据库表中字段的名称
     */
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = &quot;customer_id&quot;)
    private Long Id; // 客户的主键

    @Column(name = &quot;customer_name&quot;)
    private String name; // 客户名称

    @Column(name=&quot;customer_age&quot;)
    private int age; // 客户年龄

    @Column(name=&quot;customer_sex&quot;)
    private boolean sex; // 客户性别

    @Column(name=&quot;customer_phone&quot;)
    private String phone; // 客户的联系方式

    @Column(name=&quot;customer_address&quot;)
    private String address; // 客户地址
&#125;
</code></pre>
<p>5、对应的数据库表信息：</p>
<table>
<thead>
<tr>
<th align="center">Field</th>
<th align="center">Type</th>
<th align="center">Comment</th>
</tr>
</thead>
<tbody><tr>
<td align="center">customer_id</td>
<td align="center">bigint not null auto_increment</td>
<td align="center">客户编号（主键）</td>
</tr>
<tr>
<td align="center">customer_name</td>
<td align="center">varchar(255)</td>
<td align="center">客户名称（公司名称）</td>
</tr>
<tr>
<td align="center">customer_age</td>
<td align="center">integer</td>
<td align="center">客户年龄</td>
</tr>
<tr>
<td align="center">customer_sex</td>
<td align="center">bit</td>
<td align="center">客户性别</td>
</tr>
<tr>
<td align="center">customer_phone</td>
<td align="center">varchar(255)</td>
<td align="center">客户联系电话</td>
</tr>
<tr>
<td align="center">customer_address</td>
<td align="center">varchar(255)</td>
<td align="center">客户联系地址</td>
</tr>
</tbody></table>
<p>6、测试保存操作的执行</p>
<pre><code class="java">    /**
     * 测试jpa的保存
     * 案例：保存一个客户到数据库中
     * Jpa的操作步骤
     * 1.加载配置文件创建工厂（实体管理器工厂）对象
     * 2.通过实体管理器工厂获取实体管理器
     * 3.获取事务对象，开启事务
     * 4.完成增删改查操作
     * 5.提交事务（回滚事务）
     * 6.释放资源
     */
    @Test
    public void testSave() &#123;
        // 1.加载配置文件创建工厂（实体管理器工厂）对象
        EntityManagerFactory factory = Persistence.createEntityManagerFactory(&quot;myJpa&quot;);
        // 2.通过实体管理器工厂获取实体管理器
        EntityManager em = factory.createEntityManager();
        // 3.获取事务对象，开启事务
        EntityTransaction tx = em.getTransaction();
        tx.begin();
        //4.完成增删改查操作：保存一个客户到数据库中
        Customer customer = new Customer();
        customer.setName(&quot;Sam&quot;);
        customer.setAddress(&quot;Guangzhou&quot;);
        // 保存操作
        em.persist(customer);
        // 5.提交事务
        tx.commit();
        // 6.释放资源
        em.close();
        factory.close();
    &#125;
</code></pre>
<p>7、查看日志</p>
<pre><code class="verilog">Hibernate: 
    create table tb_customer (
       customer_id bigint not null auto_increment,
        customer_address varchar(255),
        customer_age integer,
        customer_name varchar(255),
        customer_phone varchar(255),
        customer_sex bit,
        primary key (customer_id)
    ) engine=InnoDB

Hibernate: 
    insert 
    into
        tb_customer
        (customer_address, customer_age, customer_name, customer_phone, customer_sex) 
    values
        (?, ?, ?, ?, ?)
</code></pre>
<p>8、这里可以看到为我们自动生成了SQL语句，因为 xml 里这里设置的是 update，所以有表的前提下，不会再生成表</p>
<pre><code class="xml">&lt;!-- 自动创建数据库表：
    none        ：不会创建表
    create      : 程序运行时创建数据库表（如果有表，先删除表再创建）
    update      ：程序运行时创建表（如果有表，不会创建表）
    create-drop : 每次加载hibernate时根据model类生成表，但是sessionFactory一关闭,表就自动删除。
    validate    : 每次加载hibernate时，验证创建数据库表结构，只会和数据库中的表进行比较，不会创建新表，但是会插入新值。
--&gt;
&lt;property name=&quot;hibernate.hbm2ddl.auto&quot; value=&quot;update&quot; /&gt;
</code></pre>
<p>9、错误处理（暂无）</p>
<h2 id="4、JPA-完整配置文件"><a href="#4、JPA-完整配置文件" class="headerlink" title="4、JPA 完整配置文件"></a>4、JPA 完整配置文件</h2><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;persistence xmlns=&quot;http://java.sun.com/xml/ns/persistence&quot; version=&quot;2.0&quot;&gt;

    &lt;!--
        持久化单元：
            name：持久化单元名称
            transaction-type：持久化单元事务类型
              - JTA：分布式事务管理
              - RESOURCE_LOCAL：本地事务管理
     --&gt;
    &lt;persistence-unit name=&quot;myJpa&quot; transaction-type=&quot;RESOURCE_LOCAL&quot;&gt;
        &lt;!--jpa的实现方式,配置JPA服务提供商 --&gt;
        &lt;provider&gt;org.hibernate.jpa.HibernatePersistenceProvider&lt;/provider&gt;
        &lt;!-- 可配可不配，如果配置了顺序不能错，必须在provider之后--&gt;
        &lt;!--&lt;class&gt;com.caochenlei.hibernate.jpa.Customer&lt;/class&gt;--&gt;
        &lt;!--
            配置二级缓存时候使用的模式，可配置值有：
            - ALL：所有的实体类都被缓存
            - NONE：所有的实体类都不被缓存
            - ENABLE_SELECTIVE：标识@Cacheable(true)注解的实体类将被缓存
            - DISABLE_SELECTIVE；缓存除标识@Cacheable(false)以外的所有实体类
            - UNSPECIFIED：默认值，JPA 产品默认值将被使用
         --&gt;
        &lt;shared-cache-mode&gt;ENABLE_SELECTIVE&lt;/shared-cache-mode&gt;

        &lt;!--可选配置：配置jpa实现方的配置信息--&gt;
        &lt;properties&gt;
            &lt;!-- 数据库信息配置：数据库驱动、数据库地址、数据库账户、数据库密码 --&gt;
            &lt;property name=&quot;hibernate.connection.driver_class&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;
            &lt;property name=&quot;hibernate.connection.url&quot; value=&quot;jdbc:mysql://127.0.0.1:3306/hibernate_jpa&quot;/&gt;
            &lt;property name=&quot;hibernate.connection.username&quot; value=&quot;root&quot;/&gt;
            &lt;property name=&quot;hibernate.connection.password&quot; value=&quot;password&quot;/&gt;
            &lt;!-- 数据库信息配置：数据库驱动、数据库地址、数据库账户、数据库密码 --&gt;
            &lt;!--&lt;property name=&quot;javax.persistence.jdbc.driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;
            &lt;property name=&quot;javax.persistence.jdbc.url&quot; value=&quot;jdbc:mysql://127.0.0.1:3306/hibernate_jpa&quot;/&gt;
            &lt;property name=&quot;javax.persistence.jdbc.user&quot; value=&quot;root&quot;/&gt;
            &lt;property name=&quot;javax.persistence.jdbc.password&quot; value=&quot;password&quot;/&gt;--&gt;

            &lt;!-- 配置JPA服务提供商可选参数 --&gt;
            &lt;!-- 自动显示sql --&gt;
            &lt;property name=&quot;hibernate.show_sql&quot; value=&quot;true&quot; /&gt;
            &lt;!-- 格式化sql --&gt;
            &lt;property name=&quot;hibernate.format_sql&quot; value=&quot;true&quot;/&gt;
            &lt;!-- 自动创建数据库表：
                none        ：不会创建表
                create      : 程序运行时创建数据库表（如果有表，先删除表再创建）
                update      ：程序运行时创建表（如果有表，不会创建表）
                create-drop : 每次加载hibernate时根据model类生成表，但是sessionFactory一关闭,表就自动删除。
                validate    : 每次加载hibernate时，验证创建数据库表结构，只会和数据库中的表进行比较，不会创建新表，但是会插入新值。
            --&gt;
            &lt;property name=&quot;hibernate.hbm2ddl.auto&quot; value=&quot;update&quot; /&gt;
            
            &lt;!-- 建表使用MyISAM，默认是InnoDB，下列是MySQL5 和 MySQL8 两种方言引擎设置--&gt;
            &lt;!-- InnoDB引擎：org.hibernate.dialect.MySQL5InnoDBDialect、org.hibernate.dialect.MySQL8InnoDBDialect --&gt;
            &lt;!-- MyISAM引擎：org.hibernate.dialect.MySQL5Dialect、org.hibernate.dialect.MySQL5Dialect --&gt;
            &lt;property name=&quot;hibernate.dialect&quot; value=&quot;org.hibernate.dialect.MySQL5Dialect&quot;/&gt;

            &lt;!-- Scan for annotated classes and Hibernate mapping XML files (可不配置)--&gt;
            &lt;!--&lt;property name=&quot;hibernate.archive.autodetection&quot; value=&quot;class, hbm&quot;/&gt;--&gt;

            &lt;!-- 二级缓存相关 --&gt;
            &lt;!-- 开启二级缓存 --&gt;
            &lt;property name=&quot;hibernate.cache.use_second_level_cache&quot; value=&quot;true&quot;/&gt;
            &lt;!-- 配置二级缓存处理类 --&gt;
            &lt;property name=&quot;hibernate.cache.region.factory_class&quot; value=&quot;org.hibernate.cache.ehcache.EhCacheRegionFactory&quot;/&gt;
            &lt;!-- 开启查询缓存，entityManager.find查询可以不配置，如果使用JPQL或SQL查询需要开启该配置 --&gt;
            &lt;property name=&quot;hibernate.cache.use_query_cache&quot; value=&quot;true&quot;/&gt;
            &lt;!-- 指定缓存配置文件位置,如果默认在resources下可不配置 --&gt;
            &lt;property name=&quot;hibernate.cache.provider_configuration&quot; value=&quot;classpath:ehcache.xml&quot;/&gt;

            
            &lt;!-- *****************************连接池的配置***************************** --&gt;
            
            &lt;!-- Hibernate JPA整合C3P0数据库连接池 --&gt;
            &lt;property name=&quot;hibernate.connection.provider_class&quot; 
                      value=&quot;org.hibernate.connection.C3P0ConnectionProvider&quot; /&gt;
            &lt;!-- 数据库连接池的最小连接数 --&gt;
            &lt;property name=&quot;c3p0.min_size&quot; value=&quot;5&quot; /&gt;
            &lt;!-- 数据库连接池的最大连接数 --&gt;
            &lt;property name=&quot;c3p0.max_size&quot; value=&quot;30&quot; /&gt;
            &lt;!-- 最大空闲时间，60秒内未使用则连接被丢弃。若为0则永不丢弃。Default: 0 --&gt;
            &lt;property name=&quot;c3p0.maxIdleTime&quot; value=&quot;60&quot; /&gt;
            &lt;!-- 获得连接的超时时间,如果超过这个时间,会抛出异常，单位毫秒 --&gt;
            &lt;property name=&quot;c3p0.timeout&quot; value=&quot;1800&quot; /&gt;
            &lt;!-- 最大的PreparedStatement的数量 --&gt;
            &lt;property name=&quot;c3p0.max_statements&quot; value=&quot;50&quot; /&gt;
            &lt;!-- 每隔120秒检查连接池里的空闲连接，单位是秒 --&gt;
            &lt;property name=&quot;c3p0.idle_test_period&quot; value=&quot;120&quot; /&gt;
            &lt;!-- 当连接池里面的连接用完的时候，C3P0一下获取的新的连接数 --&gt;
            &lt;property name=&quot;c3p0.acquire_increment&quot; value=&quot;1&quot; /&gt;
            &lt;!-- 是否每次都验证连接是否可用 --&gt;
            &lt;property name=&quot;c3p0.validate&quot; value=&quot;false&quot; /&gt;
            

            &lt;!-- Druid连接池配置 --&gt;
            &lt;property name=&quot;hibernate.connection.provider_class&quot; 
                      value=&quot;com.alibaba.druid.support.hibernate.DruidConnectionProvider&quot; /&gt;
            &lt;property name=&quot;url&quot;
                      value=&quot;jdbc:mysql://192.168.1.200:3306/SSH_Data?useSSL=false&amp;amp;allowPublicKeyRetrieval=true&quot; /&gt;
            &lt;property name=&quot;username&quot; value=&quot;root&quot; /&gt;
            &lt;property name=&quot;password&quot; value=&quot;123456&quot; /&gt;
            &lt;property name=&quot;driverClassName&quot;
                value=&quot;com.mysql.cj.jdbc.Driver&quot; /&gt;
            &lt;property name=&quot;filters&quot; value=&quot;stat&quot; /&gt;
            &lt;property name=&quot;maxActive&quot; value=&quot;20&quot; /&gt;
            &lt;property name=&quot;initialSize&quot; value=&quot;1&quot; /&gt;
            &lt;property name=&quot;maxWait&quot; value=&quot;60000&quot; /&gt;
            &lt;property name=&quot;minIdle&quot; value=&quot;1&quot; /&gt;
            &lt;property name=&quot;timeBetweenEvictionRunsMillis&quot; value=&quot;60000&quot; /&gt;
            &lt;property name=&quot;minEvictableIdleTimeMillis&quot; value=&quot;300000&quot; /&gt;
            &lt;property name=&quot;testWhileIdle&quot; value=&quot;true&quot; /&gt;
            &lt;property name=&quot;testOnBorrow&quot; value=&quot;false&quot; /&gt;
            &lt;property name=&quot;testOnReturn&quot; value=&quot;false&quot; /&gt;
            &lt;property name=&quot;poolPreparedStatements&quot; value=&quot;true&quot; /&gt;
            &lt;property name=&quot;maxOpenPreparedStatements&quot; value=&quot;20&quot; /&gt;
            &lt;property name=&quot;asyncInit&quot; value=&quot;true&quot; /&gt;
        &lt;/properties&gt;
    &lt;/persistence-unit&gt;
&lt;/persistence&gt;
</code></pre>
<h2 id="5、JPA-核心API对象"><a href="#5、JPA-核心API对象" class="headerlink" title="5、JPA 核心API对象"></a>5、JPA 核心API对象</h2><p>JPA类层次结构的显示单元：</p>
<table>
<thead>
<tr>
<th>单元</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Persistence</td>
<td>这个类包含静态方法来获取EntityManagerFactory实例</td>
</tr>
<tr>
<td>EntityManagerFactory</td>
<td>一个EntityManager的工厂类，创建并管理多个EntityManager实例</td>
</tr>
<tr>
<td>EntityManager</td>
<td>一个接口，管理持久化操作的对象，工厂原理类似工厂的查询实例</td>
</tr>
<tr>
<td>EntityTransaction</td>
<td>与EntityManager是一对一的关系，对于每一个EntityManager的操作由EntityTransaction类维护</td>
</tr>
<tr>
<td>Entity</td>
<td>实体是持久性对象，是存储在数据库中的记录（实际上就是Java Bean）</td>
</tr>
<tr>
<td>Query</td>
<td>该接口由每个JPA供应商实现，能够获得符合标准的关系对象</td>
</tr>
</tbody></table>
<p>JPA四个核心API对象：Persistence、EntityManagerFactory、EntityManager、EntityTransaction</p>
<p>Hibernate JPA 的操作步骤：</p>
<ol>
<li>加载配置文件创建实体管理器工厂</li>
<li>根据实体管理器工厂，创建实体管理器</li>
<li>创建事务对象，开启事务</li>
<li>完成增删改查操作</li>
<li>提交事务（回滚事务）</li>
<li>释放资源</li>
</ol>
<blockquote>
<p>1、Persistence对象（创建实体管理器工厂）</p>
</blockquote>
<pre><code class="java">/**
 * Persisitence.createEntityMnagerFactory（持久化单元名称）
 * 静态方法（根据持久化单元名称创建实体管理器工厂）
 **/
// 1.加载配置文件创建工厂（实体管理器工厂）对象
EntityManagerFactory factory = Persistence.createEntityManagerFactory(&quot;myJpa&quot;);
</code></pre>
<p>Persistence对象主要作用是用于获取EntityManagerFactory对象的 。通过调用该类的<code>createEntityManagerFactory()</code>静态方法，根据配置文件中持久化单元名称创建EntityManagerFactory。</p>
<blockquote>
<p>2、EntityManagerFactory（EntityManagerFactory 接口主要用来创建 EntityManager 实例）</p>
</blockquote>
<pre><code class="java">/**
 * entityManagerFactory.createEntityManager()：获取EntityManager对象
 *     内部维护的很多的内容:
 *         1.内部维护了数据库信息
 *         2.维护了缓存信息
 *         3.维护了所有的实体管理器对象
 *         4.在创建EntityManagerFactory的过程中会根据配置创建数据库表
 *     EntityManagerFactory的创建过程比较浪费资源
 *         特点：线程安全的对象，多个线程访问同一个EntityManagerFactory不会有线程安全问题
 *     如何解决EntityManagerFactory的创建过程浪费资源（耗时）的问题？
 *         思路：创建一个公共的EntityManagerFactory的对象
 *         静态代码块的形式创建EntityManagerFactory
 **/
// 2.通过实体管理器工厂获取实体管理器
EntityManager em = factory.createEntityManager();
</code></pre>
<blockquote>
<p>3、EntityManager：实体类管理器</p>
</blockquote>
<pre><code class="java">/**
 * EntityManager：实体类管理器
 *     获取事务对象: getTransaction()
 *     保存数据: presist()
 *     更新数据: merge()
 *     删除数据: remove()
 *     根据id查询: find()/getRefrence()
 *     清空缓存: clear()
 *     强制立即写入数据库: flush()
 *     重新加载缓存的对象: refresh()
 *     ......(还有挺多方法可以自己慢慢琢磨)
 **/
// 3.获取事务对象，然后可以开启事务、提交事务、回滚事务
EntityTransaction tx = em.getTransaction();
</code></pre>
<p>在 JPA 规范中, <code>EntityManager</code>是完成持久化操作的核心对象。实体类作为普通 java对象，只有在调用 <code>EntityManager</code>将其持久化后才会变成持久化对象。<code>EntityManager</code>对象在一组实体类与底层数据源之间进行 O&#x2F;R 映射的管理。它可以用来管理和更新 Entity Bean, 根椐主键查找 <code>Entity Bean</code>, 还可以通过JPQL语句查询实体。我们可以通过调用<code>EntityManager</code>的方法完成获取事务，以及持久化数据库的操作</p>
<blockquote>
<p>4、EntityTransaction：事务对象</p>
</blockquote>
<pre><code class="java">/**
 * EntityTransaction: 事务对象
 *     开启事务: begin()
 *     提交事务: commit()
 *     回滚事务: rollback()
 **/
// 开启事务
tx.begin();
</code></pre>
<p>在 JPA 规范中, <code>EntityTransaction</code>是完成事务操作的核心对象，对于<code>EntityTransaction</code>在我们的 java 代码中承接的功能比较简单</p>
<h2 id="6、JPA-实现CRUD操作"><a href="#6、JPA-实现CRUD操作" class="headerlink" title="6、JPA 实现CRUD操作"></a>6、JPA 实现CRUD操作</h2><h3 id="1、保存操作：persist"><a href="#1、保存操作：persist" class="headerlink" title="1、保存操作：persist"></a>1、保存操作：persist</h3><pre><code class="java">    /**
     * 运行之前，修改hibernate.hbm2ddl.auto=create
     * 保存操作
     */
    @Test
    public void testSave() &#123;
        // 获取实体管理器工厂
        EntityManagerFactory entityManagerFactory = Persistence.createEntityManagerFactory(&quot;myJpa&quot;);
        // 获取实体管理器
        EntityManager entityManager = entityManagerFactory.createEntityManager();
        // 获取事务
        EntityTransaction transaction = entityManager.getTransaction();
        // 开启事务
        transaction.begin();
        // 创建实体对象并保存
        Customer customer1 = new Customer();
        customer1.setName(&quot;张三&quot;);
        customer1.setAge(20);
        customer1.setSex(true);
        customer1.setPhone(&quot;13018882888&quot;);
        customer1.setAddress(&quot;北京&quot;);
        entityManager.persist(customer1);

        Customer customer2 = new Customer();
        customer2.setName(&quot;李四&quot;);
        customer2.setAge(18);
        customer2.setSex(false);
        customer2.setPhone(&quot;13533333555&quot;);
        customer2.setAddress(&quot;广州&quot;);
        entityManager.persist(customer2);

        Customer customer3 = new Customer();
        customer3.setName(&quot;王五&quot;);
        customer3.setAge(28);
        customer3.setSex(true);
        customer3.setPhone(&quot;13012345678&quot;);
        customer3.setAddress(&quot;深圳&quot;);
        entityManager.persist(customer3);
        // 提交事务
        transaction.commit();
        // 释放资源
        entityManager.close();
        entityManagerFactory.close();
    &#125;
</code></pre>
<p>查看日志：</p>
<pre><code class="verilog">Hibernate: 
    insert 
    into
        tb_customer
        (customer_address, customer_age, customer_name, customer_phone, customer_sex) 
    values
        (?, ?, ?, ?, ?)
Hibernate: 
    insert 
    into
        tb_customer
        (customer_address, customer_age, customer_name, customer_phone, customer_sex) 
    values
        (?, ?, ?, ?, ?)
Hibernate: 
    insert 
    into
        tb_customer
        (customer_address, customer_age, customer_name, customer_phone, customer_sex) 
    values
        (?, ?, ?, ?, ?)
</code></pre>
<h3 id="2、查询操作：find-getReference"><a href="#2、查询操作：find-getReference" class="headerlink" title="2、查询操作：find&#x2F;getReference"></a>2、查询操作：find&#x2F;getReference</h3><p>根据 ID 查询操作</p>
<p>1、<code>find</code> 方法查询（立即查询）</p>
<pre><code class="java">    /**
     * 实际发送的SQL语句就是：select * from customer where id = 2
     * 运行之前，修改hibernate.hbm2ddl.auto=update
     * 立即查询操作
     */
    @Test
    public void testQuery1() &#123;
        // 获取实体管理器工厂
        EntityManagerFactory entityManagerFactory = Persistence.createEntityManagerFactory(&quot;myJpa&quot;);
        // 获取实体管理器
        EntityManager entityManager = entityManagerFactory.createEntityManager();
        // 获取事务
        EntityTransaction transaction = entityManager.getTransaction();
        // 开启事务
        transaction.begin();
        // 查询实体并输出
        Customer customer = entityManager.find(Customer.class, 2L);
        System.out.println(customer);
        // 提交事务
        transaction.commit();
        // 释放资源
        entityManager.close();
        entityManagerFactory.close();
    &#125;
</code></pre>
<pre><code class="verilog">Hibernate: 
    select
        customer0_.customer_id as customer1_0_0_,
        customer0_.customer_address as customer2_0_0_,
        customer0_.customer_age as customer3_0_0_,
        customer0_.customer_name as customer4_0_0_,
        customer0_.customer_phone as customer5_0_0_,
        customer0_.customer_sex as customer6_0_0_ 
    from
        tb_customer customer0_ 
    where
        customer0_.customer_id=?
Customer(Id=2, name=李四, age=18, sex=false, phone=13533333555, address=广州)
</code></pre>
<p>2、<code>getReference</code> 方法实现（懒加载查询）（推荐）</p>
<pre><code class="java">    /**
     * 实际发送的SQL语句就是：select * from customer where id = 2
     * 运行之前，修改hibernate.hbm2ddl.auto=update
     * 延迟查询操作(查询结果对象的时候，才会发送查询的sql语句)
     */
    @Test
    public void testQuery2() &#123;
        // 获取实体管理器工厂
        EntityManagerFactory entityManagerFactory = Persistence.createEntityManagerFactory(&quot;myJpa&quot;);
        // 获取实体管理器
        EntityManager entityManager = entityManagerFactory.createEntityManager();
        // 获取事务
        EntityTransaction transaction = entityManager.getTransaction();
        // 开启事务
        transaction.begin();
        // 查询实体并输出
        Customer customer = entityManager.getReference(Customer.class, 2L);
        System.out.println(customer);
        // 提交事务
        transaction.commit();
        // 释放资源
        entityManager.close();
        entityManagerFactory.close();
    &#125;
</code></pre>
<p>日志发现与 find 查询没有区别：</p>
<pre><code class="verilog">Hibernate: 
    select
        customer0_.customer_id as customer1_0_0_,
        customer0_.customer_address as customer2_0_0_,
        customer0_.customer_age as customer3_0_0_,
        customer0_.customer_name as customer4_0_0_,
        customer0_.customer_phone as customer5_0_0_,
        customer0_.customer_sex as customer6_0_0_ 
    from
        tb_customer customer0_ 
    where
        customer0_.customer_id=?
Customer(Id=2, name=李四, age=18, sex=false, phone=13533333555, address=广州)
</code></pre>
<p>可以注释打印对象在对比试试：<code>//System.out.println(customer)</code>;（可以发现，如果没有使用对象的话，是没有调用查询SQL语句的）</p>
<pre><code class="verilog">INFO: HHH000490: Using JtaPlatform implementation: [org.hibernate.engine.transaction.jta.platform.internal.NoJtaPlatform]
</code></pre>
<p>3、<code>find</code> 与<code>getReference</code> 查询对比：</p>
<ul>
<li><code>find</code> 实现的查询时，是会在调用 find 方法时，立即发送SQL语句查询数据库的操作</li>
<li><code>getReference</code> 是一种延迟加载策略的操作，调用getReference方法不会立即发送sql语句查询数据库，当调用查询结果对象的时候，才会发送查询的sql语句（实际就是动态代理）</li>
</ul>
<h3 id="3、更新操作：merge"><a href="#3、更新操作：merge" class="headerlink" title="3、更新操作：merge"></a>3、更新操作：merge</h3><pre><code class="java">    /**
     * 运行之前，修改hibernate.hbm2ddl.auto=update
     * 更新操作
     */
    @Test
    public void testUpdate() &#123;
        // 获取实体管理器工厂
        EntityManagerFactory entityManagerFactory = Persistence.createEntityManagerFactory(&quot;myJpa&quot;);
        // 获取实体管理器
        EntityManager entityManager = entityManagerFactory.createEntityManager();
        // 获取事务
        EntityTransaction transaction = entityManager.getTransaction();
        // 开启事务
        transaction.begin();
        // 查询实体并更新
        Customer customer = entityManager.find(Customer.class, 2L);
        customer.setAddress(&quot;上海&quot;);
        entityManager.merge(customer);
        // 提交事务
        transaction.commit();
        // 释放资源
        entityManager.close();
        entityManagerFactory.close();
    &#125;
</code></pre>
<p>查看日志：</p>
<pre><code class="verilog">Hibernate: 
    select
        customer0_.customer_id as customer1_0_0_,
        customer0_.customer_address as customer2_0_0_,
        customer0_.customer_age as customer3_0_0_,
        customer0_.customer_name as customer4_0_0_,
        customer0_.customer_phone as customer5_0_0_,
        customer0_.customer_sex as customer6_0_0_ 
    from
        tb_customer customer0_ 
    where
        customer0_.customer_id=?
Hibernate: 
    update
        tb_customer 
    set
        customer_address=?,
        customer_age=?,
        customer_name=?,
        customer_phone=?,
        customer_sex=? 
    where
        customer_id=?
</code></pre>
<h3 id="4、删除操作：remove"><a href="#4、删除操作：remove" class="headerlink" title="4、删除操作：remove"></a>4、删除操作：remove</h3><pre><code class="java">    /**
     * 运行之前，修改hibernate.hbm2ddl.auto=update
     * 删除操作
     */
    @Test
    public void testDelete() &#123;
        // 获取实体管理器工厂
        EntityManagerFactory entityManagerFactory = Persistence.createEntityManagerFactory(&quot;myJpa&quot;);
        // 获取实体管理器
        EntityManager entityManager = entityManagerFactory.createEntityManager();
        // 获取事务
        EntityTransaction transaction = entityManager.getTransaction();
        // 开启事务
        transaction.begin();
        // 查询实体并删除
        Customer customer = entityManager.find(Customer.class, 1L);
        entityManager.remove(customer);
        // 提交事务
        transaction.commit();
        // 释放资源
        entityManager.close();
        entityManagerFactory.close();
    &#125;
</code></pre>
<p>查看日志：</p>
<pre><code class="verilog">Hibernate: 
    select
        customer0_.customer_id as customer1_0_0_,
        customer0_.customer_address as customer2_0_0_,
        customer0_.customer_age as customer3_0_0_,
        customer0_.customer_name as customer4_0_0_,
        customer0_.customer_phone as customer5_0_0_,
        customer0_.customer_sex as customer6_0_0_ 
    from
        tb_customer customer0_ 
    where
        customer0_.customer_id=?
Hibernate: 
    delete 
    from
        tb_customer 
    where
        customer_id=?
</code></pre>
<h2 id="7、JPA-连接工厂工具类"><a href="#7、JPA-连接工厂工具类" class="headerlink" title="7、JPA 连接工厂工具类"></a>7、JPA 连接工厂工具类</h2><p>为什么要抽取 JpaUtil 工具类？</p>
<p>由于<code>EntityManagerFactory</code> 是一个线程安全的对象（即多个线程访问同一个<code>EntityManagerFactory</code> 对象不会有线程安全问题），并且<code>EntityManagerFactory</code> 的创建极其浪费资源，所以在使用JPA编程时，我们可以对<code>EntityManagerFactory</code> 的创建进行优化，只需要做到一个工程只存在一个<code>EntityManagerFactory</code> 即可。</p>
<p>解决思路是通过静态代码的形式创建 <code>EntityManagerFactory</code></p>
<p><code>JpaUtil.java</code> 工具类</p>
<pre><code class="java">/**
 * 解决实体管理器工厂的浪费资源和耗时问题
 *      通过静态代码块的形式，当程序第一次访问此工具类时，创建一个公共的实体管理器工厂对象
 *
 * 第一次访问getEntityManager方法：经过静态代码块创建一个factory对象，再调用方法创建一个EntityManager对象
 * 第二次方法getEntityManager方法：直接通过一个已经创建好的factory对象，创建EntityManager对象
 */
public class JpaUtils &#123;
    private static EntityManagerFactory factory;
    static  &#123;
        //1.加载配置文件，创建entityManagerFactory
        factory = Persistence.createEntityManagerFactory(&quot;myJpa&quot;);
    &#125;

    /**
     * 获取EntityManager对象
     */
    public static EntityManager getEntityManager() &#123;
        return factory.createEntityManager();
    &#125;
&#125;
</code></pre>
<p>测试工具类</p>
<pre><code class="java">public class JpaTest &#123;
    @Test
    public void testSave() &#123;
        // 1.通过工具类获取实体类管理器
        EntityManager em = JpaUtils.getEntityManager();
        // 2.获取事务对象
        EntityTransaction tx = em.getTransaction();
        // 开启事务
        tx.begin();
        //3.完成增删改查操作：保存一个客户到数据库中
        Customer customer = new Customer();
        customer.setName(&quot;Yolo&quot;);
        customer.setAddress(&quot;BeiJing&quot;);
        //保存操作
        em.persist(customer);
        //4.提交事务
        tx.commit();
        //5.释放资源
        em.close();
        //因为工厂是公共的，不能关闭，不然其他线程将无法获取
        //factory.close();
    &#125;
&#125;
</code></pre>
<h1 id="Hibernate-JPA-复杂查询"><a href="#Hibernate-JPA-复杂查询" class="headerlink" title="Hibernate JPA 复杂查询"></a>Hibernate JPA 复杂查询</h1><h2 id="1、JPQL-查询与更新"><a href="#1、JPQL-查询与更新" class="headerlink" title="1、JPQL 查询与更新"></a>1、JPQL 查询与更新</h2><blockquote>
<p>JPQL全称：Java Persistence Query Language</p>
</blockquote>
<p>在 <code>EJB2.0</code> 中引入的 <code>EJB</code> 查询语言 (<code>EJB QL</code>)，<code>Java</code> 持久化查询语言 (<code>JPQL</code>) 是一种可移植的查询语言，旨在以面向对象表达式语言的表达式，将 <code>SQL</code> 语法和简单查询语义绑定在一起,使用这种语言编写的查询是可移植的，可以被编译成所有主流数据库服务器上的 <code>SQL</code>。</p>
<p>在使用 <code>JPQL</code> 的时候整体的处理效果与<code>SQL</code>的语法形式是几乎相同的，而后在<code>JPA</code>执行的时候会将 <code>JPQL</code> 编译为传统的关系型数据库支持的<code>SQL</code>语句。其特征与原生 <code>SQL</code> 语句类似，并且完全面向对象，<strong>通过类名和属性访问，而不是表名和表的属性</strong>。</p>
<blockquote>
<p>环境准备</p>
</blockquote>
<p>1、在实体类上加上一些Lombok的注解，方便准备测试数据</p>
<pre><code class="java">import lombok.*;
import lombok.experimental.Tolerate;
import javax.persistence.*;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
@Entity
@Table(name = &quot;tb_customer&quot;)
public class Customer &#123;

    // 这个构造是用来给 投影查询 准备的
    @Tolerate
    public Customer(String name, int age) &#123;
        this.name = name;
        this.age = age;
    &#125;

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = &quot;customer_id&quot;)
    private Long Id; // 客户的主键

    @Column(name = &quot;customer_name&quot;)
    private String name; // 客户名称

    @Column(name=&quot;customer_age&quot;)
    private int age; // 客户年龄

    @Column(name=&quot;customer_sex&quot;)
    private boolean sex; // 客户性别

    @Column(name=&quot;customer_phone&quot;)
    private String phone; // 客户的联系方式

    @Column(name=&quot;customer_address&quot;)
    private String address; // 客户地址
&#125;
</code></pre>
<p>2、准备测试数据</p>
<pre><code class="java">    @Before
    public void initData() &#123;
        EntityManager entityManager = JpaUtils.getEntityManager();
        entityManager.getTransaction().begin();
        Arrays.asList(
                Customer.builder().name(&quot;Sam&quot;).age(18).sex(true).phone(&quot;135000000001&quot;).address(&quot;广州&quot;).build(),
                Customer.builder().name(&quot;Mike&quot;).age(20).sex(true).phone(&quot;135000000002&quot;).address(&quot;广州&quot;).build(),
                Customer.builder().name(&quot;Nick&quot;).age(25).sex(true).phone(&quot;135000000003&quot;).address(&quot;深圳&quot;).build(),
                Customer.builder().name(&quot;Hom&quot;).age(30).sex(true).phone(&quot;135000000004&quot;).address(&quot;西安&quot;).build(),
                Customer.builder().name(&quot;Rachel&quot;).age(25).sex(false).phone(&quot;135000000005&quot;).address(&quot;北京&quot;).build(),
                Customer.builder().name(&quot;Kath&quot;).age(30).sex(true).phone(&quot;135000000006&quot;).address(&quot;武汉&quot;).build(),
                Customer.builder().name(&quot;Vivi&quot;).age(28).sex(false).phone(&quot;135000000007&quot;).address(&quot;南京&quot;).build(),
                Customer.builder().name(&quot;Oliver&quot;).age(30).sex(true).phone(&quot;135000000008&quot;).address(&quot;深圳&quot;).build(),
                Customer.builder().name(&quot;Angus&quot;).age(10).sex(false).phone(&quot;135000000009&quot;).address(&quot;广州&quot;).build(),
                Customer.builder().name(&quot;Wendy&quot;).age(15).sex(false).phone(&quot;135000000000&quot;).address(&quot;西安&quot;).build()
        ).forEach(customer -&gt; entityManager.persist(customer));
        entityManager.getTransaction().commit();
        entityManager.close();
    &#125;
</code></pre>
<h3 id="1-1、简单查询"><a href="#1-1、简单查询" class="headerlink" title="1.1、简单查询"></a>1.1、简单查询</h3><pre><code class="java">   /**
     * 查询全部
     * jqpl：from Customer
     * sql：select * from c_customer
     */
    @Test
    public void testFindAll() &#123;
        // 1.获取entityManager对象 &amp;&amp; 开启事务
        EntityManager entityManager = JpaUtils.getEntityManager();
        EntityTransaction transaction = entityManager.getTransaction();
        transaction.begin();

        // 2.查询全部：创建Query查询对象，query对象才是执行jqpl的对象
        Query query = entityManager.createQuery(&quot;from Customer&quot;);

        // 3.发送查询，并封装结果集
        List&lt;Customer&gt; list = query.getResultList();
        list.forEach(System.out::println);

        // 4.提交事务 &amp;&amp; 释放资源
        transaction.commit();
        entityManager.close();
    &#125;
</code></pre>
<p>查看日志：</p>
<pre><code class="verilog">Hibernate: 
    select
        customer0_.customer_id as customer1_2_,
        customer0_.customer_address as customer2_2_,
        customer0_.customer_age as customer3_2_,
        customer0_.customer_name as customer4_2_,
        customer0_.customer_phone as customer5_2_,
        customer0_.customer_sex as customer6_2_ 
    from
        tb_customer customer0_
Customer(Id=1, name=Sam, age=18, sex=true, phone=135000000001, address=广州)
Customer(Id=2, name=Mike, age=20, sex=true, phone=135000000002, address=广州)
Customer(Id=3, name=Nick, age=25, sex=true, phone=135000000003, address=深圳)
Customer(Id=4, name=Hom, age=30, sex=true, phone=135000000004, address=西安)
Customer(Id=5, name=Rachel, age=25, sex=false, phone=135000000005, address=北京)
Customer(Id=6, name=Kath, age=30, sex=true, phone=135000000006, address=武汉)
Customer(Id=7, name=Vivi, age=28, sex=false, phone=135000000007, address=南京)
Customer(Id=8, name=Oliver, age=30, sex=true, phone=135000000008, address=深圳)
Customer(Id=9, name=Angus, age=10, sex=false, phone=135000000009, address=广州)
Customer(Id=10, name=Wendy, age=15, sex=false, phone=135000000000, address=西安)
</code></pre>
<h3 id="1-2、别名查询"><a href="#1-2、别名查询" class="headerlink" title="1.2、别名查询"></a>1.2、别名查询</h3><pre><code class="java">    /**
     * 别名查询
     *     jqpl：from Customer c
     *     jqpl: select c from Customer c
     *     sql：select * from c_customer c
     */
    @Test
    public void testFindAll2() &#123;
        // 1.获取entityManager对象 &amp;&amp; 开启事务
        EntityManager entityManager = JpaUtils.getEntityManager();
        EntityTransaction transaction = entityManager.getTransaction();
        transaction.begin();

        // 查询所有客户,采用链式调用
        List&lt;Customer&gt; list1 = entityManager.createQuery(&quot;from Customer c&quot;).getResultList();
        list1.forEach(System.out::println);

        // 查询所有客户,采用链式调用
        List&lt;Customer&gt; list2 = entityManager.createQuery(&quot;select c from Customer c&quot;).getResultList();
        list2.forEach(System.out::println);

        // 4.提交事务 &amp;&amp; 释放资源
        transaction.commit();
        entityManager.close();
    &#125;
</code></pre>
<p>查看日志：</p>
<pre><code class="verilog">Hibernate: 
    select
        customer0_.customer_id as customer1_2_,
        customer0_.customer_address as customer2_2_,
        customer0_.customer_age as customer3_2_,
        customer0_.customer_name as customer4_2_,
        customer0_.customer_phone as customer5_2_,
        customer0_.customer_sex as customer6_2_ 
    from
        tb_customer customer0_
Customer(Id=1, name=Sam, age=18, sex=true, phone=135000000001, address=广州)
Customer(Id=2, name=Mike, age=20, sex=true, phone=135000000002, address=广州)
Customer(Id=3, name=Nick, age=25, sex=true, phone=135000000003, address=深圳)
Customer(Id=4, name=Hom, age=30, sex=true, phone=135000000004, address=西安)
Customer(Id=5, name=Rachel, age=25, sex=false, phone=135000000005, address=北京)
Customer(Id=6, name=Kath, age=30, sex=true, phone=135000000006, address=武汉)
Customer(Id=7, name=Vivi, age=28, sex=false, phone=135000000007, address=南京)
Customer(Id=8, name=Oliver, age=30, sex=true, phone=135000000008, address=深圳)
Customer(Id=9, name=Angus, age=10, sex=false, phone=135000000009, address=广州)
Customer(Id=10, name=Wendy, age=15, sex=false, phone=135000000000, address=西安)
Hibernate: 
    select
        customer0_.customer_id as customer1_2_,
        customer0_.customer_address as customer2_2_,
        customer0_.customer_age as customer3_2_,
        customer0_.customer_name as customer4_2_,
        customer0_.customer_phone as customer5_2_,
        customer0_.customer_sex as customer6_2_ 
    from
        tb_customer customer0_
Customer(Id=1, name=Sam, age=18, sex=true, phone=135000000001, address=广州)
Customer(Id=2, name=Mike, age=20, sex=true, phone=135000000002, address=广州)
Customer(Id=3, name=Nick, age=25, sex=true, phone=135000000003, address=深圳)
Customer(Id=4, name=Hom, age=30, sex=true, phone=135000000004, address=西安)
Customer(Id=5, name=Rachel, age=25, sex=false, phone=135000000005, address=北京)
Customer(Id=6, name=Kath, age=30, sex=true, phone=135000000006, address=武汉)
Customer(Id=7, name=Vivi, age=28, sex=false, phone=135000000007, address=南京)
Customer(Id=8, name=Oliver, age=30, sex=true, phone=135000000008, address=深圳)
Customer(Id=9, name=Angus, age=10, sex=false, phone=135000000009, address=广州)
Customer(Id=10, name=Wendy, age=15, sex=false, phone=135000000000, address=西安)
</code></pre>
<h3 id="1-3、排序查询"><a href="#1-3、排序查询" class="headerlink" title="1.3、排序查询"></a>1.3、排序查询</h3><pre><code class="java">    /**
     * 排序查询
     *     jqpl：from Customer order by Id desc
     *     sql：select * from c_customer order by Id desc
     */
    @Test
    public void testOder() &#123;
        // 1.获取entityManager对象 &amp;&amp; 开启事务
        EntityManager entityManager = JpaUtils.getEntityManager();
        EntityTransaction transaction = entityManager.getTransaction();
        transaction.begin();

        // 采用链式调用，默认情况（升序）
        List&lt;Customer&gt; list1 = entityManager.createQuery(&quot;from Customer order by Id&quot;).getResultList();
        list1.forEach(System.out::println);

        // 采用链式调用，升序情况
        List&lt;Customer&gt; list2 = entityManager.createQuery(&quot;from Customer order by Id asc&quot;).getResultList();
        list2.forEach(System.out::println);

        // 采用链式调用，降序情况
        List&lt;Customer&gt; list3 = entityManager.createQuery(&quot;from Customer order by Id desc&quot;).getResultList();
        list3.forEach(System.out::println);

        // 4.提交事务 &amp;&amp; 释放资源
        transaction.commit();
        entityManager.close();
    &#125;
</code></pre>
<p>查看日志：</p>
<pre><code class="verilog">Hibernate: 
    select
        customer0_.customer_id as customer1_2_,
        customer0_.customer_address as customer2_2_,
        customer0_.customer_age as customer3_2_,
        customer0_.customer_name as customer4_2_,
        customer0_.customer_phone as customer5_2_,
        customer0_.customer_sex as customer6_2_ 
    from
        tb_customer customer0_ 
    order by
        customer0_.customer_id
Customer(Id=1, name=Sam, age=18, sex=true, phone=135000000001, address=广州)
Customer(Id=2, name=Mike, age=20, sex=true, phone=135000000002, address=广州)
Customer(Id=3, name=Nick, age=25, sex=true, phone=135000000003, address=深圳)
Customer(Id=4, name=Hom, age=30, sex=true, phone=135000000004, address=西安)
Customer(Id=5, name=Rachel, age=25, sex=false, phone=135000000005, address=北京)
Customer(Id=6, name=Kath, age=30, sex=true, phone=135000000006, address=武汉)
Customer(Id=7, name=Vivi, age=28, sex=false, phone=135000000007, address=南京)
Customer(Id=8, name=Oliver, age=30, sex=true, phone=135000000008, address=深圳)
Customer(Id=9, name=Angus, age=10, sex=false, phone=135000000009, address=广州)
Customer(Id=10, name=Wendy, age=15, sex=false, phone=135000000000, address=西安)
Hibernate: 
    select
        customer0_.customer_id as customer1_2_,
        customer0_.customer_address as customer2_2_,
        customer0_.customer_age as customer3_2_,
        customer0_.customer_name as customer4_2_,
        customer0_.customer_phone as customer5_2_,
        customer0_.customer_sex as customer6_2_ 
    from
        tb_customer customer0_ 
    order by
        customer0_.customer_id asc
Customer(Id=1, name=Sam, age=18, sex=true, phone=135000000001, address=广州)
Customer(Id=2, name=Mike, age=20, sex=true, phone=135000000002, address=广州)
Customer(Id=3, name=Nick, age=25, sex=true, phone=135000000003, address=深圳)
Customer(Id=4, name=Hom, age=30, sex=true, phone=135000000004, address=西安)
Customer(Id=5, name=Rachel, age=25, sex=false, phone=135000000005, address=北京)
Customer(Id=6, name=Kath, age=30, sex=true, phone=135000000006, address=武汉)
Customer(Id=7, name=Vivi, age=28, sex=false, phone=135000000007, address=南京)
Customer(Id=8, name=Oliver, age=30, sex=true, phone=135000000008, address=深圳)
Customer(Id=9, name=Angus, age=10, sex=false, phone=135000000009, address=广州)
Customer(Id=10, name=Wendy, age=15, sex=false, phone=135000000000, address=西安)
Hibernate: 
    select
        customer0_.customer_id as customer1_2_,
        customer0_.customer_address as customer2_2_,
        customer0_.customer_age as customer3_2_,
        customer0_.customer_name as customer4_2_,
        customer0_.customer_phone as customer5_2_,
        customer0_.customer_sex as customer6_2_ 
    from
        tb_customer customer0_ 
    order by
        customer0_.customer_id desc
Customer(Id=10, name=Wendy, age=15, sex=false, phone=135000000000, address=西安)
Customer(Id=9, name=Angus, age=10, sex=false, phone=135000000009, address=广州)
Customer(Id=8, name=Oliver, age=30, sex=true, phone=135000000008, address=深圳)
Customer(Id=7, name=Vivi, age=28, sex=false, phone=135000000007, address=南京)
Customer(Id=6, name=Kath, age=30, sex=true, phone=135000000006, address=武汉)
Customer(Id=5, name=Rachel, age=25, sex=false, phone=135000000005, address=北京)
Customer(Id=4, name=Hom, age=30, sex=true, phone=135000000004, address=西安)
Customer(Id=3, name=Nick, age=25, sex=true, phone=135000000003, address=深圳)
Customer(Id=2, name=Mike, age=20, sex=true, phone=135000000002, address=广州)
Customer(Id=1, name=Sam, age=18, sex=true, phone=135000000001, address=广州)
</code></pre>
<h3 id="1-4、条件查询"><a href="#1-4、条件查询" class="headerlink" title="1.4、条件查询"></a>1.4、条件查询</h3><pre><code class="java">    /**
     * 条件查询
     *     jqpl：from Customer where sex = ?1 and name like ?2
     *     sql：SELECT * FROM c_customer where c_sex = ?1 and c_name like ?2
     *     jqpl：from Customer where sex = :aaa and name like :bbb
     *     sql：SELECT * FROM c_customer where c_sex = :aaa and c_name like :bbb
     */
    @Test
    public void testWhere() &#123;
        // 1.获取entityManager对象 &amp;&amp; 开启事务
        EntityManager entityManager = JpaUtils.getEntityManager();
        EntityTransaction transaction = entityManager.getTransaction();
        transaction.begin();

        // 条件查询：按参数位置绑定
        Query query1 = entityManager.createQuery(&quot;from Customer where sex = ?1 and name like ?2&quot;);
        query1.setParameter(1, true);
        query1.setParameter(2, &quot;S%&quot;);
        List&lt;Customer&gt; list1 = query1.getResultList();
        list1.forEach(System.out::println);

        // 条件查询：按参数名称绑定
        Query query2 = entityManager.createQuery(&quot;from Customer where sex = :aaa and name like :bbb&quot;);
        query2.setParameter(&quot;aaa&quot;, true);
        query2.setParameter(&quot;bbb&quot;, &quot;S%&quot;);
        List&lt;Customer&gt; list2 = query2.getResultList();
        list2.forEach(System.out::println);

        // 4.提交事务 &amp;&amp; 释放资源
        transaction.commit();
        entityManager.close();
    &#125;
</code></pre>
<p>查看日志：</p>
<pre><code class="verilog">Hibernate: 
    select
        customer0_.customer_id as customer1_2_,
        customer0_.customer_address as customer2_2_,
        customer0_.customer_age as customer3_2_,
        customer0_.customer_name as customer4_2_,
        customer0_.customer_phone as customer5_2_,
        customer0_.customer_sex as customer6_2_ 
    from
        tb_customer customer0_ 
    where
        customer0_.customer_sex=? 
        and (
            customer0_.customer_name like ?
        )
Customer(Id=1, name=Sam, age=18, sex=true, phone=135000000001, address=广州)
Hibernate: 
    select
        customer0_.customer_id as customer1_2_,
        customer0_.customer_address as customer2_2_,
        customer0_.customer_age as customer3_2_,
        customer0_.customer_name as customer4_2_,
        customer0_.customer_phone as customer5_2_,
        customer0_.customer_sex as customer6_2_ 
    from
        tb_customer customer0_ 
    where
        customer0_.customer_sex=? 
        and (
            customer0_.customer_name like ?
        )
Customer(Id=1, name=Sam, age=18, sex=true, phone=135000000001, address=广州)
</code></pre>
<h3 id="1-5、投影查询"><a href="#1-5、投影查询" class="headerlink" title="1.5、投影查询"></a>1.5、投影查询</h3><pre><code class="java">    /**
     * 投影查询
     * 1.单个字段查询
     * jqpl：select c.name from Customer c
     * sql：SELECT * FROM c_customer order by Id desc
     * 2.多个字段查询
     * jpql：select c.name,c.age from Customer c
     * jpql：select new Customer(c.name,c.age) from Customer c
     * sql：SELECT * FROM c_customer order by Id desc
     */
    @Test
    public void testFieldName() &#123;
        // 1.获取entityManager对象 &amp;&amp; 开启事务
        EntityManager entityManager = JpaUtils.getEntityManager();
        EntityTransaction transaction = entityManager.getTransaction();
        transaction.begin();

        // 查询所有客户名称：单个字段查询
        Query query1 = entityManager.createQuery(&quot;select c.name from Customer c&quot;);
        List&lt;Object&gt; list1 = query1.getResultList();
        list1.forEach(System.out::println);

        // 查询所有客户名称、客户年龄：多个字段查询，封装到数组中
        Query query2 = entityManager.createQuery(&quot;select c.name,c.age from Customer c&quot;);
        List&lt;Object[]&gt; list2 = query2.getResultList();
        list2.forEach(x-&gt; System.out.println(Arrays.toString(x)));

        // 查询所有客户名称、客户来源：多个字段查询，封装到对象中
        // 请在Customer.java添加以下两个构造方法，否则会执行失败
        // public Customer() 和 public Customer(String name, int age)
        Query query3 = entityManager.createQuery(&quot;select new Customer(c.name,c.age) from Customer c&quot;);
        List&lt;Customer&gt; list3 = query3.getResultList();
        list3.forEach(System.out::println);

        // 4.提交事务 &amp;&amp; 释放资源
        transaction.commit();
        entityManager.close();
    &#125;
</code></pre>
<p>查看日志：</p>
<pre><code class="verilog">Hibernate: 
    select
        customer0_.customer_name as col_0_0_ 
    from
        tb_customer customer0_
Sam
Mike
Nick
Hom
Rachel
Kath
Vivi
Oliver
Angus
Wendy
Hibernate: 
    select
        customer0_.customer_name as col_0_0_,
        customer0_.customer_age as col_1_0_ 
    from
        tb_customer customer0_
[Sam, 18]
[Mike, 20]
[Nick, 25]
[Hom, 30]
[Rachel, 25]
[Kath, 30]
[Vivi, 28]
[Oliver, 30]
[Angus, 10]
[Wendy, 15]
Hibernate: 
    select
        customer0_.customer_name as col_0_0_,
        customer0_.customer_age as col_1_0_ 
    from
        tb_customer customer0_
Customer(Id=null, name=Sam, age=18, sex=false, phone=null, address=null)
Customer(Id=null, name=Mike, age=20, sex=false, phone=null, address=null)
Customer(Id=null, name=Nick, age=25, sex=false, phone=null, address=null)
Customer(Id=null, name=Hom, age=30, sex=false, phone=null, address=null)
Customer(Id=null, name=Rachel, age=25, sex=false, phone=null, address=null)
Customer(Id=null, name=Kath, age=30, sex=false, phone=null, address=null)
Customer(Id=null, name=Vivi, age=28, sex=false, phone=null, address=null)
Customer(Id=null, name=Oliver, age=30, sex=false, phone=null, address=null)
Customer(Id=null, name=Angus, age=10, sex=false, phone=null, address=null)
Customer(Id=null, name=Wendy, age=15, sex=false, phone=null, address=null)
</code></pre>
<h3 id="1-6、分页查询"><a href="#1-6、分页查询" class="headerlink" title="1.6、分页查询"></a>1.6、分页查询</h3><pre><code class="java">    /**
     * 分页查询
     *      jqpl : from Customer
     *      sql：select * from c_customer limit 2,5
     */
    @Test
    public void testLimit() &#123;
        // 1.获取entityManager对象 &amp;&amp; 开启事务
        EntityManager entityManager = JpaUtils.getEntityManager();
        EntityTransaction transaction = entityManager.getTransaction();
        transaction.begin();

        // 分页查询
        Query query = entityManager.createQuery(&quot;from Customer&quot;);
        // 起始索引、每页查询的条数
        query.setFirstResult(2).setMaxResults(5);
        List&lt;Customer&gt; list = query.getResultList();
        list.forEach(System.out::println);

        // 4.提交事务 &amp;&amp; 释放资源
        transaction.commit();
        entityManager.close();
    &#125;
</code></pre>
<p>查看日志：</p>
<pre><code class="verilog">Hibernate: 
    select
        customer0_.customer_id as customer1_2_,
        customer0_.customer_address as customer2_2_,
        customer0_.customer_age as customer3_2_,
        customer0_.customer_name as customer4_2_,
        customer0_.customer_phone as customer5_2_,
        customer0_.customer_sex as customer6_2_ 
    from
        tb_customer customer0_ limit ?,
        ?
Customer(Id=3, name=Nick, age=25, sex=true, phone=135000000003, address=深圳)
Customer(Id=4, name=Hom, age=30, sex=true, phone=135000000004, address=西安)
Customer(Id=5, name=Rachel, age=25, sex=false, phone=135000000005, address=北京)
Customer(Id=6, name=Kath, age=30, sex=true, phone=135000000006, address=武汉)
Customer(Id=7, name=Vivi, age=28, sex=false, phone=135000000007, address=南京)
</code></pre>
<h3 id="1-7、分组查询"><a href="#1-7、分组查询" class="headerlink" title="1.7、分组查询"></a>1.7、分组查询</h3><pre><code class="java">    /**
     * 分组查询
     *      jqpl : select count(*) from Customer
     *      sql：select count(*) from c_customer
     *
     *      jqpl : select sex,count(*) from Customer group by sex
     *      sql：select c_sex,count(*) from c_customer group by c_sex
     */
    @Test
    public void testGroupBy() &#123;
        // 1.获取entityManager对象 &amp;&amp; 开启事务
        EntityManager entityManager = JpaUtils.getEntityManager();
        EntityTransaction transaction = entityManager.getTransaction();
        transaction.begin();

        // 聚合函数：count(),max(),min(),avg(),sum()
        Object object2 = entityManager.createQuery(&quot;select count(*) from Customer&quot;).getSingleResult();
        System.out.println(object2);

        // 分组统计：
        List&lt;Object[]&gt; list = entityManager.createQuery(&quot;select sex,count(*) from Customer group by sex&quot;).getResultList();
        list.forEach(x-&gt;System.out.println(Arrays.toString(x)));

        // 4.提交事务 &amp;&amp; 释放资源
        transaction.commit();
        entityManager.close();
    &#125;
</code></pre>
<p>查看日志：</p>
<pre><code class="verilog">Hibernate: 
    select
        count(*) as col_0_0_ 
    from
        tb_customer customer0_
10
Hibernate: 
    select
        customer0_.customer_sex as col_0_0_,
        count(*) as col_1_0_ 
    from
        tb_customer customer0_ 
    group by
        customer0_.customer_sex
[false, 4]
[true, 6]
</code></pre>
<h3 id="1-8、多表查询"><a href="#1-8、多表查询" class="headerlink" title="1.8、多表查询"></a>1.8、多表查询</h3><pre><code class="java">    @Test
    public void testXXJoin() &#123;
        // 1.获取entityManager对象 &amp;&amp; 开启事务
        EntityManager entityManager = JpaUtils.getEntityManager();
        EntityTransaction transaction = entityManager.getTransaction();
        transaction.begin();

        // 内连接
        List&lt;Object[]&gt; list1 = entityManager.createQuery(&quot;from Customer c inner join c.linkMans&quot;).getResultList();
        list1.forEach(x-&gt;System.out.println(Arrays.toString(x)));

        // 迫切内连接（hibernate独有，将另一个对象的数据封装到该对象中）
        List&lt;Customer&gt; list2 = entityManager.createQuery(&quot;select distinct c from Customer c inner join fetch c.linkMans&quot;).getResultList();
        list2.forEach(System.out::println);

        // 左外连接
        List&lt;Object[]&gt; list3 = entityManager.createQuery(&quot;from Customer c left outer join c.linkMans&quot;).getResultList();
        list3.forEach(x-&gt;System.out.println(Arrays.toString(x)));

        // 迫切左外连接（hibernate独有，将另一个对象的数据封装到该对象中）
        List&lt;Customer&gt; list4 = entityManager.createQuery(&quot;select distinct c from Customer c left outer join fetch c.linkMans&quot;).getResultList();
        list4.forEach(System.out::println);

        // 右外连接
        List&lt;Object[]&gt; list5 = entityManager.createQuery(&quot;from Customer c right outer join c.linkMans&quot;).getResultList();
        list5.forEach(x-&gt;System.out.println(Arrays.toString(x)));

        // 4.提交事务 &amp;&amp; 释放资源
        transaction.commit();
        entityManager.close();
    &#125;
</code></pre>
<h3 id="1-9、更新删除"><a href="#1-9、更新删除" class="headerlink" title="1.9、更新删除"></a>1.9、更新删除</h3><pre><code class="java">    /**
     * 数据更新
     *     jpql：update Customer c set c.age = :age where c.name = :name
     *     sql：sql：update tb_customer set customer_age = 20 where customer_name = &#39;Sam&#39;
     */
    @Test
    public void testUpdate() &#123;
        // 1.获取entityManager对象 &amp;&amp; 开启事务
        EntityManager entityManager = JpaUtils.getEntityManager();
        EntityTransaction transaction = entityManager.getTransaction();
        transaction.begin();

        // 数据更新
        String jpql = &quot;update Customer c set c.age = :age where c.name = :name&quot;;
        int updateSize = entityManager.createQuery(jpql)
                .setParameter(&quot;age&quot;, 20)
                .setParameter(&quot;name&quot;, &quot;Sam&quot;)
                .executeUpdate();
        System.out.println(&quot;更新数据量：&quot; + updateSize);

        // 4.提交事务 &amp;&amp; 释放资源
        transaction.commit();
        entityManager.close();
    &#125;

    /**
     * 数据删除
     *     jpql：delete Customer c where c.name = :name
     *     sql：delete tb_customer where customer_name = &#39;Sam&#39;
     */
    @Test
    public void testDelete() &#123;
        // 1.获取entityManager对象 &amp;&amp; 开启事务
        EntityManager entityManager = JpaUtils.getEntityManager();
        EntityTransaction transaction = entityManager.getTransaction();
        transaction.begin();

        // 数据删除
        String sql = &quot;delete Customer c where c.name = :name&quot;;
        int updateSize = entityManager.createQuery(sql)
                .setParameter(&quot;name&quot;, &quot;Sam&quot;)
                .executeUpdate();
        System.out.println(&quot;删除数据量：&quot; + updateSize);

        // 4.提交事务 &amp;&amp; 释放资源
        transaction.commit();
        entityManager.close();
    &#125;
</code></pre>
<p>查看日志：</p>
<pre><code class="verilog"># 更新日志
Hibernate: 
    update
        tb_customer 
    set
        customer_age=? 
    where
        customer_name=?
更新数据量：1
# 删除日志
Hibernate: 
    delete 
    from
        tb_customer 
    where
        customer_name=?
删除数据量：1
</code></pre>
<blockquote>
<p>如果报错：java.lang.IllegalArgumentException: Update&#x2F;delete queries cannot be typed</p>
<p>问题原因（错误写法）：Query query &#x3D; em.createQuery(jpql, Entity.class);</p>
<p>解决办法（正确写法）：Query query &#x3D; em.createQuery(jpql);</p>
</blockquote>
<h2 id="2、SQL-查询与更新"><a href="#2、SQL-查询与更新" class="headerlink" title="2、SQL 查询与更新"></a>2、SQL 查询与更新</h2><p>有些时候，JPQL使用不当会导致转化成的SQL并不如理想或者特定场合需要SQL优化，还是得用到原生SQL查询的。<code>EntityManager</code>对象的<code>createNativeQuery</code>方法，可以实现十分复杂的查询，但是需要对查询结果进行实体映射处理，并且不能跨数据库。</p>
<ul>
<li><p>获得原生SQL查询对象：<code>Query createNativeQuery(String var1, Class var2);</code></p>
</li>
<li><p>SQL对比JPQL只需要把查询对象方法由 <code>createQuery()</code>替换成<code>createNativeQuery()</code> 即可（传入值变成原生SQL和<strong>类对象</strong>）</p>
</li>
</ul>
<pre><code class="java">package query;

import entity.Customer;
import org.junit.Before;
import org.junit.Test;
import util.JpaUtils;
import javax.persistence.*;
import java.util.Arrays;
import java.util.List;

public class JpaSqlTest &#123;

    @Before
    public void initData() &#123;
        EntityManager entityManager = JpaUtils.getEntityManager();
        entityManager.getTransaction().begin();
        Arrays.asList(
                Customer.builder().name(&quot;Sam&quot;).age(18).sex(true).phone(&quot;135000000001&quot;).address(&quot;广州&quot;).build(),
                Customer.builder().name(&quot;Mike&quot;).age(20).sex(true).phone(&quot;135000000002&quot;).address(&quot;广州&quot;).build(),
                Customer.builder().name(&quot;Nick&quot;).age(25).sex(true).phone(&quot;135000000003&quot;).address(&quot;深圳&quot;).build(),
                Customer.builder().name(&quot;Hom&quot;).age(30).sex(true).phone(&quot;135000000004&quot;).address(&quot;西安&quot;).build(),
                Customer.builder().name(&quot;Rachel&quot;).age(25).sex(false).phone(&quot;135000000005&quot;).address(&quot;北京&quot;).build(),
                Customer.builder().name(&quot;Kath&quot;).age(30).sex(true).phone(&quot;135000000006&quot;).address(&quot;武汉&quot;).build(),
                Customer.builder().name(&quot;Vivi&quot;).age(28).sex(false).phone(&quot;135000000007&quot;).address(&quot;南京&quot;).build(),
                Customer.builder().name(&quot;Oliver&quot;).age(30).sex(true).phone(&quot;135000000008&quot;).address(&quot;深圳&quot;).build(),
                Customer.builder().name(&quot;Angus&quot;).age(10).sex(false).phone(&quot;135000000009&quot;).address(&quot;广州&quot;).build(),
                Customer.builder().name(&quot;Wendy&quot;).age(15).sex(false).phone(&quot;135000000000&quot;).address(&quot;西安&quot;).build()
        ).forEach(customer -&gt; entityManager.persist(customer));
        entityManager.getTransaction().commit();
        entityManager.close();
    &#125;

    /**
     * 查询全部 sql：SELECT * FROM tb_customer
     */
    @Test
    public void testFindAll() &#123;
        // 1.获取entityManager对象 &amp;&amp; 开启事务
        EntityManager entityManager = JpaUtils.getEntityManager();
        EntityTransaction transaction = entityManager.getTransaction();
        transaction.begin();

        // 2.查询全部：创建Query查询对象，query对象才是执行jqpl的对象
        String sql = &quot;select * from tb_customer&quot;;
        Query query = entityManager.createNativeQuery(sql, Customer.class);

        // 3.发送查询，并封装结果集
        List&lt;Customer&gt; list = query.getResultList();
        list.forEach(System.out::println);

        // 4.提交事务 &amp;&amp; 释放资源
        transaction.commit();
        entityManager.close();
    &#125;

    /**
     * 排序查询 sql：select * from tb_customer order by customer_id desc
     */
    @Test
    public void testOder() &#123;
        // 1.获取entityManager对象 &amp;&amp; 开启事务
        EntityManager entityManager = JpaUtils.getEntityManager();
        EntityTransaction transaction = entityManager.getTransaction();
        transaction.begin();

        // 采用链式调用，默认情况（升序）
        String sql1 = &quot;select * from tb_customer order by customer_id&quot;;
        List&lt;Customer&gt; list1 = entityManager.createNativeQuery(sql1, Customer.class).getResultList();
        list1.forEach(System.out::println);

        // 采用链式调用，升序情况
        String sql2 = &quot;select * from tb_customer order by customer_id asc &quot;;
        List&lt;Customer&gt; list2 = entityManager.createNativeQuery(sql2, Customer.class).getResultList();
        list2.forEach(System.out::println);

        // 采用链式调用，降序情况
        String sql3 = &quot;select * from tb_customer order by customer_id desc&quot;;
        List&lt;Customer&gt; list3 = entityManager.createNativeQuery(sql3, Customer.class).getResultList();
        list3.forEach(System.out::println);

        // 4.提交事务 &amp;&amp; 释放资源
        transaction.commit();
        entityManager.close();
    &#125;

    /**
     * 条件查询
     *     sql：SELECT * FROM tb_customer where customer_sex = ?1 and customer_name like ?2
     *     sql：SELECT * FROM tb_customer where customer_sex = :aaa and customer_name like :bbb
     */
    @Test
    public void testWhere() &#123;
        // 1.获取entityManager对象 &amp;&amp; 开启事务
        EntityManager entityManager = JpaUtils.getEntityManager();
        EntityTransaction transaction = entityManager.getTransaction();
        transaction.begin();

        // 条件查询：按参数位置绑定
        String sql1 = &quot;SELECT * FROM tb_customer where customer_sex = ?1 and customer_name like ?2&quot;;
        Query query1 = entityManager.createNativeQuery(sql1, Customer.class);
        query1.setParameter(1, true);
        query1.setParameter(2, &quot;S%&quot;);
        List&lt;Customer&gt; list1 = query1.getResultList();
        list1.forEach(System.out::println);

        // 条件查询：按参数名称绑定
        String sql2 = &quot;SELECT * FROM tb_customer where customer_sex = :aaa and customer_name like :bbb&quot;;
        Query query2 = entityManager.createNativeQuery(sql2, Customer.class);
        query2.setParameter(&quot;aaa&quot;, true);
        query2.setParameter(&quot;bbb&quot;, &quot;S%&quot;);
        List&lt;Customer&gt; list2 = query2.getResultList();
        list2.forEach(System.out::println);

        // 4.提交事务 &amp;&amp; 释放资源
        transaction.commit();
        entityManager.close();
    &#125;

    /**
     * 分页查询 sql：select * from tb_customer limit 2,5
     */
    @Test
    public void testLimit() &#123;
        // 1.获取entityManager对象 &amp;&amp; 开启事务
        EntityManager entityManager = JpaUtils.getEntityManager();
        EntityTransaction transaction = entityManager.getTransaction();
        transaction.begin();

        // 分页查询
        String sql = &quot;select * from tb_customer limit 2,5&quot;;
        Query query = entityManager.createNativeQuery(sql, Customer.class);
        // 起始索引、每页查询的条数
        //query.setFirstResult(2).setMaxResults(5);
        List&lt;Customer&gt; list = query.getResultList();
        list.forEach(System.out::println);

        // 4.提交事务 &amp;&amp; 释放资源
        transaction.commit();
        entityManager.close();
    &#125;

    /**
     * 分组查询
     *      sql：select count(*) from tb_customer
     *      sql：select c_sex,count(*) from tb_customer group by c_sex
     */
    @Test
    public void testGroupBy() &#123;
        // 1.获取entityManager对象 &amp;&amp; 开启事务
        EntityManager entityManager = JpaUtils.getEntityManager();
        EntityTransaction transaction = entityManager.getTransaction();
        transaction.begin();

        // 聚合函数：count(),max(),min(),avg(),sum()
        String sql1 = &quot;select count(*) from tb_customer&quot;;
        Object object2 = entityManager.createNativeQuery(sql1).getSingleResult();
        System.out.println(object2);

        // 分组统计：
        String sql2 = &quot;select customer_sex,count(*) from tb_customer group by customer_sex&quot;;
        List&lt;Object[]&gt; list = entityManager.createNativeQuery(sql2).getResultList();
        list.forEach(x-&gt;System.out.println(Arrays.toString(x)));

        // 4.提交事务 &amp;&amp; 释放资源
        transaction.commit();
        entityManager.close();
    &#125;
    
    /**
     * 数据更新 sql：update tb_customer set customer_age = 20 where customer_name = &#39;Sam&#39;
     */
    @Test
    public void testUpdate() &#123;
        // 1.获取entityManager对象 &amp;&amp; 开启事务
        EntityManager entityManager = JpaUtils.getEntityManager();
        EntityTransaction transaction = entityManager.getTransaction();
        transaction.begin();

        // 2.数据更新
        String sql = &quot;update tb_customer set customer_age = :customer_age where customer_name = :customer_name&quot;;
        int updateSize = entityManager.createNativeQuery(sql, Customer.class)
                .setParameter(&quot;customer_age&quot;, 20)
                .setParameter(&quot;customer_name&quot;, &quot;Sam&quot;)
                .executeUpdate();
        System.out.println(&quot;更新数据量：&quot; + updateSize);

        // 3.提交事务 &amp;&amp; 释放资源
        transaction.commit();
        entityManager.close();
    &#125;

    /**
     * 数据删除 sql：delete tb_customer where customer_name = &#39;Sam&#39;
     */
    @Test
    public void testDelete() &#123;
        // 1.获取entityManager对象 &amp;&amp; 开启事务
        EntityManager entityManager = JpaUtils.getEntityManager();
        EntityTransaction transaction = entityManager.getTransaction();
        transaction.begin();

        // 2.数据删除
        String sql = &quot;delete tb_customer where customer_name = :customer_name&quot;;
        int updateSize = entityManager.createNativeQuery(sql, Customer.class)
                .setParameter(&quot;customer_name&quot;, &quot;Sam&quot;)
                .executeUpdate();
        System.out.println(&quot;删除数据量：&quot; + updateSize);

        // 3.提交事务 &amp;&amp; 释放资源
        transaction.commit();
        entityManager.close();
    &#125;
&#125;
</code></pre>
<p>查看日志（随意抽取一条）：可以发现SQL语句与JPQL生成的还是有些不一样</p>
<pre><code class="verilog">Hibernate: 
    select
        * 
    from
        tb_customer
Customer(Id=1, name=Sam, age=18, sex=true, phone=135000000001, address=广州)
Customer(Id=2, name=Mike, age=20, sex=true, phone=135000000002, address=广州)
Customer(Id=3, name=Nick, age=25, sex=true, phone=135000000003, address=深圳)
Customer(Id=4, name=Hom, age=30, sex=true, phone=135000000004, address=西安)
Customer(Id=5, name=Rachel, age=25, sex=false, phone=135000000005, address=北京)
Customer(Id=6, name=Kath, age=30, sex=true, phone=135000000006, address=武汉)
Customer(Id=7, name=Vivi, age=28, sex=false, phone=135000000007, address=南京)
Customer(Id=8, name=Oliver, age=30, sex=true, phone=135000000008, address=深圳)
Customer(Id=9, name=Angus, age=10, sex=false, phone=135000000009, address=广州)
Customer(Id=10, name=Wendy, age=15, sex=false, phone=135000000000, address=西安)
</code></pre>
<p>查看数据更新与删除日志：</p>
<pre><code class="verilog"># 数据更新
Hibernate: 
    update
        tb_customer 
    set
        customer_age = ? 
    where
        customer_name = ?
更新数据量：1
# 数据删除
Hibernate: 
    delete tb_customer 
    where
        customer_name = ?
删除数据量：1
</code></pre>
<h2 id="3、Criteria-复杂查询"><a href="#3、Criteria-复杂查询" class="headerlink" title="3、Criteria 复杂查询"></a>3、Criteria 复杂查询</h2><blockquote>
<p>JPA Criteria API：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/xingqi/p/3929386.html">https://www.cnblogs.com/xingqi/p/3929386.html</a></p>
</blockquote>
<p>1、通过JPA的 Criteria API 实现：</p>
<ol>
<li>EntityManager 获取 CriteriaBuilder</li>
<li>CriteriaBuilder 创建 CriteriaQuery</li>
<li>CriteriaQuery 指定要查询的表，得到 Root（Root 代表要查询的表）</li>
<li>CriteriaBuilder 创建条件 Predicate，Predicate 相当于SQL的 where 条件，多个 Predicate 可以进行与、或操作</li>
<li>通过 EntityManager 创建 TypedQuery</li>
<li>TypedQuery 执行查询，返回结果</li>
</ol>
<p>2、基本对象的构建详细步骤：</p>
<ol>
<li>通过 EntityManager.getCriteriaBuilder() 或 EntityManagerFactory.getCriteriaBuilder() 方法可以得到 CriteriaBuilder 对象</li>
<li>通过 CriteriaBuilder.createQuery() 或 CriteriaBuilder.createTupleQuery() 方法可以获得 CriteriaQuery 实例</li>
<li>通过 CriteriaQuery.from() 方法可以获得 Root 实例</li>
<li>子句总结：<ol>
<li>SELECT：CriteriaQuery select()</li>
<li>FROM：AbstractQuery from()</li>
<li>WHERE：AbstractQuery where()</li>
<li>ORDER BY：CriteriaQuery orderBy()</li>
<li>GROUP BY：AbstractQuery groupBy()</li>
<li>HAVING：AbstractQuery having()</li>
</ol>
</li>
</ol>
<p>3、过滤条件：</p>
<ol>
<li>过滤条件会被应用到SQL语句的FROM子句中。在Criteria查询中，查询条件通过Predicate或Expression实例应用到CriteriaQuery对象上</li>
<li>这些条件使用 CriteriaQuery.where()方 法应用到CriteriaQuery对象上</li>
<li>CriteriaBuilder也作为Predicate实例的工厂，通过调用CriteriaBuilder的条件方法（equal，notEqual， gt， ge，lt， le，between，like等）创建Predicate对象</li>
<li>复合的 Predicate 语句可以使用CriteriaBuilder的 and, or, andnot 方法构建</li>
</ol>
<blockquote>
<p>准备测试数据</p>
</blockquote>
<pre><code class="java">import lombok.*;
import lombok.experimental.Tolerate;
import javax.persistence.*;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
@Entity
@Table(name = &quot;tb_customer&quot;)
public class Customer &#123;

    // 这个构造是用来给 投影查询 准备的
    @Tolerate
    public Customer(String name, int age) &#123;
        this.name = name;
        this.age = age;
    &#125;

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = &quot;customer_id&quot;)
    private Long Id; // 客户的主键

    @Column(name = &quot;customer_name&quot;)
    private String name; // 客户名称

    @Column(name=&quot;customer_age&quot;)
    private int age; // 客户年龄

    @Column(name=&quot;customer_sex&quot;)
    private boolean sex; // 客户性别

    @Column(name=&quot;customer_phone&quot;)
    private String phone; // 客户的联系方式

    @Column(name=&quot;customer_address&quot;)
    private String address; // 客户地址
&#125;
</code></pre>
<pre><code class="java">    @Before
    public void initData() &#123;
        EntityManager entityManager = JpaUtils.getEntityManager();
        entityManager.getTransaction().begin();
        Arrays.asList(
                Customer.builder().name(&quot;Sam&quot;).age(18).sex(true).phone(&quot;135000000001&quot;).address(&quot;广州&quot;).build(),
                Customer.builder().name(&quot;Mike&quot;).age(20).sex(true).phone(&quot;135000000002&quot;).address(&quot;广州&quot;).build(),
                Customer.builder().name(&quot;Nick&quot;).age(25).sex(true).phone(&quot;135000000003&quot;).address(&quot;深圳&quot;).build(),
                Customer.builder().name(&quot;Hom&quot;).age(30).sex(true).phone(&quot;135000000004&quot;).address(&quot;西安&quot;).build(),
                Customer.builder().name(&quot;Rachel&quot;).age(25).sex(false).phone(&quot;135000000005&quot;).address(&quot;北京&quot;).build(),
                Customer.builder().name(&quot;Kath&quot;).age(30).sex(true).phone(&quot;135000000006&quot;).address(&quot;武汉&quot;).build(),
                Customer.builder().name(&quot;Vivi&quot;).age(28).sex(false).phone(&quot;135000000007&quot;).address(&quot;南京&quot;).build(),
                Customer.builder().name(&quot;Oliver&quot;).age(30).sex(true).phone(&quot;135000000008&quot;).address(&quot;深圳&quot;).build(),
                Customer.builder().name(&quot;Angus&quot;).age(10).sex(false).phone(&quot;135000000009&quot;).address(&quot;广州&quot;).build(),
                Customer.builder().name(&quot;Wendy&quot;).age(15).sex(false).phone(&quot;135000000000&quot;).address(&quot;西安&quot;).build()
        ).forEach(customer -&gt; entityManager.persist(customer));
        entityManager.getTransaction().commit();
        entityManager.close();
    &#125;
</code></pre>
<h3 id="3-1、查询全部"><a href="#3-1、查询全部" class="headerlink" title="3.1、查询全部"></a>3.1、查询全部</h3><pre><code class="java">    /**
     * 查询全部（简单写法）
     * sql：select * from tb_customer
     */
    @Test
    public void testFindAll() &#123;
        // 获取entityManager对象 &amp;&amp; 这里就省略事务了
        EntityManager entityManager = JpaUtils.getEntityManager();

        // 1.EntityManager获取CriteriaBuilder
        CriteriaBuilder criteriaBuilder = entityManager.getCriteriaBuilder();
        // 2.CriteriaBuilder创建CriteriaQuery
        CriteriaQuery&lt;Customer&gt; criteriaQuery = criteriaBuilder.createQuery(Customer.class);
        // 3.CriteriaQuery指定要查询的表，得到Root，Root代表要查询的表
        criteriaQuery.from(Customer.class);
        TypedQuery&lt;Customer&gt; query = entityManager.createQuery(criteriaQuery);
        List&lt;Customer&gt; list = query.getResultList();
        list.forEach(System.out::println);

        // 释放资源
        entityManager.close();
    &#125;

    /**
     * 查询全部（完整写法）
     * sql：select * from tb_customer
     */
    @Test
    public void testFindAll2() &#123;
        // 获取entityManager对象 &amp;&amp; 这里就省略事务了
        EntityManager entityManager = JpaUtils.getEntityManager();

        // 1.EntityManager获取CriteriaBuilder
        CriteriaBuilder criteriaBuilder = entityManager.getCriteriaBuilder();
        // 2.CriteriaBuilder创建CriteriaQuery
        CriteriaQuery&lt;Customer&gt; criteriaQuery = criteriaBuilder.createQuery(Customer.class);
        // 3.CriteriaQuery指定要查询的表，得到Root，Root代表要查询的表
        Root&lt;Customer&gt; from = criteriaQuery.from(Customer.class);
        // 这一步骤可以省略,返回的依旧是CriteriaQuery对象
        CriteriaQuery&lt;Customer&gt; select = criteriaQuery.select(from);
        // 如果上一步省略就传入criteriaQuery
        TypedQuery&lt;Customer&gt; query = entityManager.createQuery(select);
        List&lt;Customer&gt; list = query.getResultList();
        list.forEach(System.out::println);

        // 释放资源
        entityManager.close();
    &#125;
</code></pre>
<p>查看日志：</p>
<pre><code class="verilog">Hibernate: 
    select
        customer0_.customer_id as customer1_2_,
        customer0_.customer_address as customer2_2_,
        customer0_.customer_age as customer3_2_,
        customer0_.customer_name as customer4_2_,
        customer0_.customer_phone as customer5_2_,
        customer0_.customer_sex as customer6_2_ 
    from
        tb_customer customer0_
Customer(Id=1, name=Sam, age=18, sex=true, phone=135000000001, address=广州)
Customer(Id=2, name=Mike, age=20, sex=true, phone=135000000002, address=广州)
Customer(Id=3, name=Nick, age=25, sex=true, phone=135000000003, address=深圳)
Customer(Id=4, name=Hom, age=30, sex=true, phone=135000000004, address=西安)
Customer(Id=5, name=Rachel, age=25, sex=false, phone=135000000005, address=北京)
Customer(Id=6, name=Kath, age=30, sex=true, phone=135000000006, address=武汉)
Customer(Id=7, name=Vivi, age=28, sex=false, phone=135000000007, address=南京)
Customer(Id=8, name=Oliver, age=30, sex=true, phone=135000000008, address=深圳)
Customer(Id=9, name=Angus, age=10, sex=false, phone=135000000009, address=广州)
Customer(Id=10, name=Wendy, age=15, sex=false, phone=135000000000, address=西安)
</code></pre>
<h3 id="3-2、投影查询"><a href="#3-2、投影查询" class="headerlink" title="3.2、投影查询"></a>3.2、投影查询</h3><p>获取 <code>CriteriaQuery</code> 实例有两种方式：</p>
<ol>
<li><code>CriteriaBuilder.createQuery()</code>：返回 <code>CriteriaQuery&lt;T&gt;</code></li>
<li><code>CriteriaBuilder.createTupleQuery()</code>：返回<code>CriteriaQuery&lt;Tuple&gt;</code></li>
</ol>
<p>两种方式的区别：</p>
<ol>
<li><code>createQuery()</code>： 主要用来查询与实体类字段对应的SQL</li>
<li><code>createTupleQuery()</code>：可以查询实体类字段以外的字段数据（count、sum、max、min、avg 等）group by用的较多，一般配合<code>criteriaQuery.multiselect()</code> 方法较多</li>
</ol>
<hr>
<p>方式一：CriteriaBuilder.createQuery()</p>
<pre><code class="java">    /**
     * 投影查询 — criteriaBuilder.createQuery(Customer.class)
     * sql：select customer_name, customer_age from tb_customer
     * 注意：
     *   实体类中必须要有该构造方法：public Customer(String name, int age) 不然会报错
     * 也可以用另一个方式：
     *   criteriaBuilder.createTupleQuery() // 创建查询，返回元组类型，Tuple包含多个TupleElements
     */
    @Test
    public void testFindAllMultiSelect() &#123;
        // 获取entityManager对象 &amp;&amp; 这里就省略事务了
        EntityManager entityManager = JpaUtils.getEntityManager();

        // 1.CriteriaBuilder 安全查询创建工厂
        CriteriaBuilder criteriaBuilder = entityManager.getCriteriaBuilder();
        // 2.CriteriaQuery 安全查询主语句
        CriteriaQuery&lt;Customer&gt; criteriaQuery = criteriaBuilder.createQuery(Customer.class);
        // 3.Root 定义查询的From子句中能出现的类型
        Root&lt;Customer&gt; from = criteriaQuery.from(Customer.class);

        // 必须要有该构造方法才行：public Customer(String name, int age)，不然会报错
        criteriaQuery.multiselect(from.get(&quot;name&quot;), from.get(&quot;age&quot;));
        TypedQuery&lt;Customer&gt; query = entityManager.createQuery(criteriaQuery);
        List&lt;Customer&gt; list = query.getResultList();
        list.forEach(System.out::println);

        // 释放资源
        entityManager.close();
    &#125;
</code></pre>
<p>查看日志：</p>
<pre><code class="verilog">Hibernate: 
    select
        customer0_.customer_name as col_0_0_,
        customer0_.customer_age as col_1_0_ 
    from
        tb_customer customer0_
Customer(Id=null, name=Sam, age=18, sex=false, phone=null, address=null)
Customer(Id=null, name=Mike, age=20, sex=false, phone=null, address=null)
Customer(Id=null, name=Nick, age=25, sex=false, phone=null, address=null)
Customer(Id=null, name=Hom, age=30, sex=false, phone=null, address=null)
Customer(Id=null, name=Rachel, age=25, sex=false, phone=null, address=null)
Customer(Id=null, name=Kath, age=30, sex=false, phone=null, address=null)
Customer(Id=null, name=Vivi, age=28, sex=false, phone=null, address=null)
Customer(Id=null, name=Oliver, age=30, sex=false, phone=null, address=null)
Customer(Id=null, name=Angus, age=10, sex=false, phone=null, address=null)
Customer(Id=null, name=Wendy, age=15, sex=false, phone=null, address=null)
</code></pre>
<p>方式二：CriteriaBuilder.createTupleQuery()</p>
<pre><code class="java">    /**
     * 投影查询 — criteriaBuilder.createTupleQuery()
     * sql：select customer_name, customer_age from tb_customer
     * 注意：
     *   使用：返回元组(Tuple)的查询，不会报错
     */
    @Test
    public void testFindAllMultiSelect2() &#123;
        // 获取entityManager对象 &amp;&amp; 这里就省略事务了
        EntityManager entityManager = JpaUtils.getEntityManager();

        // 1.CriteriaBuilder 安全查询创建工厂
        CriteriaBuilder criteriaBuilder = entityManager.getCriteriaBuilder();
        // 2.CriteriaQuery 安全查询主语句
        CriteriaQuery&lt;Tuple&gt; criteriaQuery = criteriaBuilder.createTupleQuery();
        // 3.Root 定义查询的From子句中能出现的类型
        Root&lt;Customer&gt; from = criteriaQuery.from(Customer.class);

        // 需要给字段取别名,否则无法通过tuple.get(field)获取数据
        criteriaQuery.multiselect(from.get(&quot;name&quot;).alias(&quot;name&quot;), from.get(&quot;age&quot;).alias(&quot;age&quot;));
        TypedQuery&lt;Tuple&gt; query = entityManager.createQuery(criteriaQuery);
        List&lt;Tuple&gt; list = query.getResultList();
        // name = list.get(0).get(0); age = list.get(0).get(1)
        list.forEach(x-&gt; System.out.println(x.get(&quot;name&quot;)+&quot;、&quot;+x.get(&quot;age&quot;)));

        // 释放资源
        entityManager.close();
    &#125;
</code></pre>
<p>查看日志：</p>
<pre><code class="verilog">Hibernate: 
    select
        customer0_.customer_name as col_0_0_,
        customer0_.customer_age as col_1_0_ 
    from
        tb_customer customer0_
Sam、18
Mike、20
Nick、25
Hom、30
Rachel、25
Kath、30
Vivi、28
Oliver、30
Angus、10
Wendy、15
</code></pre>
<h3 id="3-3、条件查询"><a href="#3-3、条件查询" class="headerlink" title="3.3、条件查询"></a>3.3、条件查询</h3><p>1、单条件查询</p>
<pre><code class="java">    /**
     * 条件查询——单条件
     * Predicate 过滤条件
     * sql：select * from tb_customer where customer_name = &#39;Sam&#39;
     */
    @Test
    public void testFindWhereEQ() &#123;
        // 获取entityManager对象 &amp;&amp; 这里就省略事务了
        EntityManager entityManager = JpaUtils.getEntityManager();

        CriteriaBuilder criteriaBuilder = entityManager.getCriteriaBuilder();
        CriteriaQuery&lt;Customer&gt; criteriaQuery = criteriaBuilder.createQuery(Customer.class);
        Root&lt;Customer&gt; from = criteriaQuery.from(Customer.class);
        criteriaQuery.select(from);// 定义查询，该行可以省略

        // 4.Predicate 或 Predicate[] 过滤条件
        Predicate predicate = criteriaBuilder.equal(from.get(&quot;name&quot;), &quot;Sam&quot;);
        criteriaQuery.where(predicate);
        // 采用链式调用
        entityManager.createQuery(criteriaQuery).getResultList().forEach(System.out::println);

        // 释放资源
        entityManager.close();
    &#125;
</code></pre>
<p>查看日志：</p>
<pre><code class="verilog">Hibernate: 
    select
        customer0_.customer_id as customer1_2_,
        customer0_.customer_address as customer2_2_,
        customer0_.customer_age as customer3_2_,
        customer0_.customer_name as customer4_2_,
        customer0_.customer_phone as customer5_2_,
        customer0_.customer_sex as customer6_2_ 
    from
        tb_customer customer0_ 
    where
        customer0_.customer_name=?
Customer(Id=1, name=Sam, age=18, sex=true, phone=135000000001, address=广州)
</code></pre>
<p>2、多条件查询</p>
<p>Predicate[]、Conjunction和 Disjunction 对比：</p>
<ol>
<li>Predicate[]：逻辑与（and）</li>
<li>criteriaBuilder.conjunction()：逻辑与（and）</li>
<li>criteriaBuilder.disjunction()：逻辑或（or）</li>
</ol>
<p>Predicate[] 与 conjunction 区别：Predicate[] 正常把数组内所有条件用 and 拼接，而 conjunction 会在 where 后面自动加上 1&#x3D;1 然后再拼接条件</p>
<p>操作示例：</p>
<pre><code class="java">    /**
     * 条件查询——多条件（and，equals，lt）
     * Predicate[] 多个过滤条件（个人推荐）
     * sql：select * from tb_customer where customer_name = &#39;Sam&#39; and c_age &lt; 20
     */
    @Test
    public void testFindWhereEqGt() &#123;
        // 1.获取entityManager对象 &amp;&amp; 这里就省略事务了
        EntityManager entityManager = JpaUtils.getEntityManager();

        CriteriaBuilder criteriaBuilder = entityManager.getCriteriaBuilder();
        CriteriaQuery&lt;Customer&gt; criteriaQuery = criteriaBuilder.createQuery(Customer.class);
        Root&lt;Customer&gt; from = criteriaQuery.from(Customer.class);

        // 4.Predicate[] 过滤条件，设置一个查询条件集合
        List&lt;Predicate&gt; predicates = new ArrayList&lt;&gt;();
        predicates.add(criteriaBuilder.equal(from.get(&quot;name&quot;), &quot;Sam&quot;));
        predicates.add(criteriaBuilder.lt(from.get(&quot;age&quot;), 20));
        criteriaQuery.where(predicates.toArray(new Predicate[]&#123;&#125;));// new Predicate[]&#123;&#125;=》new Predicate[predicates.size()]
        // 采用链式调用
        entityManager.createQuery(criteriaQuery).getResultList().forEach(System.out::println);

        // 释放资源
        entityManager.close();
    &#125;

    /**
     * 条件查询——多条件（like，and，equal，lt）
     * Predicate 多个过滤条件 —— criteriaBuilder.conjunction() // 逻辑与
     *                       —— criteriaBuilder.disjunction() // 逻辑或
     * sql：select * from tb_customer where 1=1 and customer_name like &#39;S%&#39; and customer_name = &#39;Sam&#39; and customer_age &lt; 20
     */
    @Test
    public void testFindWhereEqGt2() &#123;
        // 1.获取entityManager对象 &amp;&amp; 这里就省略事务了
        EntityManager entityManager = JpaUtils.getEntityManager();

        CriteriaBuilder criteriaBuilder = entityManager.getCriteriaBuilder();
        CriteriaQuery&lt;Customer&gt; criteriaQuery = criteriaBuilder.createQuery(Customer.class);
        Root&lt;Customer&gt; from = criteriaQuery.from(Customer.class);

        // 4.Predicate[] 过滤条件，设置一个查询条件集合
        Predicate predicate = criteriaBuilder.conjunction();
        // 过滤条件— like：and customer_name like S%
        predicate= criteriaBuilder.and(predicate, criteriaBuilder.like(from.get(&quot;name&quot;), &quot;S%&quot;));
        // 过滤条件— equal：and customer_name like S% and customer_name = &#39;Sam&#39;
        predicate= criteriaBuilder.and(predicate, criteriaBuilder.equal(from.get(&quot;name&quot;), &quot;Sam&quot;));
        // 过滤条件— lt：and customer_name like S% and customer_name = &#39;Sam&#39; and customer_age &lt; 20
        predicate= criteriaBuilder.and(predicate, criteriaBuilder.lt(from.get(&quot;age&quot;), 20));
        criteriaQuery.where(predicate);
        // 采用链式调用
        entityManager.createQuery(criteriaQuery).getResultList().forEach(System.out::println);

        // 释放资源
        entityManager.close();
    &#125;

    /**
     * 条件查询——多条件（not in，between）
     * Predicate 多个过滤条件 —— criteriaBuilder.conjunction() // 逻辑与
     *                        —— criteriaBuilder.disjunction() // 逻辑或
     * sql：select * from tb_customer where 1=1 and customer_age not in (18 , 20) and customer_id between 5 and 9
     */
    @Test
    public void testFindWhereNotInBetween() &#123;
        // 1.获取entityManager对象 &amp;&amp; 这里就省略事务了
        EntityManager entityManager = JpaUtils.getEntityManager();

        CriteriaBuilder criteriaBuilder = entityManager.getCriteriaBuilder();
        CriteriaQuery&lt;Customer&gt; criteriaQuery = criteriaBuilder.createQuery(Customer.class);
        Root&lt;Customer&gt; from = criteriaQuery.from(Customer.class);

        // 4.Predicate 过滤多条件
        Predicate predicate = criteriaBuilder.conjunction();
        // 过滤条件— in：customer_age not in (18 , 20)
        predicate= criteriaBuilder.and(predicate, from.get(&quot;age&quot;).in(Arrays.asList(18, 20)).not());
        // 过滤条件— in：customer_age not in (18 , 20) and customer_id between 5 and 9
        predicate= criteriaBuilder.and(predicate, criteriaBuilder.between(from.get(&quot;Id&quot;), 5,9));
        criteriaQuery.where(predicate);
        // 采用链式调用
        entityManager.createQuery(criteriaQuery).getResultList().forEach(System.out::println);

        // 释放资源
        entityManager.close();
    &#125;
</code></pre>
<p>查看日志：（条件查询——多条件（and，equals，lt））</p>
<pre><code class="verilog">Hibernate: 
    select
        customer0_.customer_id as customer1_2_,
        customer0_.customer_address as customer2_2_,
        customer0_.customer_age as customer3_2_,
        customer0_.customer_name as customer4_2_,
        customer0_.customer_phone as customer5_2_,
        customer0_.customer_sex as customer6_2_ 
    from
        tb_customer customer0_ 
    where
        customer0_.customer_name=? 
        and customer0_.customer_age&lt;20
Customer(Id=1, name=Sam, age=18, sex=true, phone=135000000001, address=广州)
</code></pre>
<p>查看日志：（条件查询——多条件（like，and，equal，lt））</p>
<pre><code class="verilog">Hibernate: 
    select
        customer0_.customer_id as customer1_2_,
        customer0_.customer_address as customer2_2_,
        customer0_.customer_age as customer3_2_,
        customer0_.customer_name as customer4_2_,
        customer0_.customer_phone as customer5_2_,
        customer0_.customer_sex as customer6_2_ 
    from
        tb_customer customer0_ 
    where
        1=1 
        and (
            customer0_.customer_name like ?
        ) 
        and customer0_.customer_name=? 
        and customer0_.customer_age&lt;20
Customer(Id=1, name=Sam, age=18, sex=true, phone=135000000001, address=广州)
</code></pre>
<p>查看日志：（条件查询——多条件（not in，between））</p>
<pre><code class="verilog">Hibernate: 
    select
        customer0_.customer_id as customer1_2_,
        customer0_.customer_address as customer2_2_,
        customer0_.customer_age as customer3_2_,
        customer0_.customer_name as customer4_2_,
        customer0_.customer_phone as customer5_2_,
        customer0_.customer_sex as customer6_2_ 
    from
        tb_customer customer0_ 
    where
        1=1 
        and (
            customer0_.customer_age not in  (
                18 , 20
            )
        ) 
        and (
            customer0_.customer_id between 5 and 9
        )
Customer(Id=5, name=Rachel, age=25, sex=false, phone=135000000005, address=北京)
Customer(Id=6, name=Kath, age=30, sex=true, phone=135000000006, address=武汉)
Customer(Id=7, name=Vivi, age=28, sex=false, phone=135000000007, address=南京)
Customer(Id=8, name=Oliver, age=30, sex=true, phone=135000000008, address=深圳)
Customer(Id=9, name=Angus, age=10, sex=false, phone=135000000009, address=广州)
</code></pre>
<h3 id="3-4、排序查询"><a href="#3-4、排序查询" class="headerlink" title="3.4、排序查询"></a>3.4、排序查询</h3><p>可以设置单个order和多个order</p>
<pre><code class="java">    /**
     * 排序查询
     * sql：select * from tb_customer where 1=1 and customer_age in (18 , 28) and customer_id between 2 and 4 order by customer_id desc
     */
    @Test
    public void testFindWhereInBetweenOderBy() &#123;
        // 1.获取entityManager对象 &amp;&amp; 这里就省略事务了
        EntityManager entityManager = JpaUtils.getEntityManager();

        CriteriaBuilder criteriaBuilder = entityManager.getCriteriaBuilder();
        CriteriaQuery&lt;Customer&gt; criteriaQuery = criteriaBuilder.createQuery(Customer.class);
        Root&lt;Customer&gt; from = criteriaQuery.from(Customer.class);

        // 4.Predicate 或 Predicate[] 过滤条件
        Predicate age = from.get(&quot;age&quot;).in(18, 28);
        Predicate id = criteriaBuilder.between(from.get(&quot;Id&quot;), 2, 10);
        criteriaQuery.where(Arrays.asList(age, id).toArray(new Predicate[]&#123;&#125;));
        // 排序（降序）
        Order idOrder = criteriaBuilder.desc(from.get(&quot;Id&quot;));
        criteriaQuery.orderBy(idOrder);
        // 可以设置多个 order。先按Id降序，然后按age升序排序
        // criteriaQuery.orderBy(criteriaBuilder.desc(from.get(&quot;Id&quot;)),criteriaBuilder.asc(from.get(&quot;age&quot;)));
        // 采用链式调用
        entityManager.createQuery(criteriaQuery).getResultList().forEach(System.out::println);

        // 释放资源
        entityManager.close();
    &#125;
</code></pre>
<p>查看日志：</p>
<pre><code class="verilog">Hibernate: 
    select
        customer0_.customer_id as customer1_2_,
        customer0_.customer_address as customer2_2_,
        customer0_.customer_age as customer3_2_,
        customer0_.customer_name as customer4_2_,
        customer0_.customer_phone as customer5_2_,
        customer0_.customer_sex as customer6_2_ 
    from
        tb_customer customer0_ 
    where
        (
            customer0_.customer_age in (
                18 , 28
            )
        ) 
        and (
            customer0_.customer_id between 2 and 10
        ) 
    order by
        customer0_.customer_id desc
Customer(Id=7, name=Vivi, age=28, sex=false, phone=135000000007, address=南京)
</code></pre>
<h3 id="3-5、分页查询"><a href="#3-5、分页查询" class="headerlink" title="3.5、分页查询"></a>3.5、分页查询</h3><pre><code class="java">    /**
     * 分页查询
     * sql：select * from tb_customer where 1=1 and customer_id between 2 and 10 limit 0,5
     */
    @Test
    public void testFindWhereBetween() &#123;
        // 1.获取entityManager对象 &amp;&amp; 这里就省略事务了
        EntityManager entityManager = JpaUtils.getEntityManager();

        CriteriaBuilder criteriaBuilder = entityManager.getCriteriaBuilder();
        CriteriaQuery&lt;Customer&gt; criteriaQuery = criteriaBuilder.createQuery(Customer.class);
        Root&lt;Customer&gt; from = criteriaQuery.from(Customer.class);

        // 4.Predicate 或 Predicate[] 过滤条件
        Predicate id = criteriaBuilder.between(from.get(&quot;Id&quot;), 2, 10);
        criteriaQuery.where(Arrays.asList(id).toArray(new Predicate[]&#123;&#125;));

        // 采用链式调用,分页查询
        entityManager.createQuery(criteriaQuery)
                .setFirstResult(0) // 起始索引
                .setMaxResults(5)  // 每页查询的条数
                .getResultList()
                .forEach(System.out::println);

        // 释放资源
        entityManager.close();
    &#125;
</code></pre>
<p>查看日志：</p>
<pre><code class="verilog">Hibernate: 
    select
        customer0_.customer_id as customer1_2_,
        customer0_.customer_address as customer2_2_,
        customer0_.customer_age as customer3_2_,
        customer0_.customer_name as customer4_2_,
        customer0_.customer_phone as customer5_2_,
        customer0_.customer_sex as customer6_2_ 
    from
        tb_customer customer0_ 
    where
        customer0_.customer_id between 2 and 10 limit ?
Customer(Id=2, name=Mike, age=20, sex=true, phone=135000000002, address=广州)
Customer(Id=3, name=Nick, age=25, sex=true, phone=135000000003, address=深圳)
Customer(Id=4, name=Hom, age=30, sex=true, phone=135000000004, address=西安)
Customer(Id=5, name=Rachel, age=25, sex=false, phone=135000000005, address=北京)
Customer(Id=6, name=Kath, age=30, sex=true, phone=135000000006, address=武汉)
</code></pre>
<h3 id="3-6、分组查询"><a href="#3-6、分组查询" class="headerlink" title="3.6、分组查询"></a>3.6、分组查询</h3><p>分组查询需要注意事项（<code>group by</code> ）：</p>
<ol>
<li>创建查询用元组类型：<code>criteriaBuilder.createTupleQuery()</code></li>
<li>设置多个选择结果：<code>criteriaQuery.multiselect()</code></li>
<li>给字段设置别名（这不是必须的，为了获取方便可以设置）</li>
</ol>
<pre><code class="java">    /**
     * 分组查询
     * sql：select c_name,count(c_name),max(c_age),min(c_age),sum(c_age),avg(c_age) from c_customer group by c_name
     */
    @Test
    public void testFindGroupBy() &#123;
        // 1.获取entityManager对象 &amp;&amp; 这里就省略事务了
        EntityManager entityManager = JpaUtils.getEntityManager();

        CriteriaBuilder criteriaBuilder = entityManager.getCriteriaBuilder();
        CriteriaQuery&lt;Tuple&gt; criteriaQuery = criteriaBuilder.createTupleQuery();
        Root&lt;Customer&gt; from = criteriaQuery.from(Customer.class);

        // .alias(&quot;name&quot;) 取别名
        criteriaQuery.multiselect(
                from.get(&quot;name&quot;).alias(&quot;name&quot;),
                criteriaBuilder.count(from.get(&quot;name&quot;)).alias(&quot;count&quot;),
                criteriaBuilder.max(from.get(&quot;age&quot;)).alias(&quot;max&quot;),
                criteriaBuilder.min(from.get(&quot;age&quot;)).alias(&quot;min&quot;),
                criteriaBuilder.sum(from.get(&quot;age&quot;)).alias(&quot;sum&quot;),
                criteriaBuilder.avg(from.get(&quot;age&quot;)).alias(&quot;avg&quot;));
        criteriaQuery.groupBy(from.get(&quot;name&quot;));
        // criteriaQuery.having(criteriaBuilder.disjunction());

        // 采用链式调用
        entityManager.createQuery(criteriaQuery).getResultList()
                .forEach(x-&gt; System.out.println(
                        x.get(&quot;name&quot;) + &quot;、&quot; +
                        x.get(&quot;count&quot;) + &quot;、&quot; +
                        x.get(&quot;max&quot;) + &quot;、&quot; +
                        x.get(&quot;min&quot;) + &quot;、&quot; +
                        x.get(&quot;sum&quot;) + &quot;、&quot; +
                        x.get(&quot;avg&quot;))
                );

        // 释放资源
        entityManager.close();
    &#125;
</code></pre>
<p>查看日志：</p>
<pre><code class="verilog">Hibernate: 
    select
        customer0_.customer_name as col_0_0_,
        count(customer0_.customer_name) as col_1_0_,
        max(customer0_.customer_age) as col_2_0_,
        min(customer0_.customer_age) as col_3_0_,
        sum(customer0_.customer_age) as col_4_0_,
        avg(customer0_.customer_age) as col_5_0_ 
    from
        tb_customer customer0_ 
    group by
        customer0_.customer_name
Angus、1、10、10、10、10.0
Hom、1、30、30、30、30.0
Kath、1、30、30、30、30.0
Mike、1、20、20、20、20.0
Nick、1、25、25、25、25.0
Oliver、1、30、30、30、30.0
Rachel、1、25、25、25、25.0
Sam、1、18、18、18、18.0
Vivi、1、28、28、28、28.0
Wendy、1、15、15、15、15.0
</code></pre>
<h3 id="3-7、多表查询"><a href="#3-7、多表查询" class="headerlink" title="3.7、多表查询"></a>3.7、多表查询</h3><p>建议先参考多对一教程的实体类测试，或者也可以直接使用下方给定的实体类</p>
<pre><code class="java">/**
 * 多方/外键表
 * 本实例采用的是：单向多对一。所以只需要配置多方即可
 */
@Data
@Entity
@Table(name = &quot;t_many&quot;)
public class Many &#123;
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = &quot;many_id&quot;)
    private Long manyId;
    @Column(name = &quot;many_name&quot;)
    private String manyName;

    @ManyToOne
    @JoinColumn(name=&quot;one_id&quot;)
    private One one;
&#125;


/**
 * 一方/主键表
 * 本实例采用的是：单向多对一。所以只需要配置多方即可
 */
@Data
@Entity
@Table(name = &quot;t_one&quot;)
public class One &#123;
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = &quot;one_id&quot;)
    private Long oneId;
    @Column(name = &quot;one_type&quot;)
    private String oneType;
&#125;
</code></pre>
<p>测试代码：</p>
<pre><code class="java">    /**
     * 多表关联：单向多对一
     * 数据插入
     */
    @Test
    public void testSaveJoinTable() &#123;
        // 1.获取entityManager对象
        EntityManager entityManager = JpaUtils.getEntityManager();
        // 开启事务
        entityManager.getTransaction().begin();

        // 给One插入一条数据（主键表）
        One one = new One();
        one.setOneType(&quot;初中&quot;);
        entityManager.persist(one);

        // 给Many插入三条数据（外键表）
        Many manyA = new Many();
        manyA.setManyName(&quot;初一&quot;);
        manyA.setOne(one);
        entityManager.persist(manyA);
        Many manyB = new Many();
        manyB.setManyName(&quot;初二&quot;);
        manyB.setOne(one);
        entityManager.persist(manyB);
        Many manyC = new Many();
        manyC.setManyName(&quot;初三&quot;);
        manyC.setOne(one);
        entityManager.persist(manyC);

        // 提交事务
        entityManager.getTransaction().commit();
    &#125;

    /**
     * Root代表需要查询的表（这里表示的是Many表）
     * Join代表连接查询(表)，通过root对象获取（Join代表的是关联表One表）
     * 创建的过程中，第一个参数为关联对象的属性名称，第二个参数为连接查询的方式（left，inner，right）
     * JoinType.INNER：内连接, JoinType.LEFT: 左外连接, JoinType.RIGHT：右外连接
     * 使用多表关联后，Join 就相当有了 root 的功能，可以join.get(&quot;对象属性名称&quot;)
     * 注意！注意！注意：
     *     Root：代表的是Many表，所以通过root.get()只能获取Many表的属性或字段.
     *     Join：代表的是One表，虽然是关联查询，但它只代表关联的One表，只能获取One的属性
     *     如果root/join获取自己表以外的属性或字段会报如下错：
     *     Unable to locate Attribute  with the the given name [categoryType] on this ManagedType[XXX]
     *     如果有第三张表关联使用join.join()往下传递即可。
     */
    @Test
    public void testFindJoinTable() &#123;
        // 1.获取entityManager对象 &amp;&amp; 这里就省略事务了
        EntityManager entityManager = JpaUtils.getEntityManager();

        CriteriaBuilder criteriaBuilder = entityManager.getCriteriaBuilder();
        CriteriaQuery&lt;Many&gt; criteriaQuery = criteriaBuilder.createQuery(Many.class);

        // 重点：root只能代表Many表，join只能代表One表。
        Root&lt;Many&gt; root = criteriaQuery.from(Many.class);
        Join&lt;Many, One&gt; join = root.join(&quot;one&quot;, JoinType.LEFT);

        Path&lt;Object&gt; type = join.get(&quot;oneType&quot;);
        Path&lt;Object&gt; manyName = root.get(&quot;manyName&quot;);
        Predicate p1 = criteriaBuilder.equal(type, &quot;初中&quot;);
        Predicate p2 = criteriaBuilder.equal(manyName, &quot;初一&quot;);
        Predicate predicate = criteriaBuilder.and(p1, p2);
        criteriaQuery.where(predicate);
        TypedQuery&lt;Many&gt; query = entityManager.createQuery(criteriaQuery);
        List&lt;Many&gt; resultList = query.getResultList();
        resultList.forEach(System.out::println);
    &#125;
</code></pre>
<p>查看日志：</p>
<pre><code class="sql">Hibernate: 
    select
        many0_.many_id as many_id1_3_,
        many0_.many_name as many_nam2_3_,
        many0_.one_id as one_id3_3_ 
    from
        t_many many0_ 
    left outer join
        t_one one1_ 
            on many0_.one_id=one1_.one_id 
    where
        one1_.one_type=? 
        and many0_.many_name=?
Hibernate: 
    select
        one0_.one_id as one_id1_4_0_,
        one0_.one_type as one_type2_4_0_ 
    from
        t_one one0_ 
    where
        one0_.one_id=?
Many(manyId=1, manyName=初一, one=One(oneId=1, oneType=初中))
</code></pre>
<h2 id="4、Query-接口方法介绍"><a href="#4、Query-接口方法介绍" class="headerlink" title="4、Query 接口方法介绍"></a>4、Query 接口方法介绍</h2><p>JPQL 语言和原生 SQL 语句可以是 select 语句、update 语句或 delete语句（注意：无法执行insert语句），它们都通过 Query 接口封装执行。Query 接口封装了执行数据库查询的相关方法。调用 EntityManager 的 createQuery、createNamedQuery 及 createNativeQuery 方法可以获得查询对象，进而调用 Query 接口的相关方法来执行查询操作。</p>
<pre><code class="java">/**
 * JPQL 语言和原生 SQL 语句可以是 select 语句、update 语句或 delete语句（没有insert），它们都通过 Query 接口封装执行
 * Query 接口封装了执行数据库查询的相关方法。调用 EntityManager 的 createQuery、createNamedQuery 及 createNativeQuery 方法可以获得查询对象，进而调用 Query 接口的相关方法来执行查询操作
 *
 * int executeUpdate()
 * 用于执行update或delete语句
 *
 * List getResultList()
 * 用于执行select语句并返回结果集实体列表
 *
 * Object getSingleResult()
 * 用于执行只返回单个结果实体的select语句
 *
 * Query setFirstResult(int startPosition)
 * 用于设置从哪个实体记录开始返回查询结果
 *
 * Query setMaxResults(int maxResult)
 * 用于设置返回结果实体的最大数。与setFirstResult结合使用可实现分页查询
 *
 * Query setFlushMode(FlushModeType flushMode)
 * 设置查询对象的Flush模式。参数可以取2个枚举值：FlushModeType.AUTO 为自动更新数据库记录，FlushMode Type.COMMIT 为直到提交事务时才更新数据库记录
 *
 * setHint(String hintName, Object value)
 * 设置与查询对象相关的特定供应商参数或提示信息。参数名及其取值需要参考特定 JPA 实现库提供商的文档。如果第二个参数无效将抛出IllegalArgumentException异常
 *
 * setParameter(int position, Object value)
 * 为查询语句的指定位置参数赋值。Position 指定参数序号，value 为赋给参数的值
 *
 * setParameter(int position, Date d, TemporalType type)
 * 为查询语句的指定位置参数赋 Date 值。Position 指定参数序号，value 为赋给参数的值，temporalType 取 TemporalType 的枚举常量，包括 DATE、TIME 及 TIMESTAMP 三个，用于将 Java 的 Date 型值临时转换为数据库支持的日期时间类型（java.sql.Date、java.sql.Time及java.sql.Timestamp）
 *
 * setParameter(int position, Calendar c, TemporalType type)
 * 为查询语句的指定位置参数赋 Calenda r值。position 指定参数序号，value 为赋给参数的值，temporalType 的含义及取舍同前
 *
 * setParameter(String name, Object value)
 * 为查询语句的指定名称参数赋值
 *
 * setParameter(String name, Date d, TemporalType type)
 * 为查询语句的指定名称参数赋 Date 值。用法同前
 *
 * setParameter(String name, Calendar c, TemporalType type)
 * 为查询语句的指定名称参数设置Calendar值。name为参数名，其它同前。该方法调用时如果参数位置或参数名不正确，或者所赋的参数值类型不匹配，将抛出 IllegalArgumentException 异常
 */
</code></pre>
<h2 id="5、NamedQuery-NamedNativeQuery-别名查询"><a href="#5、NamedQuery-NamedNativeQuery-别名查询" class="headerlink" title="5、NamedQuery&#x2F;@NamedNativeQuery 别名查询"></a>5、NamedQuery&#x2F;@NamedNativeQuery 别名查询</h2><p>又叫别名查询。主要使用：@NamedQuery 或者 @NamedNativeQuery + entityManager.createNamedQuery() 来查询</p>
<p>实体类：</p>
<pre><code class="java">@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
@Entity
@Table(name = &quot;tb_customer&quot;)
// 主要加上该注解，name是取名，用来被引用的。query是JPQL语句
@NamedQuery(name = &quot;selectAllNamedQuery&quot;, query = &quot;from Customer&quot;)
@NamedNativeQuery(name = &quot;selectAllNamedNativeQuery&quot;, query = &quot;select * from tb_customer&quot;, resultClass = Customer.class)
public class Customer &#123;

    @Tolerate
    public Customer(String name, int age) &#123;
        this.name = name;
        this.age = age;
    &#125;

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = &quot;customer_id&quot;)
    private Long Id; // 客户的主键

    @Column(name = &quot;customer_name&quot;)
    private String name; // 客户名称

    @Column(name=&quot;customer_age&quot;)
    private int age; // 客户年龄

    @Column(name=&quot;customer_sex&quot;)
    private boolean sex; // 客户性别

    @Column(name=&quot;customer_phone&quot;)
    private String phone; // 客户的联系方式

    @Column(name=&quot;customer_address&quot;)
    private String address; // 客户地址

&#125;
</code></pre>
<p>测试方法：</p>
<pre><code class="java">    /**
     * 查询全部：createNamedQuery()
     *     jqpl：from Customer
     *     sql：SELECT * FROM c_customer
     */
    @Test
    public void testNamedQuery() &#123;
        // 1.获取entityManager对象 &amp;&amp; 开启事务
        EntityManager entityManager = JpaUtils.getEntityManager();
        EntityTransaction transaction = entityManager.getTransaction();
        transaction.begin();

        // 2.查询全部：创建Query查询对象，query对象才是执行jqpl和原生sql的对象。发送查询，并封装结果集
        // 使用@NamedQuery的name
        entityManager.createNamedQuery(&quot;selectAllNamedQuery&quot;).getResultList().forEach(System.out::println);
        // 使用@NamedNativeQuery的name
        entityManager.createNamedQuery(&quot;selectAllNamedNativeQuery&quot;, Customer.class).getResultList().forEach(System.out::println);

        // 4.提交事务 &amp;&amp; 释放资源
        transaction.commit();
        entityManager.close();
    &#125;
</code></pre>
<p>查看日志：</p>
<pre><code class="verilog">Hibernate: 
    select
        customer0_.customer_id as customer1_3_,
        customer0_.customer_address as customer2_3_,
        customer0_.customer_age as customer3_3_,
        customer0_.customer_name as customer4_3_,
        customer0_.customer_phone as customer5_3_,
        customer0_.customer_sex as customer6_3_ 
    from
        tb_customer customer0_
Customer(Id=1, name=Sam, age=18, sex=true, phone=135000000001, address=广州)
Customer(Id=2, name=Mike, age=20, sex=true, phone=135000000002, address=广州)
Customer(Id=3, name=Nick, age=25, sex=true, phone=135000000003, address=深圳)
Customer(Id=4, name=Hom, age=30, sex=true, phone=135000000004, address=西安)
Customer(Id=5, name=Rachel, age=25, sex=false, phone=135000000005, address=北京)
Customer(Id=6, name=Kath, age=30, sex=true, phone=135000000006, address=武汉)
Customer(Id=7, name=Vivi, age=28, sex=false, phone=135000000007, address=南京)
Customer(Id=8, name=Oliver, age=30, sex=true, phone=135000000008, address=深圳)
Customer(Id=9, name=Angus, age=10, sex=false, phone=135000000009, address=广州)
Customer(Id=10, name=Wendy, age=15, sex=false, phone=135000000000, address=西安)
Hibernate: 
    select
        * 
    from
        tb_customer
Customer(Id=1, name=Sam, age=18, sex=true, phone=135000000001, address=广州)
Customer(Id=2, name=Mike, age=20, sex=true, phone=135000000002, address=广州)
Customer(Id=3, name=Nick, age=25, sex=true, phone=135000000003, address=深圳)
Customer(Id=4, name=Hom, age=30, sex=true, phone=135000000004, address=西安)
Customer(Id=5, name=Rachel, age=25, sex=false, phone=135000000005, address=北京)
Customer(Id=6, name=Kath, age=30, sex=true, phone=135000000006, address=武汉)
Customer(Id=7, name=Vivi, age=28, sex=false, phone=135000000007, address=南京)
Customer(Id=8, name=Oliver, age=30, sex=true, phone=135000000008, address=深圳)
Customer(Id=9, name=Angus, age=10, sex=false, phone=135000000009, address=广州)
Customer(Id=10, name=Wendy, age=15, sex=false, phone=135000000000, address=西安)
</code></pre>
<h2 id="6、JPA-自定义对象接收查询结果集"><a href="#6、JPA-自定义对象接收查询结果集" class="headerlink" title="6、JPA 自定义对象接收查询结果集"></a>6、JPA 自定义对象接收查询结果集</h2><p>使用过JPA就会知道，我们借住@Query注解进行查询操作时，如果单表查询返回的是一个字段或者一个实体类时，很容易接收查询的结果；但是如果我们进行多表关联查询，查询的字段并不一定都在一个表中，所以就不能用实体类接收了，对于这样查询结果又一下三种方式处理。</p>
<p>1、用Object[]接收：这种方式显得水平好矬，取值的时候还要通过数组索引去取值，太low了，一堆代码看起来也不好看。如果仅是做一些统计类的查询勉强可以接收。</p>
<p>2、用Map&lt;String, Object&gt;接收：这种方式相对来说要比Object[]好，因为map的key就是我们查询的字段名，再取值的时候直接通过get方法取值就行，比较方便，当是相比直接用一个pojo来接收结果，使用起来还是要差一些。如何才能将结果转成自定义的对象呢，网上有一些文章是这样处理的：先有map来接收，再讲map转成json，最后将json解析成自定义得pojo(参见JPA自定义对象接收查询结果集_klayer_cong的博客-CSDN博客)。这样看起来处理过程有点麻烦，但是比较容易理解，确实也转成了自定义的pojo，如果只是一条查询结果这样实现还说的过去，如果查询出的数量很大，将会大大影响性能，这个时候就不太好了。</p>
<p>3、用@NamedNativeQuery+@SqlResultSetMapping处理（本次使用的是当前方式）</p>
<p>具体实现如下：</p>
<pre><code class="java">@NamedNativeQuery(
        name = &quot;querySummary&quot;,
        query = &quot; select t2.city_cd as cityCd,t2.city_name as cityName,DATE_FORMAT(t1.create_time,&#39;%Y-%m-%d&#39;) as createDate,t1.sale_type as saleType &quot; +
                &quot; from tb_project_sale t2 &quot; +
                &quot; left join tb_project_sale_core t1 on t2.id = t1.id &quot; +
                &quot; where t1.sale_type is not null &quot;,
        resultClass = SummaryDTO.class,
        resultSetMapping = &quot;summaryMapping&quot;)
@MappedSuperclass
@SqlResultSetMapping(
        name = &quot;summaryMapping&quot;,
        classes = @ConstructorResult(
                targetClass = SummaryDTO.class,
                columns = &#123;
                        @ColumnResult(name = &quot;cityCd&quot;, type = String.class),
                        @ColumnResult(name = &quot;cityName&quot;, type = String.class),
                        @ColumnResult(name = &quot;createDate&quot;, type = String.class),
                        @ColumnResult(name = &quot;saleType&quot;, type = String.class),
                &#125;
        )
)

@Setter
@Getter
@AllArgsConstructor
@NoArgsConstructor
public class SummaryDTO &#123;
    private String cityCd;
    private String cityName;
    private String createDate;
    private String saleType;
&#125;
</code></pre>
<pre><code class="java">@Repository
@Transactional
public class SummaryRepository &#123;
    @PersistenceContext
    private EntityManager entityManager;

    public List&lt;SummaryDTO&gt; getSummary() &#123;
        return entityManager.createNamedQuery(&quot;querySummary&quot;).getResultList();
    &#125;
&#125;
</code></pre>
<h1 id="Hibernate-JPA-注解分析"><a href="#Hibernate-JPA-注解分析" class="headerlink" title="Hibernate JPA 注解分析"></a>Hibernate JPA 注解分析</h1><blockquote>
<p>参考资料 &amp; 鸣谢：</p>
<ol>
<li>JPA 批注参考：<a target="_blank" rel="noopener" href="https://www.oracle.com/cn/middleware/technologies/ias/toplink-jpa-annotations.html">https://www.oracle.com/cn/middleware/technologies/ias/toplink-jpa-annotations.html</a></li>
<li>JPA 批注参考：<a target="_blank" rel="noopener" href="https://blog.51cto.com/u_9058648/3562214">https://blog.51cto.com/u_9058648/3562214</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/yswKnight/article/details/79257372">https://blog.csdn.net/yswKnight/article/details/79257372</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/yiyelanxin/article/details/100107335">https://blog.csdn.net/yiyelanxin/article/details/100107335</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/banywl/articles/14004262.html">https://www.cnblogs.com/banywl/articles/14004262.html</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/justlpf/article/details/84956212">https://blog.csdn.net/justlpf/article/details/84956212</a></li>
</ol>
</blockquote>
<h2 id="1、常用注解"><a href="#1、常用注解" class="headerlink" title="1、常用注解"></a>1、常用注解</h2><h3 id="Entity"><a href="#Entity" class="headerlink" title="Entity"></a>Entity</h3><p>@Entity 应用于实体类，并且使用默认的ORM规则，即 Class 名对应数据库表中表名，Class 字段名即表中的字段名（如想改变这种默认的ORM规则，就要使用 @Table 来改变 Class 名与数据库中表名的映射规则，@Column 来改变 Class 字段名与DB中表的字段名的映射规则）</p>
<p>元数据属性说明： </p>
<ul>
<li>name（可选）：表名</li>
</ul>
<p>下面的代码说明，Customer类对应数据库中的Customer表，其中name为可选，缺省类名即表名！</p>
<pre><code class="java">@Entity(name=&quot;Customer&quot;)
public class Customer &#123;&#125;
</code></pre>
<h3 id="Table"><a href="#Table" class="headerlink" title="Table"></a>Table</h3><p>@Table用来定义Entity主表的name，catalog，schema等属性。</p>
<p>元数据属性说明： </p>
<ul>
<li>name（可选）：指定表的名称</li>
<li>catalog（可选）：指定数据库名称（对应关系数据库中的catalog）</li>
<li>schema（可选）：指定数据库的用户名（对应关系数据库中的schema）</li>
<li>UniqueConstraints（可选）：指定唯一性字段约束的列，字段值唯一不重复（定义一个UniqueConstraint数组）</li>
<li>indexes（可选）：索引，只有创建表的时候有用，默认不需要（indexes是一个数组）</li>
</ul>
<pre><code class="java">@Entity(name=&quot;Customer&quot;)
@Table(name = &quot;tb_customer&quot;, catalog = &quot;db_jpa&quot;, schema = &quot;root&quot;, 
       uniqueConstraints=&#123;@UniqueConstraint(columnNames=&#123;&quot;name&quot;, &quot;age&quot;&#125;)
&#125;)
public class Customer &#123;&#125;
</code></pre>
<h3 id="Entity-与-Table-对比"><a href="#Entity-与-Table-对比" class="headerlink" title="Entity 与 Table 对比"></a>Entity 与 Table 对比</h3><blockquote>
<p>比较：@Entity(name &#x3D; “实体名”) 、@Entity @Table(name &#x3D; “表名”)<br>参考：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/GYMJT5sNoJ8-KcdIVQAoNw">https://mp.weixin.qq.com/s/GYMJT5sNoJ8-KcdIVQAoNw</a></p>
</blockquote>
<p>我们在使用JPA的时候，需要做数据表和实体类的映射，@Entity注解的实体类，默认的实体名是非限定类名，对实体名首字母小写后得到表名，例如：</p>
<pre><code class="java">@Entity
public class Comment&#123;&#125;
</code></pre>
<p>实体名：Comment，表名：comment。但实际项目中，有的表名以 tb_ 开头，那就映射不到了，那么就需要把表名写出来，有两种方式可以写：</p>
<ol>
<li>@Entity(name &#x3D; “实体名”)，一般把实体名写成跟表名相同，相当于写出了表名</li>
<li>@Entity + @Table(name &#x3D; “表名”)</li>
</ol>
<p>那么哪种方式好呢？粗略一看，应该是第一种好，但是应用到JPQL语句时，未必。</p>
<p>例如只用@Entity定义：</p>
<pre><code class="java">// 定义实体类
@Entity(name = &quot;tb_comment&quot;)
public class Comment&#123;&#125;

// JPQL 语句
@Query(&quot;update tb_comment c set c.author = ?1 where c.id= ?2 &quot;)
</code></pre>
<p>这是JPQL语句，JPA一不小心就把<code>tb_comment</code>认为是表名，后面的 c.xxx 就会去表中找字段，<strong>如果字段名跟实体的属性名不一样</strong>，就报错了。</p>
<p>如果写成下面这样的，使用@Entity + @Table(name &#x3D; “表名”)：</p>
<pre><code class="java">// 定义实体类
@Entity
@Table(name = &quot;tb_comment&quot;)
public class Comment&#123;&#125;

// JPQL 语句
@Query(&quot;update Comment c set c.author = ?1 where c.id = ?2&quot;)
</code></pre>
<p>可读性好，Comment一看就是实体类名，后面的c.xxx就会去类中找属性名，但实体名不能用JPQL的保留字。</p>
<p><strong>结论：</strong></p>
<ol>
<li>@Entity(name &#x3D; “实体名”)：会降低JPQL语句的可读性，一般实体名不会跟JPQL保留字重复</li>
<li>@Entity + @Table(name &#x3D; “表名”)：可读性强，更容易看出来面向对象编程思想，但要避免实体名与JPQL保留字重复</li>
</ol>
<h3 id="Column"><a href="#Column" class="headerlink" title="Column"></a>Column</h3><blockquote>
<p>基于Column注解的columnDefinition用法：<a target="_blank" rel="noopener" href="https://www.jb51.net/article/226168.htm">https://www.jb51.net/article/226168.htm</a></p>
</blockquote>
<p>@Column应用于实体类属性，可以指定数据库表字段的名字和其他属性。</p>
<pre><code class="java">@Target(&#123;METHOD, FIELD&#125;) 
@Retention(RUNTIME)
public @interface Column &#123;
    String name() default &quot;&quot;;
    boolean unique() default false;
    boolean nullable() default true;
    boolean insertable() default true;
    boolean updatable() default true;
    String columnDefinition() default &quot;&quot;;
    String table() default &quot;&quot;;
    int length() default 255;
    int precision() default 0;
    int scale() default 0;
&#125;
</code></pre>
<p>元数据属性说明： </p>
<ol>
<li>name：表示数据库表中该字段的名称，默认情形属性名称一致</li>
<li>unique：表示该字段是否是唯一标识，默认：false</li>
<li>nullable：表示该字段是否允许为null，默认：true</li>
<li>insertable：表示在ORM框架执行插入操作时，该字段是否应出现INSETRT语句中，默认：true</li>
<li>updateable：表示在ORM框架执行更新操作时，该字段是否应该出现在UPDATE语句中，默认：true。对于一经创建就不能更改的字段，该属性非常有用，比如<code>email</code>属性。（insertable、updatable属性一般多用于只读的属性，例如主键和外键等。这些字段的值通常是自动生成的）</li>
<li>columnDefinition：表示该字段在数据库中的实际类型。通常ORM框架可以根据属性类型自动判断数据库中字段的类型，但是依然有些例外：Date类型无法确定数据库中字段类型究竟是DATE、TIME、TIMESTAMP。此外，String的默认映射类型为VARCHAR，如果希望将String类型映射到特定数据库的BLOB或TEXT字段类型，则需要进行设置</li>
<li>table：表示当映射多个表时，指定表的表中的字段。默认值为主表的表名</li>
<li>length：表示该字段的大小，仅对String类型的字段有效</li>
<li>precision：表示精度，当字段类型为double时，precision表示数值的总长度</li>
<li>scale：表示精度，当字段类型为double时，scale表示小数点所占的位数</li>
</ol>
<blockquote>
<p>Column注解的columnDefinition用法：</p>
</blockquote>
<p>columnDefinition属性表示创建表时，该字段创建的SQL语句，一般用于通过Entity生成表定义时使用，如果数据库中表已经建好，该属性没有必要使用</p>
<pre><code class="java">/**
 * 1、指定字段类型、长度、是否允许null、是否唯一、默认值
 */
@Column(name = &quot;code&quot;,columnDefinition = &quot;Varchar(100) not null default&#39;&#39; unique&quot;)
private String code;

/**
 * 2、需要特殊指定字段类型的情况
 * String默认映射类型为VARCHAR, 如果要将String类型映射到特定数据库的BLOB或TEXT字段类型
 */
@Column(name = &quot;text&quot;,columnDefinition=&quot;TEXT&quot;)
private String text;
@Column(name = &quot;salary&quot;, columnDefinition = &quot;decimal(5,2)&quot;)
private BigDecimal salary;
@Column(name=&quot;birthday&quot;,columnDefinition=&quot;date&quot;)
private Date birthday;
@Column(name=&quot;createTime&quot;,columnDefinition=&quot;datetime&quot;)
private Date createTime;
</code></pre>
<h3 id="Basic"><a href="#Basic" class="headerlink" title="Basic"></a>Basic</h3><p>应用于实体类属性，表明该字段是要映射到数据库表，@Entity标注的实体类，所有属性默认为@Basic（所以默认该注解可以不加）</p>
<p>元数据属性说明： </p>
<ul>
<li>fetch：属性的读取策略，有两种策略：<code>FetchType.LAZY</code>（延迟加载）和<code>FetchType.EAGER</code>（立即加载），默认：<code>EAGER</code></li>
<li>optional：表示该属性是否可以为null，默认值：true</li>
</ul>
<p>PS 注意：@Basic(fetch &#x3D;FetchType.LAZY) 标注某属性时，表示只有调用Hibernate对象的该属性的get方法时，才会从数据库表中查找对应该属性的字段值</p>
<h3 id="Transient"><a href="#Transient" class="headerlink" title="Transient"></a>Transient</h3><p>@Transient作用在类属性上，与@Basic作用相反，表明该属性不需要持久化，JPA映射数据时忽略该属性</p>
<h3 id="Temporal"><a href="#Temporal" class="headerlink" title="Temporal"></a>Temporal</h3><p>@Temporal作用在类属性上，用来设置Date类型的属性映射到数据库时的精度。当我们使用到 java.util 包中的时间日期类型，则需要此注释来说明转化成 java.util包中的类型。</p>
<ol>
<li>@Temporal(TemporalType.DATE)：映射为日期 date （只有日期）等于Java的<code>java.sql.Date</code></li>
<li>@Temporal(TemporalType.TIME)：映射为日期 time （是有时间）等于Java的<code>java.sql.Time</code></li>
<li>@Temporal(TemporalType.TIMESTAMP)：映射为日期 date + time （日期 + 时间）等于Java的<code>java.sql.Timestamp</code></li>
</ol>
<p><strong>PS 注意</strong>：@Temporal注解只能映射<code>java.util.Date or java.util.Calendar</code>，这两种时间类型，否则将报如下错误：</p>
<pre><code class="verilog">Hibernate.AnnotationException: @Temporal should only be set on a java.util.Date or java.util.Calendar property: entity.User.createLocalDateTime
</code></pre>
<p>1、首先定义实体类，并给需要处理的时间字段加上@Temporal注解。示例代码：</p>
<pre><code class="java">@Data
@Entity
@Table(name = &quot;sys_user&quot;)
public class User implements Serializable &#123;
    @Id
    private Long id;
    @Temporal(TemporalType.DATE)
    private java.util.Date createDate;
    @Temporal(TemporalType.TIME)
    private java.util.Date createTime;
    @Temporal(TemporalType.TIMESTAMP)
    private java.util.Date createTIMESTAMP;
    // @Temporal只能映射 ava.util.Date or java.util.Calendar 两种时间类型
    // @Temporal(TemporalType.TIMESTAMP)
    // private java.time.LocalDateTime createLocalDateTime;
&#125;
</code></pre>
<p>2、启动项目或者测试类，查看建表语句</p>
<pre><code class="sql">create table sys_user (
    id bigint not null,
    createDate date,
    createTIMESTAMP timestamp,
    createTime time,
    primary key (id)
)
</code></pre>
<p>3、测试代码</p>
<pre><code class="java">import entity.User;
import org.junit.Test;

import javax.persistence.EntityManager;
import javax.persistence.EntityManagerFactory;
import javax.persistence.EntityTransaction;
import javax.persistence.Persistence;

public class TestDemo &#123;

    @Test
    public void testSave() &#123;
        // 1.加载配置文件创建工厂（实体管理器工厂）对象
        EntityManagerFactory factory = Persistence.createEntityManagerFactory(&quot;myJpa&quot;);
        // 2.通过实体管理器工厂获取实体管理器
        EntityManager em = factory.createEntityManager();
        // 3.获取事务对象，开启事务
        EntityTransaction tx = em.getTransaction();

        // 开启事物新增数据，手动设置时间
        tx.begin();
        User user = new User();
        user.setId(1L);
        user.setCreateDate(new java.util.Date());
        user.setCreateTime(new java.util.Date());
        user.setCreateTIMESTAMP(new java.util.Date());
        em.persist(user);
        tx.commit();

        em.refresh(user);
        User user_selelct = em.find(User.class, 1L);
        System.out.println(user_selelct);

        // 6.释放资源
        em.close();
        factory.close();
    &#125;
&#125;
</code></pre>
<p>4、查看输出日志</p>
<pre><code class="verilog">User(id=1, createDate=2022-02-01, createTime=15:13:36, createTIMESTAMP=2022-02-01 15:13:36.325)
</code></pre>
<h3 id="CreationTimestamp"><a href="#CreationTimestamp" class="headerlink" title="CreationTimestamp"></a>CreationTimestamp</h3><blockquote>
<p>@CreationTimestamp 与 @UpdateTimestamp 注解是JPA用来自动创建、更新时间戳</p>
</blockquote>
<p>使用该注解可以让Hibernate JPA在插入时针对注解的属性对应的日期类型创建默认值。此批注没有属性。</p>
<pre><code class="java">/**
 * Marks a property as the creation timestamp of the containing entity. The property value will be set to the current
 * VM date exactly once when saving the owning entity for the first time.
 * &lt;p&gt;
 * Supported property types:
 * &lt;ul&gt;
 * &lt;li&gt;&#123;@link java.util.Date&#125;&lt;/li&gt;
 * &lt;li&gt;&#123;@link java.util.Calendar&#125;&lt;/li&gt;
 * &lt;li&gt;&#123;@link java.sql.Date&#125;&lt;/li&gt;
 * &lt;li&gt;&#123;@link java.sql.Time&#125;&lt;/li&gt;
 * &lt;li&gt;&#123;@link java.sql.Timestamp&#125;&lt;/li&gt;
 * &lt;li&gt;&#123;@link java.time.Instant&#125;&lt;/li&gt;
 * &lt;li&gt;&#123;@link java.time.LocalDate&#125;&lt;/li&gt;
 * &lt;li&gt;&#123;@link java.time.LocalDateTime&#125;&lt;/li&gt;
 * &lt;li&gt;&#123;@link java.time.LocalTime&#125;&lt;/li&gt;
 * &lt;li&gt;&#123;@link java.time.MonthDay&#125;&lt;/li&gt;
 * &lt;li&gt;&#123;@link java.time.OffsetDateTime&#125;&lt;/li&gt;
 * &lt;li&gt;&#123;@link java.time.OffsetTime&#125;&lt;/li&gt;
 * &lt;li&gt;&#123;@link java.time.Year&#125;&lt;/li&gt;
 * &lt;li&gt;&#123;@link java.time.YearMonth&#125;&lt;/li&gt;
 * &lt;li&gt;&#123;@link java.time.ZonedDateTime&#125;&lt;/li&gt;
 * &lt;/ul&gt;
 *
 * @author Gunnar Morling
 */
@ValueGenerationType(generatedBy = CreationTimestampGeneration.class)
@Retention(RetentionPolicy.RUNTIME)
public @interface CreationTimestamp &#123;
&#125;
</code></pre>
<p>示例代码参考@UpdateTimestamp</p>
<h3 id="UpdateTimestamp"><a href="#UpdateTimestamp" class="headerlink" title="UpdateTimestamp"></a>UpdateTimestamp</h3><p>使用该注解可以让Hibernate JPA在更新时时针对注解的属性对应的日期类型创建默认值。此批注没有属性。</p>
<pre><code class="java">/**
 * Marks a property as the update timestamp of the containing entity. The property value will be set to the current VM
 * date whenever the owning entity is updated.
 * &lt;p&gt;
 * Supported property types:
 * &lt;ul&gt;
 * &lt;li&gt;&#123;@link java.util.Date&#125;&lt;/li&gt;
 * &lt;li&gt;&#123;@link java.util.Calendar&#125;&lt;/li&gt;
 * &lt;li&gt;&#123;@link java.sql.Date&#125;&lt;/li&gt;
 * &lt;li&gt;&#123;@link java.sql.Time&#125;&lt;/li&gt;
 * &lt;li&gt;&#123;@link java.sql.Timestamp&#125;&lt;/li&gt;
 * &lt;li&gt;&#123;@link java.time.Instant&#125;&lt;/li&gt;
 * &lt;li&gt;&#123;@link java.time.LocalDate&#125;&lt;/li&gt;
 * &lt;li&gt;&#123;@link java.time.LocalDateTime&#125;&lt;/li&gt;
 * &lt;li&gt;&#123;@link java.time.LocalTime&#125;&lt;/li&gt;
 * &lt;li&gt;&#123;@link java.time.MonthDay&#125;&lt;/li&gt;
 * &lt;li&gt;&#123;@link java.time.OffsetDateTime&#125;&lt;/li&gt;
 * &lt;li&gt;&#123;@link java.time.OffsetTime&#125;&lt;/li&gt;
 * &lt;li&gt;&#123;@link java.time.Year&#125;&lt;/li&gt;
 * &lt;li&gt;&#123;@link java.time.YearMonth&#125;&lt;/li&gt;
 * &lt;li&gt;&#123;@link java.time.ZonedDateTime&#125;&lt;/li&gt;
 * &lt;/ul&gt;
 *
 * @author Gunnar Morling
 */
@ValueGenerationType(generatedBy = UpdateTimestampGeneration.class)
@Retention(RetentionPolicy.RUNTIME)
public @interface UpdateTimestamp &#123;
&#125;
</code></pre>
<p>1、一般情况下创建、更新时间戳注解 @CreationTimestamp、@UpdateTimestamp 会一起使用。下面是代码示例：</p>
<pre><code class="java">@Data
@Entity
@Table(name = &quot;sys_user&quot;)
public class User implements Serializable &#123;
    @Id
    private Long id;
    @CreationTimestamp
    private java.util.Date createDate;
    @UpdateTimestamp
    private java.sql.Timestamp updateTimestamp;
    @CreationTimestamp
    private java.time.LocalDate createLocalDate;
    @UpdateTimestamp
    private java.time.LocalTime updateLocalTime;
    @UpdateTimestamp
    private java.time.LocalDateTime updateLocalDateTime;
&#125;
</code></pre>
<p>2、启动项目或者测试类，查看JPA自动建表语句。<strong>可以看到他们的对应关系，使用时需要特别注意。</strong></p>
<pre><code class="sql">create table sys_user (
    id bigint not null,
    createDate timestamp,
    createLocalDate date,
    updateLocalDateTime timestamp,
    updateLocalTime time,
    updateTimestamp timestamp,
    primary key (id)
)
</code></pre>
<p>3、运行单元测试，查看手动设置时间与JPA自动设置时间的区别</p>
<pre><code class="java">import entity.User;
import org.junit.Test;
import javax.persistence.EntityManager;
import javax.persistence.EntityManagerFactory;
import javax.persistence.EntityTransaction;
import javax.persistence.Persistence;
import java.sql.Timestamp;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.util.Date;

public class TestDemo &#123;

    @Test
    public void testSave() &#123;
        // 1.加载配置文件创建工厂（实体管理器工厂）对象
        EntityManagerFactory factory = Persistence.createEntityManagerFactory(&quot;myJpa&quot;);
        // 2.通过实体管理器工厂获取实体管理器
        EntityManager em = factory.createEntityManager();
        // 3.获取事务对象，开启事务
        EntityTransaction tx = em.getTransaction();

        // 开启事物新增数据，手动设置时间
        tx.begin();
        User user = new User();
        user.setId(1L);
        user.setCreateDate(new Date());
        user.setCreateLocalDate(LocalDate.now());
        user.setUpdateTimestamp(new Timestamp(System.currentTimeMillis()));
        user.setUpdateLocalTime(LocalTime.now());
        user.setUpdateLocalDateTime(LocalDateTime.now());
        em.persist(user);
        tx.commit();

        em.refresh(user);
        User user_selelct = em.find(User.class, 1L);
        System.out.println(user_selelct);

        // 开启事物新增数据，JPA自动设置时间
        tx.begin();
        User user2 = new User();
        user2.setId(2L);
        em.persist(user2);
        tx.commit();

        em.refresh(user2);
        User user_selelct2 = em.find(User.class, 2L);
        System.out.println(user_selelct2);

        // 6.释放资源
        em.close();
        factory.close();
    &#125;
&#125;
</code></pre>
<p>4、查看输出日志</p>
<pre><code class="verilog">User(id=1, createDate=2022-01-31 21:59:16.181, updateTimestamp=2022-01-31 21:59:16.181, createLocalDate=2022-01-31, updateLocalTime=21:59:16, updateLocalDateTime=2022-01-31T21:59:16.181568)
User(id=2, createDate=2022-01-31 21:59:16.245, updateTimestamp=2022-01-31 21:59:16.245, createLocalDate=2022-01-31, updateLocalTime=21:59:16, updateLocalDateTime=2022-01-31T21:59:16.245574)
</code></pre>
<h3 id="自定义默认值注解（类似审计功能）"><a href="#自定义默认值注解（类似审计功能）" class="headerlink" title="自定义默认值注解（类似审计功能）"></a>自定义默认值注解（类似审计功能）</h3><blockquote>
<p>参考文献 &amp; 鸣谢：</p>
<ol>
<li>JPA注解@CreationTimestamp和@UpdateTimestamp：<a target="_blank" rel="noopener" href="https://blog.csdn.net/z185665096/article/details/106090223">https://blog.csdn.net/z185665096/article/details/106090223</a></li>
<li>JPA设置默认值、Timestamp设置、自动获取时间：<a target="_blank" rel="noopener" href="https://blog.csdn.net/ctwy291314/article/details/88250205">https://blog.csdn.net/ctwy291314/article/details/88250205</a></li>
</ol>
</blockquote>
<p>比如，用户名，插入时可以根据当前线程直接获取，然后利用注解赋值，这样在业务处理时就可以不用关注该属性。类似还有更新时自动赋值操作人等。</p>
<ul>
<li>新增注解@CreationUser</li>
</ul>
<pre><code class="java">/**
 * Hibernate新增插入时自动填充
 */
@ValueGenerationType(
    generatedBy = CreationUserGeneration.class
)
@Retention(RetentionPolicy.RUNTIME)
public @interface CreationUser &#123;
&#125;
</code></pre>
<ul>
<li>新增注解值生成类。主要继承<code>org.hibernate.tuple.AnnotationValueGeneration&lt;A extends Annotation&gt;</code></li>
</ul>
<pre><code class="java">import org.hibernate.tuple.AnnotationValueGeneration;
import org.hibernate.tuple.GenerationTiming;
import org.hibernate.tuple.ValueGenerator;

/**
 * 针对加了注解&#123;@link @CreationUser&#125;的属性在插入时，自动根据当前线程获取用户信息赋值
 */
public class CreationUserGeneration implements AnnotationValueGeneration&lt;CreationUser&gt; &#123;
    private ValueGenerator&lt;?&gt; generator;

    public CreationUserGeneration() &#123;
    &#125;

    @Override
    public void initialize(CreationUser annotation, Class&lt;?&gt; propertyType) &#123;
        // 主要逻辑在这里实现
        this.generator = (ValueGenerator&lt;Object&gt;) (session, o) -&gt; UserContextHolder.getUserName();
    &#125;

    @Override
    public GenerationTiming getGenerationTiming() &#123;
        // 只有插入时，每次都修改使用GenerationTiming.ALWAYS
        return GenerationTiming.INSERT;
    &#125;

    @Override
    public ValueGenerator&lt;?&gt; getValueGenerator() &#123;
        return this.generator;
    &#125;

    @Override
    public boolean referenceColumnInSql() &#123;
        return false;
    &#125;

    @Override
    public String getDatabaseGeneratedReferencedColumnValue() &#123;
        return null;
    &#125;
&#125;
</code></pre>
<p>就这样就OK了，注解@CreationUser就可以直接在实体类使用了。</p>
<h2 id="2、主键注解"><a href="#2、主键注解" class="headerlink" title="2、主键注解"></a>2、主键注解</h2><h3 id="Id"><a href="#Id" class="headerlink" title="Id"></a>Id</h3><p>@Id 定义了映射到数据库表的主键的属性，一个实体只能有一个属性被映射为主键，可置于getXxxx()前。</p>
<h3 id="IdClass"><a href="#IdClass" class="headerlink" title="IdClass"></a>IdClass</h3><p>当实体类使用复合主键时，需要定义一个类作为 ID 实体类。作为联合主键类，需要满足以下要求：</p>
<ol>
<li>必须实现Serializable</li>
<li>必须有默认的public无参构造方法</li>
<li>必须覆盖equals和hashCode方法（EntityManager通过find方法查找Entity时是根据equals来判断的）</li>
</ol>
<p>元数据属性说明： </p>
<ul>
<li>value: id class的类名</li>
</ul>
<p>假设user_article表中的联合主键是 title 与 create_user_id，联合主键类代码如下：</p>
<pre><code class="java">@Data
public class UserArticleKey implements Serializable &#123;
    private String title;
    private Long createUserId;
    public UserArticleKey() &#123;
    &#125;
    public UserArticleKey(String title, String content, Long createUserId) &#123;
        this.title = title;
        this.createUserId = createUserId;
    &#125;
&#125;
</code></pre>
<p>user_article表实体类如下：</p>
<pre><code class="java">@Data
@Entity
@Table(name=&quot;user_article&quot;)
@IdClass(value = UserArticleKey.class)
public class UserArticle &#123;
    private Integer id;
    @Id
    private String title;
    @Id
    private Long createUserId;
&#125;
</code></pre>
<h3 id="EmbeddedId"><a href="#EmbeddedId" class="headerlink" title="EmbeddedId"></a>EmbeddedId</h3><p>使用 @EmbeddedId 批注指定一个由实体拥有的可嵌入<strong>复合主键</strong>类（通常由两个或更多基元类型或 JDK 对象类型组成）。从原有数据库映射时（此时数据库键由多列组成），通常将出现<strong>复合主键</strong>。（或者也可以使复合主键类（IdClass）成为非嵌入类）</p>
<p>复合主键类具有下列特征：</p>
<ul>
<li><p>它是一个普通的旧式 Java 对象 (POJO) 类。</p>
</li>
<li><p>它必须为 public，并且必须有一个 public 无参数构造函数。</p>
</li>
<li><p>如果使用基于属性的访问，则主键类的属性必须为 public 或 protected。</p>
</li>
<li><p>它必须是可序列化的。</p>
</li>
<li><p>它必须定义 equals 和 hashCode 方法。</p>
</li>
<li><p>这些方法的值相等性的语义必须与键映射到的数据库类型的数据库相等性一致。</p>
</li>
<li><p>此批注没有属性，一般与 @Embeddable（注解在类上，表示此类是可以被其他类嵌套）配合使用。</p>
</li>
<li><p>@Embeddable 还能多层嵌套使用</p>
</li>
</ul>
<p>假设sys_user表中的联合主键是 id 与 username，联合主键类代码如下：</p>
<p>1、主键的实体类</p>
<pre><code class="java">@Data
@Embeddable
public class UserPK implements Serializable &#123;
    @Column(name = &quot;id&quot;)
    private Long id;
    @Column(name = &quot;username&quot;)
    private String username;
&#125;
</code></pre>
<p>2、表映射的持久类（持久类里要有一个注解@EmbeddedId修饰主键的成员变量，其他的和普通的Entity类一样。它所对应复合主键类需要使用@Embeddable注解）</p>
<pre><code class="java">@Data
@Entity
@Table(name = &quot;sys_user&quot;)
public class User implements Serializable &#123;
    @EmbeddedId
    private UserPK userPK;
    private String password;
&#125;
</code></pre>
<p>3、启动项目或者测试类，查看JPA自动建表语句，可以发现把 id 与 usrname 创建成联合主键了</p>
<pre><code class="sql">create table sys_user (
    id bigint not null,
    username varchar(255) not null,
    password varchar(255),
    primary key (id, username)
)
</code></pre>
<p>4、普通Java项目测试</p>
<pre><code class="java">import entity.User;
import entity.UserPK;
import org.junit.Test;
import javax.persistence.*;

public class TestDemo &#123;

    @Test
    public void testSave() &#123;
        // 1.加载配置文件创建工厂（实体管理器工厂）对象
        EntityManagerFactory factory = Persistence.createEntityManagerFactory(&quot;myJpa&quot;);
        // 2.通过实体管理器工厂获取实体管理器
        EntityManager em = factory.createEntityManager();
        // 3.获取事务对象，开启事务
        EntityTransaction tx = em.getTransaction();
        tx.begin();
        UserPK userPK = new UserPK();
        userPK.setId(1L);
        userPK.setUsername(&quot;admin&quot;);
        User user = new User();
        user.setUserPK(userPK);
        user.setPassword(&quot;password&quot;);
        em.persist(user);
        tx.commit();

        em.refresh(user);
        User user_selelct = em.find(User.class, userPK);
        System.out.println(user_selelct);

        // 6.释放资源
        em.close();
        factory.close();
    &#125;
&#125;
</code></pre>
<p>输出日志：</p>
<pre><code class="verilog">Hibernate: 
    insert 
    into
        sys_user
        (password, id, username) 
    values
        (?, ?, ?)
Hibernate: 
    select
        user0_.id as id1_0_0_,
        user0_.username as username2_0_0_,
        user0_.password as password3_0_0_ 
    from
        sys_user user0_ 
    where
        user0_.id=? 
        and user0_.username=?
User(userPK=UserPK(id=1, username=admin), password=password)
</code></pre>
<p>5、SpringBoot项目测试，查看UserRepository接口定义查询方法</p>
<pre><code class="java">@Repository
public interface UserRepository extends JpaRepository&lt;User, UserPK&gt; &#123;
    // 只查找一个条件（只查询复合主键中的一个字段）
    List&lt;User&gt; findByIdUsername(String username);

    // 查找两个条件（如果有三个复合主键可以这样使用，如果只有两个复合主键就直接findById就行了）
    List&lt;User&gt; findByIdIdAndUsername(String id,String username);
    
    // 查询所有复合主键就直接findById就行
    User findById(UserPK, userpk);
&#125;
</code></pre>
<h3 id="GeneratedValue"><a href="#GeneratedValue" class="headerlink" title="GeneratedValue"></a>GeneratedValue</h3><blockquote>
<p>请参考本人的其他篇章，Hibernate JPA 主键策略的所有文章</p>
</blockquote>
<p>@GeneratedValue主要与@Id一同使用，定义主键的生成策略，通过<code>strategy</code>属性指定。</p>
<p>元数据属性说明： </p>
<ul>
<li>strategy（表示主键生成策略）：<ol>
<li>GenerationType.AUTO：JPA自动选择合适的策略，是默认选项</li>
<li>GenerationType.IDENTITY： 采用数据库ID自增长的方式生成主键值，一般用于MySQL数据库,Oracle不支持这种方式</li>
<li>GenerationType.SEQUENCE：通过序列产生主键，通过@SequenceGenerator注解指定序列名,MySql不支持这种方式</li>
<li>GenerationType.TABLE：通过表产生主键，会生成一张表模拟序列产生主键,该策略通用性强易于数据库的移植，效率低</li>
</ol>
</li>
<li>generator（表示生成器的名字）：这个属性通常和ORM框架相关。例如：Hibernate可以指定uuid等主键生成方式（要和@SequenceGenerator(name &#x3D; “seq_tbl_user”, sequenceName &#x3D; “seq_tbl_user”, allocationSize &#x3D; 1）注解配合使用，其中name指定生成器的名字（与generator的值一样），sequenceName指定数据库中定义序列的名字，allocationSize指定序列每次增长1 )</li>
</ul>
<pre><code class="java">@javax.persistence.Id
@javax.persistence.GeneratedValue(generator=&quot;xxx&quot;,strategy=GenerationType.AUTO)

strategy:表示主键生成策略,有如下四种方式:
方式一：@GeneratedValue(strategy=GenerationType.AUTO) 默认策略，生成方式取决于底层的数据库。
方式二：@GeneratedValue(strategy = GenerationType.IDENTITY)指定“自动增长”策略，适用于MySQL。 
方式三：@GeneratedValue(strategy = GenerationType.SEQUENCE, generator = &quot;seq_tbl_user&quot;)
       指定“序列”策略，适用于Oracle。其中generator表示生成器的名字，这个属性通常和ORM框架相关。
       例如,Hibernate可以指定uuid等主键生成方式(要和@SequenceGenerator(name = &quot;seq_tbl_user&quot;, 
       sequenceName = &quot;seq_tbl_user&quot;, allocationSize = 1)注解配合使用，其中name指定生成器的名 
       字（与generator的值一样），sequenceName指定数据库中定义序列的名字，allocationSize指定序
       列每次增长1 )
方式四：@GeneratedValue(strategy=GenerationType.TABLE)  使用一个特定的数据库表格来保存主键
</code></pre>
<h3 id="SequenceGenerator"><a href="#SequenceGenerator" class="headerlink" title="SequenceGenerator"></a>SequenceGenerator</h3><blockquote>
<p>请参考本人的其他篇章，Hibernate JPA 主键策略：SEQUENCE 策略</p>
</blockquote>
<h3 id="GenericGenerator"><a href="#GenericGenerator" class="headerlink" title="GenericGenerator"></a>GenericGenerator</h3><blockquote>
<p>请参考本人的其他篇章，Hibernate JPA 主键策略：自定义主键生成器</p>
</blockquote>
<h3 id="TableGenerator"><a href="#TableGenerator" class="headerlink" title="TableGenerator"></a>TableGenerator</h3><blockquote>
<p>请参考本人的其他篇章，Hibernate JPA 主键策略：TABLE 策略</p>
</blockquote>
<h2 id="3、嵌入注解"><a href="#3、嵌入注解" class="headerlink" title="3、嵌入注解"></a>3、嵌入注解</h2><blockquote>
<p>@Embedded 与 @Embeddable：当一个实体类要在多个不同的实体类中进行使用，而其不需要生成数据库表</p>
<ol>
<li>@Embeddable：注解在类上，表示此类是可以被其他类嵌套</li>
<li>@Embedded：注解在属性上，表示嵌套被@Embeddable注解的同类型类</li>
</ol>
<p>@AttributeOverride、@AttributeOverrides 注解重定义其父类或者嵌套类属性映射到数据库表中字段</p>
</blockquote>
<h3 id="Embeddable"><a href="#Embeddable" class="headerlink" title="Embeddable"></a>Embeddable</h3><p>默认情况下，JPA 持续性提供程序假设每个实体均持久保存到它自己的数据库表。</p>
<p>使用 @Embeddable 批注指定一个类，该类的实例存储为拥有实体的固有部分并共享该实体的身份。嵌入对象的每个持久属性或字段都将映射到实体的数据库表。此批注没有属性。</p>
<p>下面使用此注解批注 实体类UserCommon.java，然后可以使用 @Embedded 或 @EmbeddedId 把UserCommon 注入另一个实体类中当做其属性。（可以理解为单独抽离几个字段出来独立到另一个类中）</p>
<pre><code class="java">@Data
@Embeddable
public class UserCommon &#123;
    @Column(name = &quot;startDate&quot;)
    private java.util.Date startDate;
    private java.util.Date endDate;
&#125;
</code></pre>
<p>PS：Embeddable一般与Embedded或EmbeddedId组合使用：@Embeddable + @Embedded、@Embeddable + @EmbeddedId</p>
<h3 id="Embedded"><a href="#Embedded" class="headerlink" title="Embedded"></a>Embedded</h3><p>使用 @Embedded 批注指定一个持久字段，该字段必须为引用类型，且还被 @Embeddable 批注。默认情况下 @Embeddable 类中指定的列定义适用于 @Embedded 类。如果要覆盖这些列定义可以使用 @AttributeOverride。</p>
<p>此批注没有属性。下面使用@Embeddable + @Embedded组合定义代码示例：</p>
<p>1、使用@Embeddable定义公共实体类</p>
<pre><code class="java">@Data
@Embeddable
public class UserCommon &#123;
    @Column(name = &quot;startDate&quot;)
    private java.util.Date startDate;
    private java.util.Date endDate;
&#125;
</code></pre>
<p>2、表映射的持久类（持久类里要有一个注解@Embedded修饰主键的成员变量，其他的和普通的Entity类一样。它所对应复合主键类需要使用@Embeddable注解）</p>
<pre><code class="java">@Data
@Entity
@Table(name = &quot;sys_user&quot;)
public class User implements Serializable &#123;
    @EmbeddedId
    private UserPK userPK;
    @Embedded
    private UserCommon userCommon;
    private String password;
&#125;
</code></pre>
<p>3、启动项目或者测试类，查看JPA自动建表语句，可以发现把 startDate 与 endDate 也创建到实体类 User 映射的数据表中了</p>
<pre><code class="sql">create table sys_user (
    id bigint not null,
    username varchar(255) not null,
    password varchar(255),
    endDate timestamp,
    startDate timestamp,
    primary key (id, username)
)
</code></pre>
<blockquote>
<p><strong>备注</strong>：正常用法一般都是 @Embedded + @Embeddable 同时使用，实际上单独使用任意一个，效果也是一样（可读性差）</p>
</blockquote>
<h3 id="MappedSuperclass"><a href="#MappedSuperclass" class="headerlink" title="MappedSuperclass"></a>MappedSuperclass</h3><blockquote>
<p>@MappedSuperclass：（很重要）实现将实体类的多个属性分别封装到不同的非实体类中</p>
<ol>
<li>注解的类将不是完整的实体类，不会映射到数据库表，但其属性将映射到子类的数据库字段</li>
<li>注解的类不能再标注@Entity或@Table注解，也无需实现序列化接口</li>
<li>注解的类继承另一个实体类或标注@MappedSuperclass类，他可使用@AttributeOverride或@AttributeOverrides注解重定义其父类属性映射到数据库表中字段</li>
</ol>
</blockquote>
<p>当我们在定义多个实体类时，可能会遇到这几个实体类都有几个共同的属性，这时就会出现很多重复代码。 这时我们可以选择用注解@MappedSuperclass。编写一个父类（基类），将这些共同属性放到这个父类中，并且在父类上加上@MappedSuperclass注解。</p>
<p><strong>使用方法和注意事项：</strong></p>
<ul>
<li>@MappedSuperclass 注解使用在父类上面，是用来标识父类的</li>
<li>@MappedSuperclass 标识的类不是一个完整的实体类，它不会映射到数据库表，但是它的属性都将映射到其子类的数据库字段中</li>
<li>@MappedSuperclass 标识的类不能再有@Entity或@Table，也无需实现序列化接口，但其子类可以有@Entity或@Table</li>
</ul>
<p>该批注没有属性。可以在子类中使用  @AttributeOverride 或  @AssociationOverride 批注来覆盖超类的映射配置。</p>
<pre><code class="java">@Data
@Entity
@Table(name = &quot;sys_user&quot;)
public class User extends BaseEntity implements Serializable &#123;
    private String admin;
    private String password;
&#125;

@Data
@MappedSuperclass
abstract class BaseEntity &#123;
    @Id
    private Long id; // 数据库主键
    @Column(name = &quot;creation_time&quot;)
    private java.util.Date creationTime; //创建时间
    @Column(name = &quot;update_time&quot;)
    private java.util.Date updateTime; //修改时间
&#125;
</code></pre>
<p>启动项目或者测试类，查看JPA自动建表语句，可以发现 id、creation_time、update_time 字段也新增了</p>
<pre><code class="sql">create table sys_user (
    id bigint not null,
    creation_time timestamp,
    update_time timestamp,
    admin varchar(255),
    password varchar(255),
    primary key (id)
)
</code></pre>
<h3 id="AttributeOverride"><a href="#AttributeOverride" class="headerlink" title="AttributeOverride"></a>AttributeOverride</h3><p>@AttributeOverride 批注是用来覆盖 @Embeddable 类或者 @MappedSuperclas 类中字段的列属性 （包含要覆盖的<code>@Embeddable</code>类中字段名name和新增的<code>@Column</code>字段的属性；）</p>
<p>元数据属性说明：</p>
<ul>
<li>name：如果使用了基于属性的访问，则映射的为嵌入对象中的属性名称，如果使用了基于字段的访问，则映射的为字段名称</li>
<li>column：映射到持久属性的 @Column。映射类型将与可嵌套类或映射超类中定义的类型相同</li>
</ul>
<p>1、下面使用 @AttributeOverride 注解重写 @Embeddable 批注的类中的属性字段。为了方便查看使用了内部类。</p>
<pre><code class="java">@Data
@Entity
@Table(name = &quot;sys_user&quot;)
public class User implements Serializable &#123;
    @EmbeddedId
    private UserPK userPK;
    @Embedded
    @AttributeOverrides(&#123; //把属性映射的列名称进行重写，startDate 和 endDate 是UserCommon类中的字段
            @AttributeOverride(name = &quot;startDate&quot;, column = @Column(name = &quot;start_date&quot;, nullable = false)),
            @AttributeOverride(name = &quot;endDate&quot;, column = @Column(name = &quot;end_date&quot;, nullable = false))
    &#125;)
    private UserCommon userCommon;
    private String password;

    @Data
    @Embeddable
    public static class UserCommon implements Serializable &#123;
        @Column(name = &quot;startDate&quot;)
        private java.util.Date startDate;
        private java.util.Date endDate;
    &#125;

    @Data
    @Embeddable
    public static class UserPK implements Serializable &#123;
        @Column(name = &quot;id&quot;)
        private Long id;
        @Column(name = &quot;username&quot;)
        private String username;
    &#125;
&#125;
</code></pre>
<p>2、启动项目或者测试类，查看JPA自动建表语句，可以发现startDate与endDate字段都被重写了，并且加了不能为空的约束。</p>
<pre><code class="sql">create table sys_user (
    id bigint not null,
    username varchar(255) not null,
    password varchar(255),
    end_date timestamp not null,
    start_date timestamp not null,
    primary key (id, username)
)
</code></pre>
<p>3、下面使用 @AttributeOverride 注解重写 @MappedSuperclass 批注的类中的属性字段。</p>
<pre><code class="java">@Data
@Entity
@Table(name = &quot;sys_user&quot;)
@AttributeOverrides(&#123; // 把属性映射的列名称进行重写，creationTime 和 updateTime 是BaseEntity类中的字段
        @AttributeOverride(name = &quot;creationTime&quot;, column = @Column(name = &quot;create_date&quot;, nullable = false)),
        @AttributeOverride(name = &quot;updateTime&quot;, column = @Column(name = &quot;update_date&quot;, nullable = false))
&#125;)
public class User extends BaseEntity implements Serializable &#123;
    private String admin;
    private String password;
&#125;

@Data
@MappedSuperclass
abstract class BaseEntity &#123;
    @Id
    private Long id; // 数据库主键
    @Column(name = &quot;creation_time&quot;)
    private java.util.Date creationTime; //创建时间
    @Column(name = &quot;update_time&quot;)
    private java.util.Date updateTime; //修改时间
&#125;
</code></pre>
<p>4、启动项目或者测试类，查看JPA自动建表语句，可以发现creationTime与updateTime字段都被重写了，并且加了不能为空的约束。</p>
<pre><code class="sql">create table sys_user (
    id bigint not null,
    create_date timestamp not null,
    update_date timestamp not null,
    admin varchar(255),
    password varchar(255),
    primary key (id)
)
</code></pre>
<h3 id="AttributeOverrides"><a href="#AttributeOverrides" class="headerlink" title="AttributeOverrides"></a>AttributeOverrides</h3><p>@AttributeOverrides 里面只包含了@AttributeOverride 类型数组，用法直接参考@AttributeOverride的即可。</p>
<h3 id="AssociationOverride"><a href="#AssociationOverride" class="headerlink" title="AssociationOverride"></a>AssociationOverride</h3><p>默认情况下，JPA 持续性提供程序自动假设子类继承超类中定义的持久属性及其关联映射。</p>
<p>如果继承的列定义对实体不正确（例如：继承的列名与已经存在的数据模型不兼容或作为数据库中的列名无效），请使用 @AssociationOverride 批注自定义从 @MappedSuperclass 或 @Embeddable 继承的 @OneToOne 或 @ManyToOne 映射，以更改与字段或属性关联的 @JoinColumn。如果有多个要进行的 @AssociationOverride 更改，则必须使用 @AssociationOverrides。</p>
<p>要自定义基本映射以更改它的 @Column，请使用 @AttributeOverride。</p>
<p>元数据属性说明：</p>
<ul>
<li>name：如果使用了基于属性的访问，则映射的为嵌入对象中的属性名称，如果使用了基于字段的访问，则映射的为字段名称</li>
<li>joinColumns：要指定映射到持久属性的连接列，请将 joinColums 设置为 JoinColumn 实例的数组，映射类型将与可嵌套类或映射的超类中定义的类型相同。</li>
</ul>
<p>1、这里使用@MappedSuperclass示例，先测试没有使用@AssociationOverride注解的效果。</p>
<pre><code class="java">import lombok.Data;
import javax.persistence.*;

@Data
@Entity
@Table(name = &quot;sys_user&quot;)
public class User extends BaseEntity implements java.io.Serializable &#123;
    @Id
    private Long id;
    private String admin;
    private String password;
&#125;

@Data
@MappedSuperclass
abstract class BaseEntity &#123;
    @ManyToOne
    @JoinColumn(name=&quot;address_id&quot;)
    private Address address;
&#125;

@Data
@Entity
@Table(name = &quot;sys_address&quot;)
class Address implements java.io.Serializable &#123;
    @Id
    @Column(name = &quot;address_id&quot;)
    private Long addressId;
    private String country;
&#125;
</code></pre>
<p>查看输出日志：</p>
<pre><code class="sql">create table sys_address (
    address_id bigint not null,
    country varchar(255),
    primary key (address_id)
);
create table sys_user (
    id bigint not null,
    admin varchar(255),
    password varchar(255),
    address_id bigint,
    primary key (id)
);
alter table sys_user 
       add constraint FK9abddsodne05nqpe2if8gjekl 
       foreign key (address_id) 
       references sys_address;
</code></pre>
<p>2、再使用@MappedSuperclass + AssociationOverride示例查看效果。</p>
<pre><code class="java">import lombok.Data;
import javax.persistence.*;

@Data
@Entity
@Table(name = &quot;sys_user&quot;)
@AssociationOverride(name=&quot;address&quot;, joinColumns=@JoinColumn(name=&quot;fk_address_id&quot;))
public class User extends BaseEntity implements java.io.Serializable &#123;
    @Id
    private Long id;
    private String admin;
    private String password;
&#125;

@Data
@MappedSuperclass
abstract class BaseEntity &#123;
    @ManyToOne
    @JoinColumn(name=&quot;address_id&quot;)
    private Address address;
&#125;

@Data
@Entity
@Table(name = &quot;sys_address&quot;)
class Address implements java.io.Serializable &#123;
    @Id
    private Long id;
    private String country;
&#125;
</code></pre>
<p>查看输出日志：</p>
<pre><code class="sql">create table sys_address (
    id bigint not null,
    country varchar(255),
    primary key (id)
);
create table sys_user (
    id bigint not null,
    admin varchar(255),
    password varchar(255),
    fk_address_id bigint,
    primary key (id)
);
alter table sys_user 
       add constraint FKmas1faywy7oyb4vr78hhm6kp0 
       foreign key (fk_address_id) 
       references sys_address;
</code></pre>
<p>从日志中可以看出@AssociationOverride的作用主要是重写了@JoinColumn注解的属性。</p>
<h3 id="AssociationOverrides"><a href="#AssociationOverrides" class="headerlink" title="AssociationOverrides"></a>AssociationOverrides</h3><p>@AssociationOverrides 里面只包含了@AssociationOverride 类型数组，用法直接参考@AssociationOverride的即可。</p>
<blockquote>
<p>简单对比@AssociationOverride与AttributeOverride的作用与区别：</p>
<ol>
<li>@AssociationOverride主要重写@MappedSuperclass 或 @Embeddable 继承的 @JoinColumn 注解字段</li>
<li>@AttributeOverride主要重写@MappedSuperclass 或 @Embeddable 继承的 @Column 注解字段</li>
</ol>
</blockquote>
<h2 id="4、次用注解"><a href="#4、次用注解" class="headerlink" title="4、次用注解"></a>4、次用注解</h2><h3 id="SecondaryTable"><a href="#SecondaryTable" class="headerlink" title="SecondaryTable"></a>SecondaryTable</h3><p>@SecondaryTable将一个实体映射到多个数据库表中。</p>
<p>元数据属性说明：</p>
<ul>
<li>name：表名 </li>
<li>catalog：对应关系数据库中的catalog </li>
<li>schema：对应关系数据库中的schema </li>
<li>pkJoinColumns：定义一个PrimaryKeyJoinColumn数组，指定从表的主键列 </li>
<li>UniqueConstraints：定义一个UniqueConstraint数组，指定需要建唯一约束的列</li>
</ul>
<pre><code class="java">// 如果只多映射一个数据表的话可以只用@SecondaryTable
@Entity
@Table(name = &quot;tb_customer&quot;)
@SecondaryTables(&#123;
    @SecondaryTable(name = &quot;tb_address&quot;, pkJoinColumns = &#123;@PrimaryKeyJoinColumn(name=&quot;address_id&quot;,referencedColumnName=&quot;id&quot;)&#125;),
    @SecondaryTable(name = &quot;tb_comments&quot;, pkJoinColumns = &#123;@PrimaryKeyJoinColumn(name=&quot;comments_id&quot;,referencedColumnName=&quot;id&quot;)&#125;)
&#125;)
public class Customer implements Serializable &#123;
    @Id
    private Long id;
    private String username;
    private String password;
    @Column(table = &quot;tb_address&quot;)
    private String street; 
    @Column(table = &quot;tb_address&quot;)
    private String city; 
    @Column(table = &quot;tb_address&quot;)
    private String conutry; 
    @Column(table = &quot;tb_comments&quot;)
    private String title; 
    @Column(table = &quot;tb_comments&quot;)
    private String comments;
&#125;
</code></pre>
<p>@Column中的table属性的值指定属性存储的哪张数据库表。没有用@Column中table值注解改变的属性，将会存在于默认tb_forum主表中。</p>
<pre><code class="sql">mysql&gt; desc tb_customer;
+----------+--------------+------+-----+---------+-------+
| Field    | Type         | Null | Key | Default | Extra |
+----------+--------------+------+-----+---------+-------+
| id       | bigint(20)   | NO   | PRI | NULL    |       |
| password | varchar(255) | YES  |     | NULL    |       |
| username | varchar(255) | YES  |     | NULL    |       |
+----------+--------------+------+-----+---------+-------+
3 rows in set (0.02 sec)

mysql&gt; desc tb_address;
+------------+--------------+------+-----+---------+-------+
| Field      | Type         | Null | Key | Default | Extra |
+------------+--------------+------+-----+---------+-------+
| city       | varchar(255) | YES  |     | NULL    |       |
| conutry    | varchar(255) | YES  |     | NULL    |       |
| street     | varchar(255) | YES  |     | NULL    |       |
| address_id | bigint(20)   | NO   | PRI | NULL    |       |
+------------+--------------+------+-----+---------+-------+
4 rows in set (0.02 sec)

mysql&gt; desc tb_comments;
+-------------+--------------+------+-----+---------+-------+
| Field       | Type         | Null | Key | Default | Extra |
+-------------+--------------+------+-----+---------+-------+
| comments    | varchar(255) | YES  |     | NULL    |       |
| title       | varchar(255) | YES  |     | NULL    |       |
| comments_id | bigint(20)   | NO   | PRI | NULL    |       |
+-------------+--------------+------+-----+---------+-------+
3 rows in set (0.03 sec)
</code></pre>
<h3 id="SecondaryTables"><a href="#SecondaryTables" class="headerlink" title="SecondaryTables"></a>SecondaryTables</h3><p>当一个实体类映射到一个主表和多个从表时，用@SecondaryTables来定义各个从表的属性。</p>
<p>元数据属性说明：</p>
<ul>
<li>columnNames:定义一个字符串数组，指定要建唯一约束的列名</li>
</ul>
<p>案例可以参考上面@SecondaryTable的示例代码。</p>
<h3 id="PrimaryKeyJoinColumn"><a href="#PrimaryKeyJoinColumn" class="headerlink" title="PrimaryKeyJoinColumn"></a>PrimaryKeyJoinColumn</h3><p>@PrimaryKeyJoinColumn一般在三种情况下会用到（@PrimaryKeyJoinColumns是用来装@PrimaryKeyJoinColumn数组的）</p>
<ol>
<li>继承</li>
<li>实体类映射到一个或多个从表。从表根据主表的主键列（列名为referencedColumnName值的列），建立一个类型一样的主键列，列名由name属性定义</li>
<li>one-to-one关系，关系维护端的主键作为外键指向关系被维护端的主键，不再新建一个外键列</li>
</ol>
<p>元数据属性说明：</p>
<ul>
<li>name：列名</li>
<li>referencedColumnName：该列引用列的列名</li>
<li>columnDefinition：定义建表时创建此列的DDL</li>
</ul>
<p>下面的代码说明Customer映射到两个表，主表tb_customer，从表tb_address，从表需要建立主键列address_id，该列和主表的主键列id除了列名不同，其他定义一样</p>
<pre><code class="java">@Entity
@Table(name = &quot;tb_customer&quot;)
@SecondaryTable(name = &quot;tb_address&quot;, pkJoinColumns = &#123;@PrimaryKeyJoinColumn(name=&quot;address_id&quot;,referencedColumnName=&quot;id&quot;)&#125;)
public class Customer implements Serializable &#123;
    @Id
    private Long id;
    private String username;
    private String password;
    @Column(table = &quot;tb_address&quot;)
    private String street; 
    @Column(table = &quot;tb_address&quot;)
    private String city; 
    @Column(table = &quot;tb_address&quot;)
    private String conutry; 
&#125;
</code></pre>
<p>下面的代码说明Customer和Address是一对一关系，Customer的主键列id作为外键指向Address的主键列address_id（这个本人暂时还没研究清楚）</p>
<pre><code class="java">@Entity
@Table(name = &quot;tb_customer&quot;)
public class Customer &#123;
    private Long customer_id;
    @OneToOne
    @PrimaryKeyJoinColumn(name = &quot;customer_id&quot;, referencedColumnName=&quot;address_id&quot;)
    private Address address;
&#125;
</code></pre>
<h3 id="PrimaryKeyJoinColumns"><a href="#PrimaryKeyJoinColumns" class="headerlink" title="PrimaryKeyJoinColumns"></a>PrimaryKeyJoinColumns</h3><p>如果实体类使用了复合主键，指定单个PrimaryKeyJoinColumn不能满足要求时，可以用PrimaryKeyJoinColumns来定义多个PrimaryKeyJoinColumn</p>
<p>元数据属性说明：</p>
<ul>
<li>value: 一个PrimaryKeyJoinColumn数组，包含所有PrimaryKeyJoinColumn。</li>
</ul>
<p>下面的代码说明了Employee和EmployeeInfo是一对一关系。他们都使用复合主键，建表时需要在Employee表建立一个外键，从Employee的主键列id,name指向EmployeeInfo的主键列INFO_ID和INFO_NAME</p>
<pre><code class="java">@Data
@IdClass(EmpPK.class)
@Entity
@Table(name = &quot;EMPLOYEE&quot;)
public class Employee &#123;
    private int id;
    private String name;
    private String address;

    @OneToOne(cascade = CascadeType.ALL)
    @PrimaryKeyJoinColumns(&#123;
        @PrimaryKeyJoinColumn(name=&quot;id&quot;, referencedColumnName=&quot;INFO_ID&quot;),
        @PrimaryKeyJoinColumn(name=&quot;name&quot; , referencedColumnName=&quot;INFO_NAME&quot;)&#125;)
    EmployeeInfo info;
&#125;
</code></pre>
<pre><code class="java">@Data
@IdClass(EmpPK.class)
@Entity
@Table(name = &quot;EMPLOYEE_INFO&quot;)
public class EmployeeInfo &#123;
    @Id
    @Column(name = &quot;INFO_ID&quot;)
    private int id;
    @Id
    @Column(name = &quot;INFO_NAME&quot;)
    private String name;
&#125;
</code></pre>
<h3 id="UniqueConstraint"><a href="#UniqueConstraint" class="headerlink" title="UniqueConstraint"></a>UniqueConstraint</h3><p>@UniqueConstraint定义在@Table或@SecondaryTable元数据里，用来指定建表时需要建唯一约束的列。</p>
<p>元数据属性说明：</p>
<ol>
<li>name：定义的名称</li>
<li>columnNames：定义一个字符串数组，指定要建唯一约束的列名</li>
</ol>
<pre><code class="java">@Entity
@Table(name=&quot;tb_person&quot;,uniqueConstraints=&#123;@UniqueConstraint(columnNames=&#123;&quot;person_id&quot;, &quot;person_name&quot;&#125;)&#125;)
public class Person &#123;
    @Id
    private Long person_id;
    private String person_name;
&#125;
</code></pre>
<h3 id="OrderBy"><a href="#OrderBy" class="headerlink" title="OrderBy"></a>OrderBy</h3><p>@OrderBy 在加载数据的时候可以为其指定顺序。有时我们希望从数据库加载出来的集合对象是按一定方式排序的，这可以通过OrderBy来实现，默认是按对象的主键升序排列。</p>
<p>元数据属性说明： </p>
<ul>
<li>value：字符串类型，指定排序方式</li>
<li>格式为：<code>fieldName1 [ASC|DESC]，fieldName2 [ASC|DESC]，...，</code>（排序类型可以不指定，默认是ASC）</li>
</ul>
<p>下面的代码说明Person和Book之间是一对多关系。集合books按照Book的age升序，name降序排列。</p>
<pre><code class="java">@Table(name=&quot;tb_person&quot;)
public class Person &#123;
    @OneToMany(targetEntity = Book.class, cascade = CascadeType.ALL, mappedBy = &quot;person&quot;)
    @OrderBy(name = &quot;age asc, name desc&quot;)
    private List&lt;Book&gt; books = new ArrayList();
    
    @OneToMany(targetEntity = Detail.class, cascade = CascadeType.ALL, mappedBy = &quot;person&quot;)
    @OrderBy // 默认使用主键排序
    private List&lt;Detail&gt; details = new ArrayList();
&#125;
</code></pre>
<h3 id="Version"><a href="#Version" class="headerlink" title="Version"></a>Version</h3><p>@Version 指定实体类在乐观事务中的 version 属性。在实体类重新由EntityManager管理并且加入到乐观事务中时，保证完整性。每一个类只能有一个属性被指定为 version，version 属性应该映射到实体类的主表上。version支持（int，Integer，short，Short, long，Long，java.sql.Timestamp）类型的属性或字段。</p>
<p>使用起来非常方便，我们只需要在实体中添加一个字段，并添加@Version注解就可以了。加了@Version后，insert和update的SQL语句都会带上version的操作。当乐观锁更新失败的时候，会抛出异常org.springframework.orm.ObjectOptimisticLockingFailureException。我们自己进行业务处理。</p>
<pre><code class="java">@Version
@Column(name = &quot;customer_version&quot;, columnDefinition=&quot;bigint default 0&quot;)
private Long version;
</code></pre>
<h3 id="Lob"><a href="#Lob" class="headerlink" title="Lob"></a>Lob</h3><p>@Lob指定一个属性作为数据库支持的大对象类型在数据库中存储。使用LobType这个枚举来定义Lob是二进制类型还是字符类型。</p>
<p><del>元数据属性说明（较老的版本）：</del></p>
<ul>
<li><del>fetch： 定义这个字段是 lazy loaded 还是 eagerly fetched。数据类型是FetchType枚举，默认：LAZY（lazy loaded）</del> </li>
<li><del>type： 定义这个字段在数据库中的JDBC数据类型。数据类型是LobType枚举，默认：BLOB</del><ul>
<li><del>LobType.BLOB：二进制大对象，byte[] 或者 Serializable 类型可以指定为 BLOB</del></li>
<li><del>LobType.CLOB：字符型大对象，char[]、Character[]或String类型可以指定为 CLOB</del></li>
</ul>
</li>
</ul>
<p>新版本中该注解中没有任何参数了。下面的代码测试：</p>
<pre><code class="java">@Lob
private byte[] picture; // 默认是立即加载

@Lob
@Basic(fetch = FetchType.LAZY) // 修改成懒加载
private String description;
</code></pre>
<p>PS：Clob、Blob占用内存空间较大，一般配合@Basic(fetch&#x3D;FetchType.LAZY)将其设置为延迟加载</p>
<h3 id="Enumerated"><a href="#Enumerated" class="headerlink" title="Enumerated"></a>Enumerated</h3><p>@Enumerated虽然不常用却很重要，使用此注解映射枚举字段，以String类型或者Interger类型存入数据库</p>
<p>注入数据库的类型有两种：</p>
<ol>
<li>EnumType.ORDINAL：如果当前实体类字段为枚举类会转换成Interger类型存入数据库（默认）</li>
<li>EnumType.STRING：如果当前实体类字段为枚举类会转换成String类型存入数据库</li>
</ol>
<pre><code class="java">// Sex为枚举类
@Column
@Enumerated(EnumType.STRING)
private Sex sex;
</code></pre>
<h3 id="ElementCollection"><a href="#ElementCollection" class="headerlink" title="ElementCollection"></a>ElementCollection</h3><p>@ElementCollection集合映射，请参考：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/K8ori0frTguph18nrcVPAQ">https://mp.weixin.qq.com/s/K8ori0frTguph18nrcVPAQ</a></p>
<h3 id="NoRepositoryBean"><a href="#NoRepositoryBean" class="headerlink" title="NoRepositoryBean"></a>NoRepositoryBean</h3><p><strong>@NoRepositoryBean</strong>：一般用作父类的repository，有这个注解，Spring不会去实例化该repository。</p>
<h3 id="EntityGraph（性能优化注解）"><a href="#EntityGraph（性能优化注解）" class="headerlink" title="EntityGraph（性能优化注解）"></a>EntityGraph（性能优化注解）</h3><ul>
<li>JPA效率优化—@EntityGraph：<a target="_blank" rel="noopener" href="https://juejin.cn/post/6869650227268157454">https://juejin.cn/post/6869650227268157454</a></li>
</ul>
<h2 id="5、审计功能（Spring-Data）"><a href="#5、审计功能（Spring-Data）" class="headerlink" title="5、审计功能（Spring Data）"></a>5、审计功能（Spring Data）</h2><blockquote>
<p>参考文献 &amp; 鸣谢：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_28804275/article/details/84801457">https://blog.csdn.net/qq_28804275/article/details/84801457</a></p>
</blockquote>
<p>@CreatedDate、@CreatedBy、@LastModifiedDate、@LastModifiedBy：表示字段为：创建时间字段（insert自动设置）、创建用户字段（insert自动设置）、最后修改时间字段（update自定设置）、最后修改用户字段（update自定设置）</p>
<p>@CreatedDate、@CreatedBy、@LastModifiedDate、@LastModifiedBy 注解的用法：</p>
<ol>
<li>申明实体类并在头部加注解：@EntityListeners(AuditingEntityListener.class)</li>
<li>在实体类中属性中加上面四种注解：@CreatedDate、@LastModifiedDate、@CreatedBy、@LastModifiedBy</li>
<li>在SpringBoot启动类中加此注解：@EnableJpaAuditing</li>
<li>如上操作默认只能实现@CreatedDate、@LastModifiedDate的自动赋值，@CreatedBy、@LastModifiedBy自定义添加修改用户字段，需要配置转换类实现AuditorAware接口才能使它们生效</li>
</ol>
<p>如下是操作示例：</p>
<p>1、在实体类上加上注解 @EntityListeners(AuditingEntityListener.class)，在相应的字段上添加对应的时间和用户注解 @CreatedDate、@LastModifiedDate、@CreatedBy、@LastModifiedBy（<strong>PS：注意：日期类型可以用 Date 也可以是 Long</strong>）</p>
<pre><code class="java">package com.example.jpa.entity;
import lombok.Data;
import org.springframework.data.annotation.CreatedBy;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.annotation.LastModifiedBy;
import org.springframework.data.annotation.LastModifiedDate;
import org.springframework.data.jpa.domain.support.AuditingEntityListener;
import javax.persistence.*;
import java.io.Serializable;

@Data
@Entity
@Table(name = &quot;sys_user&quot;)
@EntityListeners(AuditingEntityListener.class)
public class User implements Serializable &#123;
    @Id
    private Long id;

    @CreatedDate
    @Column(updatable = false, nullable = false)
    private java.util.Date createTime; // 创建时间

    @LastModifiedDate
    @Column(nullable = false)
    private Long updateTime; // 更新时间

    @CreatedBy
    private String createBy; // 创建人

    @LastModifiedBy
    private String lastModifiedBy; // 最后修改人
&#125;
</code></pre>
<p>2、配置实现AuditorAware接口，以获取用户字段需要插入的信息：</p>
<pre><code class="java">package com.example.jpa.config;
import org.springframework.data.domain.AuditorAware;
import org.springframework.stereotype.Component;
import java.util.Optional;

/**
 * @ClassName: JpaAuditorAware
 * @Description:根据你需要返回的类型修改这个T，比如我需要返回的是字符串，就是String。需要注意的是，类需要加上@Component以便Spring扫描到，否则不起作用。
 */
@Component
public class JpaAuditorAware implements AuditorAware&lt;String&gt; &#123;
    @Override
    public Optional&lt;String&gt; getCurrentAuditor() &#123;
        // SecurityUtils.getCurrentUserId(); 正常项目安装项目逻辑获取用户ID
        String userId = null;
        if (userId != null) &#123;
            return Optional.of(userId);
        &#125; else &#123;
            return Optional.of(&quot;admin_user&quot;);
        &#125;
    &#125;
&#125;
</code></pre>
<p>3、在启动类中添加注解@EnableJpaAuditing，注意如果有多个AuditorAware接口实现类，需要在@EnableJpaAuditing内指定实现类</p>
<pre><code class="java">@SpringBootApplication
@EnableJpaAuditing
public class DemoApplication &#123;
    public static void main(String[] args) &#123;
        SpringApplication.run(DemoApplication.class, args);
    &#125;
&#125;
</code></pre>
<p>4、启动项目和单元测试查看效果</p>
<pre><code class="java">@Test
@Transactional // 在测试类对于事务提交方式默认的是回滚
@Rollback(false) // 取消自动回滚
public void save() &#123;
    User user = new User();
    user.setId(1L);
    User save = userRepository.save(user);
    System.out.println(save);
&#125;
</code></pre>
<p>5、查看输出日志</p>
<pre><code class="verilog">Hibernate: 
    select
        user0_.id as id1_0_0_,
        user0_.create_by as create_b2_0_0_,
        user0_.create_time as create_t3_0_0_,
        user0_.last_modified_by as last_mod4_0_0_,
        user0_.update_time as update_t5_0_0_ 
    from
        sys_user user0_ 
    where
        user0_.id=?
User(id=1, createTime=Sat Feb 05 17:07:15 CST 2022, updateTime=1644052035337, createBy=admin_user, lastModifiedBy=admin_user)
Hibernate: 
    insert 
    into
        sys_user
        (create_by, create_time, last_modified_by, update_time, id) 
    values
        (?, ?, ?, ?, ?)
</code></pre>
<h2 id="6、关联关系注解"><a href="#6、关联关系注解" class="headerlink" title="6、关联关系注解"></a>6、关联关系注解</h2><pre><code>1.配置多表联系注解介绍
@OneToOne（一对一）                  一对一映射
    targetEntityClass：             指定另一方类的字节码
    cascade：                       级联操作
        CascadeType.MERGE           级联更新
        CascadeType.PERSIST         级联保存
        CascadeType.REFRESH         级联刷新
        CascadeType.REMOVE          级联删除
        CascadeType.ALL             级联上述4种操作
    fetch：                         抓取策略
      FetchType.LAZY：              延迟加载（默认）
      FetchType.EAGER：             迫切查询（多表连接查询）
    mappedBy：                      放弃外键维护
    orphanRemoval：                 是否使用孤儿删除

@OneToMany（一对多）
    targetEntityClass：             指定多方类的字节码
    cascade：                       指定要使用的级联操作
    fetch：                         指定是否采用延迟加载
    mappedBy：                      指定从表实体类中引用主表对象的名称
    orphanRemoval：                 是否使用孤儿删除

@ManyToOne（多对一）
    targetEntityClass：             指定一的一方实体类字节码
    cascade：                       指定要使用的级联操作
    fetch：                         指定是否采用延迟加载
    optional：                      关联是否可选。如果设置为false，则必须始终存在非空关系

@ManyToMany（多对多）
    targetEntityClass：             指定另一方类的字节码
    cascade：                       配置级联操作
    fetch：                         配置延迟加载和立即加载
    mappedBy：                      放弃外键维护
    
    
2：配置外键关系的注解
@JoinColumn：用于定义主键字段和外键字段的对应关系。
    name：                          指定外键字段的名称
    referencedColumnName：          指定引用主表的主键字段名称（注意是数据库字段不是实体类属性名）
    unique：                        是否唯一。默认值不唯一
    nullable：                      是否允许为空。默认值允许
    insertable：                    是否允许插入。默认值允许
    updatable：                     是否允许更新。默认值允许
    columnDefinition：              列的定义信息
    table
    foreignKey

@JoinTable（针对中间表的设置）
    name：                          配置中间表的名称
    joinColumns：                   中间表的外键字段关联当前实体类所对应表的主键字段
        @JoinColumn：
            name：                  本类的外键
            referencedColumnName：  本类与外键(表)对应的主键
    inverseJoinColumn：             中间表的外键字段关联对方表的主键字段
        @JoinColumn：               
            name：                  对方类的外键
            referencedColumnName：  对方类与外键(表)对应的主键
            
@OrderBy（也属于关联关系注解）主要用来排序外键列集合对象

3：首先确定多表之间的关系：
    一对一和一对多：
        一的一方称为主表，而多的一方称为从表，外键就要建立在从表上，它们的取值的来源主要来自主键
    多对多：
        这个时候需要建立一个中间表，中间表中最少由2个字段组成，这2个字段作为外键指向2张表的主键又组成了联合主键
</code></pre>
<h2 id="7、生命周期回调方法"><a href="#7、生命周期回调方法" class="headerlink" title="7、生命周期回调方法"></a>7、生命周期回调方法</h2><blockquote>
<ol>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/iteye_6832/article/details/81469467">Java持久性API（JPA）第7讲——实体生命周期及生命周期回调方法_seloba-CSDN博客</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/DCTANT/article/details/115583053">【原创】JPA中@PrePersist和@PreUpdate的用法_DCTANT的博客-CSDN博客_jpa prepersist</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/sunrainamazing/article/details/75041402">@PreUpdate 和@PrePersist_sunrainamazing的博客-CSDN博客_prepersist</a></li>
<li><a target="_blank" rel="noopener" href="http://www.manongjc.com/article/44756.html">JPA @PostPersist 等注解的使用场景和使用方法 - 码农教程 (manongjc.com)</a></li>
</ol>
</blockquote>
<p>我们在使用JPA对数据库进行操作的时候，我们时常会出现数据库字段设置未不能为空，而我们保存的字段为null导致程序报错。这个时候我们就可以使用：@PrePersist、@PostPersist 等注解回调方法来解决问题。该注释可以应用于实体类，映射超类或回调监听器类的方法。</p>
<p>回调方法是附加到实体生命周期事件的用户定义方法，并且在发生这些事件时由JPA自动调用。可以发现有很多类似的注解可以使用：</p>
<ol>
<li>@PrePersist：在新实体持久化之前（添加到EntityManager之前，即：保存操作之前）</li>
<li>@PostPersist：在数据库中存储新实体（在commit或flush，即：保存操作之后）</li>
<li>@PreUpdate：当一个实体被识别为被修改时EntityManager（即：更新数据之前）</li>
<li>@PostUpdate：更新数据库中的实体（在commit或flush，即：更新数据之后）</li>
<li>@PreRemove：在EntityManager中标记要删除的实体时（即：删除数据之前）</li>
<li>@PostRemove：从数据库中删除实体（在commit或flush，即：删除数据之后）</li>
<li>@PostLoad：从数据库中检索实体后（即：查询完数据后）</li>
<li>@EntityListeners：指定外部生命周期事件实现类</li>
</ol>
<blockquote>
<p>在Entity实体类中进行代码测试</p>
</blockquote>
<p>1、创建User实体类Entity，在Entity实体内加回调方法时，回调方法形参可有可无（外部类定义时必须要有）</p>
<pre><code class="java">package entity;
import lombok.Data;
import javax.persistence.*;

@Data
@Entity
@Table(name = &quot;sys_user&quot;)
public class User &#123;
    @Id
    private Long id;
    private String username;
    private String password;

    @PostLoad
    public void postLoad()&#123;
        System.out.println(&quot;PreLoad 生命周期方法被调用！ &quot;);
    &#125;
    @PrePersist
    public void prePersist()&#123;
        System.out.println(&quot;PrePersist 生命周期方法被调用！ &quot;);
    &#125;
    @PreUpdate
    public void preUpdate()&#123;
        System.out.println(&quot;PreUpdate 生命周期方法被调用！ &quot;);
    &#125;
    @PreRemove
    public void preRemove()&#123;
        System.out.println(&quot;PreRemove 生命周期方法被调用！ &quot;);
    &#125;
    @PostPersist
    public void postPersist()&#123;
        System.out.println(&quot;PostPersist 生命周期方法被调用！ &quot;);
    &#125;
    @PostUpdate
    public void postUpdate()&#123;
        System.out.println(&quot;PostUpdate 生命周期方法被调用！ &quot;);
    &#125;
    @PostRemove
    public void postRemove()&#123;
        System.out.println(&quot;PostRemove 生命周期方法被调用！ &quot;);
    &#125;
&#125;
</code></pre>
<p>2、进行CRUD单元测试</p>
<pre><code class="java">import entity.User;
import org.junit.Test;
import javax.persistence.*;

public class TestDemo &#123;

    @Test
    public void testSave() &#123;
        // 1.加载配置文件创建工厂（实体管理器工厂）对象
        EntityManagerFactory factory = Persistence.createEntityManagerFactory(&quot;myJpa&quot;);
        // 2.通过实体管理器工厂获取实体管理器
        EntityManager em = factory.createEntityManager();
        // 3.获取事务对象，开启事务
        EntityTransaction tx = em.getTransaction();

        // 开启事物，保存操作
        tx.begin();
        User user = new User();
        user.setId(1L);
        user.setUsername(&quot;admin&quot;);
        user.setPassword(&quot;password&quot;);
        em.persist(user);
        tx.commit();

        // 查询操作，查询同一个数据需要先清理一级缓存，不然不会发送查询SQL
        em.refresh(user);
        User user_select = em.find(User.class, 1L);

        // 开启事物，修改操作
        tx.begin();
        user_select.setUsername(&quot;root&quot;);
        em.merge(user_select);
        tx.commit();

        // 开启事物，删除操作
        tx.begin();
        em.remove(user_select);
        tx.commit();
        // 6.释放资源
        em.close();
        factory.close();
    &#125;
&#125;
</code></pre>
<p>3、输出日志</p>
<pre><code>PrePersist 生命周期方法被调用！ 
Hibernate: 
    insert 
    into
        sys_user
        (password, username, id) 
    values
        (?, ?, ?)
PostPersist 生命周期方法被调用！ 
Hibernate: 
    select
        user0_.id as id1_0_0_,
        user0_.password as password2_0_0_,
        user0_.username as username3_0_0_ 
    from
        sys_user user0_ 
    where
        user0_.id=?
PreLoad 生命周期方法被调用！ 
PreUpdate 生命周期方法被调用！ 
Hibernate: 
    update
        sys_user 
    set
        password=?,
        username=? 
    where
        id=?
PostUpdate 生命周期方法被调用！ 
PreRemove 生命周期方法被调用！ 
Hibernate: 
    delete 
    from
        sys_user 
    where
        id=?
PostRemove 生命周期方法被调用！ 
</code></pre>
<blockquote>
<p>@EntityListeners：指定外部生命周期事件实现类，在Entity实体类中进行代码测试</p>
</blockquote>
<p>1、创建User实体类（这里为了方便查看，使用static建了一个内部类，实际上登录外部新建一个类）<br>PS：在外部类中使用@PrePersist等注解时，必须要注意：回调方法中要有Object entity参数，不然会报错。</p>
<pre><code class="java">package entity;
import lombok.Data;
import javax.persistence.*;
import java.io.Serializable;

@Data
@Entity
@Table(name = &quot;sys_user&quot;)
@EntityListeners(User.UserListener.class)
public class User implements Serializable &#123;
    @Id
    private Long id;
    private String username;
    private String password;

    public static class UserListener&#123;
        @PostLoad
        public void postLoad(Object user)&#123;
            System.out.println(&quot;PreLoad 生命周期方法被调用！ &quot;);
        &#125;
        @PrePersist
        public void prePersist(Object user)&#123;
            System.out.println(&quot;PrePersist 生命周期方法被调用！ &quot;);
        &#125;
        @PreUpdate
        public void preUpdate(Object user)&#123;
            System.out.println(&quot;PreUpdate 生命周期方法被调用！ &quot;);
        &#125;
        @PreRemove
        public void preRemove(Object user)&#123;
            System.out.println(&quot;PreRemove 生命周期方法被调用！ &quot;);
        &#125;
        @PostPersist
        public void postPersist(Object user)&#123;
            System.out.println(&quot;PostPersist 生命周期方法被调用！ &quot;);
        &#125;
        @PostUpdate
        public void postUpdate(Object user)&#123;
            System.out.println(&quot;PostUpdate 生命周期方法被调用！ &quot;);
        &#125;
        @PostRemove
        public void postRemove(Object user)&#123;
            System.out.println(&quot;PostRemove 生命周期方法被调用！ &quot;);
        &#125;
    &#125;
&#125;
</code></pre>
<p>2、进行CRUD单元测试与输出日志（单元测试可以复用上面的，日志输出与上面也是一摸一样）</p>
<p>两种方式的区别：内部Entity时回调方法形参可有可无，但是外部实现时回调函数形参必须要有</p>
<h2 id="8、Convert-转换器（重点）"><a href="#8、Convert-转换器（重点）" class="headerlink" title="8、Convert 转换器（重点）"></a>8、Convert 转换器（重点）</h2><p>JPA实体属性类型转换器： @Convert + AttributeConverter，通过 @Convert 注解指定自定义转换器，可用于实体属性类型与数据库字段类型之间的相互转换，便于将数据存储至数据库或从数据库读取数据。</p>
<pre><code class="java">@Repeatable(Converts.class)
@Target(&#123;METHOD, FIELD, TYPE&#125;) @Retention(RUNTIME)
public @interface Convert &#123;
    Class converter() default void.class;
    String attributeName() default &quot;&quot;;
    boolean disableConversion() default false; // 用于禁用自动应用或继承的转换器。如果为true，则不应指定converter
&#125;
</code></pre>
<p>自定义转换器详解：</p>
<ol>
<li>实体类的字段添加@Converter注解，标识为转换器</li>
<li>编写一个转换类，实现 <code>AttributeConverter&lt;X, Y&gt;</code> 接口，X 为实体属性类型，Y 为数据库字段类型</li>
<li>转换类实现接口后需要重写 convertToDatabaseColumn()和convertToEntityAttribute()方法</li>
<li>Y convertToDatabaseColumn(X) 的作用：将实体属性X转化为Y存储到数据库中，即插入和更新操作时执行</li>
<li>X convertToEntityAttribute(Y) 的作用：将数据库中的字段Y转化为实体属性X，即查询操作时执行</li>
</ol>
<p>操作示例：</p>
<p>1、创建Convert，需要实现AttributeConverter接口</p>
<pre><code class="java">/**
 * 该转换器主要处理遇到null转为空字符串
 */
@Converter
public class CustConvert implements AttributeConverter&lt;String, String&gt; &#123;
    /**
     * 将实体属性x转化为y存储到数据库中，即插入和更新操作时执行
     */
    @Override
    public String convertToDatabaseColumn(String attribute) &#123;
        return Objects.isNull(attribute) ? &quot;&quot; : attribute;
    &#125;

    /**
     * 将数据库中的字段y转化为实体属性x，即查询操作时执行
     */
    @Override
    public String convertToEntityAttribute(String dbData) &#123;
        return Objects.isNull(dbData) ? &quot;&quot; : dbData;
    &#125;
&#125;
</code></pre>
<p>2、实体类对象使用@Convert指定转换器</p>
<pre><code class="java">@Data
@NoArgsConstructor
@AllArgsConstructor
@Entity
@Table(name = &quot;tb_convert&quot;)
public class CustConvertVO &#123;
    @Id
    private Long id;
    @Convert(converter = CustConvert.class)
    private String username;
&#125;
</code></pre>
<p>3、测试操作</p>
<pre><code class="java">public class JpaConvertTest &#123;
    /**
     * 运行之前，修改hibernate.hbm2ddl.auto=create
     */
    @Test
    public void testSave() &#123;
        // 获取实体管理器工厂
        EntityManagerFactory entityManagerFactory = Persistence.createEntityManagerFactory(&quot;myJpa&quot;);
        // 获取实体管理器
        EntityManager entityManager = entityManagerFactory.createEntityManager();
        // 获取事务
        EntityTransaction transaction = entityManager.getTransaction();
        // 开启事务
        transaction.begin();
        // 创建实体对象并保存
        entityManager.persist(new CustConvertVO(1L,null));
        entityManager.persist(new CustConvertVO(2L, &quot;sam&quot;));
        // 提交事务
        transaction.commit();
        entityManager.clear();
        System.out.println(entityManager.find(CustConvertVO.class, 1L));
        System.out.println(entityManager.find(CustConvertVO.class, 2L));
        // 释放资源
        entityManager.close();
        entityManagerFactory.close();
    &#125;
&#125;
</code></pre>
<p>4、查看日志：</p>
<pre><code class="verilog">Hibernate: 
    insert 
    into
        tb_convert
        (username, id) 
    values
        (?, ?)
Hibernate: 
    insert 
    into
        tb_convert
        (username, id) 
    values
        (?, ?)
Hibernate: 
    select
        custconver0_.id as id1_3_0_,
        custconver0_.username as username2_3_0_ 
    from
        tb_convert custconver0_ 
    where
        custconver0_.id=?
CustConvertVO(id=1, username=)
Hibernate: 
    select
        custconver0_.id as id1_3_0_,
        custconver0_.username as username2_3_0_ 
    from
        tb_convert custconver0_ 
    where
        custconver0_.id=?
CustConvertVO(id=2, username=sam)
</code></pre>
<p>5、@Converter(autoApply &#x3D; true) 的使用</p>
<pre><code class="java">@Converter(autoApply = true)
public class CustConvert implements AttributeConverter&lt;String, String&gt; &#123;&#125;
</code></pre>
<ul>
<li>使用该注解可以无需在Entity对象上显式使用<code>@Convert(converter = CustConvert.class)</code>，注意：旨在同一package下生效。</li>
</ul>
<h2 id="9、Hibernate-Validation-校验注解"><a href="#9、Hibernate-Validation-校验注解" class="headerlink" title="9、Hibernate-Validation 校验注解"></a>9、Hibernate-Validation 校验注解</h2><blockquote>
<p>由于Hibernate-Validation篇幅教程过于多，后面可能会单独教程笔记，暂时请参考如下教程：</p>
<ol>
<li>SpringBoot使用Validation校验参数（CSDN）：<a target="_blank" rel="noopener" href="https://blog.csdn.net/justry_deng/article/details/86571671">https://blog.csdn.net/justry_deng/article/details/86571671</a></li>
<li>SpringBoot使用Hibernate-Validator校验（博客园）：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/mr-yang-localhost/p/7812038.html">https://www.cnblogs.com/mr-yang-localhost/p/7812038.html</a></li>
<li>SpringBoot中在除Controller层 使用Validation的方式（博客园）：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/gxc6/p/11407599.html">https://www.cnblogs.com/gxc6/p/11407599.html</a></li>
<li>Spring Boot 参数校验（CSDN-废物大师兄）：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/cjsblog/p/8946768.html">https://www.cnblogs.com/cjsblog/p/8946768.html</a></li>
<li>使用Spring Validation优雅地校验参数（博客园）：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/zhengxl5566/p/13398546.html">https://www.cnblogs.com/zhengxl5566/p/13398546.html</a></li>
<li>SpringBoot参数校验-Validator（博客园：你在谁的风景里a)：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/sanye613/p/15027448.html">https://www.cnblogs.com/sanye613/p/15027448.html</a></li>
<li>SpringBoot 优雅的参数效验（微信）：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/VOO4QaQF8mWz0l33_G7u-A">https://mp.weixin.qq.com/s/VOO4QaQF8mWz0l33_G7u-A</a></li>
<li>自定义校验注解ConstraintValidator：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/5NtKsFO179pOflNYT1JPwA">https://mp.weixin.qq.com/s/5NtKsFO179pOflNYT1JPwA</a></li>
<li>SpringBoot开发秘籍 - 集成参数校验及高阶技巧：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/tfOlvukARGIDWQDYTmXIgA">https://mp.weixin.qq.com/s/tfOlvukARGIDWQDYTmXIgA</a></li>
</ol>
</blockquote>
<h1 id="Hibernate-JPA-主键策略"><a href="#Hibernate-JPA-主键策略" class="headerlink" title="Hibernate JPA 主键策略"></a>Hibernate JPA 主键策略</h1><p>Hibernate JPA 生成主键主要通过：@Id 和 @GeneratedValue 注解实现，其生成规则由 @GeneratedValue 设定</p>
<p>@GeneratedValue的源码：</p>
<pre><code class="java">@Target(&#123;METHOD,FIELD&#125;)
@Retention(RUNTIME)
public @interface GeneratedValue&#123;  
    GenerationType strategy() default AUTO;  
    String generator() default &quot;&quot;;  
&#125; 
</code></pre>
<p>其中GenerationType枚举属性：</p>
<pre><code class="java">public enum GenerationType&#123;  
    TABLE,  
    SEQUENCE,  
    IDENTITY,  
    AUTO 
&#125;
</code></pre>
<p>JPA 4种主键策略分别为：AUTO、IDENTITY、SEQUENCE、TABLE。剩下都是Hibernate自己的策略，包括我们常用的 native、uuid7n、assigned、sequence</p>
<ol>
<li><p>HAUTO：JPA自动选择合适的策略，是默认选项</p>
</li>
<li><p>IDENTITY：采用数据库 ID自增长的方式来自增主键字段，Oracle 不支持这种方式</p>
</li>
<li><p>SEQUENCE：通过序列产生主键，通过<code>@SequenceGenerator</code>注解指定序列名，MySql 不支持这种方式</p>
</li>
<li><p>TABLE：通过一张数据库表的形式帮助我们完成主键自增</p>
</li>
</ol>
<h2 id="1、AUTO-策略"><a href="#1、AUTO-策略" class="headerlink" title="1、AUTO 策略"></a>1、AUTO 策略</h2><p>默认的配置。如果不指定主键生成策略，默认 AUTO。设置自动主键策略，在保存对象时可以自己设置主键值，也可以不填。示例（任选其一都可以）</p>
<pre><code class="java">// 方式一：如果AUTO可以不用配置@GeneratedValue，默认就是AUTO设置
@Id
private Long Id;

// 方式二：默认配置@GeneratedValue，strategy属性default AUTO
@Id  
@GeneratedValue
private Long Id;

// 方式三：完整配置
@Id
@GeneratedValue(strategy = GenerationType.AUTO)
private Long Id;
</code></pre>
<p><strong>PS 注意（在使用AUTO策略时）：</strong></p>
<ol>
<li>如果是MySQL数据库，一定要将数据库的主键列设置成自增长，否则使用AUTO策略的时候，会报错：<code>org.hibernate.exception.GenericJDBCException: Field &#39;id&#39; doesn&#39;t have a default value</code></li>
<li>如果是Oracle数据库，那么会使用<code>hibernate_sequence</code>，这个名称是固定的，不能更改。</li>
</ol>
<h2 id="2、IDENTITY-策略"><a href="#2、IDENTITY-策略" class="headerlink" title="2、IDENTITY 策略"></a>2、IDENTITY 策略</h2><p>主键则由数据库自动维护，底层数据库必须支持自动增长（对id自增，MySQL支持，Oracle不支持）示例：</p>
<pre><code class="java">@Id  
@GeneratedValue(strategy = GenerationType.IDENTITY)
private Long Id;
</code></pre>
<p>PS：设置了主键自增的话建议在保存对象是就不要设置主键Id值了，会报错。如果想手动设置值可以先注释@GeneratedValue</p>
<h2 id="3、SEQUENCE-策略"><a href="#3、SEQUENCE-策略" class="headerlink" title="3、SEQUENCE 策略"></a>3、SEQUENCE 策略</h2><blockquote>
<p>@SequenceGenerator 注解的使。该策略一般会 @GeneratedValue 与 @SequenceGenerator 注解同时使用</p>
</blockquote>
<p>GenerationType.SEQUENCE：在某些数据库中不支持主键自增长。如<code>Oracle</code> ，其提供了一种叫做<strong>序列（sequence）</strong>的机制生成主键。该策略不足之处正好与<code>TABLE</code>相反，由于只有部分数据库（Oracle、PostgreSQL、DB2）支持序列对象。所以该策略一般不应用其他数据库。该策略一般与 @SequenceGenerator 注解一起使用，该注解指定了生成主键的序列，然后 JPA 会根据注解内容创建一个序列（或使用一个现有序列）如果不指定序列，则使用厂商提供的默认序列生成器：<code>Hibernate</code>默认提供序列名称为<code>HIBERNATE_SEQUENCE</code></p>
<pre><code class="java">@Id  
@GeneratedValue(strategy = GenerationType.SEQUENCE, generator = &quot;id_sequence&quot;)  
@SequenceGenerator(name=&quot;id_sequence&quot;, initialValue=8, allocationSize=1, sequenceName=&quot;ID_SEQUENCE&quot;)  
private int id;
</code></pre>
<p>@SequenceGenerator 注解的定义（用来指定序列的相关信息）</p>
<pre><code class="java">@Repeatable(SequenceGenerators.class)
@Target(&#123;TYPE, METHOD, FIELD&#125;) 
@Retention(RUNTIME)
public @interface SequenceGenerator &#123;
    String name();                    // 序列生成器的名称，会在@GeneratedValue中进行引用
    String sequenceName() default &quot;&quot;; // 表示生成策略用到的数据库序列名称
    String catalog() default &quot;&quot;;      // 指定生成序列号的表的 schema
    String schema() default &quot;&quot;;       // 指定生成序列号的表的 schema
    int initialValue() default 1;     // 主键的初始值，默认为0
    int allocationSize() default 50;  // 主键每次增长值的大小，默认为50
&#125;
</code></pre>
<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>name</td>
<td>该属性是必须设置的属性，序列生成器的名称，会在<code>@GeneratedValue</code>中进行引用</td>
</tr>
<tr>
<td>sequenceName</td>
<td>实体标识所使用的数据库序列号的名称。该属性是可选的，如果我们没有为该属性设置值，OpenJPA 框架将自动创建名为 OPENJPA_SEQUENCE的序列号。如果一个 OpenJPA 容器中管理的多个实体都选择使用序列号机制生成实体标识，而且实体类中都没有指定标识字段的sequenceName属性，那么这些实体将会共享系统提供的默认名为 OPENJPA_SEQUENCE的序列号。这可能引起实体类编号的不连续。我们可以用下面的这个简单例子说明这种情况：假设 OpenJPA 容器中存在两个实体类 Dog 和 Fish，它们的实体标识字段都是数值型，并且都选择使用序列号生成实体标识，但是实体类中并没有提供sequenceName属性值。当我们首先持久化一个 Dog 对象时，它的实体标识将会是 1，紧接着我们持久化一个 Fish 对象，它的实体标识就是 2，依次类推。</td>
</tr>
<tr>
<td>initialValue</td>
<td>该属性设置所使用序列号的起始值。默认为0</td>
</tr>
<tr>
<td>allocationSize</td>
<td>一些数据库的序列化机制允许预先分配序列号，比如 Oracle，这种预先分配机制可以一次性生成多个序列号，然后放在 cache 中，数据库用户获取的序列号是从序列号 cache 中获取的，这样就避免了在每一次数据库用户获取序列号的时候都要重新生成序列号。allocationSize属性设置的就是一次预先分配序列号的数目，默认情况下allocationSize属性的值是 50。</td>
</tr>
<tr>
<td>schema</td>
<td>该属性设置的是生成序列号的表的 schema。该属性并不是必须设置的属性，如果开发者没有为该属性设置值，OpenJPA 容器将会默认使用当前数据库用户对应的 schema。</td>
</tr>
<tr>
<td>catalog</td>
<td>该属性设置的是生成序列号的表的 catalog。该属性并不是必须设置的属性，如果开发者没有为该属性设置值，OpenJPA 容器将会使用默认当前数据库用户对应的 catalog。</td>
</tr>
</tbody></table>
<p><strong>PS</strong>：如果底层数据库不执行序列，会报错：<code>org.hibernate.MappingException: org.hibernate.dialect.MySQLDialect does not support sequences</code></p>
<blockquote>
<p>SQL创建序列：</p>
<pre><code class="sql">CREATE SEQUENCE seqTest
INCREMENT BY 1 -- 每次加几个
START WITH 1   -- 从1开始计数
NOMAXvalue     -- 不设置最大值
NOCYCLE        -- 一直累加，不循环
CACHE 10;      -- 设置缓存cache个序列，如果系统down掉了或者其它情况将会导致序列不连续，也可以设置为：NOCACHE


create sequence s_config_para
  maxvalue 4294967295 -- 设置最大值为4294967295
  cycle; -- 设置cycle属性，当达到最大值时，不是从start with设置的值开始循环。而是从1开始循环
</code></pre>
<p>SQL创建序列链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/jiejie5945/article/details/44198283">https://blog.csdn.net/jiejie5945/article/details/44198283</a></p>
</blockquote>
<h2 id="4、TABLE-策略"><a href="#4、TABLE-策略" class="headerlink" title="4、TABLE 策略"></a>4、TABLE 策略</h2><p>主要使用 @TableGenerator 注解，GenerationType.TABLE ：使用一张特殊的数据库表，保存插入记录的时，需要的主键值。</p>
<p>有时候为了不依赖于数据库的具体实现，在不同数据库之间更好的移植，可以在数据库中新建序列表来生成主键，序列表一般包含两个字段：第一个字段引用不同的关系表（表名），第二个字段是该关系表的最大序号。这样，只需要一张序列就可以用于多张表的主键生成。 </p>
<p>@TableGenerator 注解的定义</p>
<pre><code class="java">@Target(&#123;TYPE, METHOD, FIELD&#125;) 
@Retention(RUNTIME)
public @interface TableGenerator &#123;
    String name();
    String table() default &quot;&quot;;
    String catalog() default &quot;&quot;;
    String schema() default &quot;&quot;;
    String pkColumnName() default &quot;&quot;;
    String valueColumnName() default &quot;&quot;;
    String pkColumnValue() default &quot;&quot;;
    int initialValue() default 0;
    int allocationSize() default 50;
    UniqueConstraint[] uniqueConstraints() default &#123;&#125;;
&#125;
</code></pre>
<p>其中属性说明：</p>
<table>
<thead>
<tr>
<th>属性名</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>name</td>
<td>对应GeneratedValue的generator属性值。通过俩者将其互相关联</td>
</tr>
<tr>
<td>table</td>
<td>对应第三方主键生成表名[代表JPA将使用哪个第三方表来主键值得计算]</td>
</tr>
<tr>
<td>schema</td>
<td>指定生成序列号的表的 schema。如没设置，OpenJPA 容器将会默认使用当前数据库用户对应的 schema</td>
</tr>
<tr>
<td>catalog</td>
<td>指定生成序列号的表的 catalog。如没设值，OpenJPA 容器将会使用默认当前数据库用户对应的 catalog</td>
</tr>
<tr>
<td>pkColumnName</td>
<td>指定第三方表中对应的某个列名</td>
</tr>
<tr>
<td>valueColumnName</td>
<td>指定生成的列名[对应第三方表的另外一个列值</td>
</tr>
<tr>
<td>pkColumnValue</td>
<td>指定第三方表中对应的某个列的值，某个列指 pkColumnName属性中的指定的列名</td>
</tr>
<tr>
<td>initialValue</td>
<td>默认情况下，JPA 持续性提供程序将所有主键值的起始值设置为 0</td>
</tr>
<tr>
<td>allocationSize</td>
<td>分配大小，指主键增长步长。这里指定为1，则意思是主键每次增长为1</td>
</tr>
<tr>
<td>UniqueConstraint</td>
<td>默认值：JPA 持续性提供程序假设主键生成器表中任何列均没有唯一约束。若设置需uniqueContraints配合</td>
</tr>
</tbody></table>
<p>1、先创建保存主键的数据表，并插入初始数据（与JPA方式对比，使用一种即可）</p>
<pre><code class="sql">-- 创建表，插入一条信息（也可以不插入，使用JPA建表和初始化数据）
drop table if exists tb_generator;
create table tb_generator (
    pk_name varchar(50) not null,
    pk_value int(50) not null
) engine = innodb;
INSERT INTO tb_generator (pk_name, pk_value) VALUES (&#39;table_id&#39;, 10);

-- tb_generator表初始数据
mysql&gt; select * from tb_generator;
+----------+----------+
| pk_name  | pk_value |
+----------+----------+
| table_id |       10 |
+----------+----------+
1 row in set (0.04 sec)
</code></pre>
<p>注意：这个表可以给无数的表作为主键表，现在只插入了一数据，这一条数据只是为一个表做主键而已。需要为其他表作为主键表著需要插入一行数据即可。需要保证 table、pkColumnName、valueColumnName 三个属性值相同就可以了</p>
<p>2、使用 GenerationType.TABLE 主键策略：</p>
<pre><code class="java">@Data
@Entity
public class TablePrimarykey &#123;
    @Id
    @TableGenerator(
            name = &quot;id_generator&quot;,        // 定义一个主键生成器的名称，GeneratedValue会引用
            table = &quot;tb_generator&quot;,       // 表示表生成策略所持久化的表名（如果DB没有tb_generator表会自动创建该表，那么可以设置initialValue）
            pkColumnName = &quot;pk_name&quot;,     // 在持久化表中该主键生成策略所对应键值的名称(列)
            pkColumnValue = &quot;table_id&quot;,   // 主键操作的内容字段(pkColumnName列的值)
            valueColumnName = &quot;pk_value&quot;, // 表示在持久化表中该生成策略所对应的主键(列)
            allocationSize = 10)          // 每次增长的步长
    @GeneratedValue(strategy = GenerationType.TABLE, generator = &quot;id_generator&quot;)
    private Long id;
    private String name;
&#125;
</code></pre>
<p>3、测试代码：</p>
<pre><code class="java">public class TablePrimaryKeyTest &#123;

    /**
     * 运行之前，修改hibernate.hbm2ddl.auto=update
     * 多执行几次然后查看数据库中的数据，
     * 如果是刚创建表那么第一条数据是不会按照规则生成，从第二条数据开始查看
     */
    @Test
    public void testTableId()&#123;
        EntityManager entityManager = JpaUtils.getEntityManager();
        entityManager.getTransaction().begin();
        entityManager.persist(new TablePrimaryKey());// 保存数据，按照TABLE主键策略生成主键
        entityManager.getTransaction().commit();
        entityManager.close();
    &#125;
&#125;
</code></pre>
<p>4、查看日志：</p>
<pre><code class="verilog">Hibernate: 
    select
        tbl.pk_value 
    from
        tb_generator tbl 
    where
        tbl.pk_name=? for update
            
Hibernate: 
    update
        tb_generator 
    set
        pk_value=?  
    where
        pk_value=? 
        and pk_name=?
Hibernate: 
    insert 
    into
        tb_primary_key
        (name, id) 
    values
        (?, ?)
</code></pre>
<p>5、查看数据库表信息：</p>
<pre><code class="sql">mysql&gt; use hibernate_jpa;
Database changed
mysql&gt; select * from tb_generator;
+----+----------+----------+
| id | pk_name  | pk_value |
+----+----------+----------+
|  1 | table_id |       40 |
+----+----------+----------+
1 row in set (0.01 sec)

mysql&gt; select * from tb_primary_key;
+----+------+
| id | name |
+----+------+
|  2 | NULL |
| 12 | NULL |
| 22 | NULL |
+----+------+
3 rows in set (0.02 sec)
</code></pre>
<h2 id="5、自定义主键生成器"><a href="#5、自定义主键生成器" class="headerlink" title="5、自定义主键生成器"></a>5、自定义主键生成器</h2><p>@GenericGenerator 注解（是 Hibernate 自定义主键生成器，可以直接引用内置主键策略） 该策略一般会 @GeneratedValue 和 @GenericGenerator 同时使用，并且@GeneratedValue注解中的”generator”属性要与@GenericGenerator注解中name属性一致，strategy属性表示hibernate的主键生成策略。<br>（换种方式解释：Hibernate 同时对 JPA 进行了扩展，在 @GeneratedValue 中指定 generator，然后用 @GenericGenerator 指定策略来维护主键）</p>
<pre><code class="java">@Id
@GeneratedValue(generator = &quot;myGenerator&quot;) // 使用了generator默认可以不指定strategy
@GenericGenerator(name = &quot;myGenerator&quot;, strategy = &quot;uuid&quot;) // 使用uuid的生成策略
private String Id;
</code></pre>
<p>@GenericGenerator 注解的定义（用来指定序列的相关信息）</p>
<pre><code class="java">@Target(&#123;ElementType.PACKAGE, ElementType.TYPE, ElementType.METHOD, ElementType.FIELD&#125;)
@Retention(RetentionPolicy.RUNTIME)
@Repeatable(GenericGenerators.class)
public @interface GenericGenerator &#123;
    String name(); // @GeneratedValue 中 generator 的值
    String strategy(); // 生成器名称
    Parameter[] parameters() default &#123;&#125;; // 生成器的参数
&#125;
</code></pre>
<ol>
<li>name：指定生成器名称。会在@GeneratedValue中进行引用</li>
<li>strategy：指定具体生成器的类名</li>
<li>parameters：得到strategy指定的具体生成器所用到的参数（可选参数）</li>
</ol>
<hr>
<p><strong>通过查看 Hibernate 的源码查看内置主键策略，可以发现<code>strategy</code> 有14个内置主键策略选项：</strong></p>
<pre><code class="java">    public DefaultIdentifierGeneratorFactory() &#123;
        this.register(&quot;uuid2&quot;, UUIDGenerator.class);
        this.register(&quot;guid&quot;, GUIDGenerator.class);
        this.register(&quot;uuid&quot;, UUIDHexGenerator.class);
        this.register(&quot;uuid.hex&quot;, UUIDHexGenerator.class);
        this.register(&quot;assigned&quot;, Assigned.class);
        this.register(&quot;identity&quot;, IdentityGenerator.class);
        this.register(&quot;select&quot;, SelectGenerator.class);
        this.register(&quot;sequence&quot;, SequenceStyleGenerator.class);
        this.register(&quot;seqhilo&quot;, SequenceHiLoGenerator.class);
        this.register(&quot;increment&quot;, IncrementGenerator.class);
        this.register(&quot;foreign&quot;, ForeignGenerator.class);
        this.register(&quot;sequence-identity&quot;, SequenceIdentityGenerator.class);
        this.register(&quot;enhanced-sequence&quot;, SequenceStyleGenerator.class);
        this.register(&quot;enhanced-table&quot;, TableGenerator.class);
    &#125;
</code></pre>
<p>列出几个 Hibernate 比较常用的生成策略：</p>
<ol>
<li>native：对于Oracle采用Sequence方式，对于MySQL和SQL Server采用identity（主键自增），native就是将主键的生成交由数据库完成，hibernate不管</li>
<li>uuid：采用128位的uuid算法生成主键，uuid被编码为一个32位16进制数字的字符串。占用空间大（字符串类型）</li>
<li>assigned：在插入数据的时候主键由程序处理（即程序员手动指定）这是元素没有指定时的默认生成策略。等同AUTO</li>
<li>identity：使用SQL Server和MySQL自增字段，Oracle不支持主键自增，要设定Sequence（MySQL 和 SQL Server中很常用） 等于 JPA 的 INDENTITY</li>
<li>increment：插入数据的时候 Hibernate 会给主键添加一个自增的主键，但是一个 Hibernate 实例就维护一个计数器，所以多实例运行时不能使用这个</li>
</ol>
<pre><code class="java">@Id
@GeneratedValue(generator = &quot;IDGenerator&quot;)
@GenericGenerator(name = &quot;IDGenerator&quot;, strategy = &quot;identity&quot;)
// 等价于JPA中的IDENTITY策略
@Id
@GeneratedValue(strategy=GenerationType.IDENTITY)

@Id
@GeneratedValue(generator=&quot;paymentableGenerator&quot;)
@GenericGenerator(name=&quot;paymentableGenerator&quot;, strategy=&quot;assigned&quot;)
// 等价于JPA中的AUTO策略
@Id  
@GeneratedValue(GenerationType.AUTO) 
</code></pre>
<pre><code class="java">// uuid策略的使用，用在Oracle数据库的主键生成上，它会根据内部程序计算出32位长度的唯一id，此时保存对象可以不设置id字段的值
// 如果不用如下2个注解生成，也可以用代码手动生成UUID：`xx.setId(UUID.randomUUID().toString());
@GeneratedValue(generator = &quot;systemUUID&quot;)
@GenericGenerator(name = &quot;systemUUID&quot;, strategy = &quot;uuid&quot;)
@Id
private String id; // 注意类型必须为String
</code></pre>
<hr>
<blockquote>
<p>Hibernate—14个 内置主键策略详解：</p>
</blockquote>
<details>
    <summary>内置主键策略</summary>

<ul>
<li><p>uuid2：<br>IdentifierGenerator 的实现类是 UUIDGenerator，具体由 UUIDGenerationStrategy 策略负责生成，它有两个实现 StandardRandomStrategy 和 CustomVersionOneStrategy，他们都是使用j ava.util.UUID 的 api 生成主键的。<br>StandardRandomStrategy 最终由 UUID.randomUUID(); 生成；<br>CustomVersionOneStrategy 则采用版本号与位运算通过构造函数 new UUID(mostSignificantBits,leastSignificantBits); 生成。<br><strong>特点是：不需要和数据库交互，可根据RFC4122定义的5中变量控制具体的生成策略（因为符合RFC4122定义，所以避免了警告信息）</strong></p>
</li>
<li><p>guid：<br>IdentifierGenerator 的实现类是 GUIDGenerator，通过 session.getFactory().getDialect().getSelectGUIDString(); 获得各个数据库中的标示字符串.<br>MySQL 用 select uuid();<br>Oracle 用 return “select rawtohex(sys_guid()) from dual”;<br><strong>特点是：需要和数据库进行一次查询才能生成。数据库全局唯一</strong></p>
</li>
<li><p>uuid，uuid.hex：<br>uuid和uuid.hex 两个一个东西。IdentifierGenerator的实现类是UUIDHexGenerator，通过：StringBuffer(36).append(format(getIP())).append(sep).append(format(getJVM())).append(sep).append(format(getHiTime())).append(sep).append(format(getLoTime())).append(sep).append(format(getCount()))生成。<br><strong>特点：不需要和数据库交互，全网唯一</strong></p>
</li>
<li><p>hilo：<br>IdentifierGenerator 的实现类 TableHiLoGenerator，逻辑较为复杂，通过高低位酸腐生成，但是需要给定表和列作为高值的源。加上本地的地位计算所得。<br><strong>特点：需要和数据库交互，全数据库唯一，与guid不同的是，在标识符的单个源必须被多个插入访问时可以避免拥堵。</strong></p>
</li>
<li><p>assigned：<br>IdentifierGenerator 的实现类 Assigned，没有生成逻辑，如果为空就抛出异常。<br><strong>特点：不需要和数据库交互，自己管理主键生成，显示的指定id</strong></p>
</li>
<li><p>identity：<br>IdentityGenerator 并没有直接实现 IdentifierGenerator，而是扩展了AbstractPostInsertGenerator，并实现PostInsertIdentifierGenerator。<br>而 PostInsertIdentifierGenerator 实现了 IdentifierGenerator，通过IdentifierGeneratorHelper类生成。<br>这个比较特殊，它返回是个常量 “POST_INSERT_INDICATOR”，指在数据库插入后时生成，然后返回数据库生成的id；<br>还有个常量 “SHORT_CIRCUIT_INDICATOR”，是用外键ForeignGenerator时使用的。<br><strong>特点：需要和数据库交互，数据插入后返回（反查）id，同一列唯一</strong></p>
</li>
<li><p>select：<br>SelectGenerator 扩展了 AbstractPostInsertGenerator 实现了 Configurable 接口，而 AbstractPostInsertGenerator 实现了 PostInsertIdentifierGenerator。所以具有和identity类似的行为，有数据库触发器生成。<br><strong>特点：需要和数据库交互</strong></p>
</li>
<li><p>sequence：<br>SequenceGenerator 实现了 PersistentIdentifierGenerator 接口，和 Configurable 接口。<br>PersistentIdentifierGenerator 接口扩展 IdentifierGenerator 接口，通过不同的数据库，获取不同的取值语句 dialect.getSequenceNextValString(sequenceName); 然后进行查询，缓存到IntegralDataTypeHolder中，通过 generateHolder( session ).makeValue(); 获得。<br><strong>特点：需要和数据库交互（但不是每次都是）。sequence唯一</strong></p>
</li>
<li><p>seqhilo：<br>seqhilo，扩展了 SequenceGenerator， 处理逻辑和 hilo 相同，值不过是使用一个具名的数据库序列来生成高值部分。<br><strong>特点：需要和数据库交互，全数据库唯一，与guid不同的是，在标识符的单个源必须被多个插入访问时可以避免拥堵</strong></p>
</li>
<li><p>increment：<br>IdentifierGenerator 的实现类 IncrementGenerator，并实现了 Configurable 接口。数据库启动时查询表的最大主键列支，并通过 IntegralDataTypeHolder 缓存。插入一条，它自加一。<br><strong>特点：仅需要首次访问数据库</strong></p>
</li>
<li><p>foreign：<br>IdentifierGenerator 的实现类 ForeignGenerator，通过给定的 entityName 和 propertyName 查询获得值。<br><strong>特点：需要和数据库访问</strong></p>
</li>
</ul>
</details>




<h2 id="6、主键对数据库的支持"><a href="#6、主键对数据库的支持" class="headerlink" title="6、主键对数据库的支持"></a>6、主键对数据库的支持</h2><table>
<thead>
<tr>
<th>数据库类型</th>
<th>GenerationType.AUTO</th>
<th>GenerationType.IDENTITY</th>
<th>GenerationType.SEQUENCE</th>
<th>GenerationType.TABLE</th>
</tr>
</thead>
<tbody><tr>
<td>MySQL</td>
<td>支持</td>
<td>支持</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>Oracle</td>
<td>支持</td>
<td>不支持</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>PostgreSQL</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>Kingbase</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
</tr>
</tbody></table>
<h2 id="7、主键UUID与数字对比"><a href="#7、主键UUID与数字对比" class="headerlink" title="7、主键UUID与数字对比"></a>7、主键UUID与数字对比</h2><p>自增主键：</p>
<ul>
<li>优点<ol>
<li>数据存储空间小</li>
<li>查询效率高</li>
</ol>
</li>
<li>缺点：<ol>
<li>如果数据量过大，会超出自增长的值范围</li>
<li>分布式存储的表操作，尤其是在合并的时候操作复杂</li>
<li>安全性低,因为是有规律的，如果恶意扒取用户信息会很容易,如果是单据编号使用，竞争对手会容易查询出货量</li>
</ol>
</li>
</ul>
<p>UUID主键：</p>
<ul>
<li>优点：<ol>
<li>出现重复的机会少</li>
<li>适合大量数据的插入和更新操作，尤其是在高并发和分布式环境下</li>
<li>安全性较高</li>
</ol>
</li>
<li>缺点：<ol>
<li>存储空间大（16 byte）,因此它将会占用更多的磁盘空间, MySQL官方有明确的建议主键要尽量越短越好，36个字符长度的UUID不符合要求</li>
<li>性能降低，对MySQL索引不利：如果作为数据库主键，在InnoDB引擎下，UUID的无序性可能会引起数据位置频繁变动，严重影响性能</li>
</ol>
</li>
</ul>
<p>适用场景：</p>
<ol>
<li>项目是单机版的，并且数据量比较大（百万级）时，用自增长的,此时最好能考虑下安全性,做些安全措施</li>
<li>项目是单机版的，并且数据量没那么大，对速度和存储要求不高时，用UUID</li>
<li>项目是分布式的，那么首选UUID，分布式一般对速度和存储要求不高</li>
<li>项目是分布式的，并且数据量达到千万级别可更高时，对速度和存储有要求时,可以用自增长</li>
</ol>
<h2 id="8、参考文献-鸣谢"><a href="#8、参考文献-鸣谢" class="headerlink" title="8、参考文献 &amp; 鸣谢"></a>8、参考文献 &amp; 鸣谢</h2><ol>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_38446891/article/details/109813272">https://blog.csdn.net/weixin_38446891/article/details/109813272</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/badtree/articles/10189769.html">https://www.cnblogs.com/badtree/articles/10189769.html</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_37878255/article/details/102628997">https://blog.csdn.net/weixin_37878255/article/details/102628997</a></li>
</ol>
<h1 id="Hibernate-JPA-缓存配置"><a href="#Hibernate-JPA-缓存配置" class="headerlink" title="Hibernate JPA 缓存配置"></a>Hibernate JPA 缓存配置</h1><h2 id="1、一级缓存"><a href="#1、一级缓存" class="headerlink" title="1、一级缓存"></a>1、一级缓存</h2><p>一级缓存指的是 EntityManager 级的缓存，对于这样的缓存几乎是一直存在的，也就是说只要用户进行JPA的操作，那么就永远都会存在有一级缓存</p>
<blockquote>
<p>新建数据库视图类和初始化数据</p>
</blockquote>
<pre><code class="java">@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
@Entity
@Table(name = &quot;tb_cache&quot;)
public class CacheEntity &#123;
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long Id;
    private String name;
    private int age;
&#125;
</code></pre>
<pre><code class="java">   @Before
    public void initData()&#123;
        EntityManager entityManager = JpaUtils.getEntityManager();
        entityManager.getTransaction().begin();
        Arrays.asList(
                CacheEntity.builder().name(&quot;Sam&quot;).age(18).build(),
                CacheEntity.builder().name(&quot;Mike&quot;).age(58).build(),
                CacheEntity.builder().name(&quot;Hom&quot;).age(48).build(),
                CacheEntity.builder().name(&quot;Nick&quot;).age(28).build(),
                CacheEntity.builder().name(&quot;Kath&quot;).age(28).build()
        ).forEach(cacheEntity -&gt; entityManager.persist(cacheEntity));
        entityManager.getTransaction().commit();
    &#125;
</code></pre>
<p>1、使用 fnd() 执行两次查询，并且查询的ID信息都一样：</p>
<pre><code class="java">    // 运行之前，修改hibernate.hbm2ddl.auto=create
    @Test
    public void testFindCache()&#123;
        EntityManager entityManager = JpaUtils.getEntityManager();

        CacheEntity cacheEntity1 = entityManager.find(CacheEntity.class, 1L);
        System.err.println(cacheEntity1);

        System.err.println(&quot;--------------华丽的分割线-------------------&quot;);

        CacheEntity cacheEntity2 = entityManager.find(CacheEntity.class, 1L);
        System.err.println(cacheEntity2);
    &#125;
</code></pre>
<p>查看日志：</p>
<pre><code class="verilog">Hibernate: 
    select
        cacheentit0_.Id as Id1_2_0_,
        cacheentit0_.age as age2_2_0_,
        cacheentit0_.name as name3_2_0_ 
    from
        tb_cache cacheentit0_ 
    where
        cacheentit0_.Id=?
CacheEntity(Id=1, name=Sam, age=18)
--------------华丽的分割线-------------------
CacheEntity(Id=1, name=Sam, age=18) // 可以发现第二次查询的时候没有发送SQL语句
</code></pre>
<p>PS：可以发现这个时候真正执行的是一次数据库查询，也就是说在同一个<code>EntityManager</code>对象操作之中如果使用 find() 查询，那么同一条数据默认情况下只会査询一次，查询完成之后会将这个数据进行缓存。</p>
<p>2、如果说现在在查询过程之中发生了内容的变更呢？如：第一次查询出来的对象现在要求进行一些修改。</p>
<pre><code class="java">    // 运行之前，修改hibernate.hbm2ddl.auto=create
    @Test
    public void testFindCache2()&#123;
        EntityManager entityManager = JpaUtils.getEntityManager();

        CacheEntity cacheEntity1 = entityManager.find(CacheEntity.class, 1L);
        cacheEntity1.setName(&quot;SamXX&quot;); // 第一次查询的数据发生改变
        System.err.println(cacheEntity1);

        System.err.println(&quot;--------------华丽的分割线-------------------&quot;);

        CacheEntity cacheEntity2 = entityManager.find(CacheEntity.class, 1L);
        System.err.println(cacheEntity2);
    &#125;
</code></pre>
<p>查看日志：</p>
<pre><code class="verilog">Hibernate: 
    select
        cacheentit0_.Id as Id1_2_0_,
        cacheentit0_.age as age2_2_0_,
        cacheentit0_.name as name3_2_0_ 
    from
        tb_cache cacheentit0_ 
    where
        cacheentit0_.Id=?
CacheEntity(Id=1, name=SamXX, age=18)
--------------华丽的分割线-------------------
CacheEntity(Id=1, name=SamXX, age=18) // 可以发现第二次查询的时候可以发送SQL语句
</code></pre>
<p>PS：第一个数据读取进来之后由于发生了改变，肯定和原始数据库的内容不一样了，那么此时通过第二次查询获得的结果可以发现，依然只是查询了一次，并且在ID不改变的情况下，会发生相同ID的查询依然引用已有的缓存对象.</p>
<p>3、如果现在想内容进行更新，需要采用刷新的模式完成。<code>entityManager.refresh(object)</code></p>
<pre><code class="java">    // 运行之前，修改hibernate.hbm2ddl.auto=create
    @Test
    public void testFindRefresh()&#123;
        EntityManager entityManager = JpaUtils.getEntityManager();

        CacheEntity cacheEntity1 = entityManager.find(CacheEntity.class, 1L);
        cacheEntity1.setName(&quot;SamXX&quot;); // 第一次查询的数据发生改变
        System.err.println(cacheEntity1);
        entityManager.refresh(cacheEntity1); // 重新加载，会再次发送SQL

        System.err.println(&quot;--------------华丽的分割线-------------------&quot;);

        CacheEntity cacheEntity2 = entityManager.find(CacheEntity.class, 1L);
        System.err.println(cacheEntity2);
    &#125;
</code></pre>
<p>查看日志：</p>
<pre><code class="verilog">Hibernate: 
    select
        cacheentit0_.Id as Id1_2_0_,
        cacheentit0_.age as age2_2_0_,
        cacheentit0_.name as name3_2_0_ 
    from
        tb_cache cacheentit0_ 
    where
        cacheentit0_.Id=?
CacheEntity(Id=1, name=SamXX, age=18)
Hibernate: 
    select
        cacheentit0_.Id as Id1_2_0_,
        cacheentit0_.age as age2_2_0_,
        cacheentit0_.name as name3_2_0_ 
    from
        tb_cache cacheentit0_ 
    where
        cacheentit0_.Id=?
--------------华丽的分割线-------------------
CacheEntity(Id=1, name=Sam, age=18)
</code></pre>
<p>此时同样操作发现重复查询了两次，主要是因为使用了<code>refresh()</code>明确表示该缓存对象需要重新加载。在<code>JPA</code>中有一个非常重要的概念：<code>JPA</code> 的对象状态，在<code>JPA</code> 里面一共有四种对象状态.</p>
<h2 id="2、对象状态（生命周期）"><a href="#2、对象状态（生命周期）" class="headerlink" title="2、对象状态（生命周期）"></a>2、对象状态（生命周期）</h2><blockquote>
<p>参考文献 &amp; 鸣谢：JPA实体的四种状态：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/636954880af8">https://www.jianshu.com/p/636954880af8</a></p>
</blockquote>
<p>JPA 对象四种状态（老版中只有三种，没有移除态）：</p>
<ol>
<li>瞬时态对象（瞬时态：New or Transient）：尚未有id，还未和 Persistence Context 建立关联的对象</li>
<li>持久态对象（持久态：Managed or Persistent）：有id值，与 Persistence Context 建立了关联的对象</li>
<li>游离态对象（游离态：Datached）：有id值，没有和 Persistence Context 建立关联的对象</li>
<li>删除的对象（移除态：Removed）：有id值，尚未和 Persistence Context 有关联，但是已经准备好从数据库中删除（确切的说在事物提交前还与 Persistence Context 有关联，事物提交后就与 Persistence Context 没有关联了）</li>
</ol>
<hr>
<ol>
<li>临时状态&#x2F;瞬时状态（transient）：没有与 entityManager 发生关系，没有被持久化，不处于 entityManager 中的对象</li>
<li>持久化状态&#x2F;托管状态（persistent）：与 entityManager 发生关系，已经被持久化，加入到 entityManager 的一级缓存中的对象</li>
<li>删除状态（removed）：调用了 entityManager.remove(obj)，对象有关联的ID，并且在 entityManager 管理下。调用remove方法后已经计划删除，事物提交后才会被真正从数据库删除</li>
<li>游离状态（detached）：脱管状态：对象和 entityManager 解除关系</li>
</ol>
<pre><code>                                            持久状态     
                                            |     ⬆     
                                         find() flush() 
                                            ⬇     |     
New POJO() ----&gt; 瞬时状态 ----persist()----&gt; 托管状态 ----remove()----&gt; 销毁状态
                                            |     ⬆ 
                                        事物提交 meger/refresh
                                            ⬇     |
                                            游离状态
</code></pre>
<img src="https://upload-images.jianshu.io/upload_images/448235-c149bf356c0aaf35.png" alt="img"  />

<p>1、示例说明：</p>
<pre><code class="java">    // 运行之前，修改hibernate.hbm2ddl.auto=create
    @Test
    public void testFindAdd()&#123;
        CacheEntity cacheEntity = new CacheEntity(); // 临时状态
        cacheEntity.setName(&quot;lsx&quot;);
        cacheEntity.setAge(16);
        EntityManager entityManager = JpaUtils.getEntityManager();
        entityManager.getTransaction().begin();
        entityManager.persist(cacheEntity); // 持久状态
        entityManager.remove(cacheEntity); // 删除状态
        entityManager.getTransaction().commit();// 提交更新事务
        entityManager.close();
        System.err.println(cacheEntity);// 游离状态
    &#125;
</code></pre>
<p>2、观察在持久态下的数据更新（重点）</p>
<pre><code class="java">    // 运行之前，修改hibernate.hbm2ddl.auto=create
    @Test
    public void testFindEdit()&#123;
        EntityManager entityManager = JpaUtils.getEntityManager();
        // 持久态
        CacheEntity cacheEntity = entityManager.find(CacheEntity.class, 1L);
        entityManager.getTransaction().begin(); // 开启事务
        cacheEntity.setName(&quot;SamXX&quot;); // 持久化数据发生改变
        entityManager.getTransaction().commit(); // 提交更新事务（发现我们并没有提交更新操作）
        entityManager.close();
    &#125;
</code></pre>
<p>查看日志：</p>
<pre><code class="verilog">Hibernate: // entityManager.find(CacheEntity.class, 1L);
    select
        cacheentit0_.Id as Id1_2_0_,
        cacheentit0_.age as age2_2_0_,
        cacheentit0_.name as name3_2_0_ 
    from
        tb_cache cacheentit0_ 
    where
        cacheentit0_.Id=?
Hibernate: // 更新了持久态中的属性内容，并且提交了事务
    update
        tb_cache 
    set
        age=?,
        name=? 
    where
        Id=?
</code></pre>
<pre><code class="sql">-- 然后查看数据库这条数据：
mysql&gt; select * from tb_cache where id = 1;
+----+-----+-------+
| Id | age | name  |
+----+-----+-------+
|  1 |  18 | SamXX |
+----+-----+-------+
1 row in set (0.02 sec)
</code></pre>
<p><strong>PS：发现这条数据name发生了改变，但是我们并没有执行更新方法，可以得出结论：持久态话下的数据发生改变的话，只要在事务中并且提交了事务更新，那么默认就相当于执行了更新数据库操作</strong></p>
<p>3、一个新的对象默认情况下属于瞬时态，瞬时态也可以持久化</p>
<pre><code class="java">    // 运行之前，修改hibernate.hbm2ddl.auto=create
    @Test
    public void testFindAdd2()&#123;
        CacheEntity cacheEntity = new CacheEntity(); // 临时状态
        cacheEntity.setName(&quot;lsx&quot;);
        cacheEntity.setAge(16);

        EntityManager entityManager = JpaUtils.getEntityManager();
        entityManager.getTransaction().begin();// 开启事务
        entityManager.persist(cacheEntity);// 数据持久化，自动可以获取ID
        entityManager.getTransaction().commit();// 提交更新事务
        System.err.println(&quot;-----新增数据的ID是：&quot; + cacheEntity.getId());

        // 将刚刚保存对象信息根据ID查询出来
        CacheEntity selectCacheEntity = entityManager.find(CacheEntity.class, cacheEntity.getId());
        System.err.println(selectCacheEntity);
        entityManager.close();
    &#125;
</code></pre>
<p>查看日志：</p>
<pre><code class="verilog">Hibernate: 
    insert 
    into
        tb_cache
        (age, name) 
    values
        (?, ?)
-----新增数据的ID是：6
CacheEntity(Id=6, name=lsx, age=16) // 可以发现查询数据没有发送SQL，而是从缓存中获取
</code></pre>
<p><strong>PS：由于现在使用了<code>persisit()</code>方法将瞬时态对象变为了持久态，所以这个对象就会被缓存起来，那么再执行一次查询的时候就不会重复发出查询命令，而是直接使用缓存中的数据.</strong></p>
<p>4、如果每新增一个数据都被缓存起来，当批量新增时，缓存所占用的空间就会出现严重的不足。最好的做法是进行：<strong>强制性的保存以及清空</strong></p>
<pre><code class="java">    // 运行之前，修改hibernate.hbm2ddl.auto=create
    @Test
    public void testFindFlushAndClear()&#123;
        CacheEntity cacheEntity = new CacheEntity();
        cacheEntity.setName(&quot;lsx&quot;);
        cacheEntity.setAge(16);

        EntityManager entityManager = JpaUtils.getEntityManager();
        entityManager.getTransaction().begin();

        entityManager.persist(cacheEntity);// 数据持久化，自动可以获取ID
        entityManager.flush(); // 强制立即写入数据库
        entityManager.clear(); // 清空缓存

        entityManager.getTransaction().commit();// 提交更新事务
        System.err.println(&quot;-----新增数据的ID是：&quot; + cacheEntity.getId());

        // 将刚刚保存对象信息根据ID查询出来
        CacheEntity selectCacheEntity = entityManager.find(CacheEntity.class, cacheEntity.getId());
        System.err.println(selectCacheEntity);
        entityManager.close();
    &#125;
</code></pre>
<p>查看日志：</p>
<pre><code>Hibernate: 
    insert 
    into
        tb_cache
        (age, name) 
    values
        (?, ?)
-----新增数据的ID是：6
Hibernate: 
    select
        cacheentit0_.Id as Id1_2_0_,
        cacheentit0_.age as age2_2_0_,
        cacheentit0_.name as name3_2_0_ 
    from
        tb_cache cacheentit0_ 
    where
        cacheentit0_.Id=?
CacheEntity(Id=6, name=lsx, age=16)
</code></pre>
<p><strong>PS：由于清除了缓存，所以此时的数据再次查询的时候就需要重新发出查询指令，当然重新查询之后也就意味这一个对象重新被缓存了</strong></p>
<p>所以在真实进行数据的批量增加时，我们应该适当加上强制写入和清空缓存（例如每新增10条数据后就执行一次<code>flush</code>和<code>clear</code>方法）</p>
<p>5、删除数据（游离状态）</p>
<pre><code class="java">    // 运行之前，修改hibernate.hbm2ddl.auto=create
    @Test
    public void testDelete()&#123;
        EntityManager entityManager = JpaUtils.getEntityManager();
        CacheEntity cacheEntity = entityManager.find(CacheEntity.class, 1L);
        entityManager.getTransaction().begin();// 开启事务
        entityManager.remove(cacheEntity); // 删除数据
        cacheEntity.setName(&quot;小明&quot;);
        entityManager.getTransaction().commit();// 提交事务
        entityManager.close();
    &#125;
</code></pre>
<p>查看日志：</p>
<pre><code class="verilog">Hibernate: 
    select
        cacheentit0_.Id as Id1_2_0_,
        cacheentit0_.age as age2_2_0_,
        cacheentit0_.name as name3_2_0_ 
    from
        tb_cache cacheentit0_ 
    where
        cacheentit0_.Id=?
Hibernate: 
    delete 
    from
        tb_cache 
    where
        Id=?
</code></pre>
<p><strong>PS：删除的数据就属于游离态了，所以此时已无法实现试据的持久态管理了</strong></p>
<h2 id="3、二级缓存"><a href="#3、二级缓存" class="headerlink" title="3、二级缓存"></a>3、二级缓存</h2><p>一级缓存时针对与<code>EntityManager</code>的缓存处理，并且永久存在，而二级缓存指的是针对于多个<code>EntityManager</code>实现的缓存处理，但是二级缓存默认是没有开启的</p>
<p>1、建立两个不同的 EntityManager 进行数据查询</p>
<pre><code class="java">    // 运行之前，修改hibernate.hbm2ddl.auto=create
    @Test
    public void testFind()&#123;
        EntityManager entityManagerA = JpaUtils.getEntityManager();
        System.err.println(entityManagerA.find(CacheEntity.class, 1L));
        entityManagerA.close();

        System.err.println(&quot;--------------华丽的分割线-------------------&quot;);

        EntityManager entityManagerB = JpaUtils.getEntityManager();
        System.err.println(entityManagerB.find(CacheEntity.class, 1L));
        entityManagerB.close();
    &#125;
</code></pre>
<p>查看日志：</p>
<pre><code class="verilog">Hibernate: 
    select
        cacheentit0_.Id as Id1_2_0_,
        cacheentit0_.age as age2_2_0_,
        cacheentit0_.name as name3_2_0_ 
    from
        tb_cache cacheentit0_ 
    where
        cacheentit0_.Id=?
CacheEntity(Id=1, name=Sam, age=18)
--------------华丽的分割线-------------------
Hibernate: 
    select
        cacheentit0_.Id as Id1_2_0_,
        cacheentit0_.age as age2_2_0_,
        cacheentit0_.name as name3_2_0_ 
    from
        tb_cache cacheentit0_ 
    where
        cacheentit0_.Id=?
CacheEntity(Id=1, name=Sam, age=18)
</code></pre>
<p>可以发现不同的Seeson（EntityManager）查询同一条数据的时候依然发出了两次查询指令，所以此时表示JPA中没有开启二级缓存</p>
<p>2、二级缓存一般用第三方组件：Redis、Ehache，这里用<code>Ehcache</code>为例，pox.xml引入<code>Ehcache</code>依赖</p>
<pre><code class="xml">        &lt;!--添加Hibernate-Ehcache包,版本号与hibernate一样 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.hibernate&lt;/groupId&gt;
            &lt;artifactId&gt;hibernate-ehcache&lt;/artifactId&gt;
            &lt;version&gt;5.4.1.Final&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!--Ehcache-core 包 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;net.sf.ehcache&lt;/groupId&gt;
            &lt;artifactId&gt;ehcache-core&lt;/artifactId&gt;
            &lt;version&gt;2.6.11&lt;/version&gt;
        &lt;/dependency&gt;
</code></pre>
<p>3、在<code>resources</code>目录下新建一个**<code>ehcache.xml</code>**文件。如果在加载时未找到<code>/ehcache.xml</code>资源或出现问题，则将使用默认配置</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;ehcache xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
        xsi:noNamespaceSchemaLocation=&quot;http://ehcache.org/ehcache.xsd&quot;
        updateCheck=&quot;false&quot;&gt;
   &lt;!--
      diskStore：为缓存路径，ehcache分为内存和磁盘两级，此属性定义磁盘的缓存位置。参数解释如下：
      - user.home – 用户主目录
      - user.dir – 用户当前工作目录
      - java.io.tmpdir – 默认临时文件路径
      - 或自定义一个本地磁盘路径例如：/home、./tmpdir/Tmp_EhCache
    --&gt;
   &lt;!-- 磁盘缓存位置 --&gt; 
   &lt;diskStore path=&quot;./tmpdir/Tmp_EhCache&quot;/&gt;
   
   &lt;defaultCache
           eternal=&quot;false&quot;
           maxElementsInMemory=&quot;10000&quot;
           overflowToDisk=&quot;false&quot;
           diskPersistent=&quot;false&quot;
           timeToIdleSeconds=&quot;1800&quot;
           timeToLiveSeconds=&quot;259200&quot;
           memoryStoreEvictionPolicy=&quot;LRU&quot;/&gt;

   &lt;cache
           name=&quot;cloud_user&quot;
           eternal=&quot;false&quot;
           maxElementsInMemory=&quot;5000&quot;
           overflowToDisk=&quot;false&quot;
           diskPersistent=&quot;false&quot;
           timeToIdleSeconds=&quot;1800&quot;
           timeToLiveSeconds=&quot;1800&quot;
           memoryStoreEvictionPolicy=&quot;LRU&quot;/&gt;
   &lt;!--
      defaultCache：默认缓存策略，当ehcache找不到定义的缓存时，则使用这个缓存策略。只能定义一个。
    --&gt;
   &lt;!--
     name:缓存名称。
     maxElementsInMemory:缓存最大数目
     maxElementsOnDisk：硬盘最大缓存个数。
     eternal:对象是否永久有效，一但设置了，timeout将不起作用。
     overflowToDisk:是否保存到磁盘，当系统当机时
     timeToIdleSeconds:设置对象在失效前的允许闲置时间（单位：秒）。仅当eternal=false对象不是永久有效时使用，可选属性，默认值是0，也就是可闲置时间无穷大。
     timeToLiveSeconds:设置对象在失效前允许存活时间（单位：秒）。最大时间介于创建时间和失效时间之间。仅当eternal=false对象不是永久有效时使用，默认是0.，也就是对象存活时间无穷大。
     diskPersistent：是否缓存虚拟机重启期数据 Whether the disk store persists between restarts of the Virtual Machine. The default value is false.
     diskSpoolBufferSizeMB：这个参数设置DiskStore（磁盘缓存）的缓存区大小。默认是30MB。每个Cache都应该有自己的一个缓冲区。
     diskExpiryThreadIntervalSeconds：磁盘失效线程运行时间间隔，默认是120秒。
     memoryStoreEvictionPolicy：当达到maxElementsInMemory限制时，Ehcache将会根据指定的策略去清理内存。默认策略是LRU（最近最少使用）。你可以设置为FIFO（先进先出）或是LFU（较少使用）。
     clearOnFlush：内存数量最大时是否清除。
     memoryStoreEvictionPolicy:可选策略有：LRU（最近最少使用，默认策略）、FIFO（先进先出）、LFU（最少访问次数）。
     FIFO，first in first out，这个是大家最熟的，先进先出。
     LFU， Less Frequently Used，就是上面例子中使用的策略，直白一点就是讲一直以来最少被使用的。如上面所讲，缓存的元素有一个hit属性，hit值最小的将会被清出缓存。
     LRU，Least Recently Used，最近最少使用的，缓存的元素有一个时间戳，当缓存容量满了，而又需要腾出地方来缓存新的元素的时候，那么现有缓存元素中时间戳离当前时间最远的元素将被清出缓存。
  --&gt;
&lt;/ehcache&gt;
</code></pre>
<p>4、在JPA配置文件<code>persistence.xml</code>中增加二级缓存配置</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;persistence xmlns=&quot;http://java.sun.com/xml/ns/persistence&quot; version=&quot;2.0&quot;&gt;

    &lt;!-- 持久化单元：持久化单元事务类型,RESOURCE_LOCAL：本地事务管理 --&gt;
    &lt;persistence-unit name=&quot;myJpa&quot; transaction-type=&quot;RESOURCE_LOCAL&quot;&gt;
        &lt;provider&gt;org.hibernate.jpa.HibernatePersistenceProvider&lt;/provider&gt;
        &lt;!--
            配置二级缓存时候使用的模式，可配置值有：
            - ALL：所有的实体类都被缓存
            - NONE：所有的实体类都不被缓存
            - ENABLE_SELECTIVE：标识@Cacheable(true)注解的实体类将被缓存
            - DISABLE_SELECTIVE；缓存除标识@Cacheable(false)以外的所有实体类
            - UNSPECIFIED：默认值，JPA 产品默认值将被使用
         --&gt;
        &lt;shared-cache-mode&gt;ENABLE_SELECTIVE&lt;/shared-cache-mode&gt;

        &lt;!--可选配置：配置jpa实现方的配置信息--&gt;
        &lt;properties&gt;
            &lt;!-- 数据库信息配置：数据库驱动、数据库地址、数据库账户、数据库密码 --&gt;
            &lt;property name=&quot;hibernate.connection.driver_class&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;
            &lt;property name=&quot;hibernate.connection.url&quot; value=&quot;jdbc:mysql://127.0.0.1:3306/hibernate_jpa&quot;/&gt;
            &lt;property name=&quot;hibernate.connection.username&quot; value=&quot;root&quot;/&gt;
            &lt;property name=&quot;hibernate.connection.password&quot; value=&quot;password&quot;/&gt;
            
            &lt;!-- 配置JPA服务提供商可选参数 --&gt;
            &lt;property name=&quot;hibernate.show_sql&quot; value=&quot;true&quot; /&gt;&lt;!-- 自动显示sql --&gt;
            &lt;property name=&quot;hibernate.format_sql&quot; value=&quot;true&quot;/&gt;&lt;!-- 格式化sql --&gt;
            &lt;property name=&quot;hibernate.hbm2ddl.auto&quot; value=&quot;update&quot; /&gt;&lt;!-- 自动建表：none,create,update,create-drop,validate --&gt;

            &lt;!-- 二级缓存相关 --&gt;
            &lt;!-- 开启二级缓存 --&gt;
            &lt;property name=&quot;hibernate.cache.use_second_level_cache&quot; value=&quot;true&quot;/&gt;
            &lt;!-- 配置二级缓存处理类 --&gt;
            &lt;property name=&quot;hibernate.cache.region.factory_class&quot; value=&quot;org.hibernate.cache.ehcache.EhCacheRegionFactory&quot;/&gt;
            &lt;!-- 开启查询缓存，entityManager.find查询可以不配置，如果使用JPQL或SQL查询需要开启该配置 --&gt;
            &lt;property name=&quot;hibernate.cache.use_query_cache&quot; value=&quot;true&quot;/&gt;
            &lt;!-- 指定缓存配置文件位置,如果默认在resources下可不配置 --&gt;
            &lt;property name=&quot;hibernate.cache.provider_configuration&quot; value=&quot;classpath:ehcache.xml&quot;/&gt;

        &lt;/properties&gt;
    &lt;/persistence-unit&gt;
&lt;/persistence&gt;
</code></pre>
<p>5、其中<code>ENABLE_SELECTIVE</code>模式为实体类上配置 <code>@Cacheable(true)</code>  的才会进行生效</p>
<pre><code class="java">@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
@Entity
@Table(name = &quot;tb_cache&quot;)
@Cacheable(value = true) // 增加此注解即可，value默认为true，直接配置@Cacheable也可以
public class CacheEntity &#123;
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long Id;
    private String name;
    private int age;
&#125;
</code></pre>
<pre><code class="java">/***************另一种用法（没有特殊需求只用上面配置即可）******************/
/**
 * 如果只配置@Cacheable的话是用ehcache.xml中默认defaultCache配置，
 * 想用自定义名称的缓存配置，需要增加@Cache注解，例如想使用ehcache.xml中的&lt;cache name=&quot;cloud_user&quot;../&gt; 缓存配置
 * 增加注解 @Cache(usage = CacheConcurrencyStrategy.READ_WRITE,region=&quot;指定的cache name&quot;)
 **/
@Cache(usage = CacheConcurrencyStrategy.READ_WRITE,region=&quot;cloud_user&quot;)
@Cacheable(value = true)
@Entity
@Table(name = &quot;tb_cache&quot;)
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class CacheEntity &#123;
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long Id;
    private String name;
    private int age;
&#125;
</code></pre>
<p>usage提供缓存对象的事务隔离机制有这几种：NONE、READ_ONLY、 NONSTRICT_READ_WRITE、READ_WRITE、TRANSACTIONAL</p>
<ol>
<li>NONE：默认什么都不做</li>
<li>READ_ONLY：只读模式，在此模式下，如果对数据进行更新操作，会有异常</li>
<li>READ_WRITE：读写模式在更新缓存的时候会把缓存里面的数据换成一个锁，其它事务如果去取相应的缓存数据，发现被锁了，直接就去数据库查询</li>
<li>NONSTRICT_READ_WRITE：不严格的读写模式则不会的缓存数据加锁</li>
<li>TRANSACTIONAL：事务模式指缓存支持事务，当事务回滚时，缓存也能回滚，只支持JTA环境。</li>
</ol>
<hr>
<p>Ehcache不支持transaction事务机制，但其他三种可以使用：</p>
<ol>
<li>read-only：无需修改， 那么就可以对其进行只读 缓存，注意，在此策略下，如果直接修改数据库，即使能够看到前台显示效果，但是将对象修改至cache中会报error，cache不会发生作用。另：删除记录会报错，因为不能在read-only模式的对象从cache中删除</li>
<li>read-write：需要更新数据，那么使用读&#x2F;写缓存 比较合适，前提：数据库不可以为serializable transaction isolation level（序列化事务隔离级别）</li>
<li>nonstrice-read-write：只偶尔需要更新数据（也就是说，两个事务同时更新同一记录的情况很不常见），也不需要十分严格的事务隔离，那么比较适合使用非严格读&#x2F;写缓存策略。</li>
</ol>
<p>6、再次测试Test代码：</p>
<pre><code class="java">    // 运行之前，修改hibernate.hbm2ddl.auto=create
    @Test
    public void testFind()&#123;
        EntityManager entityManagerA = JpaUtils.getEntityManager();
        System.err.println(entityManagerA.find(CacheEntity.class, 1L));
        entityManagerA.close();

        System.err.println(&quot;--------------华丽的分割线-------------------&quot;);

        EntityManager entityManagerB = JpaUtils.getEntityManager();
        System.err.println(entityManagerB.find(CacheEntity.class, 1L));
        entityManagerB.close();
    &#125;
</code></pre>
<p>查看日志：</p>
<pre><code class="verilog">Hibernate: 
    select
        cacheentit0_.Id as Id1_2_0_,
        cacheentit0_.age as age2_2_0_,
        cacheentit0_.name as name3_2_0_ 
    from
        tb_cache cacheentit0_ 
    where
        cacheentit0_.Id=?
CacheEntity(Id=1, name=Sam, age=18)
--------------华丽的分割线-------------------
CacheEntity(Id=1, name=Sam, age=18) // 可以发现第二次查询没有发送查询语句了
</code></pre>
<h2 id="3、查询缓存"><a href="#3、查询缓存" class="headerlink" title="3、查询缓存"></a>3、查询缓存</h2><p>在进行数据查询都是直接<code>EntityManager</code>的方法直接查询，这种方式可以帮助用户直接进行缓存处理，如果现在使用<code>Query</code>查询，则对于缓存配置就不生效了</p>
<p>PS：而使用<code>Query</code>查询是没有缓存的，需要设置：<code>query.setHint(QueryHints.HINT_CACHEABLE, true);</code>（且每新创建一个<code>Query</code>都要设置）</p>
<p>由于在二级缓存中已经配置了如下配置，我们先注释掉下面的配置或者关闭配置开始测试：</p>
<pre><code class="xml">&lt;!-- 开启查询缓存，entityManager.find查询可以不配置，如果使用JPQL或SQL查询需要开启该配置，并设置query.setHint() --&gt;
&lt;!--&lt;property name=&quot;hibernate.cache.use_query_cache&quot; value=&quot;true&quot;/&gt;--&gt;
&lt;property name=&quot;hibernate.cache.use_query_cache&quot; value=&quot;false&quot;/&gt;
</code></pre>
<p>1、观察默认情况下<code>Query</code>查询处理（分别测试开启查询缓存和关闭查询缓存）</p>
<pre><code class="java">    // 运行之前，修改hibernate.hbm2ddl.auto=create
    @Test
    public void testFindQuery()&#123;
        String jpql = &quot;from CacheEntity where Id = :Id&quot;;
        EntityManager entityManagerA = JpaUtils.getEntityManager();
        TypedQuery&lt;CacheEntity&gt; queryA = entityManagerA.createQuery(jpql, CacheEntity.class);
        queryA.setParameter(&quot;Id&quot;, 1L);
        System.err.println(queryA.getSingleResult());
        entityManagerA.close();

        System.err.println(&quot;--------------华丽的分割线-------------------&quot;);

        EntityManager entityManagerB = JpaUtils.getEntityManager();
        TypedQuery&lt;CacheEntity&gt; queryB = entityManagerB.createQuery(jpql, CacheEntity.class);
        queryB.setParameter(&quot;Id&quot;, 1L);
        System.err.println(queryB.getSingleResult());
        entityManagerB.close();
    &#125;
</code></pre>
<p>查看日志：</p>
<pre><code class="verilog">Hibernate: 
    select
        cacheentit0_.Id as Id1_2_,
        cacheentit0_.age as age2_2_,
        cacheentit0_.name as name3_2_ 
    from
        tb_cache cacheentit0_ 
    where
        cacheentit0_.Id=?
CacheEntity(Id=1, name=Sam, age=18)
--------------华丽的分割线-------------------
Hibernate: 
    select
        cacheentit0_.Id as Id1_2_,
        cacheentit0_.age as age2_2_,
        cacheentit0_.name as name3_2_ 
    from
        tb_cache cacheentit0_ 
    where
        cacheentit0_.Id=?
CacheEntity(Id=1, name=Sam, age=18)
</code></pre>
<p><strong>PS：发现默认情况下即便开启或者固安必二级查询缓存，对于Query查询也是无效的，所以还是需要开启查询缓存配置（后面需要加一个配置才能生效）</strong></p>
<p>2、开启查询缓存配置（还原注释掉的配置），使用<code>QueryHints</code>操作</p>
<pre><code class="java">    // 运行之前，修改hibernate.hbm2ddl.auto=create
    @Test
    public void testFindQuery2()&#123;
        String jpql = &quot;from CacheEntity where Id = :Id&quot;;
        EntityManager entityManagerA = JpaUtils.getEntityManager();
        TypedQuery&lt;CacheEntity&gt; queryA = entityManagerA.createQuery(jpql, CacheEntity.class);
        queryA.setHint(QueryHints.HINT_CACHEABLE,true);
        queryA.setParameter(&quot;Id&quot;, 2L);
        System.err.println(queryA.getSingleResult());
        entityManagerA.close();

        System.err.println(&quot;--------------华丽的分割线-------------------&quot;);

        EntityManager entityManagerB = JpaUtils.getEntityManager();
        TypedQuery&lt;CacheEntity&gt; queryB = entityManagerB.createQuery(jpql, CacheEntity.class);
        queryB.setHint(QueryHints.HINT_CACHEABLE,true);
        queryB.setParameter(&quot;Id&quot;, 2L);
        System.err.println(queryB.getSingleResult());
        entityManagerB.close();
    &#125;
</code></pre>
<p>查看日志：</p>
<pre><code class="verilog">Hibernate: 
    select
        cacheentit0_.Id as Id1_2_,
        cacheentit0_.age as age2_2_,
        cacheentit0_.name as name3_2_ 
    from
        tb_cache cacheentit0_ 
    where
        cacheentit0_.Id=?
CacheEntity(Id=2, name=Mike, age=58)
--------------华丽的分割线-------------------
CacheEntity(Id=2, name=Mike, age=58) // 可以发现只发送了一次查询操作
</code></pre>
<p><strong>PS：使用<code>Query</code>查询是没有缓存的，需要设置：<code>query.setHint(QueryHints.HINT_CACHEABLE, true);</code>（且每新创建一个<code>Query</code>都要设置）</strong></p>
<h1 id="Hibernate-JPA-锁的机制"><a href="#Hibernate-JPA-锁的机制" class="headerlink" title="Hibernate JPA 锁的机制"></a>Hibernate JPA 锁的机制</h1><p>当数据库并发访问的时候为了保证操作的一致性，那么往往会对并发数据的访问做出限制，例如：只允许一个会话处理，这样的机制就称为锁机制，而在<code>JPA</code>之中也支持锁机制的处理，而<code>JPA</code>支持两类锁：</p>
<ol>
<li>悲观锁：假设数据的访问一直都存在有并发，所以悲观锁一直都会存在，主要依靠的是数据库的锁机制</li>
<li>乐观锁：假设不会进行并发访问（不会出现同时的数据更新处理）主要是依靠算法来实现的，设置版本号，通过版本号来判断当前的<code>Session</code>能否进行更新</li>
</ol>
<p>在<code>JPA</code>里面专门提供有一个锁的处理模式：<code>javax.persistence.LockModeType;</code></p>
<h2 id="1、悲观锁：Pessimistic"><a href="#1、悲观锁：Pessimistic" class="headerlink" title="1、悲观锁：Pessimistic"></a>1、悲观锁：Pessimistic</h2><p>悲观锁认为用户的并发访问会一直发生，并且在整个的处理之中悲观锁一定会采用锁的机制，对一个事务内的操作数据进行锁定，这样其他的事务就无法进行该数据的更新操作了。在悲观锁中定义了如下几种处理模式：</p>
<ul>
<li><p>NONE：不适用锁</p>
</li>
<li><p>PESSIMISTIEC_READ：只要事务读实体，实体管理器就锁定实体，直到事务完成锁才会解开，当你想使用重复语义查询数据时使用这种锁模式，换句话说，当你想确保数据在连续读取期间不被修改，这种锁模式不会阻碍其他事务读取数据</p>
</li>
<li><p>PESSIMISTIC_WRITE：只要事务更新实体，实体管理器就会锁定实体，这种锁模式强制尝试修改实体数据的事务串行化，当多个并发更新事务出现更新失败几率较高时使用这种锁模式</p>
</li>
<li><p>PESSIMISTIC_FORCE_INCREMENT：当事务读实体时，实体管理器就锁定实体，当事务结束时会增加实体的版本属性，即使实体没有修改</p>
</li>
</ul>
<p>1、使用悲观锁编写测试类</p>
<pre><code class="java">   /**
     * 悲观锁
     */
    @Test
    public void testFindPessimisticLock()&#123;
        EntityManager entityManager = JpaUtils.getEntityManager();
        entityManager.getTransaction().begin(); // 开启事务
        // 加上写入悲观锁
        entityManager.find(Customer.class, 2L, LockModeType.PESSIMISTIC_WRITE);
        entityManager.getTransaction().rollback(); // 可以回滚或提交
    &#125;
</code></pre>
<p>查看日志：</p>
<pre><code class="verilog">Hibernate: 
    select
        customer0_.id as id1_0_0_,
        customer0_.c_address as c_addres2_0_0_,
        customer0_.c_age as c_age3_0_0_,
        customer0_.c_name as c_name4_0_0_,
        customer0_.c_phone as c_phone5_0_0_,
        customer0_.c_sex as c_sex6_0_0_ 
    from
        tb_customer customer0_ 
    where
        customer0_.id=? for update
</code></pre>
<p>可以发现查询语句最后跟上了：<code>for update</code>（代表我对这条数据进行锁定了，在我没有提交或回滚事务之前，其他线程不能对该数据进行修改）</p>
<p>2、模仿两个线程来进行锁处理。模拟场景：</p>
<ol>
<li>线程A查询数据，并给这条数据加上写入悲观锁，然后对数据进行修改，在事务提交之前休眠20秒</li>
<li>线程B查询同一条数据，并给这条数据加上写入悲观锁，然后对数据进行修改，不休眠直接提交事务</li>
</ol>
<p>线程A：<code>TestPessimisticA.java</code></p>
<pre><code class="java">public class TestPessimisticA &#123;
    /**
     * 悲观锁
     */
    public static void main(String[] args) throws Exception &#123;
        EntityManager entityManager = JpaUtils.getEntityManager();
        entityManager.getTransaction().begin();// 开启事务
        // 加上写入悲观锁
        Customer customer = entityManager.find(Customer.class, 14L, LockModeType.PESSIMISTIC_WRITE);
        customer.setName(&quot;悲观锁修改A&quot;);
        TimeUnit.SECONDS.sleep(20);// 休眠20秒
        entityManager.getTransaction().commit();// 可以提交或回滚
        entityManager.close();
    &#125;
</code></pre>
<p>线程B：<code>TestPessimisticB.java</code></p>
<pre><code class="java">public class TestPessimisticB &#123;
    /**
     * 悲观锁
     */
    public static void main(String[] args) &#123;
        EntityManager entityManager = JpaUtils.getEntityManager();
        entityManager.getTransaction().begin();// 开启事务
        // 加上写入悲观锁
        Customer customer = entityManager.find(Customer.class, 14L, LockModeType.PESSIMISTIC_WRITE);
        customer.setName(&quot;悲观锁修改B&quot;);
        entityManager.getTransaction().commit();// 可以提交或回滚
        entityManager.close();
    &#125;
</code></pre>
<p>操作步骤和结论：</p>
<ol>
<li>先执行线程A，然后里面去执行线程B</li>
<li>会出现线程A执行完数据修改后提交事务前，休眠20秒，控制台停住了</li>
<li>线程B虽然没有休眠，可是也依旧停住了，因为在等待线程A操作完该数据</li>
<li>等待线程A操作完数据提交了事务，线程B也立马提交了事务</li>
<li>最终这条数据经历了先被A修改，然后立马又被线程B修改了</li>
</ol>
<p>查看日志（从日志上什么也看不出来，线程A和B输出日志一摸一样，需要模拟时看控制台停滞与停止状态）</p>
<pre><code class="verilog">Hibernate: 
    select
        customer0_.id as id1_0_0_,
        customer0_.c_address as c_addres2_0_0_,
        customer0_.c_age as c_age3_0_0_,
        customer0_.c_name as c_name4_0_0_,
        customer0_.c_phone as c_phone5_0_0_,
        customer0_.c_sex as c_sex6_0_0_ 
    from
        c_customer customer0_ 
    where
        customer0_.id=? for update
            
Hibernate: 
    update
        tb_customer 
    set
        customer_address=?,
        customer_age=?,
        customer_name=?,
        customer_phone=?,
        customer_sex=? 
    where
        customer_id=?
</code></pre>
<p>这个必须要亲自模拟多次才能理解清楚，可以在线程B加上控制台输出</p>
<h2 id="2、乐观锁：Optimistic"><a href="#2、乐观锁：Optimistic" class="headerlink" title="2、乐观锁：Optimistic"></a>2、乐观锁：Optimistic</h2><p><code>JPA</code>最早的时候所提供的锁机制就是乐观锁，乐观锁：假设没有多个事务修改同一条数据的情况，而且乐观锁最大的差别就是需要对数据表上增加一个表示数据版本的编号。对于乐观锁有如下几种锁的处理模式：</p>
<ol>
<li>OPTIMISTIC：它和READ锁模式相同，<code>JPA 2.0</code>仍然支持<code>READ</code>模式，但明确指出在新应用程序中推荐使用<code>OPTIMISTIC</code></li>
<li>OPTIMISTIC_FORCE_INCREMENT：它和WRITE锁模式相同，<code>JPA 2.0</code>仍然支持<code>WRITE</code>锁模式，但明确的指出在新应用程序中推荐使用<code>OPTIMISTIC_FORCE_INCREMENT</code></li>
</ol>
<p>1、修改数据库脚本：增加一个版本号字段：<code>c_version</code>（如果<code>JPA</code>设置自动检测修改表的话可以忽略这一步）</p>
<pre><code class="sql">alter table tb_customer add column customer_version bigint default 0;
</code></pre>
<p>2、修改实体类，增加版本号字段</p>
<pre><code class="java">@Version
@Column(name = &quot;customer_version&quot;,columnDefinition=&quot;bigint default 0&quot;)
private Long version;
</code></pre>
<p>3、采用乐观锁操作，编写程序类</p>
<pre><code class="java">    /**
     * 乐观锁
     */
    @Test
    public void testFindOptimisticLock()&#123;
        EntityManager entityManager = JpaUtils.getEntityManager();
        entityManager.getTransaction().begin();// 开启事务
        Customer customer = entityManager.find(Customer.class, 2L, LockModeType.OPTIMISTIC_FORCE_INCREMENT);// 查询并加上写入乐观锁
        customer.setName(&quot;李四四&quot;);
        entityManager.getTransaction().commit();// 可以回滚或提交
    &#125;
</code></pre>
<p>查看日志：</p>
<pre><code class="verilog">Hibernate: 
    select
        customer0_.id as id1_0_0_,
        customer0_.c_address as c_addres2_0_0_,
        customer0_.c_age as c_age3_0_0_,
        customer0_.c_name as c_name4_0_0_,
        customer0_.c_phone as c_phone5_0_0_,
        customer0_.c_sex as c_sex6_0_0_,
        customer0_.c_version as c_versio7_0_0_ 
    from
        c_customer customer0_ 
    where
        customer0_.id=?
Hibernate: // 会发现每一次在进行更新的时候会出现版本号的修改操作
    update
        tb_customer 
    set
        customer_version=? 
    where
        customer_id=? 
        and customer_version=?
</code></pre>
<p>4、模拟多用户并发访问。模拟场景（与悲观锁场景一样）：</p>
<ol>
<li>线程A查询数据，并给这条数据加上写入乐观锁，然后对数据进行修改，在事务提交之前休眠20秒</li>
<li>线程B查询同一条数据，并给这条数据加上写入悲观锁，然后对数据进行修改，不休眠直接提交事务</li>
</ol>
<p>线程A：<code>TestOptimisticA.java</code></p>
<pre><code class="java">public class TestOptimisticA &#123;
    /**
     * 乐观锁
     * @param args
     */
    public static void main(String[] args) throws Exception &#123;
        EntityManager entityManager = JpaUtils.getEntityManager();
        entityManager.getTransaction().begin();// 开启事务
        Customer customer = entityManager.find(Customer.class, 14L, LockModeType.OPTIMISTIC_FORCE_INCREMENT);// 加上写入乐观锁
        customer.setName(&quot;乐观锁修改A&quot;);
        TimeUnit.SECONDS.sleep(20);// 休眠20秒
        entityManager.getTransaction().commit();// 可以提交或回滚
        entityManager.close();
    &#125;
</code></pre>
<p>线程B：<code>TestOptimisticB.java</code></p>
<pre><code class="java">    /**
     * 乐观锁
     * @param args
     */
    public static void main(String[] args) &#123;
        EntityManager entityManager = JpaUtils.getEntityManager();
        entityManager.getTransaction().begin();// 开启事务
        System.err.println(&quot;查询数据--------&quot;);
        Customer customer = entityManager.find(Customer.class, 14L, LockModeType.OPTIMISTIC_FORCE_INCREMENT);// 加上写入乐观锁
        customer.setName(&quot;乐观锁修改B&quot;);
        entityManager.getTransaction().commit();// 可以提交或回滚
        System.err.println(&quot;修改线程B的数据完成&quot;);
        entityManager.close();
    &#125;
</code></pre>
<p>操作步骤和结论：</p>
<ol>
<li>先执行线程A，然后里面去执行线程B</li>
<li>由于乐观锁不是对一条数据的锁定，等于现在第二个事务（线程B）会先实现数据的更新</li>
<li>但是由于第一个事务先启动，所以他读取到版本号和它更新时候的版本号肯定是不同的</li>
<li>所以在线程A提交事务的时候会报如下错误：</li>
</ol>
<pre><code>Caused by: javax.persistence.OptimisticLockException: Row was updated or deleted by another transaction (or unsaved-value mapping was incorrect) : [domain.Customer#14]
....
Caused by: org.hibernate.StaleObjectStateException: Row was updated or deleted by another transaction (or unsaved-value mapping was incorrect) : [domain.Customer#14]
</code></pre>
<p>乐观锁是一种基于数据算法的锁的处理机制，乐观锁特点就是在于你的项目之中不存在多个用户更新同一数据的情况。如果一直存在并发更新同一数据的话，那么一定采用悲观锁</p>
<h1 id="Hibernate-JPA-关联关系"><a href="#Hibernate-JPA-关联关系" class="headerlink" title="Hibernate JPA 关联关系"></a>Hibernate JPA 关联关系</h1><p>关联关系从整体上分为单向关联和双向关联：</p>
<ol>
<li><strong>单向关联</strong>：只需从一端访问另一端，如教师Teacher可访问学生Student，则Teacher实体需要包含类型为Student的属性</li>
<li><strong>双向关联</strong>：两端均可互相访问，如教师Teacher可访问学生Student，学生Student也可访问教师Teacher，两个实体均需要包含类型为对方的属性</li>
</ol>
<h2 id="1、一对一关联映射"><a href="#1、一对一关联映射" class="headerlink" title="1、一对一关联映射"></a>1、一对一关联映射</h2><h3 id="1-1、单向一对一"><a href="#1-1、单向一对一" class="headerlink" title="1.1、单向一对一"></a>1.1、单向一对一</h3><p>单向1-1：需要在控制关系的一方实体中使用注解 @OneToOne 和 @JoinColumn 标注类型为对方的属性。如<code>Person</code>端为控制关系的一方，只需要在<code>Person</code>控制方加这两个注解即可。反端既不用配置属性字段也不用配置注解</p>
<blockquote>
<p>单向一对一是关联关系映射中最简单的一种，简单地说就是可以从关联的一方去查询另一方，却不能反向查询。我们用下面的例子来举例说明，清单 1 中的 Person 实体类和清单 2 中的 Address 类就是这种单向的一对一关系，我们可以查询一个 Person 的对应的 Address 的内容，但是我们却不能由一个 Address 的值去查询这个值对应的 Person</p>
</blockquote>
<ol>
<li>tb_person_address（外键表）：<code>address_id</code>，street，city，country，<code>person_id</code></li>
<li>tb_person（主键表）：<code>person_id</code>，username</li>
</ol>
<p>清单 1：单向一对一关系的拥有端（正端）</p>
<pre><code class="java">@Data
@Entity
@Table(name = &quot;tb_person&quot;)
public class Person implements Serializable &#123;
   private static final long serialVersionUID = 1L;
   @Id
   @GeneratedValue(strategy = GenerationType.IDENTITY)
   @Column(name = &quot;person_id&quot;)
   private Long personId;
   private String username;
   /**
    * @JoinColumn
    *     name: person_address表外键字段名（数据库字段名）
    *     referencedColumnName: person表主键字段（数据库字段名）
    */
   @OneToOne
   @JoinColumn(name = &quot;address_id&quot;,referencedColumnName = &quot;address_id&quot;)
   private PersonAddress personAddress;
&#125;
</code></pre>
<p>清单 2：单向一对一关系的被拥有端（反端）</p>
<pre><code class="java">@Data
@Entity
@Table(name = &quot;tb_person_address&quot;)
public class PersonAddress implements Serializable &#123;
   @Id
   @GeneratedValue(strategy = GenerationType.IDENTITY)
   @Column(name = &quot;address_id&quot;)
   private Long addressId;
   private String country;
   private String city;
&#125;
</code></pre>
<p>执行代码测试：</p>
<pre><code class="java">    /**
     * 运行之前，修改hibernate.hbm2ddl.auto=create
     * 单向一对一查询
     */
    @Test
    public void testOneToOne()&#123;
        EntityManager entityManager = JpaUtils.getEntityManager();
        // 开启事务
        entityManager.getTransaction().begin();

        // 保存地址数据
        PersonAddress address = new PersonAddress();
        address.setCountry(&quot;中国&quot;);
        address.setCity(&quot;广州&quot;);
        entityManager.persist(address);

        // 保存用户信息
        Person person = new Person();
        person.setUsername(&quot;Sam&quot;);
        person.setPersonAddress(address);
        entityManager.persist(person);

        // 提交更新事务
        entityManager.getTransaction().commit();

        // 查询拥有端（外键表端）,先清理缓存
        entityManager.clear();
        System.out.println(entityManager.find(Person.class,person.getPersonId()));
        entityManager.close();
    &#125;
</code></pre>
<p>查看日志1（日志分为两段，1为建表）：</p>
<pre><code class="verilog">Hibernate: 
    
    create table tb_person (
       person_id bigint not null auto_increment,
        username varchar(255),
        address_id bigint,
        primary key (person_id)
    ) engine=InnoDB
Hibernate: 
    
    create table tb_person_address (
       address_id bigint not null auto_increment,
        city varchar(255),
        country varchar(255),
        primary key (address_id)
    ) engine=InnoDB
Hibernate: 
    
    alter table tb_person 
       add constraint FKcep21ttdy3yuo1f56giyatasf 
       foreign key (address_id) 
       references t_person_address (address_id)
</code></pre>
<p>查看日志2（日志分为两段，2为数据插入与查询）：</p>
<pre><code class="verilog">Hibernate: // 数据插入
    insert 
    into
        t_person_address
        (city, country) 
    values
        (?, ?)
Hibernate: 
    insert 
    into
        t_person
        (address_id, username) 
    values
        (?, ?)
Hibernate: // 数据查询
    select
        person0_.person_id as person_i1_5_0_,
        person0_.address_id as address_3_5_0_,
        person0_.username as username2_5_0_,
        personaddr1_.address_id as address_1_6_1_,
        personaddr1_.city as city2_6_1_,
        personaddr1_.country as country3_6_1_ 
    from
        tb_person person0_ 
    left outer join
        tb_person_address personaddr1_ 
            on person0_.address_id=personaddr1_.address_id 
    where
        person0_.person_id=?
Person(personId=1, username=Sam, address=PersonAddress(addressId=1, country=中国, city=广州))
</code></pre>
<h3 id="1-2、双向一对一"><a href="#1-2、双向一对一" class="headerlink" title="1.2、双向一对一"></a>1.2、双向一对一</h3><p>清单 3：单向一对一关系的拥有端</p>
<pre><code class="java">@Data
@Entity
@Table(name = &quot;tb_person_address&quot;)
public class PersonAddress implements Serializable &#123;
   @Id
   @GeneratedValue(strategy = GenerationType.IDENTITY)
   @Column(name = &quot;address_id&quot;)
   private Long addressId;
   private String country;
   private String city;

   /**
    * @OneToOne
    *    mappedBy：放弃外键维护。mappedBy 只有在双向关联的时候设置。值为对方类引用本类的属性名
    */
   @OneToOne(mappedBy = &quot;personAddress&quot;)
   private Person person;
&#125;
</code></pre>
<p>清单 4：双向一对一关系中的接受端</p>
<pre><code class="java">@Data
@Entity
@Table(name = &quot;tb_person&quot;)
public class Person implements Serializable &#123;
   private static final long serialVersionUID = 1L;
   @Id
   @GeneratedValue(strategy = GenerationType.IDENTITY)
   @Column(name = &quot;person_id&quot;)
   private Long personId;
   private String username;
   /**
    * @JoinColumn
    *     name: person_address表外键字段名（数据库字段名）
    *     referencedColumnName: person表主键字段（数据库字段名）
    */
   @OneToOne
   @JoinColumn(name = &quot;address_id&quot;,referencedColumnName = &quot;address_id&quot;)
   private PersonAddress personAddress;
&#125;
</code></pre>
<p>执行代码测试：</p>
<pre><code class="java">    /**
     * 运行之前，修改hibernate.hbm2ddl.auto=create
     * 双向一对一查询
     */
    @Test
    public void testOneToOne2()&#123;
        EntityManager entityManager = JpaUtils.getEntityManager();
        // 开启事务
        entityManager.getTransaction().begin();

        PersonAddress personAddress = new PersonAddress();
        personAddress.setCountry(&quot;中国&quot;);
        personAddress.setCity(&quot;广州&quot;);
        entityManager.persist(personAddress);

        Person person = new Person();
        person.setUsername(&quot;Sam&quot;);
        person.setPersonAddress(personAddress);
        entityManager.persist(person);

        // 提交事务
        entityManager.getTransaction().commit();

        // 查询拥有端（外键表端）先清理缓存
        entityManager.clear();
        System.out.println(entityManager.find(PersonAddress.class,personAddress.getAddressId()));
        // 查询被拥有端（主键表端）
        System.out.println(entityManager.find(Person.class,person.getPersonId()));
        entityManager.close();
    &#125;
</code></pre>
<p>查看日志（建表语句就不重复打印了，因为是一摸一样的）：</p>
<pre><code>// ...省略插入语句和查询语句

java.lang.StackOverflowError
    at java.lang.Long.toString(Long.java:396)
    at java.lang.Long.toString(Long.java:1032)
    at java.lang.String.valueOf(String.java:2994)
    at java.lang.StringBuilder.append(StringBuilder.java:131)
    at OneToOne.Person.toString(Person.java:8)
    at java.lang.String.valueOf(String.java:2994)
    at java.lang.StringBuilder.append(StringBuilder.java:131)
    at OneToOne.PersonAddress.toString(PersonAddress.java:8)
    at java.lang.String.valueOf(String.java:2994)
    at java.lang.StringBuilder.append(StringBuilder.java:131)
    at OneToOne.Person.toString(Person.java:8)
    at java.lang.String.valueOf(String.java:2994)
...
</code></pre>
<blockquote>
<p>现在在查询步骤中会出现死循环（后面解决）</p>
</blockquote>
<h2 id="2、一对多关联映射"><a href="#2、一对多关联映射" class="headerlink" title="2、一对多关联映射"></a>2、一对多关联映射</h2><h3 id="2-1、单向一对多"><a href="#2-1、单向一对多" class="headerlink" title="2.1、单向一对多"></a>2.1、单向一对多</h3><p>单向1-N：需要在控制关系的一方实体中使用注解 @OneToMany 和 @JoinColumn 标注类型为对方的集合属性（有两种方式：一种是只加@OneToMany、另一种是 @OneToMany + @JoinColumn）</p>
<ol>
<li>tb_people（外键表）：<code>people_id</code>，name，<code>people_id</code></li>
<li>tb_people_phone（主键表）：<code>phone_id</code>，type，phone</li>
</ol>
<p>清单 5：单向一对多关系的拥有端（一方、主键表方、主表）</p>
<pre><code class="java">@Data
@Entity
@Table(name = &quot;tb_people&quot;)
public class People &#123;
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = &quot;people_id&quot;)
    private Long peopleId;
    private String name;

    /**
     *  @OneToMany
     *    cascade = CascadeType.ALL：级联保存、更新、删除、刷新
     *    fetch = FetchType.LAZY   ：延迟加载
     *  @JoinColumn
     *    name 指定外键列，这里注意指定的是people_id,实际上是为了外键表定义的字段。该字段在PeoplePhone类必须定义
     */
    @OneToMany
    @JoinColumn(name=&quot;people_id&quot;)
    private List&lt;PeoplePhone&gt; peoplePhones = new ArrayList&lt;&gt;();
&#125;
</code></pre>
<p>清单 6：单向一对多关系的接收端（多方、外键表方、从表）</p>
<pre><code class="java">@Data
@Entity
@Table(name = &quot;tb_people_phone&quot;)
public class PeoplePhone &#123;
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = &quot;phone_id&quot;)
    private Long phoneId;
    private String type;
    private String phone;
&#125;
</code></pre>
<p>测试代码：</p>
<pre><code class="java">    /**
     * 单向一对多查询
     */
    @Test
    public void testOneToMany()&#123;
        EntityManager entityManager = JpaUtils.getEntityManager();
        entityManager.getTransaction().begin(); // 开启事务

        PeoplePhone peoplePhoneA = new PeoplePhone();
        peoplePhoneA.setType(&quot;date_time&quot;);
        peoplePhoneA.setPhone(&quot;13011113333&quot;);
        PeoplePhone peoplePhoneB = new PeoplePhone();
        peoplePhoneB.setType(&quot;mobile&quot;);
        peoplePhoneB.setPhone(&quot;0208514851&quot;);
        entityManager.persist(peoplePhoneA);
        entityManager.persist(peoplePhoneB);

        People people = new People();
        people.setName(&quot;Sam&quot;);
        people.getPeoplePhones().add(peoplePhoneA);
        people.getPeoplePhones().add(peoplePhoneB);
        entityManager.persist(people);
        entityManager.getTransaction().commit(); // 提交更新事务

        // 查询拥有端（主键表端，注意：单向一对多是配置在 一方/拥有端）
        System.out.println(entityManager.find(People.class,people.getPeopleId()));
        entityManager.close();
    &#125;
</code></pre>
<p>查看日志1：（建表语句）</p>
<pre><code class="verilog">Hibernate: 
    
    create table tb_people (
       people_id bigint not null auto_increment,
        name varchar(255),
        primary key (people_id)
    ) engine=InnoDB
Hibernate: 
    
    create table tb_people_phone (
       phone_id bigint not null auto_increment,
        phone varchar(255),
        type varchar(255),
        people_id bigint,
        primary key (phone_id)
    ) engine=InnoDB
Hibernate: 
    
    alter table tb_people_phone 
       add constraint FKnied6axrmqsyl5olnjywa7set 
       foreign key (people_id) 
       references t_people (people_id)
</code></pre>
<p>查看日志2：</p>
<pre><code class="verilog">Hibernate: 
    insert 
    into
        tb_people_phone
        (phone, type) 
    values
        (?, ?)
Hibernate: 
    insert 
    into
        tb_people_phone
        (phone, type) 
    values
        (?, ?)
Hibernate: 
    insert 
    into
        tb_people
        (name) 
    values
        (?)
Hibernate: 
    update
        tb_people_phone 
    set
        people_id=? 
    where
        phone_id=?
Hibernate: 
    update
        tb_people_phone 
    set
        people_id=? 
    where
        phone_id=?
People(peopleId=1, name=Sam, peoplePhones=[PeoplePhone(phoneId=1, type=date_time, phone=13011113333), PeoplePhone(phoneId=2, type=mobile, phone=0208514851)])
</code></pre>
<pre><code class="sql">mysql&gt; select * from tb_people;
+-----------+------+
| people_id | name |
+-----------+------+
|         1 | Sam  |
+-----------+------+
1 row in set (0.01 sec)

mysql&gt; select * from tb_people_phone;
+----------+-------------+-----------+-----------+
| phone_id | phone       | type      | people_id |
+----------+-------------+-----------+-----------+
|        1 | 13011113333 | date_time |         1 |
|        2 | 0208514851  | mobile    |         1 |
+----------+-------------+-----------+-----------+
2 rows in set (0.02 sec)
</code></pre>
<h3 id="2-2、单向多对一"><a href="#2-2、单向多对一" class="headerlink" title="2.2、单向多对一"></a>2.2、单向多对一</h3><p>单向N-1：需要在控制关系的一方实体中使用注解 @ManyToOne 和 @JoinColumn 标注类型为对方的属性。</p>
<p>清单 7：单向多对一关系的拥有端（多方、外键表方、从表）</p>
<pre><code class="java">@Data
@Entity
@Table(name = &quot;tb_people_phone&quot;)
public class PeoplePhone &#123;
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = &quot;phone_id&quot;)
    private Long phoneId;
    private String type;
    private String phone;
    /**
     * @JoinColumn
     *     name 指定外键列
     *     referencedColumnName: people 表主键字段（数据库字段名）
     */
    @ManyToOne
    @JoinColumn(name=&quot;people_id&quot;, referencedColumnName = &quot;people_id&quot;)
    private People people;
&#125;
</code></pre>
<p>清单 8：单向多对一关系的被拥有端（一方、主键表方、主表）</p>
<pre><code class="java">@Data
@Entity
@Table(name = &quot;tb_people&quot;)
public class People &#123;
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = &quot;people_id&quot;)
    private Long peopleId;
    private String name;
&#125;
</code></pre>
<p>测试代码：</p>
<pre><code class="java">    /**
     * 单向多对一查询
     */
    @Test
    public void testManyToOne()&#123;
        EntityManager entityManager = JpaUtils.getEntityManager();
        entityManager.getTransaction().begin();// 开启事务

        // 先保存主键（被维护端）数据
        People people = new People();
        people.setName(&quot;Sam&quot;);
        entityManager.persist(people);

        // 然后保存外键（维护端）数据
        PeoplePhone peoplePhoneA = new PeoplePhone();
        peoplePhoneA.setType(&quot;date_time&quot;);
        peoplePhoneA.setPhone(&quot;13011113333&quot;);
        peoplePhoneA.setPeople(people);
        PeoplePhone peoplePhoneB = new PeoplePhone();
        peoplePhoneB.setType(&quot;mobile&quot;);
        peoplePhoneB.setPhone(&quot;0208514851&quot;);
        peoplePhoneB.setPeople(people);
        entityManager.persist(peoplePhoneA);
        entityManager.persist(peoplePhoneB);

        entityManager.getTransaction().commit();// 提交更新事务

        // 查询拥有端（外键表端，注意：单向多对一是配置在多方外键拥有端）
        entityManager.clear();
        System.out.println(entityManager.find(PeoplePhone.class,peoplePhoneA.getPhoneId()));
        System.out.println(entityManager.find(PeoplePhone.class,peoplePhoneB.getPhoneId()));
        entityManager.close();
    &#125;
</code></pre>
<p>查看日志：</p>
<pre><code class="verilog">Hibernate: // 插入数据
    insert 
    into
        tb_people
        (name) 
    values
        (?)
Hibernate: // 插入数据
    insert 
    into
        tb_people_phone
        (people_id, phone, type) 
    values
        (?, ?, ?)
Hibernate: // 插入数据
    insert 
    into
        tb_people_phone
        (people_id, phone, type) 
    values
        (?, ?, ?)
Hibernate: // 查询拥有端
    select
        peoplephon0_.phone_id as phone_id1_4_0_,
        peoplephon0_.people_id as people_i4_4_0_,
        peoplephon0_.phone as phone2_4_0_,
        peoplephon0_.type as type3_4_0_,
        people1_.people_id as people_i1_3_1_,
        people1_.name as name2_3_1_ 
    from
        tb_people_phone peoplephon0_ 
    left outer join
        tb_people people1_ 
            on peoplephon0_.people_id=people1_.people_id 
    where
        peoplephon0_.phone_id=?
PeoplePhone(phoneId=1, type=date_time, phone=13011113333, people=People(peopleId=1, name=Sam))
Hibernate: // 查询拥有端
    select
        peoplephon0_.phone_id as phone_id1_4_0_,
        peoplephon0_.people_id as people_i4_4_0_,
        peoplephon0_.phone as phone2_4_0_,
        peoplephon0_.type as type3_4_0_,
        people1_.people_id as people_i1_3_1_,
        people1_.name as name2_3_1_ 
    from
        tb_people_phone peoplephon0_ 
    left outer join
        tb_people people1_ 
            on peoplephon0_.people_id=people1_.people_id 
    where
        peoplephon0_.phone_id=?
PeoplePhone(phoneId=2, type=mobile, phone=0208514851, people=People(peopleId=1, name=Sam))
</code></pre>
<pre><code class="sql">mysql&gt; select * from tb_people;
+-----------+------+
| people_id | name |
+-----------+------+
|         1 | Sam  |
+-----------+------+
1 row in set (0.02 sec)

mysql&gt; select * from tb_people_phone;
+----------+-------------+-----------+-----------+
| phone_id | phone       | type      | people_id |
+----------+-------------+-----------+-----------+
|        1 | 13011113333 | date_time |         1 |
|        2 | 0208514851  | mobile    |         1 |
+----------+-------------+-----------+-----------+
</code></pre>
<h3 id="2-3、双向一对多"><a href="#2-3、双向一对多" class="headerlink" title="2.3、双向一对多"></a>2.3、双向一对多</h3><p>双向1-N（N-1）：1的一端需要使用注解<code>@OneToMany</code>标注类型为对方的集合属性，同时指定<code>mappedBy</code>属性表示1的一端不控制关系，N的一端则需要使用注解@ManyToOne 和 @JoinColumn 标注类型为对方的属性。</p>
<p>清单 9：双向一对多关系的接受端（一方、主键表方、主表）</p>
<pre><code class="java">@Data
@Entity
@Table(name = &quot;tb_people&quot;)
public class People &#123;
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = &quot;people_id&quot;)
    private Long peopleId;
    private String name;
    /**
     * mappedBy：指定从表实体类中引用主表对象的名称。指明这端不控制关系
     * targetEntity:指定多的一方的类的字节码
     * cascade ：指定要使用的级联操作
     * fetch   ：指定是否采用延迟加载
     * orphanRemoval：是否使用孤儿删除
     */
    @OneToMany(
            mappedBy = &quot;people&quot;,
            targetEntity = PeoplePhone.class,
            cascade = CascadeType.ALL,
            fetch = FetchType.LAZY)
    private List&lt;PeoplePhone&gt; peoplePhones = new ArrayList&lt;&gt;();
&#125;
</code></pre>
<p>清单 10：双向一对多关系的发出端（多方、外键表方、从表）</p>
<pre><code class="java">@Data
@Entity
@Table(name = &quot;tb_people_phone&quot;)
public class PeoplePhone &#123;
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = &quot;phone_id&quot;)
    private Long phoneId;
    private String type;
    private String phone;
    /**
     * @JoinColumn
     *     name 指定外键列
     *     referencedColumnName: people 表主键字段（数据库字段名）
     */
    @ManyToOne // cascade | fetch | targetEntity 都是可选
    @JoinColumn(name=&quot;people_id&quot;, referencedColumnName = &quot;people_id&quot;)
    private People people;
&#125;
</code></pre>
<p>测试代码：</p>
<pre><code class="java">    /**
     * 双向一对多查询
     */
    @Test
    public void testManyToOne()&#123;
        EntityManager entityManager = JpaUtils.getEntityManager();
        entityManager.getTransaction().begin();// 开启事务

        // 先保存主键（被维护端）数据
        People people = new People();
        people.setName(&quot;Sam&quot;);
        entityManager.persist(people);

        // 然后保存外键（维护端）数据
        PeoplePhone peoplePhoneA = new PeoplePhone();
        peoplePhoneA.setType(&quot;date_time&quot;);
        peoplePhoneA.setPhone(&quot;13011113333&quot;);
        peoplePhoneA.setPeople(people);
        PeoplePhone peoplePhoneB = new PeoplePhone();
        peoplePhoneB.setType(&quot;mobile&quot;);
        peoplePhoneB.setPhone(&quot;0208514851&quot;);
        peoplePhoneB.setPeople(people);
        entityManager.persist(peoplePhoneA);
        entityManager.persist(peoplePhoneB);

        entityManager.getTransaction().commit();// 提交更新事务

        entityManager.clear();
        // 查询被拥有端（主键表端）
        System.out.println(entityManager.find(People.class,people.getPeopleId()));
        // 查询拥有端（外键表端，注意：单向多对一是配置在多方外键拥有端）
        System.out.println(entityManager.find(PeoplePhone.class,peoplePhoneA.getPhoneId()));
        System.out.println(entityManager.find(PeoplePhone.class,peoplePhoneB.getPhoneId()));
        entityManager.close();
    &#125;
</code></pre>
<p>查看日志（建表语句就不重复打印了，因为是一摸一样的）：</p>
<pre><code class="verilog">// ...省略插入语句和查询语句

java.lang.StackOverflowError
    at java.lang.StringBuilder.append(StringBuilder.java:136)
    at OneToMany.PeoplePhone.toString(PeoplePhone.java:7)
    at java.lang.String.valueOf(String.java:2994)
    at java.lang.StringBuilder.append(StringBuilder.java:131)
    at java.util.AbstractCollection.toString(AbstractCollection.java:462)
    at org.hibernate.collection.internal.PersistentBag.toString(PersistentBag.java:538)
    at java.lang.String.valueOf(String.java:2994)
    at java.lang.StringBuilder.append(StringBuilder.java:131)
    at OneToMany.People.toString(People.java:9)
    at java.lang.String.valueOf(String.java:2994)
    at java.lang.StringBuilder.append(StringBuilder.java:131)
    at OneToMany.PeoplePhone.toString(PeoplePhone.java:7)
...
</code></pre>
<blockquote>
<p>现在在查询步骤中会出现死循环（后面解决）</p>
</blockquote>
<h2 id="3、多对多关联映射"><a href="#3、多对多关联映射" class="headerlink" title="3、多对多关联映射"></a>3、多对多关联映射</h2><h3 id="3-1、单向多对多"><a href="#3-1、单向多对多" class="headerlink" title="3.1、单向多对多"></a>3.1、单向多对多</h3><p>单向N-N：需要在控制关系的一方实体中使用注解@ManyToMany 和 @JoinTable标注类型为对方的属性，这里应该是一个集合属性</p>
<p>清单 11：单向多对多关系的发出端（拥有端）</p>
<pre><code class="java">@Data
@Entity
@Table(name = &quot;tb_role&quot;)
public class Role &#123;
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = &quot;role_id&quot;)
    private Long roleId;
    @Column(name = &quot;role_name&quot;)
    private String roleName;

    /**
     * @JoinTable:
     *   name：中间表名称
     *   joinColumns          中间表对应本类的信息
     *     @JoinColumn；
     *       name：本类的外键字段（中间表的数据库字段）
     *       referencedColumnName：本类与外键(表)对应的主键（本类的主键字段）
     *   inverseJoinColumns    中间表对应对方类的信息
     *     @JoinColumn：
     *       name：对方类的外键（中间表的数据字段）
     *       referencedColumnName：对方类与外键(表)对应的主键（对方类的主键字段）
     */
    @ManyToMany
    @JoinTable(name=&quot;tb_role_permission&quot;, // 中间表明
            joinColumns=@JoinColumn(
                    name=&quot;role_id&quot;, // 本类的外键
                    referencedColumnName = &quot;role_id&quot;), // 本类与外键(表)对应的主键
            inverseJoinColumns=@JoinColumn(
                    name=&quot;permission_id&quot;, // 对方类的外键
                    referencedColumnName = &quot;permission_id&quot;)) // 对方类与外键(表)对应的主键
    private Set&lt;Permission&gt; permissions = new HashSet&lt;&gt;();
&#125;
</code></pre>
<p>清单 11：单向多对多关系的接收端（被拥有端）什么都不用配置</p>
<pre><code class="java">@Data
@Entity
@Table(name = &quot;tb_permission&quot;)
public class Permission &#123;
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = &quot;permission_id&quot;)
    private Long permissionId;
    @Column(name = &quot;permission_name&quot;)
    private String permissionName;
&#125;
</code></pre>
<p>测试代码：</p>
<pre><code class="java">    /**
     * 单向多对多
     */
    @Test
    public void testManyToMany()&#123;
        EntityManager entityManager = JpaUtils.getEntityManager();
        // 开启事务
        entityManager.getTransaction().begin();

        // 增加权限数据
        Permission permissionA = new Permission();
        permissionA.setPermissionName(&quot;增加&quot;);
        Permission permissionB = new Permission();
        permissionB.setPermissionName(&quot;查询&quot;);
        entityManager.persist(permissionA);
        entityManager.persist(permissionB);
        entityManager.persist(permissionB);

        // 增加角色数据
        Role role = new Role();
        role.setRoleName(&quot;网络管理员&quot;);
        role.getPermissions().add(permissionA);
        role.getPermissions().add(permissionB);
        entityManager.persist(role);

        // 提交更新事务
        entityManager.getTransaction().commit();

        // 查询角色信息
        entityManager.clear();
        System.out.println(entityManager.find(Role.class,role.getRoleId()));
        entityManager.close();
    &#125;
</code></pre>
<p>查看日志1：（建表语句）</p>
<pre><code class="verilog">Hibernate: 
    
    create table tb_permission (
       permission_id bigint not null auto_increment,
        permission_name varchar(255),
        primary key (permission_id)
    ) engine=InnoDB
Hibernate: 
    
    create table tb_role (
       role_id bigint not null auto_increment,
        role_name varchar(255),
        primary key (role_id)
    ) engine=InnoDB
Hibernate: 
    
    create table tb_role_permission (
       role_id bigint not null,
        permission_id bigint not null,
        primary key (role_id, permission_id)
    ) engine=InnoDB
Hibernate: 
    
    alter table tb_role_permission 
       add constraint FKjobmrl6dorhlfite4u34hciik 
       foreign key (permission_id) 
       references tb_permission (permission_id)
Hibernate: 
    
    alter table tb_role_permission 
       add constraint FK90j038mnbnthgkc17mqnoilu9 
       foreign key (role_id) 
       references tb_role (role_id)
</code></pre>
<p>查看日志2：（数据插入与查询）</p>
<pre><code class="verilog">Hibernate: 
    insert 
    into
        tb_permission
        (permission_name) 
    values
        (?)
Hibernate: 
    insert 
    into
        tb_permission
        (permission_name) 
    values
        (?)
Hibernate: 
    insert 
    into
        tb_role
        (role_name) 
    values
        (?)
Hibernate: 
    insert 
    into
        tb_role_permission
        (role_id, permission_id) 
    values
        (?, ?)
Hibernate: 
    insert 
    into
        tb_role_permission
        (role_id, permission_id) 
    values
        (?, ?)
Hibernate: 
    select
        role0_.role_id as role_id1_6_0_,
        role0_.role_name as role_nam2_6_0_ 
    from
        tb_role role0_ 
    where
        role0_.role_id=?
Hibernate: 
    select
        permission0_.role_id as role_id1_0_0_,
        permission0_.permission_id as permissi2_0_0_,
        permission1_.permission_id as permissi1_3_1_,
        permission1_.permission_name as permissi2_3_1_ 
    from
        tb_role_permission permission0_ 
    inner join
        tb_permission permission1_ 
            on permission0_.permission_id=permission1_.permission_id 
    where
        permission0_.role_id=?
Role(roleId=1, roleName=网络管理员, permissions=[Permission(permissionId=2, permissionName=查询), Permission(permissionId=1, permissionName=增加)])
</code></pre>
<pre><code class="sql">mysql&gt; select * from tb_role;
+---------+------------+
| role_id | role_name  |
+---------+------------+
|       1 | 网络管理员 |
+---------+------------+
1 row in set (0.05 sec)
mysql&gt; select * from tb_permission;
+---------------+-----------------+
| permission_id | permission_name |
+---------------+-----------------+
|             1 | 增加            |
|             2 | 查询            |
+---------------+-----------------+
2 rows in set (0.06 sec)
mysql&gt; select * from tb_role_permission;
+---------+---------------+
| role_id | permission_id |
+---------+---------------+
|       1 |             3 |
|       1 |             4 |
+---------+---------------+
2 rows in set (0.05 sec)
</code></pre>
<p>PS：单向多对多反过来配置到另一个类也是一样。只需要把本类的外键和对方类外键调换一下即可。</p>
<h3 id="3-2、双向多对多"><a href="#3-2、双向多对多" class="headerlink" title="3.2、双向多对多"></a>3.2、双向多对多</h3><p>发出端（拥有端）代码不变</p>
<pre><code class="java">@Data
@Entity
@Table(name = &quot;t_role&quot;)
public class Role &#123;
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = &quot;role_id&quot;)
    private Long roleId;
    @Column(name = &quot;role_name&quot;)
    private String roleName;

    /**
     * @JoinTable:
     *   name：中间表名称
     *   joinColumns          中间表对应本类的信息
     *     @JoinColumn；
     *       name：本类的外键字段（中间表的数据库字段）
     *       referencedColumnName：本类与外键(表)对应的主键（本类的主键字段）
     *   inverseJoinColumns    中间表对应对方类的信息
     *     @JoinColumn：
     *       name：对方类的外键（中间表的数据字段）
     *       referencedColumnName：对方类与外键(表)对应的主键（对方类的主键字段）
     */
    @ManyToMany
    @JoinTable(name=&quot;t_role_permission&quot;, // 中间表明
            joinColumns=@JoinColumn(
                    name=&quot;role_id&quot;, // 本类的外键
                    referencedColumnName = &quot;role_id&quot;), // 本类与外键(表)对应的主键
            inverseJoinColumns=@JoinColumn(
                    name=&quot;permission_id&quot;, // 对方类的外键
                    referencedColumnName = &quot;permission_id&quot;)) // 对方类与外键(表)对应的主键
    private Set&lt;Permission&gt; permissions = new HashSet&lt;&gt;();
&#125;
</code></pre>
<p>接收端（被拥有端）代码增加了@ManyToMany 注解和<code>mappedBy</code>属性</p>
<pre><code class="java">@Data
@Entity
@Table(name = &quot;t_permission&quot;)
public class Permission &#123;
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = &quot;permission_id&quot;)
    private Long permissionId;
    @Column(name = &quot;permission_name&quot;)
    private String permissionName;

    /**
     * @ManyToMany
     *   mappedBy:对方类应用该类的属性名，指明这端不控制关系
     *   cascade | fetch | targetEntity 为可选属性
     */
    @ManyToMany(mappedBy = &quot;permissions&quot;)
    private Set&lt;Role&gt; role = new HashSet&lt;&gt;();
&#125;
</code></pre>
<p>测试代码：</p>
<pre><code class="java">    /**
     * 单向/双向 多对多查询代码
     */
    @Test
    public void testManyToManyFind()&#123;
        EntityManager entityManager = JpaUtils.getEntityManager();
        System.out.println(entityManager.find(Role.class,1L));
        System.err.println(&quot;--------------华丽的分割线-------------------&quot;);
        System.out.println(entityManager.find(Permission.class,1L));
        entityManager.close();
    &#125;
</code></pre>
<p>可以发现单向查询依旧正常，而双向查询 <strong>依旧会有死循环问题</strong>（该问题在SpringDataJPA篇章中解决）</p>
<h1 id="Hibernate-JPA-逻辑删除"><a href="#Hibernate-JPA-逻辑删除" class="headerlink" title="Hibernate JPA 逻辑删除"></a>Hibernate JPA 逻辑删除</h1><p>在实际开发中，删除操作往往通过修改状态码来实现软删除，以保留历史数据。但JPA中提供的delete方法是直接删除该记录，与需求不符，很难直接使用。如果使用状态码的话，删除需要先查询，再改状态最后调用save方法，查询也需要加上状态码，使用起来比较繁琐。<br>对于这种需求，</p>
<h2 id="1、什么是逻辑删除"><a href="#1、什么是逻辑删除" class="headerlink" title="1、什么是逻辑删除"></a>1、什么是逻辑删除</h2><p>所谓逻辑删除是指数据已经“不需要”了，但是并没有使用delete语句将这些数据真实的从数据库中删除，而只是用一个标志位将其设置为已经删除。查询也需要加上标志位。</p>
<h2 id="2、为什么需要逻辑删除"><a href="#2、为什么需要逻辑删除" class="headerlink" title="2、为什么需要逻辑删除"></a>2、为什么需要逻辑删除</h2><p>对数据进行逻辑删除，一般存在以下原因：</p>
<ol>
<li>防止数据误删除，不能找回数据；</li>
<li>这些数据还具有一定的商业价值，比如用户的注册信息；</li>
<li>虽然这些数据可以删除，但是这些数据还有关联数据，这些关联数据不能删除。</li>
</ol>
<p>对数据进行逻辑删除，可以保证数据的安全性和完整性。但是，逻辑删除也会带来的一些问题：</p>
<p>数据库表的数据冗余，导致查询缓慢；</p>
<ol>
<li>写sql进行数据处理时需要排除那些已经逻辑删除的数据，这就会导致sql复杂，容易出错，特别是涉及多表查询时；</li>
<li>进行逻辑删除时，还需要考虑与之相关的数据怎么处理；</li>
<li>还有，如果数据表的某个字段要求唯一，并强制约束，比如用户表中的登录用户名字段，设计为逻辑删除的话，一旦有新的同用户名记录就无法插入。但如果不将该字段设置为唯一性约束的，那么在每次插入数据的时候，都需先进行一次查询，看看有无未（逻辑）删除的同名记录存在，低效率是一回事，而且在高并发的系统中，很难保证其正确性。</li>
</ol>
<p>所以是否需要对数据进行逻辑删除，需要根据具体的业务场景，以及逻辑删除的优缺点进行综合考虑。</p>
<p>综合考虑，对于中小型的项目，逻辑删除所带来的好处有限，但带来的问题却很多。如果平时做好数据备份工作，还是可以预防物理删除隐患的。但心里应该清除，当项目大到一定程度，对数据安全性的要求高到一定程度，使用逻辑删除代替物理删除是必然的，在后面的数据库设计中，可以先小范围的尝试使用逻辑删除，一旦开发模式成熟，就全面使用逻辑删除代替物理删除。</p>
<h2 id="3、JPA-实现逻辑删除"><a href="#3、JPA-实现逻辑删除" class="headerlink" title="3、JPA 实现逻辑删除"></a>3、JPA 实现逻辑删除</h2><p>我们可以通过jpa提供的<code>@Where</code>与<code>@SQLDelete</code>两个注解来实现：</p>
<ol>
<li>通过<code>@SQLDelete</code>注解，可以替换jpa默认的delete的实现sql。</li>
<li>通过<code>@Where</code>注解，可以给所有通过JPA生成的查询语句拼接一段自定义sql。</li>
<li><code>@SQLDeleteAll</code>、<code>@SQLInsert</code>和<code>@SQLUpdate</code>功能都差不多。</li>
</ol>
<p>如果我们需要实现逻辑删除，那么就应该实现以下功能：</p>
<ol>
<li>修改删除语句，通过status字段进行删除。</li>
<li>在查询时带上状态码进行查询</li>
</ol>
<p>假设我们定义status为状态码，1为正常，2为删除，那么实体类上面可以加上如下注解：</p>
<pre><code class="java">@Data
@Entity
@Table(name = &quot;sys_user&quot;)
@SQLDelete(sql = &quot;update sys_user set deleted = 0 where id = ?&quot;)
@Where(clause = &quot;deleted != 0&quot;)
public class User &#123;
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String username;
    private String password;
    /**
     * 逻辑删除标志位，0 未删除，1 已删除
     */
    private Integer deleted;
&#125;
</code></pre>
<h2 id="4、更新当前-session-中的删除状态"><a href="#4、更新当前-session-中的删除状态" class="headerlink" title="4、更新当前 session 中的删除状态"></a>4、更新当前 session 中的删除状态</h2><p>由于 @SQLDelete 的原理是在生成 SQL 语句的时候对默认的 delete 语句进行替换，因此，Hibernate 并不知道他所管理的 Entity 的相应字段在执行过删除操作后进行了改变。通常情况下，这并没有什么问题，因为只要 Hibernate 执行了逻辑删除的 SQL，新的实体在查询的时候就会感知到删除状态。然而，在某些情况下，如执行了 EntityManager.remove(Object entity) 后，并没有立即 flush 到数据库，并立即对该 entity 进行操作，那么此时 entity 的相应字段并不会变为删除状态。解决这种情况的方法就是通过 @PreRemove 注解来注册一个回调函数，在该函数中更新相应字段的状态。这样，Hibernate 在执行删除之前，会回调该方法，从而更新相应字段的状态。</p>
<pre><code class="java">@Data
@Entity
@Table(name = &quot;sys_user&quot;)
@SQLDelete(sql = &quot;update sys_user set deleted = 0 where id = ?&quot;)
@Where(clause = &quot;deleted != 0&quot;)
public class User &#123;
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String username;
    private String password;
    /**
     * 逻辑删除标志位，0 未删除，1 已删除
     */
    private Integer deleted;
    
    /**
     * 更新当前 session 中的删除状态
     */
    @PreRemove
    public void deleteUser() &#123;
        this.deleted = 1;
    &#125;
&#125;
</code></pre>
<p>如果想实现物理删除与逻辑删除同时存在，可以参考：JPA和Mybatis的逻辑删除：<a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1948671">https://cloud.tencent.com/developer/article/1948671</a></p>
<h1 id="参考文献-鸣谢"><a href="#参考文献-鸣谢" class="headerlink" title="参考文献 &amp; 鸣谢"></a>参考文献 &amp; 鸣谢</h1><ol>
<li>Hibernate ORM 6.1.7.Final User Guide：<a target="_blank" rel="noopener" href="https://docs.jboss.org/hibernate/orm/current/userguide/html_single/Hibernate_User_Guide.html">https://docs.jboss.org/hibernate/orm/current/userguide/html_single/Hibernate_User_Guide.html</a></li>
<li>CSDN（C语言中文社区）十分钟入门 JPA：<a target="_blank" rel="noopener" href="https://blog.csdn.net/csdn_wangchong/article/details/103095115">https://blog.csdn.net/csdn_wangchong/article/details/103095115</a></li>
<li>CSDN（詠聖wK）JPA注解大全详解参考手册：<a target="_blank" rel="noopener" href="https://blog.csdn.net/yswKnight/article/details/79257372">https://blog.csdn.net/yswKnight/article/details/79257372</a></li>
<li>CSDN（入秋枫叶）JPA注释详解参考手册：<a target="_blank" rel="noopener" href="https://blog.csdn.net/yiyelanxin/article/details/100107335">https://blog.csdn.net/yiyelanxin/article/details/100107335</a></li>
<li>JPA注解大全详解参考手册：<a target="_blank" rel="noopener" href="https://www.e-learn.cn/topic/2044460">https://www.e-learn.cn/topic/2044460</a></li>
<li>Chapter 4 - JPA Queries (JPQL &#x2F; Criteria) (objectdb.com)：<a target="_blank" rel="noopener" href="https://www.objectdb.com/java/jpa/query">https://www.objectdb.com/java/jpa/query</a></li>
<li><strong>JPA效率优化—@EntityGraph：<a target="_blank" rel="noopener" href="https://juejin.cn/post/6869650227268157454">https://juejin.cn/post/6869650227268157454</a></strong></li>
</ol>

      
       <hr><span style="font-style: italic;color: gray;"> 转载请注明来源，欢迎对文章中的引用来源进行考证，欢迎指出任何有错误或不够清晰的表达。可以在下面评论区评论，也可以邮件至 8629303@qq.com </span>
    </div>
</article>


<p>
    <a  class="dashang" onclick="dashangToggle()">赏</a>
</p>






    




    </div>
    <div class="copyright">
        <p class="footer-entry">
    ©2017-2024 Sam
</p>
<p class="footer-entry">Built with <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/yelog/hexo-theme-3-hexo" target="_blank">3-hexo</a> theme</p>

    </div>
    <div class="full-toc">
        <button class="full" data-title="切换全屏 快捷键 s"><span class="min "></span></button>
<a class="" id="rocket" ></a>

    </div>
</div>

<div class="hide_box" onclick="dashangToggle()"></div>
<div class="shang_box">
    <a class="shang_close"  onclick="dashangToggle()">×</a>
    <div class="shang_tit">
        <p>喜欢就点赞,疼爱就打赏</p>
    </div>
    <div class="shang_payimg">
        <div class="pay_img">
            <img src="/img/alipay.jpg" class="alipay" title="扫码支持">
            <img src="/img/weixin.jpg" class="weixin" title="扫码支持">
        </div>
    </div>
    <div class="shang_payselect">
        <span><label><input type="radio" name="pay" checked value="alipay">支付宝</label></span><span><label><input type="radio" name="pay" value="weixin">微信</label></span>
    </div>
</div>


</body>
<script src="/js/jquery.pjax.js?v=1.1.0" ></script>

<script src="/js/script.js?v=1.1.0" ></script>
<script>
    var img_resize = 'default';
    function initArticle() {
        /*渲染对应的表格样式*/
        
            $("#post .pjax table").addClass("green_title");
        

        /*渲染打赏样式*/
        
        $("input[name=pay]").on("click", function () {
            if($("input[name=pay]:checked").val()=="weixin"){
                $(".shang_box .shang_payimg .pay_img").addClass("weixin_img");
            } else {
                $(".shang_box .shang_payimg .pay_img").removeClass("weixin_img");
            }
        })
        

        /*高亮代码块行号*/
        
        $('pre code').each(function(){
            var lines = $(this).text().trim().split('\n').length, widther='';
            if (lines>99) {
                widther = 'widther'
            }
            var $numbering = $('<ul/>').addClass('pre-numbering ' + widther).attr("unselectable","on");
            $(this).addClass('has-numbering ' + widther)
                    .parent()
                    .append($numbering);
            for(var i=1;i<=lines;i++){
                $numbering.append($('<li/>').text(i));
            }
        });
        

        /*访问数量*/
        
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js");
        

        /*代码高亮，行号对齐*/
        $('.pre-numbering').css('line-height',$('.has-numbering').css('line-height'));

        
        
    }

    /*打赏页面隐藏与展示*/
    
    function dashangToggle() {
        $(".shang_box").fadeToggle();
        $(".hide_box").fadeToggle();
    }
    

</script>

<!--加入行号的高亮代码块样式-->

<style>
    pre{
        position: relative;
        margin-bottom: 24px;
        border-radius: 10px;
        border: 1px solid #e2dede;
        background: #FFF;
        overflow: hidden;
    }
    code.has-numbering{
        margin-left: 30px;
    }
    code.has-numbering.widther{
        margin-left: 35px;
    }
    .pre-numbering{
        margin: 0;
        position: absolute;
        top: 0;
        left: 0;
        width: 20px;
        padding: 18px 3px 15px 5px;
        border-right: 1px solid #C3CCD0;
        text-align: right;
        color: #AAA;
        background-color: #fafafa;
    }
    .pre-numbering.widther {
        width: 35px;
    }
</style>

<!--自定义样式设置-->
<style>
    
    
    .nav {
        width: 582px;
    }
    .nav.fullscreen {
        margin-left: -582px;
    }
    .nav-left {
        width: 160px;
    }
    
    
    @media screen and (max-width: 1468px) {
        .nav {
            width: 492px;
        }
        .nav.fullscreen {
            margin-left: -492px;
        }
        .nav-left {
            width: 100px;
        }
    }
    
    
    @media screen and (max-width: 1024px) {
        .nav {
            width: 492px;
            margin-left: -492px
        }
        .nav.fullscreen {
            margin-left: 0;
        }
    }
    
    @media screen and (max-width: 426px) {
        .nav {
            width: 100%;
        }
        .nav-left {
            width: 100%;
        }
    }
    
    
    .nav-right .title-list nav a .post-title, .nav-right .title-list #local-search-result a .post-title {
        color: #383636;
    }
    
    
    .nav-right .title-list nav a .post-date, .nav-right .title-list #local-search-result a .post-date {
        color: #5e5e5f;
    }
    
    
    .nav-right nav a.hover, #local-search-result a.hover{
        background-color: #e2e0e0;
    }
    
    

    /*列表样式*/
    

    /* 背景图样式 */
    
    


    /*引用块样式*/
    

    /*文章列表背景图*/
    

    
</style>







</html>
