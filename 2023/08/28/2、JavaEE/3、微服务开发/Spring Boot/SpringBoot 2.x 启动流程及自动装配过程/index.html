<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>SpringBoot 2.x 启动流程及自动装配过程 | Hexo</title>
  <meta name="keywords" content="">
  <meta name="description" content="SpringBoot 2.x 启动流程及自动装配过程 | Hexo">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="description" content="请不要自己写，Spring Boot非常实用的内置功能：https:&#x2F;&#x2F;juejin.cn&#x2F;post&#x2F;7417630844100231206  在 SpringBoot 框架中，内置了许多实用的功能，这些功能可以帮助开发者高效地开发和维护应用程序。 一、请求数据记录器SpringBoot 提供了一个内置的日志记录解决方案，通过 AbstractRequestLoggingFilter 可以记录请">
<meta property="og:type" content="article">
<meta property="og:title" content="SpringBoot2.x 内置功能 - 内置过滤器和 AOP 工具类">
<meta property="og:url" content="https://8629303.github.io/2024/10/08/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot2.x%20%E5%86%85%E7%BD%AE%E5%8A%9F%E8%83%BD%20-%20%E5%86%85%E7%BD%AE%E8%BF%87%E6%BB%A4%E5%99%A8%E5%92%8C%20AOP%20%E5%B7%A5%E5%85%B7%E7%B1%BB/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="请不要自己写，Spring Boot非常实用的内置功能：https:&#x2F;&#x2F;juejin.cn&#x2F;post&#x2F;7417630844100231206  在 SpringBoot 框架中，内置了许多实用的功能，这些功能可以帮助开发者高效地开发和维护应用程序。 一、请求数据记录器SpringBoot 提供了一个内置的日志记录解决方案，通过 AbstractRequestLoggingFilter 可以记录请">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2024-10-08T08:44:19.743Z">
<meta property="article:modified_time" content="2024-10-22T03:50:18.319Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">


<link rel="icon" href="/img/avatar.jpg">

<link href="/blog/css/style.css?v=1.1.0" rel="stylesheet">

<link href="/blog/css/hl_theme/atom-light.css?v=1.1.0" rel="stylesheet">

<link href="//cdn.jsdelivr.net/npm/animate.css@4.1.0/animate.min.css" rel="stylesheet">

<script src="//cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
<script src="/blog/js/titleTip.js?v=1.1.0" ></script>

<script src="//cdn.jsdelivr.net/npm/highlightjs@9.16.2/highlight.pack.min.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>

<script src="//cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script>



<script src="//cdn.jsdelivr.net/npm/jquery.cookie@1.4.1/jquery.cookie.min.js" ></script>

<script src="/blog/js/iconfont.js?v=1.1.0" ></script>

<meta name="generator" content="Hexo 7.3.0"></head>
<div style="display: none">
  <input class="theme_disqus_on" value="false">
  <input class="theme_preload_comment" value="">
  <input class="theme_blog_path" value="/blog">
  <input id="theme_shortcut" value="true" />
  <input id="theme_highlight_on" value="true" />
  <input id="theme_code_copy" value="true" />
</div>



<body>
<aside class="nav">
    <div class="nav-left">
        <a href="/blog/"
   class="avatar_target">
    <img class="avatar"
         src="/blog/img/avatar.jpg"/>
</a>
<div class="author">
    <span>John Doe</span>
</div>

<div class="icon">
    
        
            <a title="github"
               href="https://github.com/8629303"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-github"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="email"
               href="mailto:8629303@qq.com"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-email"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="qq"
               href="http://wpa.qq.com/msgrd?v=3&uin=8629303&site=qq&menu=yes"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-qq"></use>
                    </svg>
                
            </a>
        
    
</div>





<ul>
    <li>
        <div class="all active" data-rel="全部文章">全部文章
            
                <small>(172)</small>
            
        </div>
    </li>
    
        
            
                
    <li>
        <div data-rel="数据库">
            
            数据库
            <small>(5)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="开发工具">
            <i class="fold iconfont icon-right"></i>
            开发工具
            <small>(16)</small>
        </div>
        
            <ul class="sub hide">
                
                    
    <li>
        <div data-rel="开发工具&lt;---&gt;Maven">
            
            Maven
            <small>(8)</small>
        </div>
        
    </li>

                
            </ul>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="面试篇">
            
            面试篇
            <small>(1)</small>
        </div>
        
    </li>

            
        
    
        
            
        
    
        
            
        
    
        
            
                
    <li>
        <div data-rel="中间件">
            <i class="fold iconfont icon-right"></i>
            中间件
            <small>(9)</small>
        </div>
        
            <ul class="sub hide">
                
                    
    <li>
        <div data-rel="中间件&lt;---&gt;ElasticSearch">
            
            ElasticSearch
            <small>(1)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="中间件&lt;---&gt;MongoDB">
            
            MongoDB
            <small>(2)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="中间件&lt;---&gt;RabbitMQ">
            
            RabbitMQ
            <small>(3)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="中间件&lt;---&gt;Redis">
            
            Redis
            <small>(3)</small>
        </div>
        
    </li>

                
            </ul>
        
    </li>

            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
                
    <li>
        <div data-rel="JavaEE">
            <i class="fold iconfont icon-right"></i>
            JavaEE
            <small>(72)</small>
        </div>
        
            <ul class="sub hide">
                
                    
    <li>
        <div data-rel="JavaEE&lt;---&gt;微服务开发">
            
            微服务开发
            <small>(66)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="JavaEE&lt;---&gt;JavaWeb">
            
            JavaWeb
            <small>(2)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="JavaEE&lt;---&gt;SSM框架">
            
            SSM框架
            <small>(4)</small>
        </div>
        
    </li>

                
            </ul>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="JavaSE">
            <i class="fold iconfont icon-right"></i>
            JavaSE
            <small>(62)</small>
        </div>
        
            <ul class="sub hide">
                
                    
    <li>
        <div data-rel="JavaSE&lt;---&gt;Java汇总篇">
            
            Java汇总篇
            <small>(28)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="JavaSE&lt;---&gt;Java基础篇">
            
            Java基础篇
            <small>(8)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="JavaSE&lt;---&gt;Java进阶篇">
            
            Java进阶篇
            <small>(4)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="JavaSE&lt;---&gt;Java新特性">
            
            Java新特性
            <small>(17)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="JavaSE&lt;---&gt;Java性能测试与安全">
            
            Java性能测试与安全
            <small>(5)</small>
        </div>
        
    </li>

                
            </ul>
        
    </li>

            
        
    
        
            
        
    
        
            
        
    
        
            
                
    <li>
        <div data-rel="Linux">
            <i class="fold iconfont icon-right"></i>
            Linux
            <small>(7)</small>
        </div>
        
            <ul class="sub hide">
                
                    
    <li>
        <div data-rel="Linux&lt;---&gt;虚拟机工具">
            
            虚拟机工具
            <small>(2)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="Linux&lt;---&gt;Docker">
            
            Docker
            <small>(2)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="Linux&lt;---&gt;Kubernetes">
            
            Kubernetes
            <small>(2)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="Linux&lt;---&gt;Nginx">
            
            Nginx
            <small>(1)</small>
        </div>
        
    </li>

                
            </ul>
        
    </li>

            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
</ul>
<div class="left-bottom">
    <div class="menus">
        
            
            
            
    </div>
    <div>
        
            <a class="about  hasFriend  site_url"
               
               href="/about">关于</a>
        
        <a style="width: 50%"
                
                                           class="friends">友链</a>
        
    </div>
</div>
<input type="hidden" id="yelog_site_posts_number" value="172">

<div style="display: none">
    <span id="busuanzi_value_site_uv"></span>
    <span id="busuanzi_value_site_pv"></span>
</div>

    </div>
    <div class="nav-right">
        <div class="friends-area">
    <div class="friends-title">
        友情链接
        <i class="iconfont icon-left"></i>
    </div>
    <div class="friends-content">
        <ul>
            
            <li><a target="_blank" href="http://yelog.org/">叶落阁</a></li>
            
        </ul>
    </div>
</div>
        <div class="title-list">
    <div class="right-top">
        <div id="default-panel">
            <i class="iconfont icon-search" data-title="搜索 快捷键 i"></i>
            <div class="right-title">全部文章</div>
            <i class="iconfont icon-file-tree" data-title="切换到大纲视图 快捷键 w"></i>
        </div>
        <div id="search-panel">
            <i class="iconfont icon-left" data-title="返回"></i>
            <input id="local-search-input" autocomplete="off"/>
            <label class="border-line" for="input"></label>
            <i class="iconfont icon-case-sensitive" data-title="大小写敏感"></i>
            <i class="iconfont icon-tag" data-title="标签"></i>
        </div>
        <div id="outline-panel" style="display: none">
            <div class="right-title">大纲</div>
            <i class="iconfont icon-list" data-title="切换到文章列表"></i>
        </div>
    </div>

    <div class="tags-list">
    <input id="tag-search" />
    <div class="tag-wrapper">
        
    </div>

</div>

    
    <nav id="title-list-nav">
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2024/10/08/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot2.x%20%E5%86%85%E7%BD%AE%E5%8A%9F%E8%83%BD%20-%20%E5%86%85%E7%BD%AE%E8%BF%87%E6%BB%A4%E5%99%A8%E5%92%8C%20AOP%20%E5%B7%A5%E5%85%B7%E7%B1%BB/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot2.x 内置功能 - 内置过滤器和 AOP 工具类">SpringBoot2.x 内置功能 - 内置过滤器和 AOP 工具类</span>
            <span class="post-date" title="2024-10-08 16:44:19">2024/10/08</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2024/10/08/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%E7%B3%BB%E5%88%97-%E5%85%A8%E7%BD%91%E6%9C%80%E5%85%A8%E7%9A%84%E7%89%88%E6%9C%AC%E5%8F%98%E6%9B%B4%E5%8F%B2/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot系列-全网最全的版本变更史">SpringBoot系列-全网最全的版本变更史</span>
            <span class="post-date" title="2024-10-08 16:38:53">2024/10/08</span>
        </a>
        
        
        <a  class="全部文章 开发工具 Maven "
           href="/blog/2024/10/08/6%E3%80%81%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Maven/Maven%20%E6%95%99%E7%A8%8B%E4%B9%8B%20%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE%20&%20%E9%B8%A3%E8%B0%A2/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Maven 教程之 参考文献 &amp; 鸣谢">Maven 教程之 参考文献 &amp; 鸣谢</span>
            <span class="post-date" title="2024-10-08 15:50:47">2024/10/08</span>
        </a>
        
        
        <a  class="全部文章 开发工具 "
           href="/blog/2024/10/07/6%E3%80%81%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/GitHub%20%E5%AE%9E%E6%88%98%E6%8A%80%E5%B7%A7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="GitHub 实战技巧">GitHub 实战技巧</span>
            <span class="post-date" title="2024-10-07 15:55:34">2024/10/07</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2024/10/07/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot2.x%20%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AF%87%20-%20%E9%9B%86%E6%88%90%20HirakiCP%20%E4%B8%8E%20Druid%20%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot2.x 数据库篇 - 集成 HirakiCP 与 Druid 数据库连接池">SpringBoot2.x 数据库篇 - 集成 HirakiCP 与 Druid 数据库连接池</span>
            <span class="post-date" title="2024-10-07 14:19:43">2024/10/07</span>
        </a>
        
        
        <a  class="全部文章 开发工具 "
           href="/blog/2024/09/30/6%E3%80%81%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/MacOS%20%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%8F%8A%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E5%8D%B8%E8%BD%BD/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="MacOS 开发环境搭建及软件安装卸载">MacOS 开发环境搭建及软件安装卸载</span>
            <span class="post-date" title="2024-09-30 23:56:52">2024/09/30</span>
        </a>
        
        
        <a  class="全部文章 开发工具 Maven "
           href="/blog/2024/09/30/6%E3%80%81%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Maven/Maven%20%E6%95%99%E7%A8%8B%E4%B9%8B%20JDK%20%E7%89%88%E6%9C%AC%E9%BB%98%E8%AE%A4%E8%AE%BE%E7%BD%AE%20/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Maven 教程之 JDK 版本默认设置">Maven 教程之 JDK 版本默认设置</span>
            <span class="post-date" title="2024-09-30 16:37:08">2024/09/30</span>
        </a>
        
        
        <a  class="全部文章 开发工具 Maven "
           href="/blog/2024/09/26/6%E3%80%81%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Maven/Maven%20%E6%95%99%E7%A8%8B%E4%B9%8B%20profiles%20%E5%A4%9A%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Maven 教程之 profiles 多环境配置">Maven 教程之 profiles 多环境配置</span>
            <span class="post-date" title="2024-09-26 17:40:34">2024/09/26</span>
        </a>
        
        
        <a  class="全部文章 开发工具 Maven "
           href="/blog/2024/09/25/6%E3%80%81%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Maven/Maven%20%E6%95%99%E7%A8%8B%E4%B9%8B%20plugin%20%E8%AF%A6%E8%A7%A3/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Maven 教程之 plugin 详解">Maven 教程之 plugin 详解</span>
            <span class="post-date" title="2024-09-25 11:32:44">2024/09/25</span>
        </a>
        
        
        <a  class="全部文章 开发工具 Maven "
           href="/blog/2024/09/21/6%E3%80%81%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Maven/Maven%20%E6%95%99%E7%A8%8B%E4%B9%8B%20pom.xml%20%E8%AF%A6%E8%A7%A3/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Maven 教程之 pom.xml 详解">Maven 教程之 pom.xml 详解</span>
            <span class="post-date" title="2024-09-21 16:14:13">2024/09/21</span>
        </a>
        
        
        <a  class="全部文章 开发工具 Maven "
           href="/blog/2024/09/21/6%E3%80%81%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Maven/Maven%20%E6%95%99%E7%A8%8B%E4%B9%8B%20settings.xml%20%E8%AF%A6%E8%A7%A3/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Maven 教程之 settings.xml 详解">Maven 教程之 settings.xml 详解</span>
            <span class="post-date" title="2024-09-21 16:14:09">2024/09/21</span>
        </a>
        
        
        <a  class="全部文章 面试篇 "
           href="/blog/2024/08/27/0%E3%80%81%E9%9D%A2%E8%AF%95%E7%AF%87/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8%E6%B1%87%E6%80%BB/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="面试宝典汇总">面试宝典汇总</span>
            <span class="post-date" title="2024-08-27 16:20:25">2024/08/27</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/blog/2024/08/26/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E8%87%AA%E5%AE%9A%E4%B9%89%E9%9B%86%E5%90%88%E5%B8%B8%E9%87%8F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 自定义集合常量">Java 自定义集合常量</span>
            <span class="post-date" title="2024-08-26 12:11:54">2024/08/26</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2024/08/26/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20MVC/SpringMVC%E4%B9%8B@InitBinder%E6%B3%A8%E8%A7%A3%EF%BC%88%E6%97%A5%E6%9C%9F%E8%BD%AC%E6%8D%A2%EF%BC%89/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringMVC之@InitBinder注解（日期转换）">SpringMVC之@InitBinder注解（日期转换）</span>
            <span class="post-date" title="2024-08-26 11:10:28">2024/08/26</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2024/08/21/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Transaction/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8B%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/Java%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BA%8B%E5%8A%A1%E6%8F%90%E4%BA%A4%E7%9A%84%E5%A4%84%E7%90%86/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 多线程事务提交的处理">Java 多线程事务提交的处理</span>
            <span class="post-date" title="2024-08-21 16:32:52">2024/08/21</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2024/08/20/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%20Cache%20%E6%95%B4%E5%90%88%20Redis%20%E7%BC%93%E5%AD%98%E6%A1%86%E6%9E%B6/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot Cache 整合 Redis 缓存框架">SpringBoot Cache 整合 Redis 缓存框架</span>
            <span class="post-date" title="2024-08-20 16:11:47">2024/08/20</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2024/08/16/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Transaction/Spring%20%E4%BA%8B%E5%8A%A1%E5%BA%94%E7%94%A8%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Spring 事务应用及源码分析">Spring 事务应用及源码分析</span>
            <span class="post-date" title="2024-08-16 10:33:57">2024/08/16</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2024/08/16/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Transaction/Spring%20JDBC%20-%20NamedParameterJdbcTemplate/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Spring JDBC - NamedParameterJdbcTemplate">Spring JDBC - NamedParameterJdbcTemplate</span>
            <span class="post-date" title="2024-08-16 00:18:18">2024/08/16</span>
        </a>
        
        
        <a  class="全部文章 开发工具 "
           href="/blog/2024/07/18/6%E3%80%81%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Git%20&%20GitHub/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Git &amp; GitHub">Git &amp; GitHub</span>
            <span class="post-date" title="2024-07-18 10:34:58">2024/07/18</span>
        </a>
        
        
        <a  class="全部文章 开发工具 Maven "
           href="/blog/2024/06/28/6%E3%80%81%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Maven/Maven%20%E5%AE%9E%E6%88%98/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Maven 实战">Maven 实战</span>
            <span class="post-date" title="2024-06-28 16:50:35">2024/06/28</span>
        </a>
        
        
        <a  class="全部文章 数据库 "
           href="/blog/2024/06/26/3%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%9D%A2%E8%AF%95%E5%AE%98%EF%BC%9A%E4%B8%8D%E4%BC%9A%E7%9C%8B%20Explain%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%EF%BC%8C%E7%AE%80%E5%8E%86%E6%95%A2%E5%86%99%20SQL%20%E4%BC%98%E5%8C%96%EF%BC%9F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="面试官：不会看 Explain执行计划，简历敢写 SQL 优化？">面试官：不会看 Explain执行计划，简历敢写 SQL 优化？</span>
            <span class="post-date" title="2024-06-26 19:33:03">2024/06/26</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/blog/2024/04/22/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%AF%87%E4%B9%8B%20IDEA%20-%20VM%20Options%E3%80%81Program%20Arguments%E3%80%81Environment%20Variable%20%E8%A7%A3%E6%9E%90/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 命令行篇之 IDEA - VM Options、Program Arguments、Environment Variable 解析">Java 命令行篇之 IDEA - VM Options、Program Arguments、Environment Variable 解析</span>
            <span class="post-date" title="2024-04-22 10:53:10">2024/04/22</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2024/04/19/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6-%E9%85%8D%E7%BD%AE%E5%A4%96%E9%83%A8%E5%8C%96/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 配置文件-配置外部化">SpringBoot 2.x 配置文件-配置外部化</span>
            <span class="post-date" title="2024-04-19 09:18:55">2024/04/19</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/blog/2024/04/16/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E5%8E%9F%E7%90%86%E7%AF%87%E4%B9%8B%20SPI%20%E6%9C%BA%E5%88%B6/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 原理篇之 SPI 机制">Java 原理篇之 SPI 机制</span>
            <span class="post-date" title="2024-04-16 17:26:15">2024/04/16</span>
        </a>
        
        
        <a  class="全部文章 开发工具 Maven "
           href="/blog/2024/01/14/6%E3%80%81%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Maven/Maven%20%E6%95%99%E7%A8%8B%E4%B9%8B%20mirror%20&%20repository%20%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Maven 教程之 mirror &amp; repository 配置详解">Maven 教程之 mirror &amp; repository 配置详解</span>
            <span class="post-date" title="2024-01-14 22:51:03">2024/01/14</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/12/07/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E4%B8%BA%E4%BB%80%E4%B9%88SpringBoot%20jar%20%E5%8F%AF%E4%BB%A5%E7%9B%B4%E6%8E%A5%E8%BF%90%E8%A1%8C/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 为什么SpringBoot jar 可以直接运行">SpringBoot 2.x 为什么SpringBoot jar 可以直接运行</span>
            <span class="post-date" title="2023-12-07 15:13:56">2023/12/07</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java基础篇 "
           href="/blog/2023/12/04/1%E3%80%81JavaSE/1.Java%20%E5%9F%BA%E7%A1%80%E7%AF%87/5%E3%80%81Java%20%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%BF%9B%E9%98%B6/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 多线程进阶">Java 多线程进阶</span>
            <span class="post-date" title="2023-12-04 16:37:09">2023/12/04</span>
        </a>
        
        
        <a  class="全部文章 数据库 "
           href="/blog/2023/11/18/3%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BB%BA%E6%A8%A1%E5%B7%A5%E5%85%B7%E6%B1%87%E6%80%BB/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="数据库建模工具汇总">数据库建模工具汇总</span>
            <span class="post-date" title="2023-11-18 15:31:11">2023/11/18</span>
        </a>
        
        
        <a  class="全部文章 JavaEE SSM框架 "
           href="/blog/2023/10/08/2%E3%80%81JavaEE/2%E3%80%81SSM%E6%A1%86%E6%9E%B6/Mybatis/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Mybatis">Mybatis</span>
            <span class="post-date" title="2023-10-08 19:45:47">2023/10/08</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java性能测试与安全 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/5.Java%20%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E4%B8%8E%E5%AE%89%E5%85%A8/Java%20%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E7%AF%87%E4%B9%8B%20%E5%8E%8B%E6%B5%8B%E5%B7%A5%E5%85%B7%E6%B1%87%E6%80%BB/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 性能测试篇之 压测工具汇总">Java 性能测试篇之 压测工具汇总</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java性能测试与安全 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/5.Java%20%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E4%B8%8E%E5%AE%89%E5%85%A8/Java%20%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E7%AF%87%E4%B9%8B%20%E9%AB%98%E5%B9%B6%E5%8F%91%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87%EF%BC%9AQPS%E3%80%81TPS%E3%80%81RT%E3%80%81%E5%B9%B6%E5%8F%91%E6%95%B0%E3%80%81%E5%90%9E%E5%90%90%E9%87%8F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 性能测试篇之 高并发性能指标：QPS、TPS、RT、并发数、吞吐量">Java 性能测试篇之 高并发性能指标：QPS、TPS、RT、并发数、吞吐量</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java性能测试与安全 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/5.Java%20%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E4%B8%8E%E5%AE%89%E5%85%A8/Java%20%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E7%AF%87%E4%B9%8B%20JMH%20%E5%B7%A5%E5%85%B7%E7%B1%BB/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 性能测试篇之 JMH 工具类">Java 性能测试篇之 JMH 工具类</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java性能测试与安全 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/5.Java%20%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E4%B8%8E%E5%AE%89%E5%85%A8/Java%20%E5%AE%89%E5%85%A8%E7%AF%87%E4%B9%8B%20API%20%E6%8E%A5%E5%8F%A3%E9%98%B2%E6%AD%A2%E5%8F%82%E6%95%B0%E7%AF%A1%E6%94%B9%E5%92%8C%E9%87%8D%E6%94%BE%E6%94%BB%E5%87%BB/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 安全篇之 API 接口防止参数篡改和重放攻击">Java 安全篇之 API 接口防止参数篡改和重放攻击</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java性能测试与安全 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/5.Java%20%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E4%B8%8E%E5%AE%89%E5%85%A8/Java%20%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E7%AF%87%E4%B9%8B%2048%E5%BC%A0%E5%9B%BE%E5%AD%A6%E4%BC%9A%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E3%80%81%E5%8E%8B%E6%B5%8B%E5%92%8C%E8%B0%83%E4%BC%98/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 性能测试篇之 48张图学会性能监控、压测和调优">Java 性能测试篇之 48张图学会性能监控、压测和调优</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 开发工具 "
           href="/blog/2023/08/28/6%E3%80%81%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/IDEA%20%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="IDEA 基本使用">IDEA 基本使用</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 开发工具 "
           href="/blog/2023/08/28/6%E3%80%81%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/IDEA%20%E5%BF%AB%E6%8D%B7%E9%94%AE/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="IDEA 快捷键">IDEA 快捷键</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 开发工具 "
           href="/blog/2023/08/28/6%E3%80%81%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/IDEA%20%E6%8F%92%E4%BB%B6%E5%AE%89%E8%A3%85/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="IDEA 插件安装">IDEA 插件安装</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 开发工具 "
           href="/blog/2023/08/28/6%E3%80%81%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/PostMan%20%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="PostMan 工具的使用">PostMan 工具的使用</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 开发工具 "
           href="/blog/2023/08/28/6%E3%80%81%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Git/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Git">Git</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E4%BC%98%E5%8C%96%E7%AF%87%E4%B9%8B%20%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3%20%E6%A0%A1%E9%AA%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 优化篇之 自定义注解 校验数据库表中的数据不可重复">Java 优化篇之 自定义注解 校验数据库表中的数据不可重复</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E5%B7%A5%E5%85%B7%E7%AF%87%E4%B9%8B%20API%20%E6%8E%A5%E5%8F%A3%E5%85%8D%E8%B4%B9%20JSONPlaceholder/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 工具篇之 API 接口免费 JSONPlaceholder">Java 工具篇之 API 接口免费 JSONPlaceholder</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E5%B7%A5%E5%85%B7%E7%AF%87%E4%B9%8B%20%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E7%BB%9F%E8%AE%A1%E4%BB%A3%E7%A0%81%E8%80%97%E6%97%B6/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 工具篇之 如何优雅的统计代码耗时">Java 工具篇之 如何优雅的统计代码耗时</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B9%8B%20%E4%B8%8D%E5%8F%AF%E4%B8%8D%E7%9F%A5%E7%9A%84%207%20%E4%B8%AA%20JDK%20%E5%91%BD%E4%BB%A4/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 命令行之 不可不知的 7 个 JDK 命令">Java 命令行之 不可不知的 7 个 JDK 命令</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%AF%87%E4%B9%8B%20Window%20%E5%90%8E%E5%8F%B0%E5%90%AF%E5%8A%A8%20JAR%20%E7%A8%8B%E5%BA%8F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 命令行篇之 Window 后台启动 JAR 程序">Java 命令行篇之 Window 后台启动 JAR 程序</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E5%B7%A5%E5%85%B7%E7%AF%87%E4%B9%8B%20Lombok/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 工具篇之 Lombok">Java 工具篇之 Lombok</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E5%B7%A5%E5%85%B7%E7%AF%87%E4%B9%8B%20API%20%E6%96%87%E6%A1%A3%E5%B7%A5%E5%85%B7%20Swagger3.x-2.x/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 工具篇之 API 文档工具 Swagger3.x-2.x">Java 工具篇之 API 文档工具 Swagger3.x-2.x</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E5%B7%A5%E5%85%B7%E7%AF%87%E4%B9%8B%20%E6%8E%8C%E6%8F%A114%E7%A7%8DUML%E5%9B%BE/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 工具篇之 掌握14种UML图">Java 工具篇之 掌握14种UML图</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E5%B7%A5%E5%85%B7%E7%B1%BB%E4%B9%8B%20%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B7%A5%E5%85%B7%E7%B1%BB/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 工具类之 自定义工具类">Java 工具类之 自定义工具类</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20Bean%20%E4%B9%8B%20DTO%E3%80%81VO%E3%80%81PO%E3%80%81DO%E3%80%81BO%20%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java Bean 之 DTO、VO、PO、DO、BO 类的区别">Java Bean 之 DTO、VO、PO、DO、BO 类的区别</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20JSON%20%E7%AF%87%E4%B9%8B%20Jackson/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java JSON 篇之 Jackson">Java JSON 篇之 Jackson</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20JSON%20%E7%AF%87%E4%B9%8B%20Gson/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java JSON 篇之 Gson">Java JSON 篇之 Gson</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Curl%20%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%91%BD%E4%BB%A4%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Curl 的使用及命令参数说明">Curl 的使用及命令参数说明</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20JSON%20%E7%AF%87%E4%B9%8B%20FastJson/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java JSON 篇之 FastJson">Java JSON 篇之 FastJson</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 中间件 Redis "
           href="/blog/2023/08/28/5%E3%80%81%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/backup/Redis6/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Redis6">Redis6</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 中间件 Redis "
           href="/blog/2023/08/28/5%E3%80%81%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/Redis-%E6%9C%80%E5%85%A8%E5%AE%9E%E6%88%98/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Redis-最全实战">Redis-最全实战</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 中间件 Redis "
           href="/blog/2023/08/28/5%E3%80%81%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/Redis-%E4%BB%A3%E7%A0%81%E5%AE%9E%E6%88%98/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Redis-代码实战">Redis-代码实战</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 中间件 RabbitMQ "
           href="/blog/2023/08/28/5%E3%80%81%E4%B8%AD%E9%97%B4%E4%BB%B6/RabbitMQ/RabbitMQ-3.8.14/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="RabbitMQ-3.8.14">RabbitMQ-3.8.14</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 中间件 RabbitMQ "
           href="/blog/2023/08/28/5%E3%80%81%E4%B8%AD%E9%97%B4%E4%BB%B6/RabbitMQ/RabbitMQ-3.7.x/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="RabbitMQ-3.7.x">RabbitMQ-3.7.x</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 中间件 RabbitMQ "
           href="/blog/2023/08/28/5%E3%80%81%E4%B8%AD%E9%97%B4%E4%BB%B6/RabbitMQ/RabbitMQ-3.8.14-%E5%8D%9A%E5%AE%A2%E7%89%88/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="RabbitMQ-3.8.14-博客版">RabbitMQ-3.8.14-博客版</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 中间件 MongoDB "
           href="/blog/2023/08/28/5%E3%80%81%E4%B8%AD%E9%97%B4%E4%BB%B6/MongoDB/MongDB-4.4.2-%E5%8D%9A%E5%AE%A2%E7%89%88/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="MongDB-4.4.2-博客版">MongDB-4.4.2-博客版</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 中间件 MongoDB "
           href="/blog/2023/08/28/5%E3%80%81%E4%B8%AD%E9%97%B4%E4%BB%B6/MongoDB/MongDB-4.4.2/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="MongDB-4.4.2">MongDB-4.4.2</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 中间件 ElasticSearch "
           href="/blog/2023/08/28/5%E3%80%81%E4%B8%AD%E9%97%B4%E4%BB%B6/ElasticSearch/ElasticSearch7.6.x%E5%AE%9E%E6%88%98/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="ElasticSearch7.6.x实战">ElasticSearch7.6.x实战</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Linux 虚拟机工具 "
           href="/blog/2023/08/28/4%E3%80%81Linux/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%B7%A5%E5%85%B7/Virtualbox%E7%BD%91%E7%BB%9C%E8%AE%BE%E7%BD%AE%E6%88%96%E9%85%8D%E7%BD%AE/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Virtualbox网络设置或配置">Virtualbox网络设置或配置</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Linux 虚拟机工具 "
           href="/blog/2023/08/28/4%E3%80%81Linux/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%B7%A5%E5%85%B7/Virtualbox%E5%AE%89%E8%A3%85Centos7%E5%AE%9E%E6%88%98/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Virtualbox安装Centos7实战">Virtualbox安装Centos7实战</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Linux Kubernetes "
           href="/blog/2023/08/28/4%E3%80%81Linux/Kubernetes/Minikube-k8s/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Minikube-k8s">Minikube-k8s</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Linux Kubernetes "
           href="/blog/2023/08/28/4%E3%80%81Linux/Kubernetes/k0s%20%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B%EF%BC%9A%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%20Kubernetes%20%E9%9B%86%E7%BE%A4/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="k0s 使用教程：如何快速搭建 Kubernetes 集群">k0s 使用教程：如何快速搭建 Kubernetes 集群</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Linux Nginx "
           href="/blog/2023/08/28/4%E3%80%81Linux/Nginx/Nginx-1.8.0/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Nginx-1.8.0">Nginx-1.8.0</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Linux Docker "
           href="/blog/2023/08/28/4%E3%80%81Linux/Docker/Docker%E5%88%9D%E7%BA%A7%E5%88%B0%E5%AE%9E%E6%88%98/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Docker初级到实战">Docker初级到实战</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 Linux Docker "
           href="/blog/2023/08/28/4%E3%80%81Linux/Docker/Docker&Docker-Compose%E5%AE%9E%E6%88%98-%E5%93%88%E5%96%BD%E6%B2%83%E5%BE%B7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Docker&amp;Docker-Compose实战-哈喽沃德">Docker&amp;Docker-Compose实战-哈喽沃德</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring/Spring%20Bean%20%E7%9A%8412%E7%A7%8D%E5%AE%9A%E4%B9%89%E6%96%B9%E6%B3%95/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Spring Bean 的12种定义方法">Spring Bean 的12种定义方法</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring/Spring%20Bean%20%E7%9A%84%E5%8A%A8%E6%80%81%E5%88%9B%E5%BB%BA%E8%8E%B7%E5%8F%96%E5%88%A0%E9%99%A4/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Spring Bean 的动态创建获取删除">Spring Bean 的动态创建获取删除</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring/Spring%20Bean%20%E6%B3%A8%E5%85%A5%E7%9A%843%E7%A7%8D%E6%96%B9%E5%BC%8F,%20%E4%B8%BA%E4%BD%95%E5%AE%98%E6%96%B9%E5%BB%BA%E8%AE%AE%E4%BD%BF%E7%94%A8%E6%9E%84%E9%80%A0%E5%99%A8%E6%B3%A8%E5%85%A5/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Spring Bean 注入的3种方式, 为何官方建议使用构造器注入">Spring Bean 注入的3种方式, 为何官方建议使用构造器注入</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Transaction/%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/Spring%20%E5%AE%9E%E7%8E%B0%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E5%AE%9E%E6%88%98/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Spring 实现多数据源实战">Spring 实现多数据源实战</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Transaction/%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/Spring%20%E8%A7%A3%E5%86%B3%E5%8D%95%E6%9C%BA%E7%8E%AF%E5%A2%83%E4%B8%8B%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E7%9A%84%E4%BA%8B%E5%8A%A1%E9%97%AE%E9%A2%98/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Spring 解决单机环境下多数据源的事务问题">Spring 解决单机环境下多数据源的事务问题</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Transaction/%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/Spring%20%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81%E6%95%B0%E6%8D%AE%E6%BA%90%E3%80%81%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E5%88%87%E6%8D%A2%E6%96%B9%E5%BC%8F%E3%80%81%E5%A4%9A%E6%95%B0%E6%8D%AE%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Spring 实现动态数据源、多数据源切换方式、多数据事务管理">Spring 实现动态数据源、多数据源切换方式、多数据事务管理</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Transaction/Spring%20%E4%BA%8B%E5%8A%A1%E5%8E%9F%E7%90%86%E6%B7%B1%E5%85%A5%E4%B8%8E%E5%88%86%E6%9E%90/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Spring 事务原理深入与分析">Spring 事务原理深入与分析</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Security/SpringSecurity/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringSecurity">SpringSecurity</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Transaction/JDBC/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="JDBC">JDBC</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Transaction/Spring%20JDBC%20-%20JdbcTemplate/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Spring JDBC - JdbcTemplate">Spring JDBC - JdbcTemplate</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Transaction/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8B%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/JDBC%E6%89%B9%E5%A4%84%E7%90%86%E5%AE%9E%E7%8E%B0%E6%89%8B%E5%8A%A8%E4%BA%8B%E5%8A%A1%E6%8F%92%E5%85%A51000%E4%B8%87%E6%95%B0%E6%8D%AE%EF%BC%88%E5%8D%95%E7%BA%BF%E7%A8%8B%20&%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%89/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="JDBC批处理实现手动事务插入1000万数据（单线程 &amp; 多线程）">JDBC批处理实现手动事务插入1000万数据（单线程 &amp; 多线程）</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Data%20JPA/SpringData%20JPA%20%E7%B1%BB%E5%9B%BE%E5%8F%8A%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringData JPA 类图及使用方法整理">SpringData JPA 类图及使用方法整理</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Data%20JPA/SpringData%20JPA/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringData JPA">SpringData JPA</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Data%20JPA/Spring%20Data%20JPA%20%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E6%88%98/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Spring Data JPA 原理与实战">Spring Data JPA 原理与实战</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Data%20JPA/Hibernata%20JPA/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Hibernata JPA">Hibernata JPA</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Cloud%20Alibaba/SpringCloud%20Alibaba/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringCloud Alibaba">SpringCloud Alibaba</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot2.x%20%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AF%87%20-%20%E6%95%B4%E5%90%88H2%E6%95%B0%E6%8D%AE%E5%BA%93/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot2.x 数据库篇 - 整合H2数据库">SpringBoot2.x 数据库篇 - 整合H2数据库</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot2.x%20%E9%A1%B9%E7%9B%AE%E7%BB%9F%E4%B8%80%E6%9E%9A%E4%B8%BE%E8%BD%AC%E6%8D%A2%E5%AE%9E%E8%B7%B5/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot2.x 项目统一枚举转换实践">SpringBoot2.x 项目统一枚举转换实践</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AD%A6/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot从零开始学">SpringBoot从零开始学</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%E9%85%8D%E7%BD%AE%E5%B1%9E%E6%80%A7%E4%B9%8BDataSource/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot配置属性之DataSource">SpringBoot配置属性之DataSource</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SprinigBoot%E6%96%87%E7%AB%A0%E6%91%98%E8%A6%81%E5%8F%8A%E8%BD%AC%E8%BD%BD/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SprinigBoot文章摘要及转载">SprinigBoot文章摘要及转载</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/%E4%BB%A3%E7%A0%81%E5%AE%A1%E6%9F%A5%E7%9A%84%E5%BF%85%E8%A6%81%E6%80%A7%E5%92%8C%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="代码审查的必要性和最佳实践">代码审查的必要性和最佳实践</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6-%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%B9%8B@Value%E8%BF%9B%E9%98%B6/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 配置文件-读取配置文件之@Value进阶">SpringBoot 2.x 配置文件-读取配置文件之@Value进阶</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6-%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9A%84N%E7%A7%8D%E6%96%B9%E5%BC%8F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 配置文件-读取配置文件的N种方式">SpringBoot 2.x 配置文件-读取配置文件的N种方式</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E7%BB%9F%E4%B8%80%E6%8E%A5%E5%8F%A3%E8%BF%94%E5%9B%9E%E6%A0%BC%E5%BC%8F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 统一接口返回格式">SpringBoot 2.x 统一接口返回格式</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6-%E8%AF%BB%E5%8F%96%20Resources%20%E6%96%87%E4%BB%B6%E4%B9%8B%E6%97%A0%E6%B3%95%E8%AF%BB%E5%8F%96Jar%E5%8C%85classpath%E4%B8%8B%E7%9A%84%E6%96%87%E4%BB%B6/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 配置文件-读取 Resources 文件之无法读取Jar包classpath下的文件">SpringBoot 2.x 配置文件-读取 Resources 文件之无法读取Jar包classpath下的文件</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6-%E8%AF%BB%E5%8F%96%20Resources%20%E6%96%87%E4%BB%B6%E7%9A%84N%E7%A7%8D%E6%96%B9%E5%BC%8F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 配置文件-读取 Resources 文件的N种方式">SpringBoot 2.x 配置文件-读取 Resources 文件的N种方式</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B%E7%AF%87-%E6%8B%A6%E6%88%AA%E5%99%A8%E8%BF%87%E6%BB%A4%E5%99%A8%E4%B8%8E%E7%9B%91%E5%90%AC%E5%99%A8/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 切面编程篇-拦截器过滤器与监听器">SpringBoot 2.x 切面编程篇-拦截器过滤器与监听器</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3%E5%A4%A7%E5%85%A8/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 常用注解大全">SpringBoot 2.x 常用注解大全</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E5%AE%89%E5%85%A8%E5%AF%86%E7%A0%81%E5%AD%A6%E4%B9%8B%E5%8A%A0%E8%A7%A3%E5%AF%86%E7%AE%97%E6%B3%95/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 安全密码学之加解密算法">SpringBoot 2.x 安全密码学之加解密算法</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3%E8%AF%A6%E8%A7%A3/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 常用注解详解">SpringBoot 2.x 常用注解详解</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E5%90%AF%E5%8A%A8%E6%97%B6%E5%8A%A0%E8%BD%BD%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84N%E7%A7%8D%E6%96%B9%E5%BC%8F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 启动时加载初始化的N种方式">SpringBoot 2.x 启动时加载初始化的N种方式</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%8F%8A%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E8%BF%87%E7%A8%8B/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 启动流程及自动装配过程">SpringBoot 2.x 启动流程及自动装配过程</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E5%8A%A8%E6%80%81%E8%A3%85%E9%85%8DBean%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 动态装配Bean的三种方式">SpringBoot 2.x 动态装配Bean的三种方式</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E5%88%A9%E5%99%A8-1%20JUnit5/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 单元测试利器-1 JUnit5">SpringBoot 2.x 单元测试利器-1 JUnit5</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E5%88%A9%E5%99%A8-3%20MockMvc/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 单元测试利器-3 MockMvc">SpringBoot 2.x 单元测试利器-3 MockMvc</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E5%88%A9%E5%99%A8-2%20Mockito/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 单元测试利器-2 Mockito">SpringBoot 2.x 单元测试利器-2 Mockito</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E5%88%86%E7%89%87%E4%B8%8A%E4%BC%A0%E3%80%81%E6%96%AD%E7%82%B9%E7%BB%AD%E4%BC%A0%E3%80%81%E5%A4%A7%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E3%80%81%E7%A7%92%E4%BC%A0/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 分片上传、断点续传、大文件上传、秒传">SpringBoot 2.x 分片上传、断点续传、大文件上传、秒传</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20Validation%20%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C%EF%BC%88TODO%EF%BC%89/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x Validation 参数校验（TODO）">SpringBoot 2.x Validation 参数校验（TODO）</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20WebMvcConfigurer%20%E8%AF%A6%E8%A7%A3%E3%80%90SpringMVC%E3%80%91/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x WebMvcConfigurer 详解【SpringMVC】">SpringBoot 2.x WebMvcConfigurer 详解【SpringMVC】</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20YML%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x YML配置文件详解">SpringBoot 2.x YML配置文件详解</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E5%88%86%E5%B8%83%E5%BC%8F%E5%85%A8%E5%B1%80%E5%94%AF%E4%B8%80ID%E7%94%9F%E6%88%90%E6%96%B9%E6%A1%88/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 分布式全局唯一ID生成方案">SpringBoot 2.x 分布式全局唯一ID生成方案</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20JWT%20%E6%A6%82%E5%BF%B5%E7%AF%87/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x JWT 概念篇">SpringBoot 2.x JWT 概念篇</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20Jar%20%E5%8C%85%E5%90%AF%E5%8A%A8%E3%80%81%E5%81%9C%E6%AD%A2%E3%80%81%E9%87%8D%E5%90%AF%E8%84%9A%E6%9C%AC/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x Jar 包启动、停止、重启脚本">SpringBoot 2.x Jar 包启动、停止、重启脚本</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20Java%20%E7%A8%8B%E5%BA%8F%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0%E6%80%BB%E7%BB%93/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x Java 程序命令行参数总结">SpringBoot 2.x Java 程序命令行参数总结</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20Java%20%E5%AE%9E%E7%8E%B0%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E7%9A%848%E7%A7%8D%E6%96%B9%E5%BC%8F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x Java 实现异步编程的8种方式">SpringBoot 2.x Java 实现异步编程的8种方式</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20@ControllerAdvice%E4%B8%89%E7%A7%8D%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x @ControllerAdvice三种使用场景">SpringBoot 2.x @ControllerAdvice三种使用场景</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20@ConfigurationProperties%E4%BB%A5%E5%8F%8A@NestedConfigurationProperty%E7%9A%84%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x @ConfigurationProperties以及@NestedConfigurationProperty的使用详解">SpringBoot 2.x @ConfigurationProperties以及@NestedConfigurationProperty的使用详解</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20HTTP%20Content-Type%20%E8%AF%A6%E8%A7%A3/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x HTTP Content-Type 详解">SpringBoot 2.x HTTP Content-Type 详解</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20HTTP%20Headers%20%E5%A4%B4%E4%BF%A1%E6%81%AF%E8%AF%BB%E5%8F%96/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x HTTP Headers 头信息读取">SpringBoot 2.x HTTP Headers 头信息读取</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20JWT%20%E5%AE%9E%E6%88%98%E7%AF%87/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x JWT 实战篇">SpringBoot 2.x JWT 实战篇</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%20%E6%8E%A5%E5%8F%A3%E5%B9%82%E7%AD%89%E6%80%A7%E5%AE%9E%E7%8E%B0/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x  接口幂等性实现">SpringBoot 2.x  接口幂等性实现</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/Spring%20IO%20Platform%EF%BC%9A%E8%A7%A3%E5%86%B3%E4%BE%9D%E8%B5%96%E7%89%88%E6%9C%AC%E5%86%B2%E7%AA%81/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Spring IO Platform：解决依赖版本冲突">Spring IO Platform：解决依赖版本冲突</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Spring%20Boot/SpringBoot%202.x%20%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B%E7%AF%87-AOP%20%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%8E%9F%E7%90%86/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringBoot 2.x 切面编程篇-AOP 的使用及原理">SpringBoot 2.x 切面编程篇-AOP 的使用及原理</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE SSM框架 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/2%E3%80%81SSM%E6%A1%86%E6%9E%B6/SpringMVC/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SpringMVC">SpringMVC</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Shiro/Shiro%E6%9D%83%E9%99%90%E5%AE%9E%E6%88%98%E8%AF%BE%E7%A8%8B/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Shiro权限实战课程">Shiro权限实战课程</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE 微服务开发 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/3%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/Shiro/Shiro%E6%9D%83%E9%99%90%E5%AE%9E%E6%88%98/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Shiro权限实战">Shiro权限实战</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE SSM框架 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/2%E3%80%81SSM%E6%A1%86%E6%9E%B6/Spring/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Spring">Spring</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE SSM框架 "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/2%E3%80%81SSM%E6%A1%86%E6%9E%B6/MybatisPlus/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="MybatisPlus">MybatisPlus</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE JavaWeb "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/1%E3%80%81JavaWeb/%E4%BD%A0%E8%BF%98%E5%9C%A8%E4%B8%BA%20HTTP%20%E7%9A%84%E8%BF%99%E4%BA%9B%E6%A6%82%E5%BF%B5%E5%A4%B4%E7%96%BC%E5%90%97/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="你还在为 HTTP 的这些概念头疼吗">你还在为 HTTP 的这些概念头疼吗</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaEE JavaWeb "
           href="/blog/2023/08/28/2%E3%80%81JavaEE/1%E3%80%81JavaWeb/Cookie%E3%80%81Session%E3%80%81Token%E3%80%81JWT%E7%BB%88%E4%BA%8E%E8%AE%B2%E6%B8%85%E6%A5%9A%E4%BA%86/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Cookie、Session、Token、JWT终于讲清楚了">Cookie、Session、Token、JWT终于讲清楚了</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 数据库 "
           href="/blog/2023/08/28/3%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL-%E9%AB%98%E7%BA%A7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="MySQL-高级">MySQL-高级</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 数据库 "
           href="/blog/2023/08/28/3%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL-%E5%88%9D%E7%BA%A7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="MySQL-初级">MySQL-初级</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 数据库 "
           href="/blog/2023/08/28/3%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93/H2%20Database/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="H2 Database">H2 Database</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E4%BC%98%E5%8C%96%E7%AF%87%E4%B9%8B%20%E5%BB%B6%E6%97%B6%E9%98%9F%E5%88%97%20-%20%E8%AE%A2%E5%8D%95%E8%B6%85%E6%97%B6%E8%87%AA%E5%8A%A8%E5%8F%96%E6%B6%88%E7%9A%84N%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 优化篇之 延时队列 - 订单超时自动取消的N种实现方式">Java 优化篇之 延时队列 - 订单超时自动取消的N种实现方式</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E4%BC%98%E5%8C%96%E7%AF%87%E4%B9%8B%20%E6%B3%A8%E8%A7%A3%20+%20%E5%8F%8D%E5%B0%84%E6%B6%88%E9%99%A4%E9%87%8D%E5%A4%8D%E4%BB%A3%E7%A0%81/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 优化篇之 注解 + 反射消除重复代码">Java 优化篇之 注解 + 反射消除重复代码</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E9%9B%86%E5%90%88%E7%AF%87%E4%B9%8B%20%E8%8E%B7%E5%8F%96%E4%B8%A4%E4%B8%AA%E9%9B%86%E5%90%88List%E7%9A%84%E4%BA%A4%E9%9B%86%E3%80%81%E8%A1%A5%E9%9B%86%E3%80%81%E5%B9%B6%E9%9B%86%E3%80%81%E5%B7%AE%E9%9B%86%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 集合篇之 获取两个集合List的交集、补集、并集、差集的几种方式">Java 集合篇之 获取两个集合List的交集、补集、并集、差集的几种方式</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E4%BC%98%E5%8C%96%E7%AF%87%E4%B9%8B%20if-else%20%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 优化篇之 if-else 代码优化方案">Java 优化篇之 if-else 代码优化方案</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E9%9B%86%E5%90%88%E7%AF%87%E4%B9%8B%20Lambda%20%E5%AE%9E%E7%8E%B0%E8%B6%85%E5%BC%BA%E6%8E%92%E5%BA%8F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 集合篇之 Lambda 实现超强排序">Java 集合篇之 Lambda 实现超强排序</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4%E5%90%84%E7%B1%BB%E5%9E%8B%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 日期时间各类型相互转换">Java 日期时间各类型相互转换</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 动态代理">Java 动态代理</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E5%9F%BA%E6%9C%AC%E5%8A%9F%E7%AF%87%E4%B9%8B%20for%E3%80%81for-each%E3%80%81forEach()%20%E7%9A%84%20break%E3%80%81continue%E3%80%81return/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 基本功篇之 for、for-each、forEach() 的 break、continue、return">Java 基本功篇之 for、for-each、forEach() 的 break、continue、return</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6%E8%AF%A6%E8%A7%A3/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 日志框架详解">Java 日志框架详解</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java新特性 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/3.Java%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%20%E6%96%B0%E7%89%B9%E6%80%A7%E6%A6%82%E8%BF%B0%E5%8F%8A%E7%89%88%E6%9C%AC%E5%8F%91%E8%A1%8C%E5%8F%B2/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 新特性概述及版本发行史">Java 新特性概述及版本发行史</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20Bean%20%E4%B9%8B%20Record%20%E7%B1%BB/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java Bean 之 Record 类">Java Bean 之 Record 类</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java汇总篇 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/4.Java%20%E6%B1%87%E6%80%BB%E7%AF%87/Java%20%E4%BC%98%E5%8C%96%E7%AF%87%E4%B9%8B%20GZIP%E5%8E%8B%E7%BC%A9%E5%AD%97%E7%AC%A6%E4%B8%B2/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 优化篇之 GZIP压缩字符串">Java 优化篇之 GZIP压缩字符串</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java进阶篇 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/2.Java%20%E8%BF%9B%E9%98%B6%E7%AF%87/JVM%20%E8%99%9A%E6%8B%9F%E6%9C%BA/Java%20GC%20%E6%80%BB%E7%BB%93/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java GC 总结">Java GC 总结</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java新特性 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/3.Java%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%209%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%209%20%E6%96%B0%E7%89%B9%E6%80%A7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 9 新特性">Java 9 新特性</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java新特性 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/3.Java%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%208%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%208%20%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8B%20Stream%20%E6%B5%81/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 8 新特性之 Stream 流">Java 8 新特性之 Stream 流</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java新特性 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/3.Java%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%208%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%208%20%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8B%20Optional%20%E7%B1%BB/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 8 新特性之 Optional 类">Java 8 新特性之 Optional 类</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java新特性 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/3.Java%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%208%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%208%20%E6%96%B0%E7%89%B9%E6%80%A7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 8 新特性">Java 8 新特性</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java新特性 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/3.Java%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%208%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%208%20%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8B%20DateTime%20API/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 8 新特性之 DateTime API">Java 8 新特性之 DateTime API</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java新特性 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/3.Java%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2018%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2018%20%E6%96%B0%E7%89%B9%E6%80%A7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 18 新特性">Java 18 新特性</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java新特性 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/3.Java%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2019%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2019%20%E6%96%B0%E7%89%B9%E6%80%A7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 19 新特性">Java 19 新特性</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java新特性 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/3.Java%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2020%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2020%20%E6%96%B0%E7%89%B9%E6%80%A7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 20 新特性">Java 20 新特性</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java新特性 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/3.Java%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2017%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2017%20%E6%96%B0%E7%89%B9%E6%80%A7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 17 新特性">Java 17 新特性</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java新特性 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/3.Java%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2016%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2016%20%E6%96%B0%E7%89%B9%E6%80%A7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 16 新特性">Java 16 新特性</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java新特性 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/3.Java%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2015%E6%96%B0%E7%89%B9%E6%80%A7/Java%2015%20%E6%96%B0%E7%89%B9%E6%80%A7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 15 新特性">Java 15 新特性</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java新特性 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/3.Java%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2013%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2013%20%E6%96%B0%E7%89%B9%E6%80%A7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 13 新特性">Java 13 新特性</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java新特性 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/3.Java%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2014%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2014%20%E6%96%B0%E7%89%B9%E6%80%A7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 14 新特性">Java 14 新特性</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java新特性 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/3.Java%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2010%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2010%20%E6%96%B0%E7%89%B9%E6%80%A7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 10 新特性">Java 10 新特性</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java新特性 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/3.Java%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2011%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2011%20%E6%96%B0%E7%89%B9%E6%80%A7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 11 新特性">Java 11 新特性</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java新特性 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/3.Java%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2012%20%E6%96%B0%E7%89%B9%E6%80%A7/Java%2012%20%E6%96%B0%E7%89%B9%E6%80%A7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 12 新特性">Java 12 新特性</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java基础篇 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/1.Java%20%E5%9F%BA%E7%A1%80%E7%AF%87/1%E3%80%81Java%20%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/Java%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 面向对象编程">Java 面向对象编程</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java基础篇 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/1.Java%20%E5%9F%BA%E7%A1%80%E7%AF%87/3%E3%80%81Java%20%E9%9B%86%E5%90%88%E7%B1%BB/Java%20%E7%B1%BB%E9%9B%86%E6%A1%86%E6%9E%B6/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 类集框架">Java 类集框架</span>
            <span class="post-date" title="2023-08-28 09:23:45">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java基础篇 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/1.Java%20%E5%9F%BA%E7%A1%80%E7%AF%87/2%E3%80%81Java%20%E5%B8%B8%E7%94%A8%E7%B1%BB%E5%BA%93/Java%20%E5%B8%B8%E7%94%A8%E7%B1%BB%E5%BA%93/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 常用类库">Java 常用类库</span>
            <span class="post-date" title="2023-08-28 09:23:44">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java基础篇 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/1.Java%20%E5%9F%BA%E7%A1%80%E7%AF%87/5%E3%80%81Java%20%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 多线程基础">Java 多线程基础</span>
            <span class="post-date" title="2023-08-28 09:23:44">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java基础篇 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/1.Java%20%E5%9F%BA%E7%A1%80%E7%AF%87/4%E3%80%81Java%20%E5%8F%8D%E5%B0%84%E4%B8%8E%E6%B3%A8%E8%A7%A3/Java%20%E5%8F%8D%E5%B0%84%E4%B8%8E%E6%B3%A8%E8%A7%A3/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 反射与注解">Java 反射与注解</span>
            <span class="post-date" title="2023-08-28 09:23:44">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java基础篇 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/1.Java%20%E5%9F%BA%E7%A1%80%E7%AF%87/7%E3%80%81Java%20NIO%20%E6%B5%81/Java%20NIO%20%E6%B5%81/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java NIO 流">Java NIO 流</span>
            <span class="post-date" title="2023-08-28 09:23:44">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java基础篇 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/1.Java%20%E5%9F%BA%E7%A1%80%E7%AF%87/6%E3%80%81Java%20IO%20%E6%B5%81/Java%20IO%20%E6%B5%81/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java IO 流">Java IO 流</span>
            <span class="post-date" title="2023-08-28 09:23:44">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java进阶篇 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/2.Java%20%E8%BF%9B%E9%98%B6%E7%AF%87/Java%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/Java%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java 设计模式">Java 设计模式</span>
            <span class="post-date" title="2023-08-28 09:23:44">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java进阶篇 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/2.Java%20%E8%BF%9B%E9%98%B6%E7%AF%87/JVM%20%E8%99%9A%E6%8B%9F%E6%9C%BA/7%20%E6%AE%B5%E5%B0%8F%E4%BB%A3%E7%A0%81%EF%BC%8C%E7%8E%A9%E8%BD%ACJava%E7%A8%8B%E5%BA%8F%E5%B8%B8%E8%A7%81%E7%9A%84%E5%B4%A9%E6%BA%83%E5%9C%BA%E6%99%AF/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="7 段小代码，玩转Java程序常见的崩溃场景">7 段小代码，玩转Java程序常见的崩溃场景</span>
            <span class="post-date" title="2023-08-28 09:23:44">2023/08/28</span>
        </a>
        
        
        <a  class="全部文章 JavaSE Java进阶篇 "
           href="/blog/2023/08/28/1%E3%80%81JavaSE/2.Java%20%E8%BF%9B%E9%98%B6%E7%AF%87/JVM%20%E8%99%9A%E6%8B%9F%E6%9C%BA/JVM%20%E8%99%9A%E6%8B%9F%E6%9C%BA/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="JVM 虚拟机">JVM 虚拟机</span>
            <span class="post-date" title="2023-08-28 09:23:44">2023/08/28</span>
        </a>
        
        <div id="no-item-tips">

        </div>
    </nav>
    <div id="outline-list">
    </div>
</div>

    </div>
    <div class="hide-list">
        <div class="semicircle" data-title="切换全屏 快捷键 s">
            <div class="brackets first"><</div>
            <div class="brackets">&gt;</div>
        </div>
    </div>
</aside>
<div id="post">
    <div class="pjax">
        <article id="post-2、JavaEE/3、微服务开发/Spring Boot/SpringBoot 2.x 启动流程及自动装配过程" class="article article-type-post" itemscope itemprop="blogPost">
    
        <h1 class="article-title">SpringBoot 2.x 启动流程及自动装配过程</h1>
    
    <div class="article-meta">
        
        
        
        <span class="book">
            <i class="iconfont icon-category"></i>
            
            
            <a  data-rel="JavaEE">JavaEE</a> > 
            
            <a  data-rel="JavaEE&lt;---&gt;微服务开发">微服务开发</a>
            
        </span>
        
        
    </div>
    <div class="article-meta">
        
            发布时间 : <time class="date" title='最后更新: 2024-10-22 11:50:18'>2023-08-28 09:23</time>
        
    </div>
    <div class="article-meta">
        
        
        <span id="busuanzi_container_page_pv">
            阅读 :<span id="busuanzi_value_page_pv">
                <span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </span>
        </span>
        
        
    </div>
    
    <div class="toc-ref">
    
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81SpringApplication-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%90%AF%E5%8A%A8%E6%96%B9%E5%BC%8F"><span class="toc-text">一、SpringApplication 自定义启动方式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E7%AC%AC%E4%B8%80%E7%A7%8D%EF%BC%9ASpringApplicationAPI-%E6%96%B9%E5%BC%8F"><span class="toc-text">1、第一种：SpringApplicationAPI 方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E7%AC%AC%E4%BA%8C%E7%A7%8D%EF%BC%9ASpringApplicationBuilderAPI-%E6%96%B9%E5%BC%8F"><span class="toc-text">2、第二种：SpringApplicationBuilderAPI 方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81SpringApplicationBuilder-parent-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">3、SpringApplicationBuilder parent 应用场景</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81SpringBoot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%8F%8A%E5%8E%9F%E7%90%86%EF%BC%88%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%EF%BC%89"><span class="toc-text">二、SpringBoot 启动流程及原理（自动配置）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81XxApplication-main-%E6%96%B9%E6%B3%95"><span class="toc-text">1、XxApplication.main() 方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E6%9E%84%E9%80%A0SpringApplication%E5%AE%9E%E4%BE%8B"><span class="toc-text">2、构造SpringApplication实例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1%E3%80%81%E5%88%A4%E6%96%AD%E5%BA%94%E7%94%A8%E9%A1%B9%E7%9B%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">2.1、判断应用项目类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2%E3%80%81%E5%88%9D%E5%A7%8B%E5%8C%96%E6%89%80%E6%9C%89%E6%A0%B9%E5%BC%95%E5%AF%BC%E5%90%AF%E5%8A%A8%E5%99%A8"><span class="toc-text">2.2、初始化所有根引导启动器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3%E3%80%81%E5%88%9D%E5%A7%8B%E5%8C%96%E6%89%80%E6%9C%89%E5%AE%B9%E5%99%A8%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="toc-text">2.3、初始化所有容器上下文</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4%E3%80%81%E5%88%9D%E5%A7%8B%E5%8C%96%E6%89%80%E6%9C%89%E7%9B%91%E5%90%AC%E5%99%A8"><span class="toc-text">2.4、初始化所有监听器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3%E3%80%81%E8%AE%BE%E7%BD%AE%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E7%9A%84%E4%B8%BB%E7%B1%BB"><span class="toc-text">2.3、设置程序运行的主类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E6%89%A7%E8%A1%8C%E5%AE%9E%E4%BE%8B%E7%9A%84-run-%E6%96%B9%E6%B3%95"><span class="toc-text">3、执行实例的 run() 方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-01%E3%80%81View-Code"><span class="toc-text">3.01、View Code</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-02%E3%80%81%E5%BC%80%E5%90%AF%E8%AE%A1%E6%97%B6%E5%99%A8"><span class="toc-text">3.02、开启计时器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-03%E3%80%81createBootstrapContext"><span class="toc-text">3.03、createBootstrapContext</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-04%E3%80%81configureHeadlessProperty"><span class="toc-text">3.04、configureHeadlessProperty</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-05%E3%80%81%E8%8E%B7%E5%8F%96%E5%B9%B6%E5%90%AF%E7%94%A8%E7%9B%91%E5%90%AC%E5%99%A8"><span class="toc-text">3.05、获取并启用监听器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-06%E3%80%81%E8%AE%BE%E7%BD%AE%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%8F%82%E6%95%B0"><span class="toc-text">3.06、设置应用程序参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-07%E3%80%81%E5%87%86%E5%A4%87%E5%8A%A0%E8%BD%BD%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F"><span class="toc-text">3.07、准备加载环境变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-08%E3%80%81%E9%85%8D%E7%BD%AE%E5%BF%BD%E7%95%A5Bean%E4%BF%A1%E6%81%AF"><span class="toc-text">3.08、配置忽略Bean信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-09%E3%80%81%E6%89%93%E5%8D%B0Banner%E4%BF%A1%E6%81%AF"><span class="toc-text">3.09、打印Banner信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-10%E3%80%81%E5%88%9B%E5%BB%BAIOC%E5%AE%B9%E5%99%A8%E5%B9%B6%E8%AE%BE%E7%BD%AE%E5%90%AF%E5%8A%A8%E5%99%A8"><span class="toc-text">3.10、创建IOC容器并设置启动器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-11%E3%80%81%E5%87%86%E5%A4%87IOC%E5%AE%B9%E5%99%A8%E5%9F%BA%E6%9C%AC%E4%BF%A1%E6%81%AF"><span class="toc-text">3.11、准备IOC容器基本信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-12%E3%80%81%E5%88%B7%E6%96%B0%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="toc-text">3.12、刷新上下文</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-13%E3%80%81%E5%88%B7%E6%96%B0%E4%B8%8A%E4%B8%8B%E6%96%87%E5%90%8E%E7%BD%AE%E5%A4%84%E7%90%86"><span class="toc-text">3.13、刷新上下文后置处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-14%E3%80%81%E7%BB%93%E6%9D%9F%E8%AE%A1%E6%97%B6%E5%99%A8%E5%B9%B6%E6%89%93%E5%8D%B0%E6%97%A5%E5%BF%97"><span class="toc-text">3.14、结束计时器并打印日志</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-15%E3%80%81%E5%8F%91%E5%B8%83%E7%9B%91%E5%90%AC%E5%BA%94%E7%94%A8%E5%90%AF%E5%8A%A8%E4%BA%8B%E4%BB%B6"><span class="toc-text">3.15、发布监听应用启动事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-16%E3%80%81%E6%89%A7%E8%A1%8C%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84run%E6%96%B9%E6%B3%95"><span class="toc-text">3.16、执行自定义的run方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-17%E3%80%81%E6%89%A7%E8%A1%8C%E7%9B%91%E5%90%AC%E5%99%A8%E7%9A%84running"><span class="toc-text">3.17、执行监听器的running()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81SpringBoot%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E6%80%BB%E7%BB%93"><span class="toc-text">4、SpringBoot启动流程总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81SpringBoot-%E5%90%AF%E5%8A%A8%E7%B1%BB%E4%B8%8A%E7%9A%84%E6%B3%A8%E8%A7%A3%EF%BC%88%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%EF%BC%89"><span class="toc-text">三、SpringBoot 启动类上的注解（自动配置）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81-SpringBootConfiguration"><span class="toc-text">1、@SpringBootConfiguration</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81-ComponentScan"><span class="toc-text">2、@ComponentScan</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81-EnableAutoConfiguration"><span class="toc-text">3、@EnableAutoConfiguration</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81-AutoConfigurationPackage"><span class="toc-text">4、@AutoConfigurationPackage</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81-Import-AutoConfigurationImportSelector-class"><span class="toc-text">5、@Import(AutoConfigurationImportSelector.class)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81-Conditional-%E5%B8%B8%E7%94%A8%E6%9D%A1%E4%BB%B6%E6%B3%A8%E8%A7%A3"><span class="toc-text">6、@Conditional 常用条件注解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E3%80%81SpringBoot-%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93%EF%BC%88%E9%9D%A2%E8%AF%95%EF%BC%89"><span class="toc-text">7、SpringBoot 自动装配原理总结（面试）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E3%80%81Spring-Boot-Starter-%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8F%8A%E5%8E%9F%E7%90%86"><span class="toc-text">四、Spring-Boot-Starter 的自定义及原理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81Starter-%E5%9C%BA%E6%99%AF%E5%90%AF%E5%8A%A8%E5%99%A8%E5%89%8D%E8%A8%80"><span class="toc-text">1、Starter 场景启动器前言</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF-Starter"><span class="toc-text">1、什么是 Starter</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8-Starter"><span class="toc-text">2、为什么要用 Starter</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81Starter-%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86"><span class="toc-text">2、Starter 自动配置原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81Starter-%E5%AE%98%E6%96%B9%E4%B8%8E%E9%9D%9E%E5%AE%98%E6%96%B9%E6%A8%A1%E5%BC%8F%E5%88%86%E6%9E%90"><span class="toc-text">3、Starter 官方与非官方模式分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81Starter-%E5%AE%98%E6%96%B9%E6%A8%A1%E5%BC%8F%EF%BC%88SpringBoot%E5%BC%80%E5%8F%91%EF%BC%89"><span class="toc-text">1、Starter 官方模式（SpringBoot开发）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E5%BC%95%E5%85%A5%E4%BE%9D%E8%B5%96"><span class="toc-text">1、引入依赖</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE"><span class="toc-text">2、自动配置</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81Starter-%E9%9D%9E%E5%AE%98%E6%96%B9%E6%A8%A1%E5%BC%8F%EF%BC%88%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BC%80%E5%8F%91%EF%BC%89"><span class="toc-text">2、Starter 非官方模式（第三方开发）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E5%BC%95%E5%85%A5%E4%BE%9D%E8%B5%96-1"><span class="toc-text">1、引入依赖</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE-1"><span class="toc-text">2、自动配置</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E5%9C%BA%E6%99%AF%E5%90%AF%E5%8A%A8%E5%99%A8%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3"><span class="toc-text">4、场景启动器开发常用注解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81Full%E5%85%A8%E6%A8%A1%E5%BC%8F%E5%92%8CLite%E8%BD%BB%E9%87%8F%E7%BA%A7%E6%A8%A1%E5%BC%8F"><span class="toc-text">5、Full全模式和Lite轻量级模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9C%BA%E6%99%AF%E5%90%AF%E5%8A%A8%E5%99%A8%E7%9A%84%E8%A7%84%E8%8C%83"><span class="toc-text">6、自定义场景启动器的规范</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E3%80%81Starter-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BC%96%E5%86%99%E7%A4%BA%E4%BE%8B1%EF%BC%88ID%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%EF%BC%89"><span class="toc-text">7、Starter 自定义编写示例1（ID自动生成）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E5%88%9B%E5%BB%BA%E5%90%AF%E5%8A%A8%E5%99%A8%E7%A9%BA%E9%A1%B9%E7%9B%AE-spring-boot-starter"><span class="toc-text">1、创建启动器空项目-spring-boot-starter</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E5%88%9B%E5%BB%BA%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E9%A1%B9%E7%9B%AE-spring-boot-autoconfigure"><span class="toc-text">2、创建自动配置项目-spring-boot-autoconfigure</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8%E3%80%81Starter-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BC%96%E5%86%99%E7%A4%BA%E4%BE%8B2%EF%BC%88API%E6%97%A5%E5%BF%97%E6%89%93%E5%8D%B0%EF%BC%89"><span class="toc-text">8、Starter 自定义编写示例2（API日志打印）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81mylog-spring-boot-starter"><span class="toc-text">1、mylog-spring-boot-starter</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81mylog-spring-boot-autoconfigure"><span class="toc-text">2、mylog-spring-boot-autoconfigure</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9%E3%80%81Starter-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BC%96%E5%86%99%E7%A4%BA%E4%BE%8B3%EF%BC%88AOP%E6%97%A5%E5%BF%97%E6%89%93%E5%8D%B0%EF%BC%89"><span class="toc-text">9、Starter 自定义编写示例3（AOP日志打印）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81aspectlog-spring-boot-starter"><span class="toc-text">1、aspectlog-spring-boot-starter</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81aspectlog-spring-boot-autoconfigure"><span class="toc-text">2、aspectlog-spring-boot-autoconfigure</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10%E3%80%81SpringBoot-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90-starter-%E7%BB%84%E4%BB%B6"><span class="toc-text">10、SpringBoot 自定义多数据源 starter 组件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E5%88%9B%E5%BB%BA%E6%99%AE%E9%80%9A%E9%A1%B9%E7%9B%AE%EF%BC%8C%E5%BC%95%E5%85%A5%E7%9B%B8%E5%85%B3%E7%9A%84%E4%BE%9D%E8%B5%96"><span class="toc-text">1、创建普通项目，引入相关的依赖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E5%88%9B%E5%BB%BA%E5%B8%B8%E9%87%8F%E7%B1%BB%E5%92%8C%E6%B3%A8%E8%A7%A3"><span class="toc-text">2、创建常量类和注解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E5%88%9B%E5%BB%BA%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E5%B1%9E%E6%80%A7%E7%B1%BB"><span class="toc-text">3、创建多数据源属性类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E6%BA%90key%E7%9A%84%E5%88%87%E6%8D%A2%E5%B7%A5%E5%85%B7"><span class="toc-text">4、创建数据源key的切换工具</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81%E5%88%9B%E5%BB%BA%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E7%9A%84%E5%88%87%E9%9D%A2%E7%B1%BB"><span class="toc-text">5、创建多数据源的切面类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E6%BA%90%E9%85%8D%E7%BD%AE%E7%B1%BB%E5%8F%8A%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E7%B1%BB"><span class="toc-text">6、创建数据源配置类及多数据源类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%E3%80%81%E9%85%8D%E7%BD%AEspring-factories%E6%96%87%E4%BB%B6"><span class="toc-text">7、配置spring.factories文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9%E3%80%81%E6%96%B0%E5%BB%BASpringBoot%E9%A1%B9%E7%9B%AE%E6%B5%8B%E8%AF%95%E7%A4%BA%E4%BE%8B"><span class="toc-text">9、新建SpringBoot项目测试示例</span></a></li></ol></li></ol></li></ol>
    
<style>
    .left-col .switch-btn,
    .left-col .switch-area {
        display: none;
    }
    .toc-level-3 i,
    .toc-level-3 ol {
        display: none !important;
    }
</style>
</div>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="一、SpringApplication-自定义启动方式"><a href="#一、SpringApplication-自定义启动方式" class="headerlink" title="一、SpringApplication 自定义启动方式"></a>一、SpringApplication 自定义启动方式</h1><blockquote>
<p>来源：Springboot教程系列(2) 小谈SpringApplication启动：<a target="_blank" rel="noopener" href="http://it.hzqiuxm.com/springboot%e6%95%99%e7%a8%8b%e7%b3%bb%e5%88%97%e4%b9%8b-2/">http://it.hzqiuxm.com/springboot%e6%95%99%e7%a8%8b%e7%b3%bb%e5%88%97%e4%b9%8b-2/</a></p>
</blockquote>
<p>在Springboot装配入门指南中我们简单了解了下组合注解@SpringbootApplication，它的本质是一个配置角色注解模式，同时开启了自动装配等功能。那我们是如何启动一个Springboot项目的呢？</p>
<p>SpringBoot项目中有一个启动类，该启动类会使用@SpringbootApplication进行标注，main方法中会统一使用SpringApplication.run()方法来启动。</p>
<p>我们今天的主角就是SpringApplication，谈谈它的启动和运行过程，其中会涉及到上下文应用加载、应用事件加载、应用监听器，应用推断、引导类推断、应用广播等概念</p>
<h2 id="1、第一种：SpringApplicationAPI-方式"><a href="#1、第一种：SpringApplicationAPI-方式" class="headerlink" title="1、第一种：SpringApplicationAPI 方式"></a>1、第一种：SpringApplicationAPI 方式</h2><p>1、方式一：本类作为run参数</p>
<pre><code class="java">@SpringBootApplication
public class NovelApplication &#123;
    public static void main(String[] args) &#123;
        SpringApplication.run(NovelApplication.class, args);
    &#125;
&#125;
</code></pre>
<p>2、方式二：其他类作为启动run启动参数</p>
<pre><code class="java">public class NovelApplication &#123;
    public static void main(String[] args) &#123;
        Set&lt;String&gt; sources = new HashSet();
        sources.add(ApplicationConfiguration.class.getName());
        SpringApplication springApplication = new SpringApplication();
        springApplication.setSources(sources);
        // Banner打印模式设置
        springApplication.setBannerMode(Banner.Mode.CONSOLE);
        // web应用类型设置
        springApplication.setWebApplicationType(WebApplicationType.NONE);
        // 环境设置
        springApplication.setAdditionalProfiles(&quot;prod&quot;);
        // 图形界面设置
        springApplication.setHeadless(true);
        // 启动
        springApplication.run(args);
    &#125;
    @SpringBootApplication
    public static class ApplicationConfiguration &#123;
        // 故意不使用NovelApplication类作为run的参数
    &#125;
&#125;
</code></pre>
<h2 id="2、第二种：SpringApplicationBuilderAPI-方式"><a href="#2、第二种：SpringApplicationBuilderAPI-方式" class="headerlink" title="2、第二种：SpringApplicationBuilderAPI 方式"></a>2、第二种：SpringApplicationBuilderAPI 方式</h2><p>SpringApplicationBuilder是SpringApplication和ApplicationContext实例的构建器，具有便利的流利的 API 和上下文层次结构支持。</p>
<pre><code class="java">@SpringBootApplication
public class NovelApplication &#123;
    // NovelApplication 是设置SpringBoot应用的入口。 @SpringBootApplication 注解启用自动配置和组件扫描
    public static void main(String[] args) &#123;
        // new SpringApplicationBuilder(NovelApplication.class) == new SpringApplicationBuilder()..sources(NovelApplication.class)
        ConfigurableApplicationContext applicationContext =
                new SpringApplicationBuilder(NovelApplication.class)  // main方法主类
                        .bannerMode(Banner.Mode.CONSOLE)  // Banner打印模式设置
                        .web(WebApplicationType.SERVLET)  // web应用类型设置
                        .profiles(&quot;prod&quot;)  // 环境设置
                        .headless(true)  // 图形界面设置
                        .properties(&quot;server.port=8848&quot;) // 改变端口号
                        .run(args);  // 启动
    &#125;
&#125;
</code></pre>
<p>有时我们需要创建多层次的ApplicationContext （例如，父子关系的Spring的ApplicationContext 和 SpringMVC），这时我们可以使用SpringApplicationBuilder将多个方法调用串起来，通过 parent() 和 child() 来创建多层次的ApplicationContext。</p>
<p>1、SpringApplication和ApplicationContext实例的构建器，具有方便的Builder API和上下文层次结构支持。上下文层次结构的简单示例：</p>
<pre><code class="java">@SpringBootApplication
public class NovelApplication &#123;
    public static void main(String[] args) &#123;
        new SpringApplicationBuilder(NovelApplication.class)
                .parent(ParentConfig.class)
                .child(ChildConfig.class)
                .run(args);
    &#125;
&#125;
</code></pre>
<p>2、另一个常见用例是设置激活配置文件和默认属性以设置应用程序的环境：</p>
<pre><code class="java">@SpringBootApplication
public class NovelApplication &#123;
    public static void main(String[] args) &#123;
        new SpringApplicationBuilder(NovelApplication.class)
                .profiles(&quot;test&quot;)
                .properties(&quot;password=aka&quot;)
                .run(args);
    &#125;
&#125;
</code></pre>
<p>3、配置多个配置文件，切换profile环境、以及启动多个Spring容器</p>
<pre><code class="java">@SpringBootApplication
public class TestProfiles &#123;
    public static void main(String[] args) &#123;
        // 启动第一个Spring容器，默认端口为8080
        ConfigurableApplicationContext context1 = new SpringApplicationBuilder(TestProfiles.class)
            .properties(&quot;spring.config.location=classpath:/test-profiles.yml&quot;)
            .properties(&quot;spring.profiles.active=oracle&quot;)
            .run(args);
        // 输出变量
        System.out.println(context1.getEnvironment().getProperty(&quot;jdbc.driver&quot;));

        // 启动第二个Spring容器，指定端口为8848
        ConfigurableApplicationContext context2 = new SpringApplicationBuilder(TestProfiles.class)
            .properties(&quot;spring.config.location=classpath:/test-profiles.yml&quot;)
            .properties(&quot;spring.profiles.active=mysql&quot;)
            .properties(&quot;server.port=8848&quot;)
            .run(args);
        // 输出变量
        System.out.println(context2.getEnvironment().getProperty(&quot;jdbc.driver&quot;));
    &#125;
&#125;
</code></pre>
<p>如果需求很简单，使用SpringApplication类中的静态方法即可。创建ApplicationContext层次结构时有一些限制，例如，Web组件必须包含在子上下文中，并且父上下文和子上下文都使用相同的环境。</p>
<h2 id="3、SpringApplicationBuilder-parent-应用场景"><a href="#3、SpringApplicationBuilder-parent-应用场景" class="headerlink" title="3、SpringApplicationBuilder parent 应用场景"></a>3、SpringApplicationBuilder parent 应用场景</h2><p>SpringApplicationBuilder类是Spring框架的一部分，它可以用来构建和运行Spring应用程序。在这个类中有一个parent属性，它可以用来指定一个”父”应用程序上下文，这个上下文中包含了一些共享的bean定义和资源。</p>
<p>应用场景：</p>
<p>当你想在一个已经存在的Spring应用程序上下文中构建另一个应用程序时，可以使用parent属性。这在微服务架构中很有用，因为你可以在一个”父”应用程序上下文中共享公共的Bean定义和资源，而不用在每个子应用程序中都重复定义。</p>
<h1 id="二、SpringBoot-启动流程及原理（自动配置）"><a href="#二、SpringBoot-启动流程及原理（自动配置）" class="headerlink" title="二、SpringBoot 启动流程及原理（自动配置）"></a>二、SpringBoot 启动流程及原理（自动配置）</h1><blockquote>
<p>SpringBoot 启动过程:</p>
<ol>
<li>作者：南宫煌_慧；来源：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/nangonghui/p/15663125.html">https://www.cnblogs.com/nangonghui/p/15663125.html</a></li>
<li>作者：涛姐涛哥；来源：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/taojietaoge/p/16075820.html">https://www.cnblogs.com/taojietaoge/p/16075820.html</a></li>
<li>作者：Fly丶X；来源：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44947701/article/details/124055713">https://blog.csdn.net/weixin_44947701/article/details/124055713</a></li>
<li>作者：业余草；来源：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/viDJc489EjuCPLPWNAnIzA">https://mp.weixin.qq.com/s/viDJc489EjuCPLPWNAnIzA</a></li>
<li>3分钟了解 SpringBoot 的启动流程：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/eT2A76G-42MvvN6RMZcPMg">https://mp.weixin.qq.com/s/eT2A76G-42MvvN6RMZcPMg</a></li>
</ol>
</blockquote>
<p>SpringBoot 的启动经过了一系列的处理（装配、加载、监听…），我们先看看整体过程的流程图：</p>
<pre><code>          ┌───────────────────────────────────────┐
          │           SpringBoot启动过程           │
          └───────────────────────────────────────┘
                            ⬇
          ┌───────────────────────────────────────┐
          │  1、运行 SpringApplication.run() 方法  │
          └───────────────────────────────────────┘
                            ⬇     
          ┌───────────────────────────────────────┐
          │          2、判断应用项目的类型          │ »» new SpringApplication() «« 开始
          └───────────────────────────────────────┘
                            ⬇
          ┌───────────────────────────────────────┐
          │        3、初始化所有根引导启动器        │
          └───────────────────────────────────────┘
                            ⬇
          ┌───────────────────────────────────────┐
          │         4、初始化所有容器上下文         │
          └───────────────────────────────────────┘
                            ⬇
          ┌───────────────────────────────────────┐
          │          5、初始化所有的监听器          │
          └───────────────────────────────────────┘
                            ⬇
          ┌───────────────────────────────────────┐
          │          6、设置程序运行的主类          │ »» new SpringApplication() «« 结束
          └───────────────────────────────────────┘
                            ⬇
          ┌───────────────────────────────────────┐
          │             7、开启计时器              │ »» springApplication.run() «« 开始
          └───────────────────────────────────────┘
                            ⬇
          ┌───────────────────────────────────────┐
          │ 8、创建启动上下文对象即bootstrapContext │
          └───────────────────────────────────────┘
                            ⬇
          ┌───────────────────────────────────────┐
          │        9、开启headless无头模式         │
          └───────────────────────────────────────┘
                            ⬇
          ┌───────────────────────────────────────┐
          │         10、获取并启动所有监听器        │
          └───────────────────────────────────────┘
                            ⬇
          ┌───────────────────────────────────────┐
          │         11、设置默认应用程序参数        │
          └───────────────────────────────────────┘
                            ⬇
          ┌───────────────────────────────────────┐
          │            12、准备环境变量            │
          └───────────────────────────────────────┘
                            ⬇
          ┌───────────────────────────────────────┐
          │          13、配置忽略Bean信息          │
          └───────────────────────────────────────┘
                            ⬇
          ┌───────────────────────────────────────┐
          │            14、打印Banner信息          │
          └───────────────────────────────────────┘
                            ⬇
          ┌───────────────────────────────────────┐
          │       15、创建IOC容器并设置启动器       │
          └───────────────────────────────────────┘
                            ⬇
          ┌───────────────────────────────────────┐
          │         16、准备IOC容器基本信息         │
          └───────────────────────────────────────┘
                            ⬇
          ┌───────────────────────────────────────┐
          │             17、刷新上下文             │
          └───────────────────────────────────────┘
                            ⬇
          ┌───────────────────────────────────────┐
          │          18、刷新上下文后置处理         │
          └───────────────────────────────────────┘
                            ⬇
          ┌───────────────────────────────────────┐
          │         19、结束计时器并打印日志        │
          └───────────────────────────────────────┘
                            ⬇
          ┌───────────────────────────────────────┐
          │         20、发布监听应用启动事件        │
          └───────────────────────────────────────┘
                            ⬇
          ┌───────────────────────────────────────┐
          │        21、执行自定义的run()方法        │
          └───────────────────────────────────────┘
                            ⬇
          ┌───────────────────────────────────────┐
          │        22、执行监听器的running()       │ »» springApplication.run() «« 结束
          └───────────────────────────────────────┘
                            ⬇
          ┌───────────────────────────────────────┐
          │           SpringBoot启动完成           │
          └───────────────────────────────────────┘
</code></pre>
<p>SpringBoot 启动流程分析使用版本SpringBoot VERSION：版本 <strong>2.5.0</strong>。</p>
<h2 id="1、XxApplication-main-方法"><a href="#1、XxApplication-main-方法" class="headerlink" title="1、XxApplication.main() 方法"></a>1、XxApplication.main() 方法</h2><p>SpringBoot项目最简单的Application启动类。所有的标准的SpringBoot的应用程序都是从run方法开始的</p>
<pre><code class="java">import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class TestApplication &#123;
    public static void main(String[] args) &#123;
        // 启动SpringBoot的入口
        SpringApplication.run(TestApplication.class, args);
    &#125;
&#125;
</code></pre>
<p>可以看出Application启动类中，包含了@SpringBootApplication 注解和 SpringApplication.run() 启动方法，所以SpringBoot的启动可以分解为 <strong>注解</strong> 和 <strong>启动方法</strong> 两大过程，而仔细看启动类中还引入了一个【org.springframework.boot.SpringApplication】包，所以启动方法中又可以分为两个阶段即 创建 <strong>SpringApplication实例</strong> 和 <strong>执行run方法</strong>。</p>
<p>简单总结一下 SpringBoot 启动主要分为两个阶段：</p>
<ol>
<li>构造SpringApplection的实例</li>
<li>调用实例的run方法</li>
</ol>
<h2 id="2、构造SpringApplication实例"><a href="#2、构造SpringApplication实例" class="headerlink" title="2、构造SpringApplication实例"></a>2、构造SpringApplication实例</h2><p>从启动类中的run方法跟进去：SpringApplication.run » return run » return new SpringApplication(primarySources).run(args) » this(null, primarySources) » SpringApplication 构造方法</p>
<pre><code class="java">    /**
     * Create a new &#123;@link SpringApplication&#125; instance. The application context will load
     * beans from the specified primary sources (see &#123;@link SpringApplication class-level&#125;
     * documentation for details. The instance can be customized before calling
     * &#123;@link #run(String...)&#125;.
     * @param resourceLoader the resource loader to use
     * @param primarySources the primary bean sources
     * @see #run(Class, String[])
     * @see #setSources(Set)
     */
    @SuppressWarnings(&#123; &quot;unchecked&quot;, &quot;rawtypes&quot; &#125;)
    public SpringApplication(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources) &#123;
        // 0.初始化类加载器
        this.resourceLoader = resourceLoader;
        // Assert 断言非空，若传入的class参数为null则打印异常并退出初始化
        Assert.notNull(primarySources, &quot;PrimarySources must not be null&quot;);
        // 0.获取main方法中的args，初始化启动时配置的额外参数集合
        this.primarySources = new LinkedHashSet&lt;&gt;(Arrays.asList(primarySources));
        // 1.判断项目启动类型：NONE/SERVLET/REACTIVE (默认是Servlet容器)
        this.webApplicationType = WebApplicationType.deduceFromClasspath();
        // 2.设置Bootstrapper: 从Spring工厂获取 BootstrapRegistryInitializers
        this.bootstrapRegistryInitializers = getBootstrapRegistryInitializersFromSpringFactories();
        // 3.设置所有初始化器: 获取Spring工厂实例 -&gt; 容器上下文相关的初始化
        setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));
        // 4.设置所有监听器: 获取Spring工厂实例 -&gt; 设置应用程序监听器
        setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));
        // 5.推导出主应用程序类，即从当前的栈信息中寻找main所在主类：com.iot.SpringBootLoveApplication
        this.mainApplicationClass = deduceMainApplicationClass();
    &#125;
</code></pre>
<p>总结一下构造方法都做了什么：</p>
<ol>
<li><p>把参数sources设置到SpringApplection属性中，这个sources可以是任何类型的参数</p>
</li>
<li><p>推断Web应用类型（WebApplicationType），本例中是SERVLET</p>
</li>
<li><p>设置 Bootstrapper、ApplicationContextInitializer 和 ApplicationListener</p>
</li>
<li><p>初始化主类mainApplectionClass，定位main方法</p>
</li>
<li><p>注意到：在设置 Bootstrapper、ApplicationContextInitializer 和 ApplicationListener 时，都调用了同一个方法getSpringFactoriesInstances，从所有 META-INF&#x2F;spring.factories 文件中加载，并查找指定名称的的值</p>
<p>回到之前的构造方法那里，现在我们知道设置的 Bootstrapper、ApplicationContextInitializer、ApplicationListener 是从哪儿来的了，原来是在META-INF&#x2F;spring.factories中配置的。查找指定key对应的值，然后实例化它们，并返回一个List。</p>
</li>
</ol>
<p>总结一句话概括：构造函数的功能主要是为成员变量赋值，包括首要类、确定web应用类型，从资源文件中加载的类资源，为注册初始类、监听器类、上下文初始化类赋值，确定主类</p>
<h3 id="2-1、判断应用项目类型"><a href="#2-1、判断应用项目类型" class="headerlink" title="2.1、判断应用项目类型"></a>2.1、判断应用项目类型</h3><p>在SpringApplication的构造方法内，首先会通过 WebApplicationType.deduceFromClasspath()； 方法判断当前应用程序的容器，默认使用的是Servlet 容器，除了Servlet之外，还有NONE 和 REACTIVE （响应式编程）。WebApplicationType.java 枚举类方法如下：</p>
<pre><code class="java">/**
 * deduceFromClasspath
 * 依次循环遍历当前应用中是否存在相关的类来判断最终应用的启动类型
 */
static WebApplicationType deduceFromClasspath() &#123;
    /**
     * REACTIVE：响应式WEB项目
     * 若启动类型为REACTIVE,
     * 则类路径下存在 org.springframework.web.reactive.DispatcherHandler 类
     * 并且不存在 org.springframework.web.servlet.DispatcherServlet 和 org.glassfish.jersey.servlet.ServletContainer
     * 两者指的是SpringMVC/Tomcat和jersey容器
     */
    if (ClassUtils.isPresent(WEBFLUX_INDICATOR_CLASS, null) &amp;&amp; !ClassUtils.isPresent(WEBMVC_INDICATOR_CLASS, null)
            &amp;&amp; !ClassUtils.isPresent(JERSEY_INDICATOR_CLASS, null)) &#123;
        return WebApplicationType.REACTIVE;
    &#125;
    /**
     * NONE：非WEB项目,就是一个最简单的Springboot应用
     * 若启动类型为NONE
     * 则类路径下 javax.servlet.Servlet 和org.springframework.web.context.ConfigurableWebApplicationContext都不存在
     */
    for (String className : SERVLET_INDICATOR_CLASSES) &#123;
        if (!ClassUtils.isPresent(className, null)) &#123;
            return WebApplicationType.NONE;
        &#125;
    &#125;
    /**
     * SERVLET：SERVLET WEB 项目
     * 若启动类型为Servlet，则必须有SERVLET_INDICATOR_CLASSES中的javax.servlet.Servlet
     * 和org.springframework.web.context.ConfigurableWebApplicationContext
     */
    return WebApplicationType.SERVLET;
&#125;
</code></pre>
<h3 id="2-2、初始化所有根引导启动器"><a href="#2-2、初始化所有根引导启动器" class="headerlink" title="2.2、初始化所有根引导启动器"></a>2.2、初始化所有根引导启动器</h3><blockquote>
<p>初始化根引导程序：Bootstrapper</p>
</blockquote>
<p>getBootstrapRegistryInitializersFromSpringFactories() 方法从spring.factories 中获取 BootstrapRegistryInitializer</p>
<pre><code class="java">// 2.设置Bootstrapper: 从Spring工厂获取 BootstrapRegistryInitializers
this.bootstrapRegistryInitializers = getBootstrapRegistryInitializersFromSpringFactories();
</code></pre>
<pre><code class="java">private List&lt;BootstrapRegistryInitializer&gt; getBootstrapRegistryInitializersFromSpringFactories() &#123;
    ArrayList&lt;BootstrapRegistryInitializer&gt; initializers = new ArrayList&lt;&gt;();
    /**
     * 从spring.factories 中获取Bootstrapper集合，
     * 然后遍历转化为BootstrapRegistryInitializer，再存入 initializers
     */
    getSpringFactoriesInstances(Bootstrapper.class).stream()
            .map((bootstrapper) -&gt; ((BootstrapRegistryInitializer) bootstrapper::initialize))
            .forEach(initializers::add);
    /**
     * 从spring.factories 中获取BootstrapRegistryInitializer集合，再存入 initializers
     * getSpringFactoriesInstances 该方法在整个启动流程中会频繁出现,下面集中介绍
     */
    initializers.addAll(getSpringFactoriesInstances(BootstrapRegistryInitializer.class));
    return initializers;
&#125;
</code></pre>
<p>设定初始引导启动器，保存在List中：从classpath的spring.factories文件中去找org.springframework.boot.Bootstrapper（在此项目中，没有找到）</p>
<h3 id="2-3、初始化所有容器上下文"><a href="#2-3、初始化所有容器上下文" class="headerlink" title="2.3、初始化所有容器上下文"></a>2.3、初始化所有容器上下文</h3><p>setInitializers 是容器上下文初始化，容器上下文初始化调用了getSpringFactoriesInstances() 方法，从spring.factories中获取配置</p>
<pre><code class="java">// 3.设置所有初始化器: 获取Spring工厂实例 -&gt; 容器上下文相关的初始化
setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));
</code></pre>
<pre><code class="java">public static final String FACTORIES_RESOURCE_LOCATION = &quot;META-INF/spring.factories&quot;;

public static List&lt;String&gt; loadFactoryNames(Class&lt;?&gt; factoryType, @Nullable ClassLoader classLoader) &#123;
    ClassLoader classLoaderToUse = classLoader;
    if (classLoaderToUse == null) &#123;
        classLoaderToUse = SpringFactoriesLoader.class.getClassLoader();
    &#125;
    String factoryTypeName = factoryType.getName();
    return loadSpringFactories(classLoaderToUse).getOrDefault(factoryTypeName, Collections.emptyList());
&#125;


/**
 * Springboot自动配置的秘密
 * Springboot在启动时读取了所有starter jar包里的META-INF/spring.factories配置文件，实现了所谓的自动化配置
 * 这里jar包里的都是默认配置，后续Springboot也会从xml、yaml文件中的用户配置去覆盖同名的配置。
 * 另外，这里的缓存配置是保存在一个map类型的cache中，其中的key键对应上面提到的各种Type类型，value就是Type的各种初始jar包里的同类型Java类。
 */
private static Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(ClassLoader classLoader) &#123;
    // 获取相应类加载器中内容
    Map&lt;String, List&lt;String&gt;&gt; result = cache.get(classLoader);
    // 存在则直接返回类加载器中内容
    if (result != null) &#123;
        return result;
    &#125;
    // 不存在则初始化类加载器中内容
    result = new HashMap&lt;&gt;();
    try &#123;
        /**
         * 获取资源 -&gt; META-INF/spring.factories 列表
         * 其中FACTORIES_RESOURCE_LOCATION的值：META-INF/spring.factories
         */
        Enumeration&lt;URL&gt; urls = classLoader.getResources(FACTORIES_RESOURCE_LOCATION);
        // 可能存在多个META-INF/spring.factories 文件,循环加载
        while (urls.hasMoreElements()) &#123;
            // 获取 META-INF/spring.factories 文件URL地址
            URL url = urls.nextElement();
            // 加载资源
            UrlResource resource = new UrlResource(url);
            // 加载资源配置
            Properties properties = PropertiesLoaderUtils.loadProperties(resource);
            // key:value形式循环配置
            for (Map.Entry&lt;?, ?&gt; entry : properties.entrySet()) &#123;
                String factoryTypeName = ((String) entry.getKey()).trim();
                // 逗号分隔列表到字符串数组
                String[] factoryImplementationNames =
                        StringUtils.commaDelimitedListToStringArray((String) entry.getValue());
                // 循环value中子项到列表中
                for (String factoryImplementationName : factoryImplementationNames) &#123;
                    result.computeIfAbsent(factoryTypeName, key -&gt; new ArrayList&lt;&gt;())
                            .add(factoryImplementationName.trim());
                &#125;
            &#125;
        &#125;

        // Replace all lists with unmodifiable lists containing unique elements
        // 列表去重
        result.replaceAll((factoryType, implementations) -&gt; implementations.stream().distinct()
                .collect(Collectors.collectingAndThen(Collectors.toList(), Collections::unmodifiableList)));
        // 列表保存
        cache.put(classLoader, result);
    &#125; catch (IOException ex) &#123;
        throw new IllegalArgumentException(&quot;Unable to load factories from location [&quot; +
                FACTORIES_RESOURCE_LOCATION + &quot;]&quot;, ex);
    &#125;
    return result;
&#125;


/**
 * 反射创建实现类
 */
private &lt;T&gt; List&lt;T&gt; createSpringFactoriesInstances(Class&lt;T&gt; type, Class&lt;?&gt;[] parameterTypes,
                                                   ClassLoader classLoader, Object[] args, Set&lt;String&gt; names) &#123;
    List&lt;T&gt; instances = new ArrayList&lt;&gt;(names.size());
    for (String name : names) &#123;
        try &#123;
            Class&lt;?&gt; instanceClass = ClassUtils.forName(name, classLoader);
            Assert.isAssignable(type, instanceClass);
            Constructor&lt;?&gt; constructor = instanceClass.getDeclaredConstructor(parameterTypes);
            T instance = (T) BeanUtils.instantiateClass(constructor, args);
            instances.add(instance);
        &#125; catch (Throwable ex) &#123;
            throw new IllegalArgumentException(&quot;Cannot instantiate &quot; + type + &quot; : &quot; + name, ex);
        &#125;
    &#125;
    return instances;
&#125;
</code></pre>
<pre><code class="java">// 调用链如下：
org.springframework.boot.SpringApplication.getSpringFactoriesInstances() -&gt;
    org.springframework.core.io.support.SpringFactoriesLoader.loadFactoryNames() -&gt;
        org.springframework.core.io.support.SpringFactoriesLoader.loadSpringFactories() -&gt;
            org.springframework.boot.SpringApplication.createSpringFactoriesInstances();
</code></pre>
<h3 id="2-4、初始化所有监听器"><a href="#2-4、初始化所有监听器" class="headerlink" title="2.4、初始化所有监听器"></a>2.4、初始化所有监听器</h3><p>初始化监听器与初始化容器上下文及引导启动器基本一样。调用getSpringFactoriesInstances() 方法，从spring.factories中获取配置</p>
<pre><code class="java">// 4.设置所有监听器: 获取Spring工厂实例 -&gt; 设置应用程序监听器
setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));
</code></pre>
<p>getBootstrapRegistryInitializersFromSpringFactories &amp;&amp; setInitializers &amp;&amp; setListeners 分别是：<strong>根引导程序初始化</strong> &amp; <strong>容器上下文初始化</strong> &amp; <strong>监听器初始化</strong>。根引导程序初始化、容器上下文初始化 和 监听器初始化 都是调用了getSpringFactoriesInstances() 方法，从spring.factories中获取配置。不同的是传给它的type参数，主要有一下几种类型。</p>
<ul>
<li>ApplicationContextInitializer.class：上下文相关</li>
<li>ApplicationListener.class：监听器相关</li>
<li>SpringApplicationRunListener.class：运行时监听器</li>
<li>SpringBootExceptionReporter.class：异常类相关</li>
<li>Bootstrapper.class：根引导程序</li>
</ul>
<hr>
<hr>
<blockquote>
<p>模拟初始化自定义类：</p>
</blockquote>
<p>在初始化 Bootstrapper、ApplicationContextInitializer 和 ApplicationListener 时，都调用了同一个方法getSpringFactoriesInstances，从所有 META-INF&#x2F;spring.factories 文件中加载，并查找指定名称的的值，那么这个文件在哪呢？SpringBoot 自己定义的都放在源码的jar包的 spring-boot-autoconfigure 项目里，而其他第三方start都定义在自己的 xxx-spring-boot-autoconfigure 项目里。实际上我们也可以定义在自己的SpringBoot项目中的 classpath 路径下（只是这样不太规范）</p>
<p>下面我们做个示例根据配置文件（META-INF&#x2F;spring.factories），创建ApplicationContextInitializer.class &amp; ApplicationListener.class两个接口的实现类：</p>
<p>1、自定义初始化器：实现 ApplicationContextInitializer 接口</p>
<pre><code class="java">import org.springframework.context.ApplicationContextInitializer;
import org.springframework.context.ConfigurableApplicationContext;

/**
 * 自定义的初始化器
 */
public class MyApplicationContextInitializer implements ApplicationContextInitializer&lt;ConfigurableApplicationContext&gt; &#123;
    @Override
    public void initialize(ConfigurableApplicationContext configurableApplicationContext) &#123;
        System.out.println(&quot;我是初始化的 MyApplicationContextInitializer...&quot;);
    &#125;
&#125;
</code></pre>
<p>2、自定义监听器：实现 ApplicationListener 接口</p>
<pre><code class="java">import org.springframework.boot.context.event.ApplicationStartedEvent;
import org.springframework.context.ApplicationListener;

public class MyApplicationListener implements ApplicationListener&lt;ApplicationStartedEvent&gt; &#123;
    @Override
    public void onApplicationEvent(ApplicationStartedEvent event) &#123;
        System.out.println(&quot;我是初始化的 MyApplicationListener...&quot;);
    &#125;
&#125;
</code></pre>
<p>3、在resources目录下添加 META-INF&#x2F;spring.factories 配置文件，内容如下，将自定义的初始化器和监听器注册进去；</p>
<pre><code class="properties">org.springframework.context.ApplicationContextInitializer=\
com.example.test.config.MyApplicationContextInitializer

org.springframework.context.ApplicationListener=\
com.example.test.config.MyApplicationListener
</code></pre>
<p>4、输出结果</p>
<pre><code>  .   ____          _            __ _ _
 /\\ / ___&#39;_ __ _ _(_)_ __  __ _ \ \ \ \
( ( )\___ | &#39;_ | &#39;_| | &#39;_ \/ _` | \ \ \ \
 \\/  ___)| |_)| | | | | || (_| |  ) ) ) )
  &#39;  |____| .__|_| |_|_| |_\__, | / / / /
 =========|_|==============|___/=/_/_/_/
 :: Spring Boot ::                (v2.5.0)
 
我是初始化的 MyApplicationContextInitializer...
### 省略了中间的日志 ###
我是初始化的 MyApplicationListener...
</code></pre>
<h3 id="2-3、设置程序运行的主类"><a href="#2-3、设置程序运行的主类" class="headerlink" title="2.3、设置程序运行的主类"></a>2.3、设置程序运行的主类</h3><p>deduceMainApplicationClass() 这个方法仅仅是找到main方法所在的类，为后面的扫包作准备，deduce是推断的意思，所以准确地说，这个方法作用是推断出主方法所在的类（其实遍历当前虚拟机栈获取main方法所在的类并且返回）：</p>
<pre><code class="java">// 5.推导出主应用程序类，即从当前的栈信息中寻找main所在主类：com.iot.SpringBootLoveApplication
this.mainApplicationClass = deduceMainApplicationClass();
</code></pre>
<pre><code class="java">/**
 * 推导主应用程序类
 */
private Class&lt;?&gt; deduceMainApplicationClass() &#123;
    try &#123;
        // 获取当前的栈信息
        StackTraceElement[] stackTrace = new RuntimeException().getStackTrace();
        for (StackTraceElement stackTraceElement : stackTrace) &#123;
            // 获取main方法所在的类class，此处即com.iot.SpringBootLoveApplication
            if (&quot;main&quot;.equals(stackTraceElement.getMethodName())) &#123;
                return Class.forName(stackTraceElement.getClassName());
            &#125;
        &#125;
    &#125; catch (ClassNotFoundException ex) &#123;
        // Swallow and continue
    &#125;
    return null;
&#125;
</code></pre>
<h2 id="3、执行实例的-run-方法"><a href="#3、执行实例的-run-方法" class="headerlink" title="3、执行实例的 run() 方法"></a>3、执行实例的 run() 方法</h2><p>接下来，重头戏来了，调用run()方法（重点看try里面的内容）</p>
<ol>
<li>首先是启动监听器来监听启动过程，这里再一次调用了熟悉的getSpringFactoriesInstances</li>
<li>然后将main方法中传的参数包装成ApplicationArguments对象</li>
<li>紧接着，创建并配置环境，返回一个ConfigurableEnvironment对象，由于本例中是SERVLET，所以创建的是StandardServletEnvironment</li>
<li>然后打印Banner</li>
<li>创建ApplicationContext，所有基于Spring的项目启动过程都是创建ApplicationContext，这里创建的ConfigurableApplicationContext是AnnotationConfigServletWebServerApplicationContext</li>
<li>有了ApplicationContext，紧接着要配置ApplicationContext</li>
<li>加载所有的source（其实就是class），然后实例化</li>
<li>这里就是一个，就是启动类</li>
<li>接下来，刷新容器</li>
<li>最终是调用Spring的applicationContext.refresh()，又看到了熟悉的一幕</li>
<li>最后还留了一个入口，回调子容器的onRefresh()</li>
<li>Spring MVC的启动是创建父子两个WebApplicationContext</li>
<li>在刷新容器之后，所有的Bean都已经实例化完成</li>
<li>afterRefresh什么也没做</li>
<li>最后是回调Runner，回调所有的ApplicationRunner和CommandLineRunner</li>
<li>至此，Spring Boot启动完成</li>
</ol>
<p>回顾一下：</p>
<ol>
<li>推断Web应用类型</li>
<li>设置Bootstrapper、ApplicationContextInitializer、ApplicationListener</li>
<li>推断main方法</li>
<li>创建并配置环境Environment</li>
<li>打印Banner</li>
<li>创建并配置ApplicationContext</li>
<li>刷新ApplicationContext（此处交由Spring处理，调用Spring的refresh()方法）实例化所有的bean</li>
<li>回调所有的ApplicationRunner和CommandLineRunner</li>
</ol>
<blockquote>
<p>初始化完SpringApplication对象就可以运行他的run方法了，也就是启动方法中的第二阶段。</p>
</blockquote>
<h3 id="3-01、View-Code"><a href="#3-01、View-Code" class="headerlink" title="3.01、View Code"></a>3.01、View Code</h3><p>首先查看run方法的代码，返回值为：ConfigurableApplicationContext</p>
<pre><code class="java">/**
 * Run the Spring application, creating and refreshing a new
 * &#123;@link ApplicationContext&#125;.
 *
 * @param args the application arguments (usually passed from a Java main method)
 * @return a running &#123;@link ApplicationContext&#125;
 */
public ConfigurableApplicationContext run(String... args) &#123;
    // 启动一个秒表计时器，用于统计项目启动时间
    StopWatch stopWatch = new StopWatch();
    stopWatch.start();
    // 创建启动上下文对象即Spring根容器
    DefaultBootstrapContext bootstrapContext = createBootstrapContext();
    // 定义可配置的应用程序上下文变量
    ConfigurableApplicationContext context = null;
    /**
     * 设置JDK系统属性
     * headless直译就是无头模式，
     * headless模式的意思是明确Springboot要在无鼠键支持的环境中运行，一般也都跑在Linux上，无鼠键支持，默认值true
     */
    configureHeadlessProperty();
    /**
     * 获取运行监听器 getRunListeners, 其中也是调用了上面说到的getSpringFactoriesInstances 方法
     * 从spring.factories中获取配置
     */
    SpringApplicationRunListeners listeners = getRunListeners(args);
    // 启动监听器
    listeners.starting(bootstrapContext, this.mainApplicationClass);
    try &#123;
        // 包装默认应用程序参数，也就是在命令行下启动应用带的参数，如--server.port=9000
        ApplicationArguments applicationArguments = new DefaultApplicationArguments(args);
        /**
         * 准备环境 prepareEnvironment 是个硬茬，里面主要涉及到
         * getOrCreateEnvironment、configureEnvironment、configurePropertySources、configureProfiles
         * environmentPrepared、bindToSpringApplication、attach诸多方法可以在下面的例子中查看
         */
        ConfigurableEnvironment environment = prepareEnvironment(listeners, bootstrapContext, applicationArguments);
        // 配置忽略的 bean
        configureIgnoreBeanInfo(environment);
        // 打印 SpringBoot 标志，即启动的时候在控制台的图案logo，可以在src/main/resources下放入名字是banner的自定义文件
        Banner printedBanner = printBanner(environment);
        // 创建 IOC 容器
        context = createApplicationContext();
        // 设置一个启动器，设置应用程序启动
        context.setApplicationStartup(this.applicationStartup);
        // 配置 IOC 容器的基本信息 (spring容器前置处理)
        prepareContext(bootstrapContext, context, environment, listeners, applicationArguments, printedBanner);
        /**
         * 刷新IOC容器
         * 这里会涉及Spring容器启动、自动装配、创建 WebServer启动Web服务即SpringBoot启动内嵌的 Tomcat
         */
        refreshContext(context);
        /**
         * 留给用户自定义容器刷新完成后的处理逻辑
         * 刷新容器后的扩展接口(spring容器后置处理)
         */
        afterRefresh(context, applicationArguments);
        // 结束计时器并打印，这就是我们启动后console的显示的时间
        stopWatch.stop();
        if (this.logStartupInfo) &#123;
            // 打印启动完毕的那行日志
            new StartupInfoLogger(this.mainApplicationClass).logStarted(getApplicationLog(), stopWatch);
        &#125;
        // 发布监听应用上下文启动完成（发出启动结束事件），所有的运行监听器调用 started() 方法
        listeners.started(context);
        // 执行runner，遍历所有的 runner，调用 run 方法
        callRunners(context, applicationArguments);
    &#125; catch (Throwable ex) &#123;
        // 异常处理，如果run过程发生异常
        handleRunFailure(context, ex, listeners);
        throw new IllegalStateException(ex);
    &#125;

    try &#123;
        // 所有的运行监听器调用 running() 方法,监听应用上下文
        listeners.running(context);
    &#125; catch (Throwable ex) &#123;
        // 异常处理
        handleRunFailure(context, ex, null);
        throw new IllegalStateException(ex);
    &#125;
    // 返回最终构建的容器对象
    return context;
&#125;
</code></pre>
<h3 id="3-02、开启计时器"><a href="#3-02、开启计时器" class="headerlink" title="3.02、开启计时器"></a>3.02、开启计时器</h3><p>程序运行到这里，就已经进入了run方法的主体了，第一步调用的run方法是静态方法，那个时候还没实例化SpringApplication对象，现在调用的run方法是非静态的，是需要实例化后才可以调用的，进来后首先会开启计时器，这个计时器有什么作用呢？顾名思义就使用来计时的嘛，计算SpringBoot启动花了多长时间；关键代码如下：</p>
<pre><code class="java">// 实例化计时器，然后开始计时
StopWatch stopWatch = new StopWatch();
stopWatch.start();
</code></pre>
<h3 id="3-03、createBootstrapContext"><a href="#3-03、createBootstrapContext" class="headerlink" title="3.03、createBootstrapContext"></a>3.03、createBootstrapContext</h3><p>调用createBootstrapContext方法创建引导上下文（即：创建启动上下文对象即Spring根容器）：对之前保存的bootstrappers挨个遍历执行intitialize方法来完成对引导启动器上下文环境的设置。</p>
<pre><code class="java">public class SpringApplication &#123;
    private DefaultBootstrapContext createBootstrapContext() &#123;
        DefaultBootstrapContext bootstrapContext = new DefaultBootstrapContext();
        // 此时的bootstrapRegistryInitializers为空，没有任何处理
        this.bootstrapRegistryInitializers.forEach((initializer) -&gt; initializer.initialize(bootstrapContext));
        return bootstrapContext;
    &#125;
&#125;
</code></pre>
<pre><code class="java">/**
 * 一个简单的引导上下文，在启动和环境后处理期间可用，直到准备好ApplicationContext。
 */
public class DefaultBootstrapContext implements ConfigurableBootstrapContext &#123;
&#125;
</code></pre>
<h3 id="3-04、configureHeadlessProperty"><a href="#3-04、configureHeadlessProperty" class="headerlink" title="3.04、configureHeadlessProperty"></a>3.04、configureHeadlessProperty</h3><p>configureHeadlessProperty 设置当前应用进入headless无头模式（java.awt.headless）</p>
<pre><code class="java">private static final String SYSTEM_PROPERTY_JAVA_AWT_HEADLESS = &quot;java.awt.headless&quot;;
/**
 * headless直译就是无头模式，
 * headless模式的意思是明确Springboot要在无鼠键支持的环境中运行，一般也都跑在Linux上，无鼠键支持，默认值true
 */
private void configureHeadlessProperty() &#123;
    // SYSTEM_PROPERTY_JAVA_AWT_HEADLESS = &quot;java.awt.headless&quot;;
    System.setProperty(SYSTEM_PROPERTY_JAVA_AWT_HEADLESS,
            System.getProperty(SYSTEM_PROPERTY_JAVA_AWT_HEADLESS, Boolean.toString(this.headless)));
&#125;
</code></pre>
<p>通过方法可以看到，setProperty()方法里面又有个getProperty()；这不多此一举吗？其实getProperty()方法里面有2个参数， 第一个key值，第二个是默认值，意思是通过key值查找属性值，如果属性值为空，则返回默认值 true；保证了一定有值的情况；</p>
<h3 id="3-05、获取并启用监听器"><a href="#3-05、获取并启用监听器" class="headerlink" title="3.05、获取并启用监听器"></a>3.05、获取并启用监听器</h3><p>获取所有RunListener运行监听器：从spring.factories中找SpringApplicationRunListener.class，遍历所有的RunListener，调用starting方法。相当于通知所有感兴趣系统正在启动的人，项目正在starting，这一部分涉及到自定义SpringBoot启动过程。</p>
<p>通过监听器来实现初始化的的基本操作：1.创建所有 Spring 运行监听器并发布应用启动事件。2.启用监听器</p>
<pre><code class="java">/**
 * 获取运行监听器 getRunListeners, 其中也是调用了上面说到的getSpringFactoriesInstances方法
 * 从spring.factories中获取配置, 启动监听器
 */
SpringApplicationRunListeners listeners = getRunListeners(args);
listeners.starting(bootstrapContext,this.mainApplicationClass);
</code></pre>
<h3 id="3-06、设置应用程序参数"><a href="#3-06、设置应用程序参数" class="headerlink" title="3.06、设置应用程序参数"></a>3.06、设置应用程序参数</h3><p>将执行run方法时传入的参数封装成一个对象，<strong>保存命令行参数</strong>，保存到ApplicationArguments实例中</p>
<pre><code class="java">// 包装默认应用程序参数，也就是在命令行下启动应用带的参数，如--server.port=9000
ApplicationArguments applicationArguments = new DefaultApplicationArguments(args);
</code></pre>
<pre><code class="java">public DefaultApplicationArguments(String... args) &#123;
    Assert.notNull(args, &quot;Args must not be null&quot;);
    this.source = new Source(args);
    this.args = args;
&#125;
</code></pre>
<h3 id="3-07、准备加载环境变量"><a href="#3-07、准备加载环境变量" class="headerlink" title="3.07、准备加载环境变量"></a>3.07、准备加载环境变量</h3><p>执行prepareEnvironment方法准备环境变量，包含系统属性和用户配置的属性。</p>
<pre><code class="java">/**
 * 准备环境 prepareEnvironment 是个硬茬，里面主要涉及到
 * getOrCreateEnvironment、configureEnvironment、configurePropertySources、configureProfiles
 * environmentPrepared、bindToSpringApplication、attach诸多方法可以在下面的例子中查看
 */
ConfigurableEnvironment environment = prepareEnvironment(listeners, bootstrapContext, applicationArguments);
</code></pre>
<p>prepareEnvironment方法里面主要涉及到：getOrCreateEnvironment、configureEnvironment、configurePropertySources、configureProfilesenvironmentPrepared、bindToSpringApplication、attach诸多方法。</p>
<ul>
<li>getOrCreateEnvironment：获取ApplicationServletEnvironment，主要从类路径下面加载配置文件资源，包括加载激活文件等</li>
<li>configureEnvironment：配置属性源和添加命令行参数；</li>
<li>ConfigurationPropertySources.attach：添加附件配置属性</li>
<li>listeners.environmentPrepared：发布环境已经准备好事件通知</li>
<li>DefaultPropertiesPropertySource.moveToEnd：将默认配置文件属性移至最后</li>
<li>bindToSpringApplication：将环境信息绑定至Spring应用</li>
</ul>
<pre><code class="java">/**
 * 准备环境
 *
 * @param listeners
 * @param bootstrapContext
 * @param applicationArguments
 * @return
 */
private ConfigurableEnvironment prepareEnvironment(SpringApplicationRunListeners listeners,
                                                   DefaultBootstrapContext bootstrapContext,
                                                   ApplicationArguments applicationArguments) &#123;
    // Create and configure the environment 创建和配置环境
    // 根据项目类型建环境ConfigurableEnvironment
    ConfigurableEnvironment environment = getOrCreateEnvironment();
    // 从环境中获取并设置 PropertySources 和 activeProfiles
    configureEnvironment(environment, applicationArguments.getSourceArgs());
    // 把 PropertySources 设置在自己PropertySources的第一个位置
    ConfigurationPropertySources.attach(environment);
    /**
     * 运行监听器调用
     * 广播事件，listeners环境准备(就是广播ApplicationEnvironmentPreparedEvent事件)
     * 发布事件通知所有的监听器当前环境准备完成
     */
    listeners.environmentPrepared(bootstrapContext, environment);
    // 移动 defaultProperties 属性源到环境中的最后一个源
    DefaultPropertiesPropertySource.moveToEnd(environment);
    // 断言 抛异常
    Assert.state(!environment.containsProperty(&quot;spring.main.environment-prefix&quot;),
            &quot;Environment prefix cannot be set via properties.&quot;);
    // 与容器绑定当前环境
    bindToSpringApplication(environment);
    // 若非web环境，将环境转换成StandardEnvironment
    if (!this.isCustomEnvironment) &#123;
        environment = new EnvironmentConverter(getClassLoader()).convertEnvironmentIfNecessary(environment,
                deduceEnvironmentClass());
    &#125;
    // 配置PropertySources对它自己的递归依赖
    ConfigurationPropertySources.attach(environment);
    return environment;
&#125;


/**
 * 获取或创建环境Environment
 *
 * @return
 */
private ConfigurableEnvironment getOrCreateEnvironment() &#123;
    // 存在则直接返回
    if (this.environment != null) &#123;
        return this.environment;
    &#125;
    /**
     * 根据webApplicationType创建对应的Environment
     */
    switch (this.webApplicationType) &#123;
        // SERVLET WEB 项目
        case SERVLET:
            return new ApplicationServletEnvironment();
        // REACTIVE：响应式WEB项目
        case REACTIVE:
            return new ApplicationReactiveWebEnvironment();
        // 非WEB项目,就是一个最简单的Springboot应用
        default:
            return new ApplicationEnvironment();
    &#125;
&#125;

/**
 * 从环境中获取并设置 PropertySources 和 activeProfiles
 * 将配置任务按顺序委托给configurePropertySources和configureProfiles
 * Template method delegating to
 * &#123;@link #configurePropertySources(ConfigurableEnvironment, String[])&#125; and
 * &#123;@link #configureProfiles(ConfigurableEnvironment, String[])&#125; in that order.
 * Override this method for complete control over Environment customization, or one of
 * the above for fine-grained control over property sources or profiles, respectively.
 *
 * @param environment this application&#39;s environment
 * @param args        arguments passed to the &#123;@code run&#125; method
 * @see #configureProfiles(ConfigurableEnvironment, String[])
 * @see #configurePropertySources(ConfigurableEnvironment, String[])
 */
protected void configureEnvironment(ConfigurableEnvironment environment, String[] args) &#123;
    if (this.addConversionService) &#123;
        environment.setConversionService(new ApplicationConversionService());
    &#125;
    // 配置PropertySources
    configurePropertySources(environment, args);
    // 配置Profiles
    configureProfiles(environment, args);
&#125;

/**
 * 配置PropertySources
 * Add, remove or re-order any &#123;@link PropertySource&#125;s in this application&#39;s
 * environment.
 *
 * @param environment this application&#39;s environment
 * @param args        arguments passed to the &#123;@code run&#125; method
 * @see #configureEnvironment(ConfigurableEnvironment, String[])
 */
protected void configurePropertySources(ConfigurableEnvironment environment, String[] args) &#123;
    MutablePropertySources sources = environment.getPropertySources();
    // 初始化 defaultProperties
    if (!CollectionUtils.isEmpty(this.defaultProperties)) &#123;
        // 存在的话将其放到最后位置
        DefaultPropertiesPropertySource.addOrMerge(this.defaultProperties, sources);
    &#125;
    /**
     * 存在命令行参数，则解析它并封装进SimpleCommandLinePropertySource对象
     * 同时将此对象放到sources的第一位置（优先级最高）
     */
    if (this.addCommandLineProperties &amp;&amp; args.length &gt; 0) &#123;
        String name = CommandLinePropertySource.COMMAND_LINE_PROPERTY_SOURCE_NAME;
        if (sources.contains(name)) &#123;
            PropertySource&lt;?&gt; source = sources.get(name);
            CompositePropertySource composite = new CompositePropertySource(name);
            composite.addPropertySource(
                    new SimpleCommandLinePropertySource(&quot;springApplicationCommandLineArgs&quot;, args));
            composite.addPropertySource(source);
            sources.replace(name, composite);
        &#125; else &#123;
            // 放到首位
            sources.addFirst(new SimpleCommandLinePropertySource(args));
        &#125;
    &#125;
&#125;

/**
 * 配置Profiles
 *
 * @param environment
 * @param args
 */
protected void configureProfiles(ConfigurableEnvironment environment, String[] args) &#123;
    /**
     * 保证environment的activeProfiles属性被初始化了。从PropertySources中查找spring.profiles.active属性
     * 存在则将其值添加activeProfiles集合中。
     * 配置应用环境中的哪些配置文件处于激活状态(或默认激活)
     * 可以通过spring.profiles.active属性在配置文件处理期间激活其他配置文件
     * 就是我们项目中通常配置的dev、sit、prod等环境配置信息设置哪些Profiles是激活的。
     */
    environment.getActiveProfiles(); // ensure they are initialized
    // But these ones should go first (last wins in a property key clash)
    // 如果存在其他的Profiles，则将这些Profiles放到第一的位置
    Set&lt;String&gt; profiles = new LinkedHashSet&lt;&gt;(this.additionalProfiles);
    profiles.addAll(Arrays.asList(environment.getActiveProfiles()));
    environment.setActiveProfiles(StringUtils.toStringArray(profiles));
&#125;

/**
 * 运行监听器调用
 *
 * @param bootstrapContext
 * @param environment
 */
void environmentPrepared(ConfigurableBootstrapContext bootstrapContext, ConfigurableEnvironment environment) &#123;
    doWithListeners(&quot;spring.boot.application.environment-prepared&quot;,
            (listener) -&gt; listener.environmentPrepared(bootstrapContext, environment));
&#125;

/**
 * 运行监听器调用
 * Called once the environment has been prepared, but before the
 * &#123;@link ApplicationContext&#125; has been created.
 *
 * @param environment the environment
 * @deprecated since 2.4.0 for removal in 2.6.0 in favor of
 * &#123;@link #environmentPrepared(ConfigurableBootstrapContext, ConfigurableEnvironment)&#125;
 */
@Deprecated
default void environmentPrepared(ConfigurableEnvironment environment) &#123;
    for (SpringApplicationRunListener listener : this.listeners) &#123;
        // 广播ApplicationEnvironmentPreparedEvent事件,后面再看
        listener.environmentPrepared(environment);
    &#125;
&#125;

/**
 * 与容器绑定当前环境
 * Bind the environment to the &#123;@link SpringApplication&#125;.
 *
 * @param environment the environment to bind
 */
protected void bindToSpringApplication(ConfigurableEnvironment environment) &#123;
    try &#123;
        // 将environment绑定到SpringApplication
        Binder.get(environment).bind(&quot;spring.main&quot;, Bindable.ofInstance(this));
    &#125; catch (Exception ex) &#123;
        throw new IllegalStateException(&quot;Cannot bind to SpringApplication&quot;, ex);
    &#125;
&#125;

/**
 * 配置PropertySources对它自己的递归依赖
 * Attach a &#123;@link ConfigurationPropertySource&#125; support to the specified
 * &#123;@link Environment&#125;. Adapts each &#123;@link PropertySource&#125; managed by the environment
 * to a &#123;@link ConfigurationPropertySource&#125; and allows classic
 * &#123;@link PropertySourcesPropertyResolver&#125; calls to resolve using
 * &#123;@link ConfigurationPropertyName configuration property names&#125;.
 * &lt;p&gt;
 * The attached resolver will dynamically track any additions or removals from the
 * underlying &#123;@link Environment&#125; property sources.
 *
 * @param environment the source environment (must be an instance of
 *                    &#123;@link ConfigurableEnvironment&#125;)
 * @see #get(Environment)
 */
public static void attach(Environment environment) &#123;
    // 判断environment是否是ConfigurableEnvironment的实例
    Assert.isInstanceOf(ConfigurableEnvironment.class, environment);
    // 从environment获取PropertySources
    MutablePropertySources sources = ((ConfigurableEnvironment) environment)
            .getPropertySources();
    PropertySource&lt;?&gt; attached = sources.get(ATTACHED_PROPERTY_SOURCE_NAME);
    if (attached != null &amp;&amp; attached.getSource() != sources) &#123;
        sources.remove(ATTACHED_PROPERTY_SOURCE_NAME);
        attached = null;
    &#125;
    if (attached == null) &#123;
        // 将sources封装成ConfigurationPropertySourcesPropertySource对象，并把这个对象放到sources的第一位置
        sources.addFirst(new ConfigurationPropertySourcesPropertySource(
                ATTACHED_PROPERTY_SOURCE_NAME,
                new SpringConfigurationPropertySources(sources)));
    &#125;
&#125;
</code></pre>
<p>调用getOrCreateEnvironment() 方法得到环境对象：如果环境信息已经存在，直接返回使用；如果环境信息没有，则创建环境信息对象，不同的应用创建不同的环境信息：</p>
<ol>
<li>SERVLET &#x3D;&gt; StandardServletEnvironment</li>
<li>REACTIVE &#x3D;&gt; StandardReactiveWebEnvironment</li>
<li>NONE or Default &#x3D;&gt; StandardEnvironment</li>
</ol>
<h3 id="3-08、配置忽略Bean信息"><a href="#3-08、配置忽略Bean信息" class="headerlink" title="3.08、配置忽略Bean信息"></a>3.08、配置忽略Bean信息</h3><p>configureIgnoreBeanInfo() 这个方法是将 spring.beaninfo.ignore 的默认值值设为 true，意思是跳过beanInfo的搜索，其设置默认值的原理和configureHeadlessProperty设置headless无头模式一样；</p>
<pre><code class="java">// 配置忽略的 bean
configureIgnoreBeanInfo(environment);
</code></pre>
<pre><code class="java">private void configureIgnoreBeanInfo(ConfigurableEnvironment environment) &#123;
    if (System.getProperty(
            CachedIntrospectionResults.IGNORE_BEANINFO_PROPERTY_NAME) == null) &#123;
        Boolean ignore = environment.getProperty(&quot;spring.beaninfo.ignore&quot;,
                Boolean.class, Boolean.TRUE);
        System.setProperty(CachedIntrospectionResults.IGNORE_BEANINFO_PROPERTY_NAME,
                ignore.toString());
    &#125;
&#125;
</code></pre>
<p>如上是设置环境变量来配置，当然也可以在配置文件中添加以下配置来设为false。目前还不知道这个配置的具体作用。</p>
<pre><code class="properties">spring.beaninfo.ignore=false
</code></pre>
<h3 id="3-09、打印Banner信息"><a href="#3-09、打印Banner信息" class="headerlink" title="3.09、打印Banner信息"></a>3.09、打印Banner信息</h3><p>printBanner 打印SpringBoot标志。printBanner(environment)方法就是打印Banner，Banner就是项目启动时看到的那个logo，默认标准信息在SpringBootBanner.java类中。如果想自定义Banner可以在工程项目src&#x2F;main&#x2F;resources路径下下放入名字是banner的文件，后缀后可以是SpringApplicationBannerPrinter.java类里的{ “gif”, “jpg”, “png” }，或者是txt、图片也可以的，但是图片打印时会字符化，而不是打印图片本身。<a target="_blank" rel="noopener" href="https://www.bootschool.net/ascii">自定义banner链接</a></p>
<pre><code class="java">// 打印 SpringBoot 标志，即启动的时候在控制台的图案logo，可以在src/main/resources下放入名字是banner的自定义文件
Banner printedBanner = printBanner(environment);
</code></pre>
<pre><code class="java">/**
 * 打印SpringBoot标志
 * banner的输出默认有三种种模式，LOG、CONSOLE、OFF。
 * 1. LOG：将banner信息输出到日志文件。
 * 2. CONSOLE：将banner信息输出到控制台。
 * 3. OFF：禁用banner的信息输出。
 *
 * @param environment
 * @return
 */
private Banner printBanner(ConfigurableEnvironment environment) &#123;
    // 判断Banner的模式是否关闭，如果关闭直接返回。
    if (this.bannerMode == Banner.Mode.OFF) &#123;
        return null;
    &#125;
    ResourceLoader resourceLoader = (this.resourceLoader != null) ? this.resourceLoader
            : new DefaultResourceLoader(null);
    // 创建SpringApplicationBannerPrinter 打印类
    SpringApplicationBannerPrinter bannerPrinter = new SpringApplicationBannerPrinter(resourceLoader, this.banner);
    // LOG：将banner信息输出到日志文件
    if (this.bannerMode == Mode.LOG) &#123;
        return bannerPrinter.print(environment, this.mainApplicationClass, logger);
    &#125;
    //banner没有关闭且没有指定是写到log文件中 将banner信息输出到控制台
    return bannerPrinter.print(environment, this.mainApplicationClass, System.out);
&#125;

/**
 * 打印
 *
 * @param environment
 * @param sourceClass
 * @param logger
 * @return
 */
Banner print(Environment environment, Class&lt;?&gt; sourceClass, Log logger) &#123;
    // 获取banner内容
    Banner banner = getBanner(environment);
    try &#123;
        logger.info(createStringFromBanner(banner, environment, sourceClass));
    &#125; catch (UnsupportedEncodingException ex) &#123;
        logger.warn(&quot;Failed to create String for banner&quot;, ex);
    &#125;
    return new PrintedBanner(banner, sourceClass);
&#125;

/**
 * 获取banner内容
 *
 * @param environment
 * @return
 */
private Banner getBanner(Environment environment) &#123;
    Banners banners = new Banners();
    // 图片类型的banner内容
    banners.addIfNotNull(getImageBanner(environment));
    // 文本类型的banner内容
    banners.addIfNotNull(getTextBanner(environment));
    if (banners.hasAtLeastOneBanner()) &#123;
        return banners;
    &#125;
    if (this.fallbackBanner != null) &#123;
        return this.fallbackBanner;
    &#125;
    return DEFAULT_BANNER;
&#125;

static final String BANNER_LOCATION_PROPERTY = &quot;spring.banner.location&quot;;
static final String DEFAULT_BANNER_LOCATION = &quot;banner.txt&quot;;

/**
 * 文本类型的banner内容获取
 *
 * @param environment
 * @return
 */
private Banner getTextBanner(Environment environment) &#123;
    /**
     * 拿到自定义配置的banner文件地址
     * BANNER_LOCATION_PROPERTY = &quot;spring.banner.location&quot;
     * DEFAULT_BANNER_LOCATION = &quot;banner.txt&quot;;
     */
    String location = environment.getProperty(BANNER_LOCATION_PROPERTY, DEFAULT_BANNER_LOCATION);
    Resource resource = this.resourceLoader.getResource(location);
    try &#123;
        if (resource.exists() &amp;&amp; !resource.getURL().toExternalForm().contains(&quot;liquibase-core&quot;)) &#123;
            return new ResourceBanner(resource);
        &#125;
    &#125; catch (IOException ex) &#123;
        // Ignore
    &#125;
    return null;
&#125;
</code></pre>
<h3 id="3-10、创建IOC容器并设置启动器"><a href="#3-10、创建IOC容器并设置启动器" class="headerlink" title="3.10、创建IOC容器并设置启动器"></a>3.10、创建IOC容器并设置启动器</h3><p>createApplicationContext 创建IOC容器（应用程序上下文）。并设置应用启动器。</p>
<pre><code class="java">// 创建 IOC 容器
context = createApplicationContext();
// 设置一个启动器，设置应用程序启动
context.setApplicationStartup(this.applicationStartup);
</code></pre>
<p>1.使用applicationContextFactory上下文工厂创建一个应用上下文，其中applicationContextFactory是一个成员变量</p>
<pre><code class="java">public class SpringApplication &#123;
    private ApplicationContextFactory applicationContextFactory = ApplicationContextFactory.DEFAULT;
    protected ConfigurableApplicationContext createApplicationContext() &#123;
        // 进入default的lambda表达式，返回AnnotationConfigServletWebServerApplicationContext
        return this.applicationContextFactory.create(this.webApplicationType);
    &#125;
&#125;
</code></pre>
<p>2.ApplicationContextFactory根据webApplicationType返回应用上下文，返回AnnotationConfigServletWebServerApplicationContext</p>
<pre><code class="java">@FunctionalInterface
public interface ApplicationContextFactory &#123;
    /**
     * 创建 IOC 容器
     * A default &#123;@link ApplicationContextFactory&#125; implementation that will create an
     * appropriate context for the &#123;@link WebApplicationType&#125;.
     */
    ApplicationContextFactory DEFAULT = (webApplicationType) -&gt; &#123;
        try &#123;
            // 根据当前应用的类型创建 IOC 容器
            switch (webApplicationType) &#123;
                // Web 应用环境对应 AnnotationConfigServletWebServerApplicationContext
                case SERVLET:
                    return new AnnotationConfigServletWebServerApplicationContext();
                // 响应式编程对应 AnnotationConfigReactiveWebServerApplicationContext
                case REACTIVE:
                    return new AnnotationConfigReactiveWebServerApplicationContext();
                // 默认为 Spring 环境 AnnotationConfigApplicationContext
                default:
                    return new AnnotationConfigApplicationContext();
            &#125;
        &#125; catch (Exception ex) &#123;
            throw new IllegalStateException(&quot;Unable create a default ApplicationContext instance, &quot;
                    + &quot;you may need a custom ApplicationContextFactory&quot;, ex);
        &#125;
    &#125;;
    ConfigurableApplicationContext create(WebApplicationType webApplicationType);
&#125;
</code></pre>
<h3 id="3-11、准备IOC容器基本信息"><a href="#3-11、准备IOC容器基本信息" class="headerlink" title="3.11、准备IOC容器基本信息"></a>3.11、准备IOC容器基本信息</h3><p>prepareContext 配置 IOC 容器的基本信息（准备应用程序上下文环境）</p>
<pre><code class="java">// 配置 IOC 容器的基本信息 (Spring容器前置处理)
prepareContext(bootstrapContext, context, environment, listeners, applicationArguments, printedBanner);
</code></pre>
<p>虽然已经得到了ApplicationContext对象，但此时的对象还只是一个空白对象，需要准备和处理后，ApplicationContext才能被使用。在准备过程中主要做了做了几件事：</p>
<ol>
<li>为ApplicationContext设置之前准备好的Environment对象</li>
<li>通过对ApplicationContext后置处理或是BeanDefinitionLoader等方式往容器中添加一些初始的Bean</li>
<li>应用默认的初始化器初始化应用程序上下文（责任链模式的应用，多个初始化器形成一个List，应用程序需要被每个初始化器应用一次，每个初始化器有自己的职责）</li>
<li>准备过程中ApplicationRunListener发出两个消息，分别是contextPrepared和contextLoaded</li>
</ol>
<pre><code class="java">/**
 * 准备IOC容器基本信息
 *
 * @param bootstrapContext
 * @param context
 * @param environment
 * @param listeners
 * @param applicationArguments
 * @param printedBanner
 */
private void prepareContext(DefaultBootstrapContext bootstrapContext, ConfigurableApplicationContext context,
                            ConfigurableEnvironment environment, SpringApplicationRunListeners listeners,
                            ApplicationArguments applicationArguments, Banner printedBanner) &#123;
    // 设置容器环境，包括各种变量
    context.setEnvironment(environment);
    // 后置处理流程，设置IOC容器的 bean 生成器和资源加载器
    postProcessApplicationContext(context);
    /**
     * 获取所有的初始化器调用 initialize() 方法进行初始化
     * 执行容器中的ApplicationContextInitializer（包括从 spring.factories和自定义的实例）初始化
     */
    applyInitializers(context);
    /**
     * 触发所有 SpringApplicationRunListener 监听器的 contextPrepared 事件方法
     * 所有的运行监听器调用 environmentPrepared() 方法，EventPublishingRunListener 发布事件通知 IOC 容器准备完成
     */
    listeners.contextPrepared(context);
    bootstrapContext.close(context);
    // 打印启动日志
    if (this.logStartupInfo) &#123;
        logStartupInfo(context.getParent() == null);
        logStartupProfileInfo(context);
    &#125;
    // Add boot specific singleton beans
    ConfigurableListableBeanFactory beanFactory = context.getBeanFactory();
    // 注册添加特定的单例bean
    beanFactory.registerSingleton(&quot;springApplicationArguments&quot;, applicationArguments);
    if (printedBanner != null) &#123;
        beanFactory.registerSingleton(&quot;springBootBanner&quot;, printedBanner);
    &#125;
    if (beanFactory instanceof DefaultListableBeanFactory) &#123;
        ((DefaultListableBeanFactory) beanFactory)
                .setAllowBeanDefinitionOverriding(this.allowBeanDefinitionOverriding);
    &#125;
    if (this.lazyInitialization) &#123;
        context.addBeanFactoryPostProcessor(new LazyInitializationBeanFactoryPostProcessor());
    &#125;
    // 加载所有资源 (Load the sources)
    Set&lt;Object&gt; sources = getAllSources();
    // 断言资源费控
    Assert.notEmpty(sources, &quot;Sources must not be empty&quot;);
    // 创建BeanDefinitionLoader，加载启动类，将启动类注入容器
    load(context, sources.toArray(new Object[0]));
    // 触发所有 SpringApplicationRunListener 监听器的 contextLoaded 事件方法
    listeners.contextLoaded(context);
&#125;
</code></pre>
<h3 id="3-12、刷新上下文"><a href="#3-12、刷新上下文" class="headerlink" title="3.12、刷新上下文"></a>3.12、刷新上下文</h3><p>refresh 刷新应用上下文，即刷新Spring上下文信息refreshContext。这里会涉及Spring容器启动（创建出容器中的所有组件）、SpringBoot 自动装配（starter 原理）、创建 WebServer启动Web服务即SpringBoot启动内嵌的 Tomcat。还有其他的Spring自带的机制在这里就不一一细说了。</p>
<pre><code class="java">public class SpringApplication &#123;
    /**
     * 刷新应用上下文
     *
     * @param context
     */
    private void refreshContext(ConfigurableApplicationContext context) &#123;
        if (this.registerShutdownHook) &#123;
            // 判断是否注册关闭的钩子，是则注册钩子
            shutdownHook.registerApplicationContext(context);
        &#125;
        refresh(context);
    &#125;

    /**
     * Refresh the underlying &#123;@link ApplicationContext&#125;.
     *
     * @param applicationContext the application context to refresh
     */
    protected void refresh(ConfigurableApplicationContext applicationContext) &#123;
        applicationContext.refresh();
    &#125;
&#125;

/******************************************分割线******************************************/

public abstract class AbstractApplicationContext extends DefaultResourceLoader
        implements ConfigurableApplicationContext &#123;
    /**
     * 刷新IOC容器
     *
     * @throws BeansException
     * @throws IllegalStateException
     */
    @Override
    public void refresh() throws BeansException, IllegalStateException &#123;
        synchronized (this.startupShutdownMonitor) &#123;
            StartupStep contextRefresh = this.applicationStartup.start(&quot;spring.context.refresh&quot;);

            // Prepare this context for refreshing. 准备刷新上下文
            prepareRefresh();

            // Tell the subclass to refresh the internal bean factory. 通知子类刷新内部工厂
            ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();

            // Prepare the bean factory for use in this context. 准备Bean工厂
            prepareBeanFactory(beanFactory);

            try &#123;
                // Allows post-processing of the bean factory in context subclasses.
                // 允许在上下文子类中对bean工厂进行后处理,这部分涉及Web服务器的启动，如servlet
                postProcessBeanFactory(beanFactory);

                StartupStep beanPostProcess = this.applicationStartup.start(&quot;spring.context.beans.post-process&quot;);
                // Invoke factory processors registered as beans in the context.
                // 调用在上下文中注册为 bean 的工厂处理器
                invokeBeanFactoryPostProcessors(beanFactory);

                // Register bean processors that intercept bean creation. 注册拦截 bean 创建的 bean 处理器
                registerBeanPostProcessors(beanFactory);
                beanPostProcess.end();

                // Initialize message source for this context. 初始化此上下文的消息源
                initMessageSource();

                // Initialize event multicaster for this context. 为该上下文初始化事件多播器
                initApplicationEventMulticaster();

                // Initialize other special beans in specific context subclasses. 初始化特定上下文子类中的其他特殊 bean
                /**
                 * SpringBoot 一键启动web工程的关键方法
                 * 创建 WebServer启动Web服务
                 * SpringBoot启动内嵌的 Tomcat 首先要在pom文件配置内嵌容器为tomcat
                 * SpringBoot 嵌入式 Servlet 容器，默认支持的 webServe：Tomcat、Jetty、Undertow
                 *          &lt;exclusion&gt;
                 *             &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                 *             &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;
                 *         &lt;/exclusion&gt;
                 */
                onRefresh();

                // Check for listener beans and register them. 检查侦听器 bean 并注册
                registerListeners();

                // Instantiate all remaining (non-lazy-init) singletons. 实例化所有剩余的（非延迟初始化）单例
                finishBeanFactoryInitialization(beanFactory);

                // Last step: publish corresponding event. 发布事件
                finishRefresh();
            &#125; catch (BeansException ex) &#123;
                if (logger.isWarnEnabled()) &#123;
                    logger.warn(&quot;Exception encountered during context initialization - &quot; +
                            &quot;cancelling refresh attempt: &quot; + ex);
                &#125;

                // Destroy already created singletons to avoid dangling resources.  销毁bean
                destroyBeans();

                // Reset &#39;active&#39; flag.
                cancelRefresh(ex);

                // Propagate exception to caller.
                throw ex;
            &#125; finally &#123;
                // Reset common introspection caches in Spring&#39;s core, since we
                // might not ever need metadata for singleton beans anymore...
                resetCommonCaches();
                contextRefresh.end();
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<p><strong>onRefresh</strong> 方法中创建WebServer、创建Tomcat对象，是SpringBoot一键启动web工程的关键。SpringBoot 嵌入式 Servlet 容器，默认支持的 webServe：Tomcat、Jetty、Undertow，但要在POM文件加入tomcat相关配置。</p>
<pre><code class="java">/**
 * 创建 WebServer启动Web服务
 */
@Override
protected void onRefresh() &#123;
    // 初始化给定应用程序上下文的主题资源
    super.onRefresh();
    try &#123;
        // 创建Web 服务
        createWebServer();
    &#125; catch (Throwable ex) &#123;
        throw new ApplicationContextException(&quot;Unable to start web server&quot;, ex);
    &#125;
&#125;

/**
 * super.onRefresh();
 * Initialize the theme capability.
 */
@Override
protected void onRefresh() &#123;
    /**
     * 初始化给定应用程序上下文的主题资源，自动检测一个名为“themeSource”的bean。
     * 如果没有这样的，将使用默认的(空的)ThemeSource。
     */
    this.themeSource = UiApplicationContextUtils.initThemeSource(this);
&#125;

/**
 * 创建Web 服务
 */
private void createWebServer() &#123;
    WebServer webServer = this.webServer;
    ServletContext servletContext = getServletContext();
    if (webServer == null &amp;&amp; servletContext == null) &#123;
        // 获取web server
        StartupStep createWebServer = this.getApplicationStartup().start(&quot;spring.boot.webserver.create&quot;);
        // 获取创建容器的工厂
        ServletWebServerFactory factory = getWebServerFactory();
        createWebServer.tag(&quot;factory&quot;, factory.getClass().toString());
        /**
         * 获取 tomcat 、Jetty 或 Undertow 容器
         * 从 getWebServer 方法点进去，找到 TomcatServletWebServerFactory 的实现方法，
         * 与之对应的还有 Jetty 和 Undertow。这里配置了基本的连接器、引擎、虚拟站点等配置。
         * 自动配置类 ServletWebServerFactoryAutoConfiguration 导入了 ServletWebServerFactoryConfiguration（配置类）,
         * 根据条件装配判断系统中到底导入了哪个 Web 服务器的包，创建出服务器并启动
         * 默认是 web-starter 导入 tomcat 包，容器中就有 TomcatServletWebServerFactory，创建出 Tomcat 服务器并启动
         */
        this.webServer = factory.getWebServer(getSelfInitializer());
        createWebServer.end();
        getBeanFactory().registerSingleton(&quot;webServerGracefulShutdown&quot;,
                new WebServerGracefulShutdownLifecycle(this.webServer));
        getBeanFactory().registerSingleton(&quot;webServerStartStop&quot;,
                new WebServerStartStopLifecycle(this, this.webServer));
    &#125; else if (servletContext != null) &#123;
        try &#123;
            // 启动web server
            getSelfInitializer().onStartup(servletContext);
        &#125; catch (ServletException ex) &#123;
            throw new ApplicationContextException(&quot;Cannot initialize servlet context&quot;, ex);
        &#125;
    &#125;
    initPropertySources();
&#125;

/**
 * 获取tomcat 容器
 * 配置了基本的连接器、引擎、虚拟站点等配置
 *
 * @param initializers
 * @return
 */
@Override
public WebServer getWebServer(ServletContextInitializer... initializers) &#123;
    if (this.disableMBeanRegistry) &#123;
        Registry.disableRegistry();
    &#125;
    /**
     * 创建了Tomcat对象，并设置参数
     */
    Tomcat tomcat = new Tomcat();
    // 设置工作忙碌
    File baseDir = (this.baseDirectory != null) ? this.baseDirectory : createTempDir(&quot;tomcat&quot;);
    tomcat.setBaseDir(baseDir.getAbsolutePath());
    // 初始化tomcat 连接，默认NIO
    Connector connector = new Connector(this.protocol);
    connector.setThrowOnFailure(true);
    tomcat.getService().addConnector(connector);
    customizeConnector(connector);
    // 配置基本的连接器、引擎、虚拟站点
    tomcat.setConnector(connector);
    // 设置自动部署为false
    tomcat.getHost().setAutoDeploy(false);
    configureEngine(tomcat.getEngine());
    for (Connector additionalConnector : this.additionalTomcatConnectors) &#123;
        tomcat.getService().addConnector(additionalConnector);
    &#125;
    // 准备上下文
    prepareContext(tomcat.getHost(), initializers);
    // 返回TomcatWebServer服务
    return getTomcatWebServer(tomcat);
&#125;

/**
 * Create a new &#123;@link TomcatWebServer&#125; instance.
 *
 * @param tomcat    the underlying Tomcat server
 * @param autoStart if the server should be started
 * @param shutdown  type of shutdown supported by the server
 * @since 2.3.0
 */
public TomcatWebServer(Tomcat tomcat, boolean autoStart, Shutdown shutdown) &#123;
    Assert.notNull(tomcat, &quot;Tomcat Server must not be null&quot;);
    this.tomcat = tomcat;
    this.autoStart = autoStart;
    this.gracefulShutdown = (shutdown == Shutdown.GRACEFUL) ? new GracefulShutdown(tomcat) : null;
    // 初始化Tomcat
    initialize();
&#125;

/**
 * 初始化Tomcat
 *
 * @throws WebServerException
 */
private void initialize() throws WebServerException &#123;
    logger.info(&quot;Tomcat initialized with port(s): &quot; + getPortsDescription(false));
    synchronized (this.monitor) &#123;
        try &#123;
            addInstanceIdToEngineName();

            Context context = findContext();
            context.addLifecycleListener((event) -&gt; &#123;
                if (context.equals(event.getSource()) &amp;&amp; Lifecycle.START_EVENT.equals(event.getType())) &#123;
                    // Remove service connectors so that protocol binding doesn&#39;t
                    // happen when the service is started.
                    removeServiceConnectors();
                &#125;
            &#125;);

            // Start the server to trigger initialization listeners
            this.tomcat.start();

            // We can re-throw failure exception directly in the main thread
            rethrowDeferredStartupExceptions();

            try &#123;
                ContextBindings.bindClassLoader(context, context.getNamingToken(), getClass().getClassLoader());
            &#125; catch (NamingException ex) &#123;
                // Naming is not enabled. Continue
            &#125;

            // Unlike Jetty, all Tomcat threads are daemon threads. We create a
            // blocking non-daemon to stop immediate shutdown
            startDaemonAwaitThread();
        &#125; catch (Exception ex) &#123;
            stopSilently();
            destroySilently();
            throw new WebServerException(&quot;Unable to start embedded Tomcat&quot;, ex);
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="3-13、刷新上下文后置处理"><a href="#3-13、刷新上下文后置处理" class="headerlink" title="3.13、刷新上下文后置处理"></a>3.13、刷新上下文后置处理</h3><p>afterRefresh(context, applicationArguments) 方法是启动后的一些处理，是一个空实现，留给用户扩展使。</p>
<pre><code class="java">/**
 * Called after the context has been refreshed.
 * @param context the application context
 * @param args the application arguments
  */
protected void afterRefresh(ConfigurableApplicationContext context, ApplicationArguments args) &#123;
&#125;
</code></pre>
<h3 id="3-14、结束计时器并打印日志"><a href="#3-14、结束计时器并打印日志" class="headerlink" title="3.14、结束计时器并打印日志"></a>3.14、结束计时器并打印日志</h3><pre><code class="java">// 结束计时器并打印，这就是我们启动后控制台的显示的时间
stopWatch.stop();
if (this.logStartupInfo) &#123;
    // 打印启动完毕的那行日志
    new StartupInfoLogger(this.mainApplicationClass).logStarted(getApplicationLog(), stopWatch);
&#125;
</code></pre>
<h3 id="3-15、发布监听应用启动事件"><a href="#3-15、发布监听应用启动事件" class="headerlink" title="3.15、发布监听应用启动事件"></a>3.15、发布监听应用启动事件</h3><pre><code class="java">// 通知所有监听器，可以started开始工作了
// 发布监听应用上下文启动完成（发出启动结束事件），所有的运行监听器调用 started() 方法
listeners.started(context);
</code></pre>
<h3 id="3-16、执行自定义的run方法"><a href="#3-16、执行自定义的run方法" class="headerlink" title="3.16、执行自定义的run方法"></a>3.16、执行自定义的run方法</h3><p>这是一个扩展功能，callRunners(context, applicationArguments) 可以在启动完成后执行自定义的run方法；有2中方式可以实现：</p>
<ol>
<li>实现 ApplicationRunner 接口</li>
<li>实现 CommandLineRunner 接口</li>
</ol>
<pre><code class="java">// 执行runner，遍历所有的 runner，调用 run 方法
callRunners(context, applicationArguments);
</code></pre>
<p>接下来我们验证一把，为了方便代码可读性，我把这2种方式都放在同一个类里面</p>
<pre><code class="java">import org.springframework.boot.ApplicationArguments;
import org.springframework.boot.ApplicationRunner;
import org.springframework.boot.CommandLineRunner;
import org.springframework.stereotype.Component;

@Component
public class MyRunner implements ApplicationRunner, CommandLineRunner &#123;
    @Override
    public void run(ApplicationArguments args) throws Exception &#123;
        System.out.println(&quot;我是自定义的run方法1，实现 ApplicationRunner 接口既可运行&quot;);
    &#125;
    
    @Override
    public void run(String... args) throws Exception &#123;
        System.out.println(&quot;我是自定义的run方法2，实现 CommandLineRunner 接口既可运行&quot;);
    &#125;
&#125;
</code></pre>
<blockquote>
<p>如果以上步骤出现了异常，SpringBoot会执行<code>listeners.failed(context, exception);</code>，通知所有监听器应用failed</p>
</blockquote>
<h3 id="3-17、执行监听器的running"><a href="#3-17、执行监听器的running" class="headerlink" title="3.17、执行监听器的running()"></a>3.17、执行监听器的running()</h3><p>通知所有监听器应用正在running，running 发布上下文完成准备事件，listeners.running() 发布上下文完成准备事件同前面的listeners.started() 方法一样，都是发布了一个running事件，代码也相同。</p>
<pre><code class="java">/**
 * 发布上下文完成准备事件
 * 与上面的 listeners.started() 方法一样
 *
 * @param context
 */
void running(ConfigurableApplicationContext context) &#123;
    // listener.started(context) 中交由context.publishEvent（）方法处理
    // 实际上是发送了一个ApplicationStartedEvent的事件
    doWithListeners(&quot;spring.boot.application.running&quot;, (listener) -&gt; listener.running(context));
&#125;

/**
 * 发布上下文完成准备事件
 * Called immediately before the run method finishes, when the application context has
 * been refreshed and all &#123;@link CommandLineRunner CommandLineRunners&#125; and
 * &#123;@link ApplicationRunner ApplicationRunners&#125; have been called.
 *
 * @param context the application context.
 * @since 2.0.0
 */
@Override
public void running(ConfigurableApplicationContext context) &#123;
    context.publishEvent(new ApplicationReadyEvent(this.application, this.args, context));
    AvailabilityChangeEvent.publish(context, ReadinessState.ACCEPTING_TRAFFIC);
&#125;
</code></pre>
<blockquote>
<p>如果running出现异常，则继续调用<code>listeners.failed(context, exception);</code></p>
</blockquote>
<p>这也是SpringBoot启动流程两大过程中的第二阶段的启动方法run中最后一个方法了，该方法执行完成后，SpringApplication的run(String… args)方法执行结束，至此Spring Boot的ApplicationContext 启动结束。SpringBoot启动流程比较复杂，期间涉及到许多的监听器和事件监听机制，需要深入学习</p>
<h2 id="4、SpringBoot启动流程总结"><a href="#4、SpringBoot启动流程总结" class="headerlink" title="4、SpringBoot启动流程总结"></a>4、SpringBoot启动流程总结</h2><p>SpringBoot启动流程总结就是下面代码块，一个创建SpringApplication实例，一个执行run方法，所有的猫腻都在其中。</p>
<p>1、创建SpringApplication实例</p>
<pre><code class="java">@SuppressWarnings(&#123; &quot;unchecked&quot;, &quot;rawtypes&quot; &#125;)
public SpringApplication(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources) &#123;
    // 0.初始化类加载器
    this.resourceLoader = resourceLoader;
    // Assert 断言非空，若传入的class参数为null则打印异常并退出初始化
    Assert.notNull(primarySources, &quot;PrimarySources must not be null&quot;);
    // 0.获取main方法中的args，初始化启动时配置的额外参数集合
    this.primarySources = new LinkedHashSet&lt;&gt;(Arrays.asList(primarySources));
    // 1.判断项目启动类型：NONE/SERVLET/REACTIVE (默认是Servlet容器)
    this.webApplicationType = WebApplicationType.deduceFromClasspath();
    // 2.设置Bootstrapper: 从Spring工厂获取 BootstrapRegistryInitializers
    this.bootstrapRegistryInitializers = getBootstrapRegistryInitializersFromSpringFactories();
    // 3.设置所有初始化器: 获取Spring工厂实例 -&gt; 容器上下文相关的初始化
    setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));
    // 4.设置所有监听器: 获取Spring工厂实例 -&gt; 设置应用程序监听器
    setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));
    // 5.推导出主应用程序类，即从当前的栈信息中寻找main所在主类：com.iot.SpringBootLoveApplication
    this.mainApplicationClass = deduceMainApplicationClass();
&#125;
</code></pre>
<p>2、执行实例的run()方法</p>
<pre><code class="java">public ConfigurableApplicationContext run(String... args) &#123;
    // 启动一个秒表计时器，用于统计项目启动时间
    StopWatch stopWatch = new StopWatch();
    stopWatch.start();
    // 创建启动上下文对象即Spring根容器
    DefaultBootstrapContext bootstrapContext = createBootstrapContext();
    // 定义可配置的应用程序上下文变量
    ConfigurableApplicationContext context = null;
    // headless直译就是无头模式，无鼠键支持
    configureHeadlessProperty();
    // 获取运行监听器 getRunListeners, 从spring.factories中获取配置, 并启动监听器
    SpringApplicationRunListeners listeners = getRunListeners(args);
    listeners.starting(bootstrapContext, this.mainApplicationClass);
    try &#123;
        // 包装默认应用程序参数，也就是在命令行下启动应用带的参数，如--server.port=9000
        ApplicationArguments applicationArguments = new DefaultApplicationArguments(args);
        // 准备环境 prepareEnvironment
        ConfigurableEnvironment environment = prepareEnvironment(listeners, bootstrapContext, applicationArguments);
        // 配置忽略的 bean
        configureIgnoreBeanInfo(environment);
        // 打印 SpringBoot 标志，即启动的时候在控制台的图案logo，可以在src/main/resources下放入名字是banner的自定义文件
        Banner printedBanner = printBanner(environment);
        // 创建 IOC 容器
        context = createApplicationContext();
        // 设置一个启动器，设置应用程序启动
        context.setApplicationStartup(this.applicationStartup);
        // 配置 IOC 容器的基本信息 (spring容器前置处理)
        prepareContext(bootstrapContext, context, environment, listeners, applicationArguments, printedBanner);
        // 刷新IOC容器，会涉及Spring容器启动、自动装配、创建 WebServer启动Web服务即SpringBoot启动内嵌的 Tomcat
        refreshContext(context);
        // 留给用户自定义容器刷新完成后的处理逻辑, 刷新容器后的扩展接口(spring容器后置处理)
        afterRefresh(context, applicationArguments);
        // 结束计时器并打印，这就是我们启动后console的显示的时间
        stopWatch.stop();
        if (this.logStartupInfo) &#123;
            // 打印启动完毕的那行日志
            new StartupInfoLogger(this.mainApplicationClass).logStarted(getApplicationLog(), stopWatch);
        &#125;
        // 发布监听应用上下文启动完成（发出启动结束事件），所有的运行监听器调用 started() 方法
        listeners.started(context);
        // 执行runner，遍历所有的 runner，调用 run 方法
        callRunners(context, applicationArguments);
    &#125; catch (Throwable ex) &#123;
        // 异常处理，如果run过程发生异常
        handleRunFailure(context, ex, listeners);
        throw new IllegalStateException(ex);
    &#125;

    try &#123;
        // 所有的运行监听器调用 running() 方法,监听应用上下文
        listeners.running(context);
    &#125; catch (Throwable ex) &#123;
        // 异常处理
        handleRunFailure(context, ex, null);
        throw new IllegalStateException(ex);
    &#125;
    // 返回最终构建的容器对象
    return context;
&#125;
</code></pre>
<h1 id="三、SpringBoot-启动类上的注解（自动配置）"><a href="#三、SpringBoot-启动类上的注解（自动配置）" class="headerlink" title="三、SpringBoot 启动类上的注解（自动配置）"></a>三、SpringBoot 启动类上的注解（自动配置）</h1><blockquote>
<p>作者：Jimoer；来源：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/ibJnLu4vplGadWcWBqdPpQ">https://mp.weixin.qq.com/s/ibJnLu4vplGadWcWBqdPpQ</a></p>
</blockquote>
<p>上面说到在SpringApplication的run()方法中，通过调用自己的prepareContext()方法，在prepareContext()方法中又调用getAllSources()方法，然后去获取启动类，然后通过SpringApplication的load()方法，去加载启动类，然后在刷新容器的时候就会去将启动类在容器中进行实例化。在刷新ApplicationContext容器时，就开始解析启动类上的注解了。</p>
<p>启动类XxoApplication就只有一个注解@SpringBootApplication，那么下面来看一下这个注解：</p>
<pre><code class="java">@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@SpringBootConfiguration
@EnableAutoConfiguration
@ComponentScan(excludeFilters = &#123; @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),
        @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)
public @interface SpringBootApplication &#123;
&#125;
</code></pre>
<p>可以看到这个注解是一个复合注解，有三个关键注解需要说明一下。</p>
<h2 id="1、-SpringBootConfiguration"><a href="#1、-SpringBootConfiguration" class="headerlink" title="1、@SpringBootConfiguration"></a>1、@SpringBootConfiguration</h2><p>@SpringBootConfiguration这个注解说明再点进去查看详情发现就是一个@Configuration注解，这说明启动类就是一个配置类。支持Spring以JavaConfig的形式启动。</p>
<pre><code class="java">@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Configuration
@Indexed
public @interface SpringBootConfiguration &#123;
&#125;
</code></pre>
<h2 id="2、-ComponentScan"><a href="#2、-ComponentScan" class="headerlink" title="2、@ComponentScan"></a>2、@ComponentScan</h2><p>这个注解，从字面的意思上也能看出来，就是组件扫描的意思，即默认扫描当前package以及其子包下面的Spring的注解，例如：@Controller、@Service、@Component等等注解。</p>
<pre><code class="java">@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
@Documented
@Repeatable(ComponentScans.class)
&#125;
</code></pre>
<h2 id="3、-EnableAutoConfiguration"><a href="#3、-EnableAutoConfiguration" class="headerlink" title="3、@EnableAutoConfiguration"></a>3、@EnableAutoConfiguration</h2><pre><code class="java">@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@AutoConfigurationPackage
@Import(AutoConfigurationImportSelector.class)
public @interface EnableAutoConfiguration &#123;
&#125;
</code></pre>
<p>@EnableAutoConfiguration这个注解也是一个复合注解：这个注解是比较核心的一个注解，SpringBoot的主要自动配置原理基本上都来自@EnableAutoConfiguration这个注解的配置，那么我们通过看这个注解的源码可以发现有两个注解比较重要的。</p>
<ul>
<li>一个是@AutoConfigurationPackage，自动配置包。</li>
<li>另一个是@Import(AutoConfigurationImportSelector.class)，自动引入组件。</li>
</ul>
<h2 id="4、-AutoConfigurationPackage"><a href="#4、-AutoConfigurationPackage" class="headerlink" title="4、@AutoConfigurationPackage"></a>4、@AutoConfigurationPackage</h2><p>@AutoConfigurationPackage这个注解字面的意思是<strong>自动配置包</strong>，那么我们点进去看看里面是什么样的。</p>
<pre><code class="java">@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@Import(AutoConfigurationPackages.Registrar.class)
public @interface AutoConfigurationPackage &#123;
&#125;
</code></pre>
<p>还是一个复合注解，但是最终依赖的确实@Import这个注解，这个注解后面我们会介绍，现在先明白它就是给Spring容器引入组件的功能的一个注解。</p>
<p>那么我们接着来看看AutoConfigurationPackages.Registrar.class这个类里面的代码。</p>
<pre><code class="java">/**
 * &#123;@link ImportBeanDefinitionRegistrar&#125; to store the base package from the importing
 * configuration.
 */
static class Registrar implements ImportBeanDefinitionRegistrar, DeterminableImports &#123;
    @Override
    public void registerBeanDefinitions(AnnotationMetadata metadata, BeanDefinitionRegistry registry) &#123;
        register(registry, new PackageImports(metadata).getPackageNames().toArray(new String[0]));
    &#125;

    @Override
    public Set&lt;Object&gt; determineImports(AnnotationMetadata metadata) &#123;
        return Collections.singleton(new PackageImports(metadata));
    &#125;
&#125;
</code></pre>
<pre><code class="java">public static void register(BeanDefinitionRegistry registry, String... packageNames) &#123;
    if (registry.containsBeanDefinition(BEAN)) &#123;
        BasePackagesBeanDefinition beanDefinition = (BasePackagesBeanDefinition) registry.getBeanDefinition(BEAN);
        beanDefinition.addBasePackages(packageNames);
    &#125;
    else &#123;
        registry.registerBeanDefinition(BEAN, new BasePackagesBeanDefinition(packageNames));
    &#125;
&#125;
</code></pre>
<p>这两段代码就是这个AutoConfigurationPackages.Registrar这个类的关键部分，说实话，我是没看出来什么东西。但是网上搜到的是这个register()方法的作用是，用来自动注册一些组件中的配置，例如JPA的@Entity这个注解，这里就是会开启自动扫描这类注解的功能。</p>
<h2 id="5、-Import-AutoConfigurationImportSelector-class"><a href="#5、-Import-AutoConfigurationImportSelector-class" class="headerlink" title="5、@Import(AutoConfigurationImportSelector.class)"></a>5、@Import(AutoConfigurationImportSelector.class)</h2><p>我们接着回来看@EnableAutoConfiguration下的@Import(AutoConfigurationImportSelector.class)这个注解的功能。进入到AutoConfigurationImportSelector这个类里面后源码如下：</p>
<pre><code class="java">public class AutoConfigurationImportSelector implements DeferredImportSelector, BeanClassLoaderAware, ResourceLoaderAware, BeanFactoryAware, EnvironmentAware, Ordered &#123;
    
    @Override
    public String[] selectImports(AnnotationMetadata annotationMetadata) &#123;
        if (!isEnabled(annotationMetadata)) &#123;
            return NO_IMPORTS;
        &#125;
        // 关键代码
        AutoConfigurationEntry autoConfigurationEntry = getAutoConfigurationEntry(annotationMetadata);
        return StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());
    &#125;
&#125;
</code></pre>
<p>然后我们进入getAutoConfigurationEntry()方法来看看：</p>
<pre><code class="java">protected AutoConfigurationEntry getAutoConfigurationEntry(AnnotationMetadata annotationMetadata) &#123;
    if (!isEnabled(annotationMetadata)) &#123;
        return EMPTY_ENTRY;
    &#125;
    AnnotationAttributes attributes = getAttributes(annotationMetadata);
    // 关键代码
    List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes);
    configurations = removeDuplicates(configurations);
    Set&lt;String&gt; exclusions = getExclusions(annotationMetadata, attributes);
    checkExcludedClasses(configurations, exclusions);
    configurations.removeAll(exclusions);
    configurations = getConfigurationClassFilter().filter(configurations);
    fireAutoConfigurationImportEvents(configurations, exclusions);
    return new AutoConfigurationEntry(configurations, exclusions);
&#125;
</code></pre>
<p>我们继续进入getCandidateConfigurations()方法：</p>
<pre><code class="java">protected List&lt;String&gt; getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) &#123;
    // 关键代码
    List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(getSpringFactoriesLoaderFactoryClass(),
                                                                         getBeanClassLoader());
    Assert.notEmpty(configurations, &quot;No auto configuration classes found in META-INF/spring.factories. If you &quot;
                    + &quot;are using a custom packaging, make sure that file is correct.&quot;);
    return configurations;
&#125;
</code></pre>
<p>看来最核心的方法是SpringFactroiesLoader.loadFactoryNames()方法了，我们再进入看看：</p>
<pre><code class="java">public static List&lt;String&gt; loadFactoryNames(Class&lt;?&gt; factoryType, @Nullable ClassLoader classLoader) &#123;
    ClassLoader classLoaderToUse = classLoader;
    if (classLoaderToUse == null) &#123;
        classLoaderToUse = SpringFactoriesLoader.class.getClassLoader();
    &#125;
    String factoryTypeName = factoryType.getName();
    // 关键代码
    return loadSpringFactories(classLoaderToUse).getOrDefault(factoryTypeName, Collections.emptyList());
&#125;
</code></pre>
<p>包的好深，居然还有一层，那么继续进入loadSpringFactories()方法。</p>
<pre><code class="java">private static Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(ClassLoader classLoader) &#123;
    Map&lt;String, List&lt;String&gt;&gt; result = cache.get(classLoader);
    if (result != null) &#123;
        return result;
    &#125;

    result = new HashMap&lt;&gt;();
    try &#123;
        /** 关键代码1 **/
        Enumeration&lt;URL&gt; urls = classLoader.getResources(FACTORIES_RESOURCE_LOCATION);
        while (urls.hasMoreElements()) &#123;
            URL url = urls.nextElement();
            UrlResource resource = new UrlResource(url);
            /** 关键代码2 **/
            Properties properties = PropertiesLoaderUtils.loadProperties(resource);
            for (Map.Entry&lt;?, ?&gt; entry : properties.entrySet()) &#123;
                String factoryTypeName = ((String) entry.getKey()).trim();
                String[] factoryImplementationNames =
                    StringUtils.commaDelimitedListToStringArray((String) entry.getValue());
                for (String factoryImplementationName : factoryImplementationNames) &#123;
                    /** 关键代码3 **/
                    result.computeIfAbsent(factoryTypeName, key -&gt; new ArrayList&lt;&gt;())
                        .add(factoryImplementationName.trim());
                &#125;
            &#125;
        &#125;

        // Replace all lists with unmodifiable lists containing unique elements
        result.replaceAll((factoryType, implementations) -&gt; implementations.stream().distinct()
                          .collect(Collectors.collectingAndThen(Collectors.toList(), Collections::unmodifiableList)));
        /** 关键代码4 **/
        cache.put(classLoader, result);
    &#125;
    catch (IOException ex) &#123;
        throw new IllegalArgumentException(&quot;Unable to load factories from location [&quot; +
                                           FACTORIES_RESOURCE_LOCATION + &quot;]&quot;, ex);
    &#125;
    return result;
&#125;
</code></pre>
<blockquote>
<p>注意：上面代码标注了四处关键代码</p>
</blockquote>
<p>终于到最后一层了，算是“拨开云雾见天日,守得云开见月明”，下面就来梳理一下loadSpringFactories()方法。</p>
<p>首先<strong>FACTORIES_RESOURCE_LOCATION</strong>这个常量的值是：”<strong>META-INF&#x2F;spring.factories</strong>“</p>
<pre><code class="java">/**
 * The location to look for factories.
 * &lt;p&gt;Can be present in multiple JAR files.
 */
public static final String FACTORIES_RESOURCE_LOCATION = &quot;META-INF/spring.factories&quot;;
</code></pre>
<p>所以第一个关键核心代码的意思是：启动的时候会扫描所有jar包下<strong>META-INF&#x2F;spring.factories</strong>这个文件。第二段代码的意思是将这些扫描到的文件转成Properties对象，后面两个核心代码的意思就是说将加载到的Properties对象放入到缓存中。</p>
<p>然后<strong>getCandidateConfigurations()<strong>方法，是只获取了key是</strong>EnableAutoConfiguration.class</strong>的配置。</p>
<pre><code class="java">protected List&lt;String&gt; getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) &#123;
    List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(getSpringFactoriesLoaderFactoryClass(),
                                                                         getBeanClassLoader());
    Assert.notEmpty(configurations, &quot;No auto configuration classes found in META-INF/spring.factories. If you &quot;
                    + &quot;are using a custom packaging, make sure that file is correct.&quot;);
    return configurations;
&#125;

// 上面的方法调用了当前方法
protected Class&lt;?&gt; getSpringFactoriesLoaderFactoryClass() &#123;
    return EnableAutoConfiguration.class;
&#125;
</code></pre>
<p>我们可以打断点看到getCandidateConfigurations()方法，通过SpringFactoriesLoader.loadFactoryNames()获取到了131个配置（注意：不同SpringBoot版本看到的值是不一样的，本人使用的是SpringBoot-2.5.0版本）。请查看如下代码注意打上断点DEBUG测试查看值：</p>
<pre><code class="java">protected AutoConfigurationEntry getAutoConfigurationEntry(AnnotationMetadata annotationMetadata) &#123;
    if (!isEnabled(annotationMetadata)) &#123;
        return EMPTY_ENTRY;
    &#125;
    AnnotationAttributes attributes = getAttributes(annotationMetadata);
    // 断点打在如下一行，然后查看List值
    List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes);
    configurations = removeDuplicates(configurations);
    Set&lt;String&gt; exclusions = getExclusions(annotationMetadata, attributes);
    checkExcludedClasses(configurations, exclusions);
    configurations.removeAll(exclusions);
    configurations = getConfigurationClassFilter().filter(configurations);
    fireAutoConfigurationImportEvents(configurations, exclusions);
    return new AutoConfigurationEntry(configurations, exclusions);
&#125;
</code></pre>
<p>那么我们来看一个spring.factories文件中的内容是什么样子的呢？请查看spring-boot-autoconfigure.jar包下的文件：</p>
<pre><code class="properties"># Initializers
org.springframework.context.ApplicationContextInitializer=\
org.springframework.boot.autoconfigure.SharedMetadataReaderFactoryContextInitializer,\
org.springframework.boot.autoconfigure.logging.ConditionEvaluationReportLoggingListener

# Application Listeners
org.springframework.context.ApplicationListener=\
org.springframework.boot.autoconfigure.BackgroundPreinitializer

# Auto Configure
org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\

### 省略...
</code></pre>
<p>原来是这种形式的，看来这和上一篇文章中讲解的Java中的SPI机制加载接口实现很像啊，其实通过查阅资料发现，这就是一种自定义SPI的实现方式的功能。</p>
<p>那么我们以第一个配置类：org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration来看一下，这些类都是如果实现的。打开org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration的源码：</p>
<pre><code class="java">@Configuration(proxyBeanMethods = false)
@AutoConfigureAfter(JmxAutoConfiguration.class)
/** 关键代码 **/
@ConditionalOnProperty(prefix = &quot;spring.application.admin&quot;, value = &quot;enabled&quot;, havingValue = &quot;true&quot;,
        matchIfMissing = false)
public class SpringApplicationAdminJmxAutoConfiguration &#123;
    private static final String JMX_NAME_PROPERTY = &quot;spring.application.admin.jmx-name&quot;;
    private static final String DEFAULT_JMX_NAME = &quot;org.springframework.boot:type=Admin,name=SpringApplication&quot;;

    @Bean
    @ConditionalOnMissingBean
    public SpringApplicationAdminMXBeanRegistrar springApplicationAdminRegistrar(
            ObjectProvider&lt;MBeanExporter&gt; mbeanExporters, Environment environment) throws MalformedObjectNameException &#123;
        String jmxName = environment.getProperty(JMX_NAME_PROPERTY, DEFAULT_JMX_NAME);
        if (mbeanExporters != null) &#123; // Make sure to not register that MBean twice
            for (MBeanExporter mbeanExporter : mbeanExporters) &#123;
                mbeanExporter.addExcludedBean(jmxName);
            &#125;
        &#125;
        return new SpringApplicationAdminMXBeanRegistrar(jmxName);
    &#125;
&#125;
</code></pre>
<p>我们看到这个类有三个注解@Configuration、@AutoConfigureAfter、@ConditionalOnProperty、因为有@Configuration注解所以它也是一个配置类，然后第二注解中的参数类JmxAutoConfiguration.class进入之后是这样的：</p>
<pre><code class="java">@Configuration(proxyBeanMethods = false)
@ConditionalOnClass(&#123; MBeanExporter.class &#125;)
@ConditionalOnProperty(prefix = &quot;spring.jmx&quot;, name = &quot;enabled&quot;, havingValue = &quot;true&quot;)
public class JmxAutoConfiguration &#123;
&#125;
</code></pre>
<p>也是存在@ConditionalOnProperty注解的。那看来关键点就是@ConditionalOnProperty这个注解了。这个注解其实是一个条件判断注解，这个条件注解后面的参数的意思是当存在系统属性前缀为<strong>spring.application.admin</strong>，并且属性名称为<strong>enabled</strong>，并且值为<strong>true</strong>时，才加载当前这个Bean并进行实例化。</p>
<h2 id="6、-Conditional-常用条件注解"><a href="#6、-Conditional-常用条件注解" class="headerlink" title="6、@Conditional 常用条件注解"></a>6、@Conditional 常用条件注解</h2><p>这种Spring4.0后面出现的的条件注解，可以极大的增加了框架的灵活性和扩展性，可以保证很多组件可以通过后期配置，而且阅读源码的人，通过这些注解就能明白在什么情况下才会实例化当前Bean。后面还有不少这种条件注解呢：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>@ConditionalOnBean</td>
<td>当容器里有指定Bean的条件下才生效</td>
</tr>
<tr>
<td>@ConditionalOnMissingBean</td>
<td>当容器里没有指定Bean的情况下才生效</td>
</tr>
<tr>
<td>@ConditionalOnClass</td>
<td>当类路径下有指定的类的条件下才生效</td>
</tr>
<tr>
<td>@ConditionalOnMissingClass</td>
<td>当容器里没有指定类的情况下才生效</td>
</tr>
<tr>
<td>@ConditionalOnProperty</td>
<td>指定的属性是否有指定的值才生效</td>
</tr>
<tr>
<td>@ConditionalOnWebApplication</td>
<td>当前项目时Web项目的条件下才生效</td>
</tr>
<tr>
<td>@ConditionalOnNotWebApplication</td>
<td>当前项目不是Web项目的条件下才生效</td>
</tr>
<tr>
<td>@ConditionalOnExpression</td>
<td>基于SpEL表达式为true的时候作为判断条件才去实例化</td>
</tr>
<tr>
<td>@ConditionalOnJava</td>
<td>基于JVM版本作为判断条件</td>
</tr>
<tr>
<td>@ConditionalOnJndi</td>
<td>在JNDI存在的条件下查找指定的位置</td>
</tr>
<tr>
<td>@ConditionalOnResource</td>
<td>类路径是否有指定的值</td>
</tr>
<tr>
<td>@ConditionalOnOnSingleCandidate</td>
<td>当指定Bean在容器中只有一个，或者有多个但是指定首选的Bean</td>
</tr>
</tbody></table>
<p>这些注解其实都是通过@Conditional注解扩展而来的，只是使用了不同的组合条件来判断是否需要加载和初始化当前Bean。</p>
<h2 id="7、SpringBoot-自动装配原理总结（面试）"><a href="#7、SpringBoot-自动装配原理总结（面试）" class="headerlink" title="7、SpringBoot 自动装配原理总结（面试）"></a>7、SpringBoot 自动装配原理总结（面试）</h2><p>这就是SpringBoot 自动配置的过程：</p>
<p>SpringBoot 启动时，是依靠启动类的main方法来进行启动的，而main方法中执行的是SpringApplication.run()方法，而SpringApplication.run()方法中会创建Spring的容器，并且刷新容器。而在刷新容器的时候就会去解析启动类，然后就会去解析启动类上的@SpringBootApplication注解，而这个注解是个复合注解，这个注解中有一个@EnableAutoConfiguration注解，这个注解就是开启自动配置，这个注解中又有@Import注解引入了一个AutoConfigurationImportSelector这个类，这个类会进过一些核心方法，然后去扫描我们所有jar包下的META-INF下的spring.factories文件，而从这个配置文件中取找key为EnableAutoConfiguration类的全路径的值下面的所有配置都加载，这些配置里面都是有条件注解的，然后这些条件注解会根据你当前的项目依赖的jar包以及是否配置了符合这些条件注解的配置来进行装载的。</p>
<hr>
<p><strong>其实上面这些内容还是有点多，而且还有好多注解的单词也不好记，那换成大白话，再精炼一下：</strong></p>
<blockquote>
<p>SpringBoot在启动的时候会调用run()方法，run()方法会刷新容器，刷新容器的时候，会扫描classpath下面的的包中<strong>META-INF&#x2F;spring.factories</strong>文件，在这个文件中记录了好多的自动配置类，在刷新容器的时候会将这些自动配置类加载到容器中，然后在根据这些配置类中的条件注解，来判断是否将这些配置类在容器中进行实例化，这些条件主要是判断项目是否有相关jar包或是否引入了相关的bean。这样SpringBoot就帮助我们完成了自动装配。</p>
</blockquote>
<h1 id="四、Spring-Boot-Starter-的自定义及原理"><a href="#四、Spring-Boot-Starter-的自定义及原理" class="headerlink" title="四、Spring-Boot-Starter 的自定义及原理"></a>四、Spring-Boot-Starter 的自定义及原理</h1><blockquote>
<ol>
<li>作者：业余草；来源：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/fcCz1V2asnLGmdYGo-uILg">https://mp.weixin.qq.com/s/fcCz1V2asnLGmdYGo-uILg</a></li>
<li>作者：Java笔记虾；来源：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/42HzC1AFbDb7tOWb_tdezQ">https://mp.weixin.qq.com/s/42HzC1AFbDb7tOWb_tdezQ</a></li>
<li>作者：苏三说技术；来源：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/_dCZpoFGzkSSLXdz9rzI8g">https://mp.weixin.qq.com/s/_dCZpoFGzkSSLXdz9rzI8g</a></li>
<li>Springboot如何自定义Starter（主要是步骤）<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_47356044/article/details/124937738">https://blog.csdn.net/weixin_47356044/article/details/124937738</a></li>
</ol>
</blockquote>
<h2 id="1、Starter-场景启动器前言"><a href="#1、Starter-场景启动器前言" class="headerlink" title="1、Starter 场景启动器前言"></a>1、Starter 场景启动器前言</h2><h3 id="1、什么是-Starter"><a href="#1、什么是-Starter" class="headerlink" title="1、什么是 Starter"></a>1、什么是 Starter</h3><p>Starter是Spring Boot中的一个非常重要的概念，Starter相当于模块，它能将模块所需的依赖整合起来并对模块内的Bean根据环境（ 条件）进行自动配置。</p>
<p><strong>「使用者只需要依赖相应功能的Starter，无需做过多的配置和依赖，Spring Boot就能自动扫描并加载相应的模块并设置默认值，做到开箱即用」</strong></p>
<h3 id="2、为什么要用-Starter"><a href="#2、为什么要用-Starter" class="headerlink" title="2、为什么要用 Starter"></a>2、为什么要用 Starter</h3><p>在SpringBoot还没有出来之前，我们使用Spring开发项目。如果程序需要连接数据库，我们一般会使用Hibernate或Mybatis等ORM框架，这里我以Mybatis为例，具体的操作步骤如下：</p>
<ol>
<li>到maven仓库去找需要引入的mybatis jar包，选取合适的版本</li>
<li>到maven仓库去找mybatis-spring整合的jar包，选取合适的版本</li>
<li>根据具体使用的数据库引入数据库驱动包（mysql、oracle、postgresql）</li>
<li>在spring的applicationContext.xml文件中配置dataSource和mybatis相关信息</li>
</ol>
<p>如上只是配置好了连接数据库这一个功能，后面还需要配置SpringMVC，需要引入更多的功能，比如：连接redis、连接mongodb、使用rocketmq、使用excel功能等等。引入这些功能的话，需要再把上面的步骤再重复一次，工作量无形当中增加了不少，而且有很多重复的工作。另外，还是有个问题，每次到要到maven中找合适的版本，如果哪次找的mybatis.jar包 和 mybatis-spring.jar包版本不兼容，程序不是会出现问题？</p>
<p>这就是使用Spring框架开发项目带来的一些的问题：</p>
<ul>
<li><strong>依赖导入问题：</strong> 每个项目都需要来单独维护自己所依赖的jar包，在项目中使用到什么功能就需要引入什么样的依赖。手动导入依赖容易出错，且无法统一集中管理</li>
<li><strong>配置繁琐：</strong> 在引入依赖之后需要做繁杂的配置，并且这些配置是每个项目来说都是必要的，例如web.xml配置（Listener配置、Filter配置、Servlet配置）、log4j配置、数据库连接池配置等等。这些配置重复且繁杂，在不同的项目中需要进行多次重复开发，这在很大程度上降低了我们的开发效率</li>
</ul>
<p>SpringBoot出现之后，它为我们提供了一个强大的功能来解决上述的两个痛点，这就是SpringBoot的starters机制（场景启动器）。</p>
<p>SpringBoot通过将我们常用的功能场景抽取出来，做成的一系列场景启动器，这些启动器帮我们导入了实现各个功能所需要依赖的全部组件，我们只需要在项目中引入这些starters，相关场景的所有依赖就会全部被导入进来，并且我们可以抛弃繁杂的配置，仅需要通过配置文件来进行少量的配置就可以使用相应的功能。</p>
<h2 id="2、Starter-自动配置原理"><a href="#2、Starter-自动配置原理" class="headerlink" title="2、Starter 自动配置原理"></a>2、Starter 自动配置原理</h2><p>在导入的starter之后，SpringBoot主要帮我们完成了两件事情：</p>
<ul>
<li>相关组件的自动导入（实际上就是导入spring-boot-starter依赖，依赖中已经编写好自动配置类，等待SpringBoot启动扫描注入）</li>
<li>相关组件的自动配置（实际上就是启动SpringBoot应用，SpringBoot启动过程中会获取和注入自动配置类）</li>
</ul>
<p>这两件事情统一称为SpringBoot的自动配置，如果想了解SpringBoot自动配置原理的可以参考另外两篇文章</p>
<ol>
<li>SpringBoot 启动流程及原理</li>
<li>SpringBoot 启动类上的注解</li>
</ol>
<h2 id="3、Starter-官方与非官方模式分析"><a href="#3、Starter-官方与非官方模式分析" class="headerlink" title="3、Starter 官方与非官方模式分析"></a>3、Starter 官方与非官方模式分析</h2><h3 id="1、Starter-官方模式（SpringBoot开发）"><a href="#1、Starter-官方模式（SpringBoot开发）" class="headerlink" title="1、Starter 官方模式（SpringBoot开发）"></a>1、Starter 官方模式（SpringBoot开发）</h3><p>选择一个官方的自动配置进行分析，这里就选择spring-boot-starter-web中常见的配置端口号配置。</p>
<h4 id="1、引入依赖"><a href="#1、引入依赖" class="headerlink" title="1、引入依赖"></a>1、引入依赖</h4><p>使用端口号之前我们需要先引入 web 依赖。</p>
<pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<p>如果你观察 starter 多的话，也许你发已经发现了一个<strong>模式</strong>，SpringBoot 官方的 starter 的名字都是 spring-boot-starter-xxxx 命名的。</p>
<p>查看 spring-boot-starter-web 会发现，其实这个依赖只是一个空盒子，除了依赖其他 pom 之外，没有一行代码。</p>
<pre><code class="bash">├─Maven: org.springframework.boot:spring-boot-starter-web:2.5.0
    ├─spring-boot-starter-web-2.5.0.jar
        ├─META-INF
            ├─LICENSE.txt
            ├─MANIFEST.MF
            ├─NOTICE.TXT
</code></pre>
<p>这时，发现了另外一个模式：starter 只依赖其他 pom，不做代码实现。那么 spring-boot-starter-web 到底依赖了哪些内容？</p>
<pre><code class="java">├─Dependencies
    ├─org.springframework.boot:spring-boot-starter-web:2.5.0
        ├─org.springframework.boot:spring-boot-starter:2.5.0
        ├─org.springframework.boot:spring-boot-starter-json:2.5.0
        ├─org.springframework.boot:spring-boot-starter-tomcat:2.5.0
        ├─org.springframework:spring-web:5.3.7
        ├─org.springframework:spring-webmvc:5.3.7
</code></pre>
<p>观察这个依赖信息，然后再参照其他的官方 starter ，可以找到几个固定的引入，可以被称之为模式的依赖引入。</p>
<ol>
<li>依赖：spring-boot-starter</li>
<li>依赖：spring-boot-autoconfigure</li>
</ol>
<h4 id="2、自动配置"><a href="#2、自动配置" class="headerlink" title="2、自动配置"></a>2、自动配置</h4><p>1、引入依赖让然后配置端口号</p>
<pre><code class="properties">server.port=8090
</code></pre>
<p>IDEA 中可以通过点击 server.port 找到这个配置绑定的类文件。可以看到配置最终会注入到类 ServerProperties 类的 port 属性上。</p>
<pre><code class="java">// 1.绑定的配置
@ConfigurationProperties(prefix = &quot;server&quot;, ignoreUnknownFields = true)
public class ServerProperties &#123;
    // 2.注入的属性
    /**
     * Server HTTP port.
     */
    private Integer port;
    // .....
&#125;
</code></pre>
<p>那么这个 ServerProperties 到底是哪里使用的呢？继续查找，找到一个和 Servlet 的有关的调用。</p>
<p>发现是被 ServletWebServerFactoryCustomizer 类进行了调用，这个类里面定义了</p>
<pre><code class="java">private final ServerProperties serverProperties;
</code></pre>
<p>用来使用配置的属性。继续查看这个类的调用，发现只有一个类使用这个类，这个类是 ServletWebServerFactoryAutoConfiguration。</p>
<pre><code class="java">@Configuration(proxyBeanMethods = false)
@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE)
@ConditionalOnClass(ServletRequest.class)
@ConditionalOnWebApplication(type = Type.SERVLET)
@EnableConfigurationProperties(ServerProperties.class)
@Import(&#123; ServletWebServerFactoryAutoConfiguration.BeanPostProcessorsRegistrar.class,
         ServletWebServerFactoryConfiguration.EmbeddedTomcat.class,
         ServletWebServerFactoryConfiguration.EmbeddedJetty.class,
         ServletWebServerFactoryConfiguration.EmbeddedUndertow.class &#125;)
public class ServletWebServerFactoryAutoConfiguration &#123;
&#125;
</code></pre>
<p>根据我们对注解的理解，这个类就是自动配置主要类了。同时自动配置类都是以 AutoConfiguration 结尾。看这个类的几个注解的意思。</p>
<ol>
<li><p>优先级别较高</p>
<pre><code class="java">@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE)
</code></pre>
</li>
<li><p>只有在 ServletRequest 类存在和是 Web 应用时生效</p>
<pre><code class="java">@ConditionalOnClass(ServletRequest.class)
@ConditionalOnWebApplication(type = Type.SERVLET)
</code></pre>
</li>
<li><p>开启了 ServerProperties 的配置绑定</p>
<pre><code class="java">@EnableConfigurationProperties(ServerProperties.class)
</code></pre>
</li>
<li><p>导入了几个类</p>
<pre><code class="java">@Import(&#123; ServletWebServerFactoryAutoConfiguration.BeanPostProcessorsRegistrar.class,
         ServletWebServerFactoryConfiguration.EmbeddedTomcat.class,
         ServletWebServerFactoryConfiguration.EmbeddedJetty.class,
         ServletWebServerFactoryConfiguration.EmbeddedUndertow.class &#125;)
</code></pre>
</li>
<li><p>同时注入配置到 Bean 工厂以供其他地方调用</p>
<pre><code class="java">@Bean
public ServletWebServerFactoryCustomizer servletWebServerFactoryCustomizer(ServerProperties serverProperties) &#123;
    return new ServletWebServerFactoryCustomizer(serverProperties);
&#125;
</code></pre>
</li>
</ol>
<p>自动配置仅仅是这些东西吗？根据之前文章里的分析，我们知道不止代码，至少还有一个指定自动配置类的配置文件需要读取。也就是 spring.factories 文件。具体路径存在spring-boot-autoconfigure-2.5.0.jar&#x2F;META-INF&#x2F;spring.factories。</p>
<p>根据上面的分析，可以发现 SpringBoot 官方 starter 的几个<strong>模式</strong>。</p>
<ol>
<li>使用 XXXProperties 自动绑定 XXX 开头的配置信息，如：ServerProperties。</li>
<li>把 XXXProperties 定义到要使用的类中，如：ServletWebServerFactoryCustomizer。</li>
<li>编写一个 XXXAutoConfiguration ，开启 XXXProperties 的自动配置，限定生效场景，创建需要的类到 Bean 工厂。如：ServletWebServerFactoryAutoConfiguration。</li>
</ol>
<h3 id="2、Starter-非官方模式（第三方开发）"><a href="#2、Starter-非官方模式（第三方开发）" class="headerlink" title="2、Starter 非官方模式（第三方开发）"></a>2、Starter 非官方模式（第三方开发）</h3><p>Springboot 官方如果把所有的框架都编写成 starter 是不现实的。因此很多第三方框架需要主动集成到 SpringBoot，所以我们选择一个常用的框架分析它的 starter 实现。因为已经看过了 SpringBoot 官方 starter 是如何配置的， 第三方框架也是类似，所以在下面观察的过程中会直接指出相同点，而不再做对比详细对比。</p>
<p>这里选择 mybatis-spring-boot-starter 进行学习分析。</p>
<h4 id="1、引入依赖-1"><a href="#1、引入依赖-1" class="headerlink" title="1、引入依赖"></a>1、引入依赖</h4><pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;
    &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;
    &lt;version&gt;1.3.2&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>这里 mybatis 框架的 starter 依赖符合一定的规则，即：xxx-spring-boot-starter。观察这个 starter，发现它也没有做任何的代码实现，这一点和 SpringBoot 官方一致。</p>
<pre><code class="bash">├─Maven: org.mybatis.spring.boot:mybatis-spring-boot-starter:2.2.2
    └─mybatis-spring-boot-starter-2.2.2.jar
        └─META-INF
            └─maven.org.mybatis.spring.boot.mybatis-spring-boot-starter
                ├─pom.properties
                ├─pom.xml
            └─MANIFEST.MF
</code></pre>
<p>可以看到它的META-INF目录下只包含了：</p>
<ul>
<li>pom.protperties：配置maven所需的项目version、groupId和artifactId</li>
<li>pom.xml：配置所依赖的jar包</li>
<li>MANIFEST.MF：这个文件描述了该Jar文件的很多信息</li>
</ul>
<p>注意一下，没有一行代码。我们重点看一下<code>pom.xml</code>的依赖项，因为这个jar包里面除了这个没有啥重要的信息</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;parent&gt;
        &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;
        &lt;artifactId&gt;mybatis-spring-boot&lt;/artifactId&gt;
        &lt;version&gt;2.2.2&lt;/version&gt;
    &lt;/parent&gt;
    &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;
    &lt;name&gt;mybatis-spring-boot-starter&lt;/name&gt;
    &lt;properties&gt;
        &lt;module.name&gt;org.mybatis.spring.boot.starter&lt;/module.name&gt;
    &lt;/properties&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis-spring-boot-autoconfigure&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/project&gt;
</code></pre>
<p>可以看出pom.xml中引入一些jar包，其中除了<code>spring-boot-starter</code>，之外重点看一下：<code>mybatis-spring-boot-autoconfigure</code></p>
<h4 id="2、自动配置-1"><a href="#2、自动配置-1" class="headerlink" title="2、自动配置"></a>2、自动配置</h4><p>查看 mybatis-spring-boot-autoconfigure 的内容发现和 SpringBoot 官方的 autoconfigure 结构上是差不多的。</p>
<pre><code class="bash">├─Maven: org.mybatis.spring.boot:mybatis-spring-boot-autoconfigure:2.2.2
    ├─mybatis-spring-boot-autoconfigure-2.2.2.jar
        ├─META-INF
            ├─maven.org.mybatis.spring.boot.mybatis-spring-boot-autoconfigure
                ├─pom.properties
                ├─pom.xml
            ├─additional-spring-configuration-metadata.json
            ├─MANIFEST.MF
            ├─spring.factories
            ├─spring-autoconfigure-metadata.properties
            ├─spring-configuration-metadata.json
        ├─org.mybatis.spring.boot.autoconfigure
            ├─ConfigurationCustomizer
            ├─MybatisAutoConfiguration
            ├─MybatisLanguageDriverAutoConfiguration
            ├─MybatisProperties
            ├─SpringBootVFS
            ├─SqlSessionFactoryBeanCustomizer
</code></pre>
<p>里面包含如下文件：</p>
<ul>
<li>pom.properties：配置maven所需的项目version、groupId和artifactId</li>
<li>pom.xml：配置所依赖的jar包</li>
<li>additional-spring-configuration-metadata.json：手动添加IDE提示功能</li>
<li>MANIFEST.MF：这个文件描述了该Jar文件的很多信息</li>
<li>spring.factories：SPI会读取的文件</li>
<li>spring-configuration-metadata.json：系统自动生成的IDE提示功能</li>
<li>spring-autoconfigure-metadata.properties：系统自动生成的IDE提示功能</li>
<li>ConfigurationCustomizer：自定义Configuration回调接口</li>
<li>MybatisAutoConfiguration：mybatis配置类</li>
<li>MybatisLanguageDriverAutoConfiguration：MyBatis脚本语言驱动程序的自动配置</li>
<li>MybatisProperties：mybatis属性类</li>
<li>SpringBootVFS：扫描嵌套的jar包中的类</li>
<li>SqlSessionFactoryBeanCustomizer：回调接口，可以定制自动配置时生成的SqlSessionFactoryBean对象</li>
</ul>
<p>mybatis 的自动配置也是通过 spring.factories 来指明自动配置，然后通过 XxxAutoConfiguration 绑定 XxxProperties 来进行自动配置</p>
<pre><code class="java">// 如下所有注解都是一些辅助功能，决定Configuration是否生效，当然这些注解不是必须的
@Configuration
// @ConditionalOnClass 配置了只有包含SqlSessionFactory.class和SqlSessionFactoryBean.class，该配置类才生效
@ConditionalOnClass(&#123;SqlSessionFactory.class, SqlSessionFactoryBean.class&#125;)
// @ConditionalOnBean 配置了只有包含dataSource实例时，该配置类才生效
@ConditionalOnSingleCandidate(DataSource.class)
// @EnableConfigurationProperties 该注解会自动填充MybatisProperties实例中的属性
@EnableConfigurationProperties(&#123;MybatisProperties.class&#125;)
// AutoConfigureAfter 该配置类在DataSourceAutoConfiguration与MybatisLanguageDriverAutoConfiguratio类之后自动配置
@AutoConfigureAfter(&#123;DataSourceAutoConfiguration.class, MybatisLanguageDriverAutoConfiguration.class&#125;)
public class MybatisAutoConfiguration implements InitializingBean &#123;
    // ...省略
&#125;
</code></pre>
<p>在原理上，和上面 SpringBoot 官方的 starter 是相同的，所以不做过多的介绍了。可以自己点开源码分析。</p>
<h2 id="4、场景启动器开发常用注解"><a href="#4、场景启动器开发常用注解" class="headerlink" title="4、场景启动器开发常用注解"></a>4、场景启动器开发常用注解</h2><p>注解使用已经大大方便我们开发，再也不需要写xml配置文件了，SpringBoot经过查找spring.factories文件，加载自动配置类，而自动配置类中定义了各种运行时判断条件，如@ConditionalOnMissingBean(A.class)等，只要IOC容器中没有指定的A类型的Bean信息，该配置文件才会生效。</p>
<p>@Conditional是Spring4新提供的注解，它的作用是按照一定的条件进行判断，满足条件给容器注册Bean。</p>
<ul>
<li><p>属性映射注解</p>
<ul>
<li>@ConfigurationProperties ：配置文件属性值和实体类的映射</li>
<li>@EnableConfigurationProperties：与@ConfigurationProperties配合，把@ConfigurationProperties修饰的类加入IOC容器</li>
</ul>
</li>
<li><p>配置Bean注解</p>
<ul>
<li>@Configuration ：标识该类为配置类，并把该类注入IOC容器</li>
<li>@Bean ：一般在方法上使用，声明一个Bean，Bean名称默认是方法名称，类型为返回值</li>
</ul>
</li>
<li><p>条件注解：</p>
<ul>
<li>@Conditional：根据条件类创建特定的Bean，条件类需要实现Condition接口，并重写matches接口来构造判断条件</li>
<li>@ConditionalOnBean ：容器中存在指定Bean，才会实例化一个Bean</li>
<li>@ConditionalOnMissingBean：容器中不存在指定Bean，才会实例化一个Bean</li>
<li>@ConditionalOnClass：系统中有指定类，才会实例化一个Bean</li>
<li>@ConditionalOnMissingClass：系统中没有指定类，才会实例化一个Bean</li>
<li>@ConditionalOnExpression：当SpEL表达式为true的时候，才会实例化一个Bean</li>
<li>@ConditionalOnWebApplication：是web应用</li>
<li>@ConditionalOnNotWebApplication：不是web应用</li>
<li>@ConditionalOnJava ：系统中版本是否符合要求</li>
<li>@ConditionalOnSingleCandidate：当指定的Bean在容器中只有一个，或者有多个但是指定了首选的Bean时触发实例化</li>
<li>@ConditionalOnResource：类路径下是否存在指定资源文件</li>
<li>@ConditionalOnJndi：JNDI指定存在项</li>
<li>@AutoConfigureAfter ：在某个Bean完成自动配置后实例化这个Bean</li>
<li>@AutoConfigureBefore ：在某个Bean完成自动配置前实例化这个Bean</li>
<li>@ConditionalOnProperty：配置Configuration的加载规则<ul>
<li>prefix ：配置属性名称的前缀</li>
<li>value ：数组，获取对应property名称的值，与name不可同时使用</li>
<li>name ：数组，可与prefix组合使用，组成完整的配置属性名称，与value不可同时使用</li>
<li>havingValue ：比较获取到的属性值与havingValue给定的值是否相同，相同才加载配置</li>
<li>matchIfMissing ：缺少该配置属性时是否可以加载。如果为true，没有该配置属性时也会正常加载；反之则不生效</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="5、Full全模式和Lite轻量级模式"><a href="#5、Full全模式和Lite轻量级模式" class="headerlink" title="5、Full全模式和Lite轻量级模式"></a>5、Full全模式和Lite轻量级模式</h2><ul>
<li><p>@Configuration注解的参数：proxyBeanMethods：</p>
</li>
<li><ul>
<li>同一配置类下，当直接调用@Bean修饰的<code>方法</code>注入的对象，则调用<code>该方法不会被代理</code>，相当于直接调用一个普通方法，会有构造方法，但是没有bean的生命周期，返回的是不同的实例。</li>
</ul>
</li>
<li><ul>
<li>同一配置类下，当直接调用@Bean修饰的<code>方法</code>注入的对象，则调用<code>该方法会被代理</code>，从ioc容器中取bean实列，所以实列是一样的。即单实例对象，在该模式下SpringBoot每次启动都会判断检查容器中是否存在该组件</li>
</ul>
</li>
<li><ul>
<li>Full 全模式（默认）：<code>@Configuration(proxyBeanMethods = true)</code></li>
<li>Lite 轻量级模式：<code>@Configuration(proxyBeanMethods = false)</code></li>
</ul>
</li>
<li><p>注：proxyBeanMethods 是为了让使用@Bean注解的<code>方法</code>被代理。而不是@Bean的单例多例的设置参数。</p>
</li>
</ul>
<pre><code class="java">@Configuration(proxyBeanMethods = false)
public class AppConfig &#123;
    // 注册myBean到IOC容器
    @Bean
    public MyBean myBean() &#123;
        return new Mybean();
    &#125;

    // 注册yourBean到IOC容器
    @Bean
    public YourBean yourBean() &#123;
        System.out.println(&quot;==========&quot;);
        // 注意：@Configuration(proxyBeanMethods = false): myBean()方法不代理, 直接调用
        // 注意：@Configuration(proxyBeanMethods = true):  myBean()方法代理, 从IOC容器拿
        return new YourBean(myBean());
    &#125;
&#125;
</code></pre>
<p>具体什么时候用Full全模式，什么时候用Lite轻量级模式呢？</p>
<ul>
<li>当在你的同一个Configuration配置类中，注入到容器中的Bean实例之间有依赖关系时，建议使用Full全模式</li>
<li>当在你的同一个Configuration配置类中，注入到容器中的Bean实例之间没有依赖关系时，建议使用Lite轻量级模式，以提高SpringBoot的启动速度和性能</li>
</ul>
<h2 id="6、自定义场景启动器的规范"><a href="#6、自定义场景启动器的规范" class="headerlink" title="6、自定义场景启动器的规范"></a>6、自定义场景启动器的规范</h2><p>1、SpringBoot Starter 的命名规范</p>
<p>官方命名空间</p>
<ul>
<li>前缀：spring-boot-starter-</li>
<li>模式：spring-boot-starter-模块名</li>
<li>举例：spring-boot-starter-web、spring-boot-starter-jdbc</li>
</ul>
<p>自定义命名空间</p>
<ul>
<li>后缀：-spring-boot-starter</li>
<li>模式：模块-spring-boot-starter</li>
<li>举例：mybatis-spring-boot-starter</li>
</ul>
<hr>
<p>2、SpringBoot Starter 模块整体结构</p>
<ul>
<li>xxAutoConfiguration：自动配置类，对某个场景下需要使用到的组件进行自动注入，并利用xxProperties类来进行组件相关配置</li>
<li>xxProperties：属性自动绑定类，某个场景下所有可配置属性的集成，在配置文件中配置可以进行属性值的覆盖，按照SpringBoot官方的定义，Starer的作用就是依赖聚合，因此直接在Starer内部去进行代码实现是不符合规定的，Starer应该只起到依赖导入的作用，而具体的代码实现应该去交给其他模块来实现，然后在Starer中去引用该模块即可。</li>
<li>Starer模块依赖了两部分：一部分是一些常用依赖，另一部分就是对自动配置模块的依赖，而xxAutoConfiguration与xxProperties的具体实现，都封装在自动配置模块中，Starer实际是通过该模块来对外提供相应的功能。</li>
<li>实际上还有第三部分：自动处理类：xxService，这是可选的，可能每个工具处理方式不一样，命名也不一致。</li>
</ul>
<h2 id="7、Starter-自定义编写示例1（ID自动生成）"><a href="#7、Starter-自定义编写示例1（ID自动生成）" class="headerlink" title="7、Starter 自定义编写示例1（ID自动生成）"></a>7、Starter 自定义编写示例1（ID自动生成）</h2><h3 id="1、创建启动器空项目-spring-boot-starter"><a href="#1、创建启动器空项目-spring-boot-starter" class="headerlink" title="1、创建启动器空项目-spring-boot-starter"></a>1、创建启动器空项目-spring-boot-starter</h3><pre><code class="bash">├─id-generate-spring-boot-starter
   │  pom.xml
   └─src
       └─main
           ├─java
           └─resources
</code></pre>
<p>由于启动器不需要代码实现，只需要依赖其他项目，所以直接创建一个空的 maven 项目（记住不是SpringBoot项目）。所以如果使用SpringBoot方法创建项目记得首先删除main启动类，没有main入口，需要去除pom文件中maven打包插件spring-boot-maven-plugin。但是记住项目名字要规范。这里创建的 starter 是 id-generate-spring-boot-starter。如下是添加依赖：</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
   
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;groupId&gt;org.example&lt;/groupId&gt;
    &lt;artifactId&gt;id-generate-spring-boot-starter&lt;/artifactId&gt;
    &lt;version&gt;1.0.0&lt;/version&gt;

    &lt;properties&gt;
        &lt;maven.compiler.source&gt;11&lt;/maven.compiler.source&gt;
        &lt;maven.compiler.target&gt;11&lt;/maven.compiler.target&gt;
    &lt;/properties&gt;

    &lt;!--starter 模块中只进行依赖导入，添加对autoconfigure模块的依赖，如有需要可以添加一些其他必要依赖项--&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.example&lt;/groupId&gt;
            &lt;artifactId&gt;id-generate-spring-boot-autoconfigure&lt;/artifactId&gt;
            &lt;version&gt;1.0.0&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/project&gt;
</code></pre>
<p>它只引入了id-generate-spring-boot-autoconfigure。当然如果有需要这里还可以引入多个autoconfigure或者多个其他jar包或者。</p>
<h3 id="2、创建自动配置项目-spring-boot-autoconfigure"><a href="#2、创建自动配置项目-spring-boot-autoconfigure" class="headerlink" title="2、创建自动配置项目-spring-boot-autoconfigure"></a>2、创建自动配置项目-spring-boot-autoconfigure</h3><p>结合上面的项目，这里我们创建创建id-generate-spring-boot-autoconfigure项目，可以使用SpringBoot Initializr（这种方式记得删除main启动类，还有pom文件中的maven打包插件spring-boot-maven-plugin），所以还是建议直接创建一个简单的maven项目即可。项目结构如下所示：</p>
<pre><code class="bash">├─id-generate-spring-boot-autoconfigure
   │  pom.xml
   ├─src
      ├─main
         ├─java
         │  └─org
         │      └─example
         │              IdGenerateAutoConfiguration.java
         │              IdGenerateProperties.java
         │              IdGenerateService.java
         └─resources
             └─META-INF
                     spring.factories
</code></pre>
<p>该项目当中包含：pom.xml、spring.factories、IdGenerateAutoConfiguration、IdGenerateService 和 IdGenerateProperties 这5个关键文件，下面我们逐一看看。</p>
<p>1、pom.xml，引入必要的依赖，视情况设置optional&#x3D;true（有些业务相关类，设置optional后，需要用户方重新依赖）</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;parent&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
        &lt;version&gt;2.5.0&lt;/version&gt;
        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;
    &lt;/parent&gt;

    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;groupId&gt;org.example&lt;/groupId&gt;
    &lt;artifactId&gt;id-generate-spring-boot-autoconfigure&lt;/artifactId&gt;
    &lt;version&gt;1.0.0&lt;/version&gt;

    &lt;properties&gt;
        &lt;maven.compiler.source&gt;11&lt;/maven.compiler.source&gt;
        &lt;maven.compiler.target&gt;11&lt;/maven.compiler.target&gt;
    &lt;/properties&gt;

    &lt;dependencies&gt;
        &lt;!-- springboot的相关jar包, 也可不引入(引入spring-boot-autoconfigure的情况下) --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!-- 包含自动配置的代码, 包含很多与自动配置相关的注解的定义, 必须要引入 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-autoconfigure&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!-- 非必须的, 配置文件点击可以跳转实体, 引入后可以在配置文件中输入我们自定义配置的时候有相应的提示 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;
            &lt;optional&gt;true&lt;/optional&gt;
        &lt;/dependency&gt;
        &lt;!-- 其他依赖的选择根据项目需要进行添加即可 --&gt;
    &lt;/dependencies&gt;
&lt;/project&gt;
</code></pre>
<p>我们可以看到，这个文件比较简单就引入了：</p>
<ul>
<li>spring-boot-starter：springboot的相关jar包</li>
<li>spring-boot-autoconfigure：springboot自动配置相关jar包</li>
<li>spring-boot-configuration-processor：springboot生成IDE提示功能相关jar包</li>
</ul>
<p>spring-boot-configuration-processor 依赖的作用：</p>
<ul>
<li>spring-boot-configuration-processor 其实是一个注解处理器，在编译阶段干活的，一般maven的optional设置为true</li>
<li>你在idea里面可以点击port，进到这个字段里面，还可以看到配置的提示信息</li>
<li>这是因为在你的资源文件里面有一个spring-configuration-metadata.json文件，这是spring配置的元数据，是json形式</li>
</ul>
<hr>
<p>2、定义配置文件对应类IdGenerateProperties，为了让配置更加灵活，可以让使用方去配置参数</p>
<pre><code class="java">package org.example;
import org.springframework.boot.context.properties.ConfigurationProperties;

@ConfigurationProperties(prefix = &quot;id-generate&quot;)
public class IdGenerateProperties &#123;
    /** 是否开启 **/
    private Boolean enable;
    /** 生成ID类型, uuid or bigint **/
    private String type = &quot;bigint&quot;;
    /** 相当于自己给一串密钥丢进ID中 **/
    public Boolean getEnable() &#123;
        return enable;
    &#125;
    public void setEnable(Boolean enable) &#123;
        this.enable = enable;
    &#125;
    public String getType() &#123;
        return type;
    &#125;
    public void setType(String type) &#123;
        this.type = type;
    &#125;
&#125;
</code></pre>
<p>它是一个配置实体类，里面包含了相关的配置文件。使用@ConfigurationProperties注解，会自动把application.properties文件中以id开通的，参数名称跟IdGenerateProperties中一样的参数值，自动注入到IdGenerateProperties对象中。</p>
<hr>
<p>3、定义业务工具类IdGenerateService，用来生成随机ID的代码</p>
<pre><code class="java">package org.example;
import java.util.*;

public class IdGenerateService &#123;
    private final IdGenerateProperties idGenerateProperties;
    public IdGenerateService(IdGenerateProperties idGenerateProperties) &#123;
        this.idGenerateProperties = idGenerateProperties;
    &#125;

    public String generateId() &#123;
        if (Objects.isNull(idGenerateProperties.getEnable()) || !idGenerateProperties.getEnable()) &#123;
            throw new RuntimeException(&quot;id-generate function is not enabled&quot;);
        &#125;
        if (&quot;uuid&quot;.equals(idGenerateProperties.getType())) &#123;
            return UUID.randomUUID().toString();
        &#125; else if (&quot;bigint&quot;.equals(idGenerateProperties.getType())) &#123;
            return new Random().nextLong() + &quot;&quot;;
        &#125; else &#123;
            throw new RuntimeException(&quot;id-generate type is error&quot;);
        &#125;
    &#125;
&#125;
</code></pre>
<hr>
<p>4、重点看一下 IdGenerateAutoConfiguration，核心自动配置代码</p>
<pre><code class="java">package org.example;

import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;
import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.boot.context.properties.EnableConfigurationProperties;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

/**
 * @Configuration: 会把此类加入Spring
 * @EnableConfigurationProperties: 导入我们自定义的配置类,供当前类使用
 * @ConditionalOnClass: 当存在某个类时，此自动配置类才会生效
 * @ConditionalOnProperty:
 *     判断id-generate.enable的值是否为“true”, 如果为true的化会加载此类
 *     matchIfMissing = true: 当前属性表示没有该配置属性时也会正常加载
 */
@Configuration
@EnableConfigurationProperties(IdGenerateProperties.class)
@ConditionalOnClass(&#123;IdGenerateProperties.class, IdGenerateService.class&#125;)
@ConditionalOnProperty(prefix = &quot;id-generate&quot;, name = &quot;enable&quot;, havingValue = &quot;true&quot;, matchIfMissing = true)
public class IdGenerateAutoConfiguration &#123;
    private final IdGenerateProperties properties;
    public IdGenerateAutoConfiguration(IdGenerateProperties properties) &#123;
        this.properties = properties;
    &#125;
    /**
     * @ConditionalOnMissingBean: 当容器里没有指定Bean的条件下此配置才会生效
     */
    @Bean
    @ConditionalOnMissingBean(IdGenerateService.class)
    public IdGenerateService idGenerateService() &#123;
        System.out.println(&quot;create idGenerateService bean...&quot;);
        return new IdGenerateService(properties);
    &#125;
&#125;
</code></pre>
<p>该类是一个使用了@Configuration注解标记为了配置类，生效的条件是@ConditionalOnClass注解中检测到包含IdProperties.class。并且使用@EnableConfigurationProperties注解会自动注入IdProperties的实例。关键的点是该类里面创建了idGenerateService的bean实例，这是自动配置的精髓。</p>
<hr>
<p>5、在resource&#x2F;META-INF目录下新建spring.factories文件，SpringBoot会自动加载该文件并根据条件装配：</p>
<pre><code class="properties">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
  org.example.IdGenerateAutoConfiguration
</code></pre>
<hr>
<p>6、编写配置提示文件（非必须）：<code>resource/META-INF/additional-spring-configuration-metadata.json</code></p>
<p>配置additional-spring-configuration-metadata.json文件后，在IDE工具使用编写的配置读取很有效的在application.properties 或 application.yml文件下完成提示。</p>
<p>配置详细格式参数可查看文档：<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/configuration-metadata.html#configuration-metadata.format">https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/configuration-metadata.html#configuration-metadata.format</a></p>
<p>additional-spring-configuration-metadata.json 配置内容如下：</p>
<pre><code class="json">&#123;
    &quot;properties&quot;: [
        &#123;
            &quot;name&quot;: &quot;id-generate.enable&quot;,
            &quot;type&quot;: &quot;java.lang.Boolean&quot;,
            &quot;description&quot;: &quot;是否开启&quot;,
            &quot;sourceType&quot;: &quot;org.example.IdGenerateProperties&quot;
        &#125;,
        &#123;
            &quot;name&quot;: &quot;id-generate.type&quot;,
            &quot;type&quot;: &quot;java.lang.String&quot;,
            &quot;description&quot;: &quot;生成ID类型, uuid or bigint&quot;,
            &quot;sourceType&quot;: &quot;org.example.IdGenerateProperties&quot;,
            &quot;defaultValue&quot;: &quot;bigint&quot;
        &#125;,
        &#123;
            &quot;name&quot;: &quot;id-generate.staticId&quot;,
            &quot;type&quot;: &quot;java.lang.Integer&quot;,
            &quot;description&quot;: &quot;静态Id, 如果staticId有值则使用staticId当成初始Id值&quot;,
            &quot;sourceType&quot;: &quot;org.example.IdGenerateProperties&quot;,
            &quot;defaultValue&quot;: &quot;0&quot;,
            &quot;deprecation&quot;: &#123;
                &quot;level&quot;: &quot;error&quot;,
                &quot;reason&quot;: &quot;过时原因.&quot;,
                &quot;replacement&quot;: &quot;替代key是：id-generate.type&quot;
            &#125;
        &#125;
    ]
&#125;
</code></pre>
<p>参考下面properties表格进行配置上的理解。</p>
<table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">类型</th>
<th align="left">目的</th>
</tr>
</thead>
<tbody><tr>
<td align="left">name</td>
<td align="left">String</td>
<td align="left">属性的全名。名称采用小写的周期分隔形式(例如server.address)。此属性是强制性的。</td>
</tr>
<tr>
<td align="left">type</td>
<td align="left">String</td>
<td align="left">属性的数据类型的完整签名（例如java.lang.String），但也是完整的泛型类型（例如java.util.Map&lt;java.util.String,acme.MyEnum&gt;）。您可以使用此属性来指导用户可以输入的值的类型。为了保持一致性，通过使用其包装对应项（例如，boolean变为java.lang.Boolean）来指定基元的类型。请注意，此类可能是一个复杂类型，它从Stringas绑定的值转换而来。<code>如果类型未知或基本类型，则可以省略。</code></td>
</tr>
<tr>
<td align="left">description</td>
<td align="left">String</td>
<td align="left">可以向用户显示的组的简短描述。如果没有可用的描述，则可以省略。建议描述为简短段落，第一行提供简明摘要。描述中的最后一行应以句点（.）结尾。</td>
</tr>
<tr>
<td align="left">sourceType</td>
<td align="left">String</td>
<td align="left">贡献此属性的源的类名称。例如，如果属性来自带注释的类@ConfigurationProperties，则此属性将包含该类的完全限定名称。如果源类型未知，则可以省略。</td>
</tr>
<tr>
<td align="left">defaultValue</td>
<td align="left">Object</td>
<td align="left">默认值，如果未指定属性，则使用该值。如果属性的类型是数组，则它可以是值数组。如果默认值未知，则可以省略。</td>
</tr>
<tr>
<td align="left">deprecation</td>
<td align="left">数组</td>
<td align="left">过时的描述。</td>
</tr>
</tbody></table>
<p><code>deprecation</code>每个<code>properties</code>元素的属性中包含的JSON对象可以包含以下属性：</p>
<table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">类型</th>
<th align="left">目的</th>
</tr>
</thead>
<tbody><tr>
<td align="left">level</td>
<td align="left">String</td>
<td align="left">弃用级别，可以是warning（默认）或error。当属性具有warning弃用级别时，它仍应绑定在环境中。但是，当它具有error弃用级别时，该属性不再受管理且不受约束。</td>
</tr>
<tr>
<td align="left">reason</td>
<td align="left">String</td>
<td align="left">该属性被弃用的原因的简短描述。如果没有可用的原因，可以省略。建议描述为简短段落，第一行提供简明摘要。描述中的最后一行应以句点（.）结尾。</td>
</tr>
<tr>
<td align="left">replacement</td>
<td align="left">String</td>
<td align="left">替换此不推荐使用的属性的属性的全名。如果此属性没有替换，则可以省略。</td>
</tr>
</tbody></table>
<hr>
<p>7、SpringBoot 配置文件提示及自动生成</p>
<p>spring-configuration-metadata.json 代码量挺大的，为了方便我们可以通过IDE来生成，这里使用的是idea。</p>
<p><strong>「在idea设置中搜索Annotation Processors，接下来勾住Enable annonation processing就完成了。在编译打包后的文件中看到自动生成的spring-configuration-metadata.json。这个文件不用我们编写」</strong></p>
<p>下面是自动生成的：</p>
<pre><code class="json">&#123;
    &quot;groups&quot;: [
        &#123;
            &quot;name&quot;: &quot;id-generate&quot;,
            &quot;type&quot;: &quot;org.example.IdGenerateProperties&quot;,
            &quot;sourceType&quot;: &quot;org.example.IdGenerateProperties&quot;
        &#125;
    ],
    &quot;properties&quot;: [
        &#123;
            &quot;name&quot;: &quot;id-generate.enable&quot;,
            &quot;type&quot;: &quot;java.lang.Boolean&quot;,
            &quot;description&quot;: &quot;是否开启&quot;,
            &quot;sourceType&quot;: &quot;org.example.IdGenerateProperties&quot;
        &#125;,
        &#123;
            &quot;name&quot;: &quot;id-generate.type&quot;,
            &quot;type&quot;: &quot;java.lang.String&quot;,
            &quot;description&quot;: &quot;生成ID类型, uuid or bigint&quot;,
            &quot;sourceType&quot;: &quot;org.example.IdGenerateProperties&quot;,
            &quot;defaultValue&quot;: &quot;bigint&quot;
        &#125;
    ],
    &quot;hints&quot;: []
&#125;
</code></pre>
<hr>
<p>8、mvn install打包自定义starter与autoconfigure项目：id-generate-spring-boot-autoconfigure、id-generate-spring-boot-starter</p>
<p>然后新建一个SpringBoot项目：只需要引入id-generate-spring-boot-starter即可，测试代码如下：</p>
<pre><code class="properties">id-generate.enable=true
id-generate.type=uuid
</code></pre>
<pre><code class="java">@Autowired
private IdGenerateService idGenerateService;
@Test
void contextLoads() &#123;
    String generateId = idGenerateService.generateId();
    System.out.println(generateId);
&#125;
</code></pre>
<pre><code>565886ae-6f0c-4207-a4ef-ff1948810cd1
</code></pre>
<hr>
<p>9、<strong>查看自动配置类生效的方法</strong>：通过启用 debug&#x3D;true 属性，开启SpringBoot的日志调试类，让控制台打印自动配置报告，这样就可以方便的知道哪些自动配置类生效。</p>
<pre><code class="shell"> Positive matches:（自动配置类启用的：正匹配）
-----------------
 IdGenerateAutoConfiguration matched:
      - @ConditionalOnClass found required classes &#39;org.example.IdGenerateProperties&#39;, &#39;org.example.IdGenerateService&#39; (OnClassCondition)
      - @ConditionalOnProperty (id-generate.enable=true) matched (OnPropertyCondition)

   IdGenerateAutoConfiguration#idGenerateService matched:
      - @ConditionalOnMissingBean (types: org.example.IdGenerateService; SearchStrategy: all) did not find any beans (OnBeanCondition)
      
Negative matches:（没有启动，没有匹配成功的自动配置类：负匹配）
-----------------
   ActiveMQAutoConfiguration:
      Did not match:
         - @ConditionalOnClass did not find required class &#39;javax.jms.ConnectionFactory&#39; (OnClassCondition)

Exclusions:
-----------

    org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration


Unconditional classes:
----------------------

    org.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration
</code></pre>
<ul>
<li>Positive matches:（自动配置类启用的：正匹配）</li>
<li>Negative matches:（没有启动，没有匹配成功的自动配置类：负匹配）</li>
<li>Exclusions、Unconditional classes（排除的、没有限定条件的自动配置类）</li>
</ul>
<h2 id="8、Starter-自定义编写示例2（API日志打印）"><a href="#8、Starter-自定义编写示例2（API日志打印）" class="headerlink" title="8、Starter 自定义编写示例2（API日志打印）"></a>8、Starter 自定义编写示例2（API日志打印）</h2><p>本案例我们需要通过自动配置来创建一个拦截器对象，通过此拦截器对象来实现记录日志功能。</p>
<h3 id="1、mylog-spring-boot-starter"><a href="#1、mylog-spring-boot-starter" class="headerlink" title="1、mylog-spring-boot-starter"></a>1、mylog-spring-boot-starter</h3><pre><code class="bash">├─mylog-spring-boot-starter
   │  pom.xml
   └─src
       └─main
           ├─java
           └─resources
</code></pre>
<p>创建一个空的 maven 项目，在mylog-spring-boot-starter的pom.xml文件中添加如下maven坐标（与上面案例一致）</p>
<pre><code class="xml-dtd">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;

    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;groupId&gt;org.example&lt;/groupId&gt;
    &lt;artifactId&gt;mylog-spring-boot-starter&lt;/artifactId&gt;
    &lt;version&gt;1.0.0&lt;/version&gt;

    &lt;properties&gt;
        &lt;maven.compiler.source&gt;11&lt;/maven.compiler.source&gt;
        &lt;maven.compiler.target&gt;11&lt;/maven.compiler.target&gt;
    &lt;/properties&gt;

    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.example&lt;/groupId&gt;
            &lt;artifactId&gt;mylog-spring-boot-autoconfigure&lt;/artifactId&gt;
            &lt;version&gt;1.0.0&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/project&gt;
</code></pre>
<h3 id="2、mylog-spring-boot-autoconfigure"><a href="#2、mylog-spring-boot-autoconfigure" class="headerlink" title="2、mylog-spring-boot-autoconfigure"></a>2、mylog-spring-boot-autoconfigure</h3><pre><code class="bash">├─mylog-spring-boot-autoconfigure
   │  pom.xml
   └─src
       └─main
           ├─java
           │  └─org
           │      └─example
           │              MyLog.java
           │              MyLogAutoConfiguration.java
           │              MyLogInterceptor.java
           └─resources
               └─META-INF
                       spring.factories
</code></pre>
<p>1、pom.xml 文件引入依赖，这里增加了spring-boot-web依赖主要是为了使用拦截器</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;parent&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
        &lt;version&gt;2.5.0&lt;/version&gt;
        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;
    &lt;/parent&gt;

    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;groupId&gt;org.example&lt;/groupId&gt;
    &lt;artifactId&gt;mylog-spring-boot-autoconfigure&lt;/artifactId&gt;
    &lt;version&gt;1.0.0&lt;/version&gt;

    &lt;properties&gt;
        &lt;maven.compiler.source&gt;11&lt;/maven.compiler.source&gt;
        &lt;maven.compiler.target&gt;11&lt;/maven.compiler.target&gt;
    &lt;/properties&gt;

    &lt;dependencies&gt;
        &lt;!-- springboot的相关jar包, 也可不引入(引入spring-boot-autoconfigure的情况下) --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!-- 包含自动配置的代码, 包含很多与自动配置相关的注解的定义, 必须要引入 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-autoconfigure&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!-- 非必须的, 配置文件点击可以跳转实体, 引入后可以在配置文件中输入我们自定义配置的时候有相应的提示 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;
            &lt;optional&gt;true&lt;/optional&gt;
        &lt;/dependency&gt;
        &lt;!-- 其他依赖的选择根据项目需要进行添加即可 --&gt;
        &lt;!-- 由于使用了拦截器, 所以引入了spring-mvc, 只在编译阶段干活, 所以optional=true --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
            &lt;optional&gt;true&lt;/optional&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/project&gt;
</code></pre>
<p>2、自定义MyLog注解，用来记录那些接口需要打印日志</p>
<pre><code class="java">package org.example;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface MyLog &#123;
    /** 方法描述 **/
    String desc() default &quot;&quot;;
&#125;
</code></pre>
<p>3、自定义日志拦截器MyLogInterceptor，主要处理方法在这里编写，我这只打印日志，有需要也可以记录到数据库</p>
<pre><code class="java">package org.example;
import org.springframework.web.method.HandlerMethod;
import org.springframework.web.servlet.HandlerInterceptor;
import org.springframework.web.servlet.ModelAndView;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.lang.reflect.Method;

/**
 * 日志拦截器
 */
public class MyLogInterceptor implements HandlerInterceptor &#123;
    private static final ThreadLocal&lt;Long&gt; startTimeThreadLocal = new ThreadLocal&lt;&gt;();

    public boolean preHandle(HttpServletRequest request,
                             HttpServletResponse response, Object handler) &#123;
        HandlerMethod handlerMethod = (HandlerMethod) handler;
        // 获得被拦截的方法对象
        Method method = handlerMethod.getMethod();
        // 获得方法上的注解
        MyLog myLog = method.getAnnotation(MyLog.class);
        if (myLog != null) &#123;
            // 方法上加了MyLog注解，需要进行日志记录
            long startTime = System.currentTimeMillis();
            startTimeThreadLocal.set(startTime);
        &#125;
        return true;
    &#125;

    public void postHandle(HttpServletRequest request, HttpServletResponse response,
                           Object handler, ModelAndView modelAndView) &#123;
        HandlerMethod handlerMethod = (HandlerMethod) handler;
        // 获得被拦截的方法对象
        Method method = handlerMethod.getMethod();
        // 获得方法上的注解
        MyLog myLog = method.getAnnotation(MyLog.class);
        if (myLog != null) &#123;
            // 方法上加了MyLog注解，需要进行日志记录
            long endTime = System.currentTimeMillis();
            Long startTime = startTimeThreadLocal.get();
            long optTime = endTime - startTime;

            String requestUri = request.getRequestURI();
            String methodName = method.getDeclaringClass().getName() +
                    &quot;.&quot; + method.getName();
            String methodDesc = myLog.desc();

            System.out.println(&quot;请求uri：&quot; + requestUri);
            System.out.println(&quot;请求方法名：&quot; + methodName);
            System.out.println(&quot;方法描述：&quot; + methodDesc);
            System.out.println(&quot;方法执行时间：&quot; + optTime + &quot;ms&quot;);
        &#125;
    &#125;
&#125;
</code></pre>
<p>4、创建自动配置类MyLogAutoConfiguration，用于自动配置拦截器、参数解析器等web组件</p>
<pre><code class="java">package org.example;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.InterceptorRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

/**
 * 配置类，用于自动配置拦截器、参数解析器等web组件
 */
@Configuration
public class MyLogAutoConfiguration implements WebMvcConfigurer&#123;
    // 注册自定义日志拦截器
    public void addInterceptors(InterceptorRegistry registry) &#123;
        registry.addInterceptor(new MyLogInterceptor());
    &#125;
&#125;
</code></pre>
<p>5、在resource&#x2F;META-INF&#x2F;spring.factories中追加MyLogAutoConfiguration配置，让SpringBoot可以注入容器</p>
<pre><code class="properties">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
  org.example.MyLogAutoConfiguration
</code></pre>
<p>6、mvn intall 打包测试，在SpringBoot工程引入mylog-spring-boot-starter，在Controller方法上加入@MyLog注解</p>
<pre><code class="java">@RestController
public class TestController &#123;
    @MyLog(desc = &quot;test api&quot;) //日志记录注解
    @GetMapping(&quot;/test&quot;)
    public String test() &#123;
        return &quot;ok&quot;;
    &#125;
&#125;
</code></pre>
<p>7、访问地址：localhost:8080&#x2F;test，控制台打印结果如下：</p>
<pre><code class="java">请求uri：/test
请求方法名：com.example.controller.TestController.test
方法描述：test api
方法执行时间：59ms
</code></pre>
<h2 id="9、Starter-自定义编写示例3（AOP日志打印）"><a href="#9、Starter-自定义编写示例3（AOP日志打印）" class="headerlink" title="9、Starter 自定义编写示例3（AOP日志打印）"></a>9、Starter 自定义编写示例3（AOP日志打印）</h2><p>本案例我们需要通过自动配置来创建一个AOP，通过此AOP来实现记录日志功能，对比上面的日志打印区别是可以记录Service方法</p>
<h3 id="1、aspectlog-spring-boot-starter"><a href="#1、aspectlog-spring-boot-starter" class="headerlink" title="1、aspectlog-spring-boot-starter"></a>1、aspectlog-spring-boot-starter</h3><pre><code class="bash">├─aspectlog-spring-boot-starter
   │  pom.xml
   └─src
       └─main
           ├─java
           └─resources
</code></pre>
<p>创建一个空的 maven 项目，在aspectlog-spring-boot-starter的pom.xml文件中添加如下maven坐标（与上面案例一致）</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;groupId&gt;org.example&lt;/groupId&gt;
    &lt;artifactId&gt;aspectlog-spring-boot-starter&lt;/artifactId&gt;
    &lt;version&gt;1.0.0&lt;/version&gt;

    &lt;properties&gt;
        &lt;maven.compiler.source&gt;11&lt;/maven.compiler.source&gt;
        &lt;maven.compiler.target&gt;11&lt;/maven.compiler.target&gt;
    &lt;/properties&gt;

    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.example&lt;/groupId&gt;
            &lt;artifactId&gt;aspectlog-spring-boot-autoconfigure&lt;/artifactId&gt;
            &lt;version&gt;1.0.0&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/project&gt;
</code></pre>
<h3 id="2、aspectlog-spring-boot-autoconfigure"><a href="#2、aspectlog-spring-boot-autoconfigure" class="headerlink" title="2、aspectlog-spring-boot-autoconfigure"></a>2、aspectlog-spring-boot-autoconfigure</h3><pre><code class="bash">├─aspectlog-spring-boot-autoconfigure
   │  pom.xml
   └─src
       ├─main
          ├─java
          │  └─org
          │      └─example
          │              AspectLog.java
          │              AspectLogAutoConfiguration.java
          │              AspectLogProperties.java
          └─resources
              └─META-INF
                      spring.factories
</code></pre>
<p>1、pom.xml 依赖，这里增加了spring-boot-aop依赖，也可以使用spring-boot-web依赖</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;parent&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
        &lt;version&gt;2.5.0&lt;/version&gt;
        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;
    &lt;/parent&gt;

    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;groupId&gt;org.example&lt;/groupId&gt;
    &lt;artifactId&gt;aspectlog-spring-boot-autoconfigure&lt;/artifactId&gt;
    &lt;version&gt;1.0.0&lt;/version&gt;

    &lt;properties&gt;
        &lt;maven.compiler.source&gt;11&lt;/maven.compiler.source&gt;
        &lt;maven.compiler.target&gt;11&lt;/maven.compiler.target&gt;
    &lt;/properties&gt;

    &lt;dependencies&gt;
        &lt;!-- springboot的相关jar包, 也可不引入(引入spring-boot-autoconfigure的情况下) --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!-- 包含自动配置的代码, 包含很多与自动配置相关的注解的定义, 必须要引入 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-autoconfigure&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!-- 非必须的, 配置文件点击可以跳转实体, 引入后可以在配置文件中输入我们自定义配置的时候有相应的提示 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;
            &lt;optional&gt;true&lt;/optional&gt;
        &lt;/dependency&gt;
        &lt;!-- 其他依赖的选择根据项目需要进行添加即可 --&gt;
        &lt;!-- 这里使用到了AOP, 所以增加AOP的依赖, 由于增加optional=true, 所以使用者还需引入该依赖 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;
            &lt;optional&gt;true&lt;/optional&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/project&gt;
</code></pre>
<p>2、定义AspectLog注解，该注解用于标注需要打印执行时间的方法</p>
<pre><code class="java">package org.example;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
/**
 * 用于控制定时任务的开启与关闭
 * 对应切面
 **/
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface AspectLog &#123;
&#125;
</code></pre>
<p>3、定义配置文件对应类</p>
<pre><code class="java">package org.example;
import org.springframework.boot.context.properties.ConfigurationProperties;

@ConfigurationProperties(prefix = &quot;aspect-log&quot;)
public class AspectLogProperties &#123;
    private boolean enable;
    public boolean isEnable() &#123;
        return enable;
    &#125;
    public void setEnable(boolean enable) &#123;
        this.enable = enable;
    &#125;
&#125;
</code></pre>
<p>4、定义自动配置类</p>
<pre><code class="java">package org.example;
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.boot.autoconfigure.condition.*;
import org.springframework.boot.context.properties.EnableConfigurationProperties;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.EnableAspectJAutoProxy;
import org.springframework.core.PriorityOrdered;

@Aspect
@EnableAspectJAutoProxy(exposeProxy = true, proxyTargetClass = true)
@Configuration
@EnableConfigurationProperties(AspectLogProperties.class)
@ConditionalOnProperty(prefix = &quot;aspectLog&quot;, name = &quot;enable&quot;, havingValue = &quot;true&quot;, matchIfMissing = true)
public class AspectLogAutoConfiguration implements PriorityOrdered &#123;
    protected Logger logger = LoggerFactory.getLogger(getClass());

    @Around(&quot;@annotation(org.example.AspectLog)&quot;)
    public Object isOpen(ProceedingJoinPoint thisJoinPoint) throws Throwable &#123;
        // 执行方法名称
        String taskName = thisJoinPoint.getSignature()
                .toString().substring(
                        thisJoinPoint.getSignature()
                                .toString().indexOf(&quot; &quot;),
                        thisJoinPoint.getSignature().toString().indexOf(&quot;(&quot;));
        taskName = taskName.trim();
        long time = System.currentTimeMillis();
        Object result = thisJoinPoint.proceed();
        logger.info(&quot;method:&#123;&#125; run :&#123;&#125; ms&quot;, taskName, (System.currentTimeMillis() - time));
        return result;
    &#125;

    @Override
    public int getOrder() &#123;
        // 保证事务等切面先执行
        return Integer.MAX_VALUE;
    &#125;
&#125;
</code></pre>
<p>配置类简要说明：</p>
<pre><code class="java">// 1.当配置文件有aspectLog.enable=true时开启，如果配置文件没有设置aspectLog.enable也开启
@ConditionalOnProperty(prefix = &quot;aspectLog&quot;, name = &quot;enable&quot;, havingValue = &quot;true&quot;, matchIfMissing = true)
// 2.此注解作用是把当前类标识为一个切面供容器读取
@Aspect
/**
 * 3.@EnbleAspectJAutoProxy类有两个成员属性:
 * - proxyTargetClass: 表明该类采用CGLIB代理还是使用JDK的动态代理，如果选择为true则是cglib，
 *                     false则尽可能选择JDK，如果bean没有实现任何接口，就算是false也会选择cglib
 * - exposeProxy: 解决内部调用不能使用代理的场景，默认为false表示不处理，
 *                true则表示这个代理对象的副本可以通过AopContext.currentProxy()获得(ThreadLocal里面),
 *                从而我们可以很方便得在Spring框架上下文中拿到当前代理对象（处理事务时很方便）
 *
 * 注意: Spring中如果不在配置类中添加@EnableAspectJAutoProxy，那么所有切面注解是不生效的
 *      SpringBoot因为有自动配置，所以不需要开发人员手工配置@EnableAspectJAutoProxy　　　
 */
@EnableAspectJAutoProxy(exposeProxy = true, proxyTargetClass = true)
</code></pre>
<p>5、META-INF&#x2F;spring.factories是Spring的工厂机制，文件中定义的类，都会被自动加载。多个配置使用逗号分割，换行用<code>\</code></p>
<pre><code class="properties">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
  org.example.AspectLogAutoConfiguration
</code></pre>
<p>6、mvn intall 打包测试，在SpringBoot工程引入aspectlog-spring-boot-starter，在任意方法上加入@AspectLog注解测试</p>
<pre><code class="properties">aspect-log.enable=true
</code></pre>
<pre><code class="java">@Service
public class TestService &#123;
    @SneakyThrows
    @AspectLog
    public void sleep () &#123;
        TimeUnit.SECONDS.sleep(1);
    &#125;
&#125;
</code></pre>
<pre><code class="java">@Autowired
TestService testService;
@Test
void testAspectLog() &#123;
    testService.sleep();
&#125;
</code></pre>
<p>7、执行测试方法，控制台打印结果如下：</p>
<pre><code>method:com.swagger3.service.TestService.sleep run :1019 ms
</code></pre>
<h2 id="10、SpringBoot-自定义多数据源-starter-组件"><a href="#10、SpringBoot-自定义多数据源-starter-组件" class="headerlink" title="10、SpringBoot 自定义多数据源 starter 组件"></a>10、SpringBoot 自定义多数据源 starter 组件</h2><p>本案例我们使用多数据源封装成一个starter组件，以方便使用多数据源访问数据库的操作。</p>
<pre><code class="bash">├─dynamic-multi-datasource-spring-boot-starter
   │  pom.xml
   └─src
       ├─main
          ├─java
          │  └─org
          │      └─example
          │              DS.java
          │              DynamicDataSourceAspect.java
          │              DynamicDataSourceContextHolder.java
          │              DynamicMultiDataSourceAutoConfiguration.java
          │              DynamicMultiDataSourceProperties.java
          └─resources
              └─META-INF
                      spring.factories
</code></pre>
<h3 id="1、创建普通项目，引入相关的依赖"><a href="#1、创建普通项目，引入相关的依赖" class="headerlink" title="1、创建普通项目，引入相关的依赖"></a>1、创建普通项目，引入相关的依赖</h3><p>创建一个普通Java项目，引入SpringBoot相关的依赖。pom.xml</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;parent&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
        &lt;version&gt;2.5.0&lt;/version&gt;
        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;
    &lt;/parent&gt;
    &lt;groupId&gt;org.example&lt;/groupId&gt;
    &lt;artifactId&gt;dynamic-multi-datasource-spring-boot-starter&lt;/artifactId&gt;
    &lt;version&gt;1.0.0&lt;/version&gt;

    &lt;properties&gt;
        &lt;maven.compiler.source&gt;11&lt;/maven.compiler.source&gt;
        &lt;maven.compiler.target&gt;11&lt;/maven.compiler.target&gt;
    &lt;/properties&gt;

    &lt;dependencies&gt;
        &lt;!-- 包含了springboot与spring的相关jar包, 也包括spring-boot-autoconfigure --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!-- 非必须的, 配置文件点击可以跳转实体, 引入后可以在配置文件中输入我们自定义配置的时候有相应的提示 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;
            &lt;optional&gt;true&lt;/optional&gt;
        &lt;/dependency&gt;
        &lt;!-- 其他依赖的选择根据项目需要进行添加即可 --&gt;
        &lt;!-- 导入jdbc相关依赖 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!-- 这里使用到了AOP, 所以增加AOP的依赖, 这里不能optional=true, 因为配置中使用了new --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;
            &lt;optional&gt;true&lt;/optional&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/project&gt;
</code></pre>
<h3 id="2、创建常量类和注解"><a href="#2、创建常量类和注解" class="headerlink" title="2、创建常量类和注解"></a>2、创建常量类和注解</h3><pre><code class="java">package org.example;
import java.lang.annotation.*;

/**
 * 数据源切换扫描注解及常量
 */
@Documented
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface DS &#123;
    String value() default DS.DEFAULT;
    /**
     * 如下为常量
     */
    String DEFAULT = &quot;default&quot;;
    String DY_MULTI_DS = &quot;dynamicMultiDataSource&quot;;
    String DS_TYPE = &quot;datasourceType&quot;;
    String CONFIG_PREFIX = &quot;spring.datasource.multi&quot;;
&#125;
</code></pre>
<h3 id="3、创建多数据源属性类"><a href="#3、创建多数据源属性类" class="headerlink" title="3、创建多数据源属性类"></a>3、创建多数据源属性类</h3><pre><code class="java">package org.example;
import org.springframework.boot.context.properties.ConfigurationProperties;
import java.util.HashMap;
import java.util.Map;

/**
 * 主要用于存储SpringBoot配置文件中配置的数据源属性
 */
@ConfigurationProperties(prefix = DS.CONFIG_PREFIX)
public class DynamicMultiDataSourceProperties &#123;
    private Map&lt;String, DataSourceProp&gt; dataSourcePropMap;

    public Map&lt;String, DataSourceProp&gt; getDataSourcePropMap() &#123;
        return dataSourcePropMap;
    &#125;

    public void setDataSourcePropMap(Map&lt;String, DataSourceProp&gt; dataSourcePropMap) &#123;
        this.dataSourcePropMap = dataSourcePropMap;
    &#125;

    public static class DataSourceProp extends HashMap&lt;String, String&gt; &#123;
    &#125;
&#125;
</code></pre>
<h3 id="4、创建数据源key的切换工具"><a href="#4、创建数据源key的切换工具" class="headerlink" title="4、创建数据源key的切换工具"></a>4、创建数据源key的切换工具</h3><pre><code class="java">package org.example;

/**
 * 主要用于设置当前线程下数据源切换时的数据源唯一标识key, 以便获取指定的数据源
 */
public class DynamicDataSourceContextHolder &#123;

    /**
     * 动态数据源名称上下文
     */
    private static final ThreadLocal&lt;String&gt; DATA_SOURCE_THEAD_LOCAL =
            ThreadLocal.withInitial(() -&gt; DS.DEFAULT);

    /**
     * 返回当前数据源
     */
    public static String getDataSource() &#123;
        return DATA_SOURCE_THEAD_LOCAL.get();
    &#125;

    /**
     * 设置当前数据源
     */
    public static void setDataSource(String dataSource) &#123;
        DATA_SOURCE_THEAD_LOCAL.set(dataSource);
    &#125;

    /**
     * 重置释放数据源
     */
    public static void remove() &#123;
        DATA_SOURCE_THEAD_LOCAL.remove();
    &#125;
&#125;
</code></pre>
<h3 id="5、创建多数据源的切面类"><a href="#5、创建多数据源的切面类" class="headerlink" title="5、创建多数据源的切面类"></a>5、创建多数据源的切面类</h3><p>切面类主要用于获取被数据与注解指定的方法，拿到其注解中的属性值，再设置到数据源key设置组件中，方便数据源类获取该key，需使用@Order设置切面优先级，或者继承PriorityOrdered重写getOrder()也可以，否则设置无效。</p>
<pre><code class="java">package org.example;
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.reflect.MethodSignature;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.core.annotation.Order;
import java.lang.reflect.Method;

@Order
@Aspect
public class DynamicDataSourceAspect &#123;
    private static final Logger log = LoggerFactory.getLogger(DynamicDataSourceAspect.class);

    @Around(&quot;@annotation(org.example.DS)&quot;)
    public Object around(ProceedingJoinPoint point) throws Throwable &#123;
        try &#123;
            // 获取被代理的方法对象、数据源注解
            MethodSignature signature = (MethodSignature) point.getSignature();
            Method method = signature.getMethod();
            DS DS = method.getAnnotation(DS.class);
            log.debug(&quot;切换前数据源为: &#123;&#125;&quot; + DS.value());
            DynamicDataSourceContextHolder.setDataSource(DS.value());
            return point.proceed();
        &#125; finally &#123;
            DynamicDataSourceContextHolder.remove();
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="6、创建数据源配置类及多数据源类"><a href="#6、创建数据源配置类及多数据源类" class="headerlink" title="6、创建数据源配置类及多数据源类"></a>6、创建数据源配置类及多数据源类</h3><p>创建多数据源类继承AbstractRoutingDataSource类，重写determineCurrentLookupKey()方法，用于获取当前线程中的指定的数据源key，通过该key拿到对应的数据源对象。此类DynamicMultiDataSource我偷懒了写成静态内部类了。</p>
<pre><code class="java">package org.example;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.boot.context.properties.EnableConfigurationProperties;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Primary;
import org.springframework.jdbc.datasource.DataSourceTransactionManager;
import org.springframework.jdbc.datasource.lookup.AbstractRoutingDataSource;
import org.springframework.util.ReflectionUtils;
import javax.sql.DataSource;
import java.util.HashMap;
import java.util.Map;
import java.util.Objects;

@Configuration
@EnableConfigurationProperties(DynamicMultiDataSourceProperties.class)
public class DynamicMultiDataSourceAutoConfiguration &#123;
    private final DynamicMultiDataSourceProperties dynamicMultiDataSourceProperties;

    public DynamicMultiDataSourceAutoConfiguration(DynamicMultiDataSourceProperties dynamicMultiDataSourceProperties) &#123;
        this.dynamicMultiDataSourceProperties = dynamicMultiDataSourceProperties;
    &#125;

    /**
     * 必须实现该接口。用来获取当前数据源
     */
    static class DynamicMultiDataSource extends AbstractRoutingDataSource &#123;
        @Override
        protected Object determineCurrentLookupKey() &#123;
            return DynamicDataSourceContextHolder.getDataSource();
        &#125;
    &#125;

    @Primary
    @Bean(DS.DY_MULTI_DS)
    public DataSource dynamicMultiDataSource() &#123;
        DynamicMultiDataSource dynamicMultiDataSource = new DynamicMultiDataSource();
        Map&lt;String, DynamicMultiDataSourceProperties.DataSourceProp&gt; dataSourcePropMap = dynamicMultiDataSourceProperties.getDataSourcePropMap();

        Map&lt;Object, Object&gt; dataSourceMap = new HashMap&lt;&gt;(dataSourcePropMap.size());
        dataSourcePropMap.forEach((lookupKey, dsProp) -&gt; dataSourceMap.put(lookupKey, createDs(dsProp)));

        // 添加数据源集合, 然后设置默认数据源
        dynamicMultiDataSource.setTargetDataSources(dataSourceMap);
        dynamicMultiDataSource.setDefaultTargetDataSource(dataSourceMap.get(DS.DEFAULT));
        return dynamicMultiDataSource;
    &#125;

    @Bean
    public DataSourceTransactionManager dataSourceTransactionManager(
            @Qualifier(DS.DY_MULTI_DS) DataSource dataSource) &#123;
        return new DataSourceTransactionManager(dataSource);
    &#125;

    @Bean
    public DynamicDataSourceAspect dynamicDataSourceAspect() &#123;
        return new DynamicDataSourceAspect();
    &#125;

    /**
     * 这里是定义了Map所以才这样处理了, 实际上也可以直接定义一个JavaBean，
     * 然后设置设定的字段, 如果有需要还能把连接池配置一起带上
     */
    private DataSource createDs(DynamicMultiDataSourceProperties.DataSourceProp dataSourceProp) &#123;
        DataSource dataSource = null;
        try &#123;
            Class&lt;?&gt; dsClass = Class.forName(dataSourceProp.get(DS.DS_TYPE));
            if (DataSource.class.isAssignableFrom(dsClass)) &#123;
                dataSource = (DataSource) dsClass.getConstructor().newInstance();

                DataSource finalDataSource = dataSource;
                // 反射获取指定类中的属性
                ReflectionUtils.doWithFields(dsClass,
                        field -&gt; &#123;
                            field.setAccessible(true);
                            field.set(finalDataSource, dataSourceProp.get(field.getName()));
                        &#125;,
                        field -&gt; &#123;
                            if (Objects.equals(dataSourceProp.get(DS.DS_TYPE), field.getName())) &#123;
                                return false;
                            &#125;
                            return Objects.nonNull(dataSourceProp.get(field.getName()));
                        &#125;);

            &#125;
        &#125; catch (Exception e) &#123;
            throw new RuntimeException(e);
        &#125;
        return dataSource;
    &#125;
&#125;
</code></pre>
<h3 id="7、配置spring-factories文件"><a href="#7、配置spring-factories文件" class="headerlink" title="7、配置spring.factories文件"></a>7、配置spring.factories文件</h3><p>在resources目录下创建META-INF目录，在该目录创建spring.factories文件，内容如下：</p>
<pre><code class="properties">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
  org.example.DynamicMultiDataSourceAutoConfiguration
</code></pre>
<p>设置key为开启自动配置的注解全路径名，后面的value值为配置类全路径名，本starter组件中为数据源配置类，如有多个配置类，则以逗号分隔，以反斜杆表示忽略换行</p>
<h3 id="9、新建SpringBoot项目测试示例"><a href="#9、新建SpringBoot项目测试示例" class="headerlink" title="9、新建SpringBoot项目测试示例"></a>9、新建SpringBoot项目测试示例</h3><p>我们封装的一个简单的多数据源starter组件就完成了，只需进行maven打包即可在本地使用。为了方便测试使用H2内存数据库。</p>
<p>1、maven 命令：<code>mvn clean install</code>。引入打包后的依赖：</p>
<pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.example&lt;/groupId&gt;
    &lt;artifactId&gt;dynamic-multi-datasource-spring-boot-starter&lt;/artifactId&gt;
    &lt;version&gt;1.0.0&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>2、修改SpringBoot全局配置文件：default为默认数据源，必须配置， master为可选数据源，名称可自定义。数据源的属性名称为对应的dsType数据源类型的属性字段。</p>
<pre><code class="yaml">spring:
  datasource:
    multi:
      data-source-prop-map:
        default:
          datasourceType: com.zaxxer.hikari.HikariDataSource
          driverClassName: org.h2.Driver
          jdbcUrl: jdbc:h2:mem:default
          username: sa
          password: sa
        master:
          datasourceType: com.zaxxer.hikari.HikariDataSource
          driverClassName: org.h2.Driver
          jdbcUrl: jdbc:h2:mem:master
          username: sa
          password: sa
</code></pre>
<p>3、使用数据源：直接在指定的方法上添加@DataSource注解即可，注解的默认值为default,数据源的切换通过注解的值进行切换。值为application.yml中配置的default，master等。</p>
<p>4、查看完整pom.xml与代码，yml配置文件参考上面即可。</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;parent&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
        &lt;version&gt;2.5.0&lt;/version&gt;
        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;
    &lt;/parent&gt;
    &lt;groupId&gt;com.example&lt;/groupId&gt;
    &lt;artifactId&gt;test-spring-boot&lt;/artifactId&gt;
    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;
    &lt;name&gt;test-spring-boot&lt;/name&gt;
    &lt;description&gt;test-spring-boot&lt;/description&gt;
    &lt;properties&gt;
        &lt;java.version&gt;11&lt;/java.version&gt;
    &lt;/properties&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;com.h2database&lt;/groupId&gt;
            &lt;artifactId&gt;h2&lt;/artifactId&gt;
            &lt;scope&gt;runtime&lt;/scope&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
            &lt;artifactId&gt;lombok&lt;/artifactId&gt;
            &lt;optional&gt;true&lt;/optional&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.example&lt;/groupId&gt;
            &lt;artifactId&gt;dynamic-multi-datasource-spring-boot-starter&lt;/artifactId&gt;
            &lt;version&gt;1.0.0&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

    &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
                &lt;configuration&gt;
                    &lt;excludes&gt;
                        &lt;exclude&gt;
                            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
                            &lt;artifactId&gt;lombok&lt;/artifactId&gt;
                        &lt;/exclude&gt;
                    &lt;/excludes&gt;
                &lt;/configuration&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;
&lt;/project&gt;
</code></pre>
<pre><code class="java">package com.example.testspringboot;
import org.example.DS;
import org.example.DynamicDataSourceContextHolder;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;
import javax.annotation.PostConstruct;
import javax.sql.DataSource;
import java.util.Arrays;
import java.util.List;
import java.util.Map;

@RestController
@SpringBootApplication
public class TestSpringBootApplication &#123;
    public static void main(String[] args) &#123;
        SpringApplication.run(TestSpringBootApplication.class, args);
    &#125;

    @Autowired
    DataSource dynamicMultiDataSource;
    JdbcTemplate jdbcTemplate;
    @PostConstruct
    public void initData() &#123;
        jdbcTemplate = new JdbcTemplate(dynamicMultiDataSource);
        Arrays.asList(&quot;default&quot;, &quot;master&quot;).forEach(type -&gt; &#123;
            // 切换数据源
            DynamicDataSourceContextHolder.setDataSource(type);
            // 初始化表和数据
            jdbcTemplate.execute(&quot;DROP TABLE IF EXISTS user&quot;);
            jdbcTemplate.execute(&quot;CREATE TABLE user (&quot;
                    + &quot;id BIGINT NOT NULL,&quot;
                    + &quot;name VARCHAR(50) DEFAULT NULL,&quot;
                    + &quot;type VARCHAR(50) DEFAULT NULL,&quot;
                    + &quot;PRIMARY KEY (id))&quot;);
            String sql = &quot;INSERT INTO user (id, name, type) VALUES (?, ?, ?)&quot;;
            jdbcTemplate.update(sql, 1, &quot;Sam&quot;, type);
            jdbcTemplate.update(sql, 2, &quot;Kath&quot;, type);
            jdbcTemplate.update(sql, 3, &quot;Tom&quot;, type);
            jdbcTemplate.update(sql, 4, &quot;Sandy&quot;, type);
            jdbcTemplate.update(sql, 5, &quot;Oliver&quot;, type);
        &#125;);
        // 还原数据源
        DynamicDataSourceContextHolder.remove();
    &#125;

    @DS
    @GetMapping(&quot;/default&quot;)
    public List&lt;Map&lt;String, Object&gt;&gt; test1()&#123;
        return jdbcTemplate.queryForList(&quot;select * from user&quot;);
    &#125;

    @DS(&quot;master&quot;)
    @GetMapping(&quot;/master&quot;)
    public List&lt;Map&lt;String, Object&gt;&gt; test2()&#123;
        return jdbcTemplate.queryForList(&quot;select * from user&quot;);
    &#125;
&#125;
</code></pre>
<p>5、动态切换多数据测试，我这里直接 CURL 请求</p>
<pre><code class="shell">➜  ~ curl localhost:8080/default
[&#123;&quot;ID&quot;:1,&quot;NAME&quot;:&quot;Sam&quot;,&quot;TYPE&quot;:&quot;default&quot;&#125;,
&#123;&quot;ID&quot;:2,&quot;NAME&quot;:&quot;Kath&quot;,&quot;TYPE&quot;:&quot;default&quot;&#125;,
&#123;&quot;ID&quot;:3,&quot;NAME&quot;:&quot;Tom&quot;,&quot;TYPE&quot;:&quot;default&quot;&#125;,
&#123;&quot;ID&quot;:4,&quot;NAME&quot;:&quot;Sandy&quot;,&quot;TYPE&quot;:&quot;default&quot;&#125;,
&#123;&quot;ID&quot;:5,&quot;NAME&quot;:&quot;Oliver&quot;,&quot;TYPE&quot;:&quot;default&quot;&#125;]

➜  ~ curl localhost:8080/master
[&#123;&quot;ID&quot;:1,&quot;NAME&quot;:&quot;Sam&quot;,&quot;TYPE&quot;:&quot;master&quot;&#125;,
&#123;&quot;ID&quot;:2,&quot;NAME&quot;:&quot;Kath&quot;,&quot;TYPE&quot;:&quot;master&quot;&#125;,
&#123;&quot;ID&quot;:3,&quot;NAME&quot;:&quot;Tom&quot;,&quot;TYPE&quot;:&quot;master&quot;&#125;,
&#123;&quot;ID&quot;:4,&quot;NAME&quot;:&quot;Sandy&quot;,&quot;TYPE&quot;:&quot;master&quot;&#125;,
&#123;&quot;ID&quot;:5,&quot;NAME&quot;:&quot;Oliver&quot;,&quot;TYPE&quot;:&quot;master&quot;&#125;]
</code></pre>

      
       <hr><span style="font-style: italic;color: gray;"> 转载请注明来源，欢迎对文章中的引用来源进行考证，欢迎指出任何有错误或不够清晰的表达。可以在下面评论区评论，也可以邮件至 8629303@qq.com </span>
    </div>
</article>


<p>
    <a  class="dashang" onclick="dashangToggle()">赏</a>
</p>






    




    </div>
    <div class="copyright">
        <p class="footer-entry">
    ©2017-2024 Sam
</p>
<p class="footer-entry">Built with <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/yelog/hexo-theme-3-hexo" target="_blank">3-hexo</a> theme</p>

    </div>
    <div class="full-toc">
        <button class="full" data-title="切换全屏 快捷键 s"><span class="min "></span></button>
<a class="" id="rocket" ></a>

    </div>
</div>

<div class="hide_box" onclick="dashangToggle()"></div>
<div class="shang_box">
    <a class="shang_close"  onclick="dashangToggle()">×</a>
    <div class="shang_tit">
        <p>喜欢就点赞,疼爱就打赏</p>
    </div>
    <div class="shang_payimg">
        <div class="pay_img">
            <img src="/blog/img/alipay.jpg" class="alipay" title="扫码支持">
            <img src="/blog/img/weixin.jpg" class="weixin" title="扫码支持">
        </div>
    </div>
    <div class="shang_payselect">
        <span><label><input type="radio" name="pay" checked value="alipay">支付宝</label></span><span><label><input type="radio" name="pay" value="weixin">微信</label></span>
    </div>
</div>


</body>
<script src="/blog/js/jquery.pjax.js?v=1.1.0" ></script>

<script src="/blog/js/script.js?v=1.1.0" ></script>
<script>
    var img_resize = 'default';
    function initArticle() {
        /*渲染对应的表格样式*/
        
            $("#post .pjax table").addClass("green_title");
        

        /*渲染打赏样式*/
        
        $("input[name=pay]").on("click", function () {
            if($("input[name=pay]:checked").val()=="weixin"){
                $(".shang_box .shang_payimg .pay_img").addClass("weixin_img");
            } else {
                $(".shang_box .shang_payimg .pay_img").removeClass("weixin_img");
            }
        })
        

        /*高亮代码块行号*/
        
        $('pre code').each(function(){
            var lines = $(this).text().trim().split('\n').length, widther='';
            if (lines>99) {
                widther = 'widther'
            }
            var $numbering = $('<ul/>').addClass('pre-numbering ' + widther).attr("unselectable","on");
            $(this).addClass('has-numbering ' + widther)
                    .parent()
                    .append($numbering);
            for(var i=1;i<=lines;i++){
                $numbering.append($('<li/>').text(i));
            }
        });
        

        /*访问数量*/
        
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js");
        

        /*代码高亮，行号对齐*/
        $('.pre-numbering').css('line-height',$('.has-numbering').css('line-height'));

        
        
    }

    /*打赏页面隐藏与展示*/
    
    function dashangToggle() {
        $(".shang_box").fadeToggle();
        $(".hide_box").fadeToggle();
    }
    

</script>

<!--加入行号的高亮代码块样式-->

<style>
    pre{
        position: relative;
        margin-bottom: 24px;
        border-radius: 10px;
        border: 1px solid #e2dede;
        background: #FFF;
        overflow: hidden;
    }
    code.has-numbering{
        margin-left: 30px;
    }
    code.has-numbering.widther{
        margin-left: 35px;
    }
    .pre-numbering{
        margin: 0;
        position: absolute;
        top: 0;
        left: 0;
        width: 20px;
        padding: 18px 3px 15px 5px;
        border-right: 1px solid #C3CCD0;
        text-align: right;
        color: #AAA;
        background-color: #fafafa;
    }
    .pre-numbering.widther {
        width: 35px;
    }
</style>

<!--自定义样式设置-->
<style>
    
    
    .nav {
        width: 582px;
    }
    .nav.fullscreen {
        margin-left: -582px;
    }
    .nav-left {
        width: 160px;
    }
    
    
    @media screen and (max-width: 1468px) {
        .nav {
            width: 492px;
        }
        .nav.fullscreen {
            margin-left: -492px;
        }
        .nav-left {
            width: 100px;
        }
    }
    
    
    @media screen and (max-width: 1024px) {
        .nav {
            width: 492px;
            margin-left: -492px
        }
        .nav.fullscreen {
            margin-left: 0;
        }
    }
    
    @media screen and (max-width: 426px) {
        .nav {
            width: 100%;
        }
        .nav-left {
            width: 100%;
        }
    }
    
    
    .nav-right .title-list nav a .post-title, .nav-right .title-list #local-search-result a .post-title {
        color: #383636;
    }
    
    
    .nav-right .title-list nav a .post-date, .nav-right .title-list #local-search-result a .post-date {
        color: #5e5e5f;
    }
    
    
    .nav-right nav a.hover, #local-search-result a.hover{
        background-color: #e2e0e0;
    }
    
    

    /*列表样式*/
    

    /* 背景图样式 */
    
    


    /*引用块样式*/
    

    /*文章列表背景图*/
    

    
</style>







</html>
